(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-9eba8e6a"],{"0717":function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nconst VotingEntity_1 = __importDefault(__webpack_require__("f633"));\nconst connector_1 = __importDefault(__webpack_require__("81e0"));\nclass Voting extends VotingEntity_1.default {\n    constructor(appAddress, subgraphUrl, verbose = false) {\n        super(new connector_1.default(subgraphUrl, verbose));\n        this.appAddress = appAddress;\n    }\n    async votes({ first = 1000, skip = 0 } = {}) {\n        return this._connector.votesForApp(this.appAddress, first, skip);\n    }\n    onVotes(callback) {\n        return this._connector.onVotesForApp(this.appAddress, callback);\n    }\n}\nexports.default = Voting;\n//# sourceMappingURL=Voting.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L2VudGl0aWVzL1ZvdGluZy5qcz8wNzE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RCx1Q0FBdUMsbUJBQU8sQ0FBQyxNQUFnQjtBQUMvRCxvQ0FBb0MsbUJBQU8sQ0FBQyxNQUFjO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCLEtBQUs7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIwNzE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBWb3RpbmdFbnRpdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Wb3RpbmdFbnRpdHlcIikpO1xuY29uc3QgY29ubmVjdG9yXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2Nvbm5lY3RvclwiKSk7XG5jbGFzcyBWb3RpbmcgZXh0ZW5kcyBWb3RpbmdFbnRpdHlfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihhcHBBZGRyZXNzLCBzdWJncmFwaFVybCwgdmVyYm9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKG5ldyBjb25uZWN0b3JfMS5kZWZhdWx0KHN1YmdyYXBoVXJsLCB2ZXJib3NlKSk7XG4gICAgICAgIHRoaXMuYXBwQWRkcmVzcyA9IGFwcEFkZHJlc3M7XG4gICAgfVxuICAgIGFzeW5jIHZvdGVzKHsgZmlyc3QgPSAxMDAwLCBza2lwID0gMCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rvci52b3Rlc0ZvckFwcCh0aGlzLmFwcEFkZHJlc3MsIGZpcnN0LCBza2lwKTtcbiAgICB9XG4gICAgb25Wb3RlcyhjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdG9yLm9uVm90ZXNGb3JBcHAodGhpcy5hcHBBZGRyZXNzLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gVm90aW5nO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Vm90aW5nLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0717\n')},"0789":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NewTextVote_vue_vue_type_style_index_0_id_391d3732_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("9698");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NewTextVote_vue_vue_type_style_index_0_id_391d3732_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NewTextVote_vue_vue_type_style_index_0_id_391d3732_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_NewTextVote_vue_vue_type_style_index_0_id_391d3732_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvTmV3VGV4dFZvdGUudnVlPzQ5OGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQThmLENBQWdCLHdnQkFBRyxFQUFDIiwiZmlsZSI6IjA3ODkuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS02LW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL05ld1RleHRWb3RlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTM5MWQzNzMyJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS02LW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL05ld1RleHRWb3RlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTM5MWQzNzMyJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0789\n')},"0dad":function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.parseCasts = void 0;\nconst Cast_1 = __importDefault(__webpack_require__("4b05"));\nfunction parseCasts(result, connector) {\n    const casts = result.data.casts;\n    if (!casts) {\n        throw new Error(\'Unable to parse casts.\');\n    }\n    const datas = casts.map((cast) => {\n        return {\n            id: cast.id,\n            voteId: cast.voteId,\n            voter: cast.voter,\n            supports: cast.supports,\n        };\n    });\n    return datas.map((data) => {\n        return new Cast_1.default(data, connector);\n    });\n}\nexports.parseCasts = parseCasts;\n//# sourceMappingURL=casts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L3BhcnNlcnMvY2FzdHMuanM/MGRhZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxNQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EiLCJmaWxlIjoiMGRhZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUNhc3RzID0gdm9pZCAwO1xuY29uc3QgQ2FzdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuLi9lbnRpdGllcy9DYXN0XCIpKTtcbmZ1bmN0aW9uIHBhcnNlQ2FzdHMocmVzdWx0LCBjb25uZWN0b3IpIHtcbiAgICBjb25zdCBjYXN0cyA9IHJlc3VsdC5kYXRhLmNhc3RzO1xuICAgIGlmICghY2FzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgY2FzdHMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGFzID0gY2FzdHMubWFwKChjYXN0KSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogY2FzdC5pZCxcbiAgICAgICAgICAgIHZvdGVJZDogY2FzdC52b3RlSWQsXG4gICAgICAgICAgICB2b3RlcjogY2FzdC52b3RlcixcbiAgICAgICAgICAgIHN1cHBvcnRzOiBjYXN0LnN1cHBvcnRzLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBkYXRhcy5tYXAoKGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYXN0XzEuZGVmYXVsdChkYXRhLCBjb25uZWN0b3IpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5wYXJzZUNhc3RzID0gcGFyc2VDYXN0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNhc3RzLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0dad\n')},1186:function(module){eval('module.exports = JSON.parse("{\\"appName\\":\\"apm-enssub.aragonpm.eth\\",\\"roles\\":[{\\"id\\":\\"CREATE_NAME_ROLE\\",\\"bytes\\":\\"0xf86bc2abe0919ab91ef714b2bec7c148d94f61fdb069b91a6cfe9ecdee1799ba\\",\\"name\\":\\"Create subdomains\\",\\"params\\":[]},{\\"id\\":\\"DELETE_NAME_ROLE\\",\\"bytes\\":\\"0x03d74c8724218ad4a99859bcb2d846d39999449fd18013dd8d69096627e68622\\",\\"name\\":\\"Remove subdomains\\",\\"params\\":[]},{\\"id\\":\\"POINT_ROOTNODE_ROLE\\",\\"bytes\\":\\"0x9ecd0e7bddb2e241c41b595a436c4ea4fd33c9fa0caa8056acf084fc3aa3bfbe\\",\\"name\\":\\"Point root domain\\",\\"params\\":[]}],\\"functions\\":[{\\"sig\\":\\"initialize(address,bytes32)\\",\\"roles\\":[],\\"notice\\":\\"Initialize this ENSSubdomainRegistrar instance with `_ens` as the root ENS registry and `_rootNode` as the node to allocate subdomains under\\"},{\\"sig\\":\\"createName(bytes32,address)\\",\\"roles\\":[\\"CREATE_NAME_ROLE\\"],\\"notice\\":\\"Create a new ENS subdomain record for `_label` and assign ownership to `_owner`\\"},{\\"sig\\":\\"createNameAndPoint(bytes32,address)\\",\\"roles\\":[\\"CREATE_NAME_ROLE\\"],\\"notice\\":\\"Create a new ENS subdomain record for `_label` that resolves to `_target` and is owned by this ENSSubdomainRegistrar\\"},{\\"sig\\":\\"deleteName(bytes32)\\",\\"roles\\":[\\"DELETE_NAME_ROLE\\"],\\"notice\\":\\"Deregister ENS subdomain record for `_label`\\"},{\\"sig\\":\\"pointRootNode(address)\\",\\"roles\\":[\\"POINT_ROOTNODE_ROLE\\"],\\"notice\\":\\"Resolve this ENSSubdomainRegistrar\'s root node to `_target`\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIxMTg2LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1186\n')},"205c":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Pagination_vue_vue_type_style_index_0_id_0e07d546_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d0a4");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Pagination_vue_vue_type_style_index_0_id_0e07d546_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Pagination_vue_vue_type_style_index_0_id_0e07d546_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Pagination_vue_vue_type_style_index_0_id_0e07d546_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvUGFnaW5hdGlvbi52dWU/NGU1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBNmYsQ0FBZ0IsdWdCQUFHLEVBQUMiLCJmaWxlIjoiMjA1Yy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTYtb25lT2YtMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtb25lT2YtMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTYtb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUGFnaW5hdGlvbi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wZTA3ZDU0NiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tNi1vbmVPZi0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNi1vbmVPZi0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi1vbmVPZi0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9QYWdpbmF0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTBlMDdkNTQ2JnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///205c\n')},2388:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RootModal_vue_vue_type_style_index_0_id_9b4d4c52_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("aae3");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RootModal_vue_vue_type_style_index_0_id_9b4d4c52_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RootModal_vue_vue_type_style_index_0_id_9b4d4c52_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_RootModal_vue_vue_type_style_index_0_id_9b4d4c52_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL1Jvb3RNb2RhbC52dWU/NzFmZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBNGYsQ0FBZ0Isc2dCQUFHLEVBQUMiLCJmaWxlIjoiMjM4OC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTYtb25lT2YtMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtb25lT2YtMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTYtb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUm9vdE1vZGFsLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTliNGQ0YzUyJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS02LW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1Jvb3RNb2RhbC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD05YjRkNGM1MiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2388\n')},"25d7":function(module){eval('module.exports = JSON.parse("{\\"abi\\":[{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"hasInitialized\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_script\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"getEVMScriptExecutor\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"POINT_ROOTNODE_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getRecoveryVault\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"ens\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"allowRecoverability\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"appId\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getInitializationBlock\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"transferToVault\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_sender\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_params\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"canPerform\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getEVMScriptRegistry\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"DELETE_NAME_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"kernel\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"isPetrified\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"rootNode\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"CREATE_NAME_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"label\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"NewName\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"label\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"DeleteName\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"executor\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"script\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"input\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"returnData\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"ScriptResult\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"vault\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"token\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"amount\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"RecoverToVault\\",\\"type\\":\\"event\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_ens\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_rootNode\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"initialize\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_label\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_owner\\",\\"type\\":\\"address\\"}],\\"name\\":\\"createName\\",\\"outputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_label\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_target\\",\\"type\\":\\"address\\"}],\\"name\\":\\"createNameAndPoint\\",\\"outputs\\":[{\\"name\\":\\"node\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_label\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"deleteName\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_target\\",\\"type\\":\\"address\\"}],\\"name\\":\\"pointRootNode\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiIyNWQ3LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25d7\n')},3049:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvVm90ZXMudnVlPzgyNzEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzA0OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3049\n")},3816:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Votes_vue_vue_type_style_index_0_id_5848e871_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("3049");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Votes_vue_vue_type_style_index_0_id_5848e871_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Votes_vue_vue_type_style_index_0_id_5848e871_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Votes_vue_vue_type_style_index_0_id_5848e871_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvVm90ZXMudnVlPzA5NmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQXdmLENBQWdCLGtnQkFBRyxFQUFDIiwiZmlsZSI6IjM4MTYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS02LW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1ZvdGVzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTU4NDhlODcxJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS02LW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1ZvdGVzLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTU4NDhlODcxJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///3816\n')},"4b05":function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nconst VotingEntity_1 = __importDefault(__webpack_require__("f633"));\nclass Cast extends VotingEntity_1.default {\n    constructor(data, connector) {\n        super(connector);\n        Object.assign(this, data);\n    }\n}\nexports.default = Cast;\n//# sourceMappingURL=Cast.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L2VudGl0aWVzL0Nhc3QuanM/NGIwNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsdUNBQXVDLG1CQUFPLENBQUMsTUFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0YjA1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBWb3RpbmdFbnRpdHlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9Wb3RpbmdFbnRpdHlcIikpO1xuY2xhc3MgQ2FzdCBleHRlbmRzIFZvdGluZ0VudGl0eV8xLmRlZmF1bHQge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIGNvbm5lY3Rvcikge1xuICAgICAgICBzdXBlcihjb25uZWN0b3IpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRhdGEpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENhc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYXN0LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4b05\n')},"4cd3":function(module){eval('module.exports = JSON.parse("{\\"abi\\":[{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"hasInitialized\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"apps\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"allowRecoverability\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"recoveryVaultAppId\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getInitializationBlock\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"APP_MANAGER_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"transferToVault\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_initializePayload\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"newAppProxyPinned\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"isPetrified\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"newAppProxy\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_initializePayload\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"newAppProxy\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"newAppProxyPinned\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"inputs\\":[{\\"name\\":\\"_shouldPetrify\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"constructor\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":false,\\"name\\":\\"proxy\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"isUpgradeable\\",\\"type\\":\\"bool\\"},{\\"indexed\\":false,\\"name\\":\\"appId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"NewAppProxy\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"vault\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"token\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"amount\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"RecoverToVault\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"namespace\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"appId\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"app\\",\\"type\\":\\"address\\"}],\\"name\\":\\"SetApp\\",\\"type\\":\\"event\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_baseAcl\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_permissionsCreator\\",\\"type\\":\\"address\\"}],\\"name\\":\\"initialize\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_appBase\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_initializePayload\\",\\"type\\":\\"bytes\\"},{\\"name\\":\\"_setDefault\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"newAppInstance\\",\\"outputs\\":[{\\"name\\":\\"appProxy\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_appBase\\",\\"type\\":\\"address\\"}],\\"name\\":\\"newAppInstance\\",\\"outputs\\":[{\\"name\\":\\"appProxy\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_appBase\\",\\"type\\":\\"address\\"}],\\"name\\":\\"newPinnedAppInstance\\",\\"outputs\\":[{\\"name\\":\\"appProxy\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_appBase\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_initializePayload\\",\\"type\\":\\"bytes\\"},{\\"name\\":\\"_setDefault\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"newPinnedAppInstance\\",\\"outputs\\":[{\\"name\\":\\"appProxy\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_namespace\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"}],\\"name\\":\\"setApp\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_recoveryVaultAppId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"setRecoveryVaultAppId\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"CORE_NAMESPACE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"pure\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"APP_BASES_NAMESPACE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"pure\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"APP_ADDR_NAMESPACE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"pure\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"KERNEL_APP_ID\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"pure\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"DEFAULT_ACL_APP_ID\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"pure\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_namespace\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"getApp\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getRecoveryVault\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"acl\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_who\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_where\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_what\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_how\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"hasPermission\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI0Y2QzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4cd3\n')},5023:function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.parseVotes = void 0;\nconst Vote_1 = __importDefault(__webpack_require__("fe98"));\nfunction parseVotes(result, connector) {\n    const votes = result.data.votes;\n    if (!votes) {\n        throw new Error(\'Unable to parse votes.\');\n    }\n    const datas = votes.map((vote) => {\n        return vote;\n    });\n    return datas.map((data) => {\n        return new Vote_1.default(data, connector);\n    });\n}\nexports.parseVotes = parseVotes;\n//# sourceMappingURL=votes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L3BhcnNlcnMvdm90ZXMuanM/NTAyMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSwrQkFBK0IsbUJBQU8sQ0FBQyxNQUFrQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsImZpbGUiOiI1MDIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlVm90ZXMgPSB2b2lkIDA7XG5jb25zdCBWb3RlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4uL2VudGl0aWVzL1ZvdGVcIikpO1xuZnVuY3Rpb24gcGFyc2VWb3RlcyhyZXN1bHQsIGNvbm5lY3Rvcikge1xuICAgIGNvbnN0IHZvdGVzID0gcmVzdWx0LmRhdGEudm90ZXM7XG4gICAgaWYgKCF2b3Rlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSB2b3Rlcy4nKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YXMgPSB2b3Rlcy5tYXAoKHZvdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHZvdGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGFzLm1hcCgoZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFZvdGVfMS5kZWZhdWx0KGRhdGEsIGNvbm5lY3Rvcik7XG4gICAgfSk7XG59XG5leHBvcnRzLnBhcnNlVm90ZXMgPSBwYXJzZVZvdGVzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dm90ZXMuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5023\n')},5872:function(module){eval('module.exports = JSON.parse("{\\"appName\\":\\"kernel.aragonpm.eth\\",\\"roles\\":[{\\"name\\":\\"Manage apps\\",\\"id\\":\\"APP_MANAGER_ROLE\\",\\"bytes\\":\\"0xb6d92708f3d4817afc106147d969e229ced5c46e65e0a5002a0d391287762bd0\\"},{\\"name\\":\\"Manage profile\\",\\"id\\":\\"MANAGE_PROFILE_ROLE\\",\\"bytes\\":\\"0x675b358b95ae7561136697fcc3302da54a334ac7c199d53621288290fb863f5c\\"}],\\"functions\\":[{\\"sig\\":\\"initialize(address,address)\\",\\"roles\\":[],\\"notice\\":\\"Initializes a kernel instance along with its ACL and sets `_permissionsCreator` as the entity that can create other permissions\\"},{\\"sig\\":\\"newAppInstance(bytes32,address)\\",\\"roles\\":[\\"APP_MANAGER_ROLE\\"],\\"notice\\":\\"Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`\\"},{\\"sig\\":\\"newAppInstance(bytes32,address,bytes,bool)\\",\\"roles\\":[\\"APP_MANAGER_ROLE\\"],\\"notice\\":\\"Create a new upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? \'Also sets it as the default app instance.\':\'\'`\\"},{\\"sig\\":\\"newPinnedAppInstance(bytes32,address)\\",\\"roles\\":[\\"APP_MANAGER_ROLE\\"],\\"notice\\":\\"Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`.\\"},{\\"sig\\":\\"newPinnedAppInstance(bytes32,address,bytes,bool)\\",\\"roles\\":[\\"APP_MANAGER_ROLE\\"],\\"notice\\":\\"Create a new non-upgradeable instance of `_appId` app linked to the Kernel, setting its code to `_appBase`. `_setDefault ? \'Also sets it as the default app instance.\':\'\'`\\"},{\\"sig\\":\\"setApp(bytes32,bytes32,address)\\",\\"roles\\":[\\"APP_MANAGER_ROLE\\"],\\"notice\\":\\"Set the resolving address of `_appId` in namespace `_namespace` to `_app`\\"},{\\"sig\\":\\"setRecoveryVaultAppId(bytes32)\\",\\"roles\\":[\\"APP_MANAGER_ROLE\\"],\\"notice\\":null},{\\"sig\\":\\"transferToVault(address)\\",\\"roles\\":[],\\"notice\\":\\"Send funds to recovery Vault. This contract should never receive funds, but in case it does, this function allows one to recover them.\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI1ODcyLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5872\n')},"5ac7":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Modal_vue_vue_type_style_index_0_id_0382e763_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ad46");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Modal_vue_vue_type_style_index_0_id_0382e763_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Modal_vue_vue_type_style_index_0_id_0382e763_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Modal_vue_vue_type_style_index_0_id_0382e763_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL01vZGFsLnZ1ZT9lOWYxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUF3ZixDQUFnQixrZ0JBQUcsRUFBQyIsImZpbGUiOiI1YWM3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tNi1vbmVPZi0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNi1vbmVPZi0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi1vbmVPZi0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Nb2RhbC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wMzgyZTc2MyZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tNi1vbmVPZi0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNi1vbmVPZi0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi1vbmVPZi0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Nb2RhbC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wMzgyZTc2MyZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5ac7\n')},"5d16":function(module){eval('module.exports = JSON.parse("{\\"abi\\":[{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"hasInitialized\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_script\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"getEVMScriptExecutor\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getRecoveryVault\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"allowRecoverability\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"appId\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getInitializationBlock\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"transferToVault\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_sender\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_params\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"canPerform\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getEVMScriptRegistry\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"CREATE_VERSION_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"kernel\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"isPetrified\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":false,\\"name\\":\\"versionId\\",\\"type\\":\\"uint256\\"},{\\"indexed\\":false,\\"name\\":\\"semanticVersion\\",\\"type\\":\\"uint16[3]\\"}],\\"name\\":\\"NewVersion\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"executor\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"script\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"input\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"returnData\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"ScriptResult\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"vault\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"token\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"amount\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"RecoverToVault\\",\\"type\\":\\"event\\"},{\\"constant\\":false,\\"inputs\\":[],\\"name\\":\\"initialize\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_newSemanticVersion\\",\\"type\\":\\"uint16[3]\\"},{\\"name\\":\\"_contractAddress\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_contentURI\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"newVersion\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getLatest\\",\\"outputs\\":[{\\"name\\":\\"semanticVersion\\",\\"type\\":\\"uint16[3]\\"},{\\"name\\":\\"contractAddress\\",\\"type\\":\\"address\\"},{\\"name\\":\\"contentURI\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_contractAddress\\",\\"type\\":\\"address\\"}],\\"name\\":\\"getLatestForContractAddress\\",\\"outputs\\":[{\\"name\\":\\"semanticVersion\\",\\"type\\":\\"uint16[3]\\"},{\\"name\\":\\"contractAddress\\",\\"type\\":\\"address\\"},{\\"name\\":\\"contentURI\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_semanticVersion\\",\\"type\\":\\"uint16[3]\\"}],\\"name\\":\\"getBySemanticVersion\\",\\"outputs\\":[{\\"name\\":\\"semanticVersion\\",\\"type\\":\\"uint16[3]\\"},{\\"name\\":\\"contractAddress\\",\\"type\\":\\"address\\"},{\\"name\\":\\"contentURI\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_versionId\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"getByVersionId\\",\\"outputs\\":[{\\"name\\":\\"semanticVersion\\",\\"type\\":\\"uint16[3]\\"},{\\"name\\":\\"contractAddress\\",\\"type\\":\\"address\\"},{\\"name\\":\\"contentURI\\",\\"type\\":\\"bytes\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getVersionsCount\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_oldVersion\\",\\"type\\":\\"uint16[3]\\"},{\\"name\\":\\"_newVersion\\",\\"type\\":\\"uint16[3]\\"}],\\"name\\":\\"isValidBump\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"pure\\",\\"type\\":\\"function\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI1ZDE2LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5d16\n')},7197:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/EnactVote.vue?vue&type=template&id=0692063c&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'span\',[(_vm.showRootModal)?_c(\'div\',{staticClass:"modal rootmodal",attrs:{"id":"modal"},on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.hideRootModal($event)}}},[_c(\'div\',{staticClass:"modal-content window white"},[_c(\'fieldset\',[_c(\'div\',{staticClass:"legend2 hoverpointer",on:{"click":_vm.hideRootModal}},[_vm._v(" ["),_c(\'span\',{staticClass:"greentext"},[_vm._v("X")]),_vm._v("] ")]),_c(\'legend\',[_vm._v("Execute vote #"+_vm._s(_vm.vote.voteNumber)+" on "+_vm._s(_vm.appName))]),_c(\'div\',{staticClass:"content"},[_c(\'div\',[_c(\'span\',[_vm._v(" "+_vm._s(_vm.voteDescription)+" ")]),(_vm.vote)?_c(\'div\',{staticClass:"content"},[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.contractName),expression:"vote.contractName"}]},[_vm._v(" "+_vm._s(_vm.vote.contractName)+": "),_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.metadata),expression:"!vote.contractName && vote.metadata"}]},[_vm._v(" "+_vm._s(_vm.vote.metadata)+" ")]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.description),expression:"!vote.contractName && vote.description"}]},[_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})])]):_vm._e()]),_c(\'hr\'),_c(\'p\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.executeVote),expression:"!executeVote"}],staticClass:"explanation"},[_vm._v(" This vote requires "+_vm._s(_vm.getSupportText)+"% acceptance and "+_vm._s(_vm.getQuorumText)+"% quorum to be passed ")]),_c(\'p\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.willSucceed),expression:"!willSucceed"}],staticClass:"simple-error"},[_vm._v(" The transaction may fail, you may not have the required permissions to make the transaction ")])]),_c(\'button\',{on:{"click":_vm.createVote}},[_vm._v("Execute")])])])]):_vm._e(),_c(\'button\',{directives:[{name:"show",rawName:"v-show",value:(_vm.canExecute),expression:"canExecute"}],on:{"click":_vm.enact}},[_vm._v("Enact "),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.loading),expression:"loading"}],staticClass:"loading line"})])])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/votes/EnactVote.vue?vue&type=template&id=0692063c&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__("96cf");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__("1da1");\n\n// EXTERNAL MODULE: ./src/contract.js\nvar contract = __webpack_require__("51bf");\n\n// EXTERNAL MODULE: ./src/components/dao/voteStore.js\nvar voteStore = __webpack_require__("3f2c");\n\n// EXTERNAL MODULE: ./src/components/dao/common/RootModalMixin.js\nvar RootModalMixin = __webpack_require__("f655");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/EnactVote.vue?vue&type=script&lang=js&\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n/* harmony default export */ var EnactVotevue_type_script_lang_js_ = ({\n  props: [\'vote\'],\n  mixins: [RootModalMixin["a" /* default */]],\n  data: function data() {\n    return {\n      loading: false\n    };\n  },\n  methods: {\n    canExecute: voteStore["f" /* canExecute */],\n    enact: function enact() {\n      var _this = this;\n\n      return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var intent, paths;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                console.log("ENACT");\n                _this.loading = true;\n                _context.prev = 2;\n                _context.next = 5;\n                return voteStore["n" /* state */].org.appIntent(_this.vote.appAddress.toLowerCase(), \'executeVote(uint256)\', [_this.vote.voteNumber]);\n\n              case 5:\n                intent = _context.sent;\n                _context.next = 11;\n                break;\n\n              case 8:\n                _context.prev = 8;\n                _context.t0 = _context["catch"](2);\n                console.error(_context.t0);\n\n              case 11:\n                _context.next = 13;\n                return intent.paths(contract["b" /* contract */].default_account);\n\n              case 13:\n                paths = _context.sent;\n                voteStore["n" /* state */].transactionIntent = paths;\n                _this.loading = false;\n                voteStore["n" /* state */].showModal = false;\n                _this.showRootModal = true;\n                voteStore["n" /* state */].executeVote = true;\n                console.log(paths, "THEPATH");\n\n              case 20:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 8]]);\n      }))();\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/votes/EnactVote.vue?vue&type=script&lang=js&\n /* harmony default export */ var votes_EnactVotevue_type_script_lang_js_ = (EnactVotevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// CONCATENATED MODULE: ./src/components/dao/votes/EnactVote.vue\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  votes_EnactVotevue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "0692063c",\n  null\n  \n)\n\n/* harmony default export */ var EnactVote = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvRW5hY3RWb3RlLnZ1ZT81M2EyIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvRW5hY3RWb3RlLnZ1ZT9iYjA1Iiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9FbmFjdFZvdGUudnVlP2EwNjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL3ZvdGVzL0VuYWN0Vm90ZS52dWU/Mzk1ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDBCQUEwQixhQUFhLDBCQUEwQix3QkFBd0IsZ0RBQWdELHFDQUFxQyxhQUFhLEtBQUsseUJBQXlCLDJDQUEyQyxhQUFhLEVBQUUsbUNBQW1DLFlBQVkseUNBQXlDLDJCQUEyQix1Q0FBdUMsMkJBQTJCLDBCQUEwQix3QkFBd0Isd0lBQXdJLHNCQUFzQiwwRkFBMEYsc0JBQXNCLGFBQWEsYUFBYSwwRkFBMEYsRUFBRSw0REFBNEQsVUFBVSwwQ0FBMEMsZUFBZSxhQUFhLGtJQUFrSSxFQUFFLHlEQUF5RCxhQUFhLHdJQUF3SSxFQUFFLGFBQWEsVUFBVSwwQ0FBMEMsa0NBQWtDLGFBQWEsZ0ZBQWdGLDRCQUE0Qiw2SUFBNkksYUFBYSxnRkFBZ0YsNkJBQTZCLDJIQUEySCxJQUFJLHdCQUF3QixrREFBa0QsYUFBYSw0RUFBNEUsTUFBTSxtQkFBbUIsOEJBQThCLGFBQWEsc0VBQXNFLDZCQUE2QjtBQUMxd0U7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN5Q0E7QUFFQTtBQUVBO0FBRUE7QUFDQSxpQkFEQTtBQUdBLDZDQUhBO0FBS0E7QUFBQTtBQUNBO0FBREE7QUFBQSxHQUxBO0FBU0E7QUFDQSwrQ0FEQTtBQUVBLFNBRkEsbUJBRUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUFBLHVCQUtBLDhIQUxBOztBQUFBO0FBS0Esc0JBTEE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQVFBOztBQVJBO0FBQUE7QUFBQSx1QkFVQSwwREFWQTs7QUFBQTtBQVVBLHFCQVZBO0FBWUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUdBOztBQXJCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXNCQTtBQXhCQTtBQVRBLEc7O0FDaERpVyxDQUFnQiw2R0FBRyxFQUFDLEM7Ozs7O0FDQWpSO0FBQ3ZDO0FBQ0w7OztBQUd4RDtBQUNnRztBQUNoRyxnQkFBZ0IsOENBQVU7QUFDMUIsRUFBRSx1Q0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSwwRiIsImZpbGUiOiI3MTk3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ3NwYW4nLFsoX3ZtLnNob3dSb290TW9kYWwpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcIm1vZGFsIHJvb3Rtb2RhbFwiLGF0dHJzOntcImlkXCI6XCJtb2RhbFwifSxvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7aWYoJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXQpeyByZXR1cm4gbnVsbDsgfXJldHVybiBfdm0uaGlkZVJvb3RNb2RhbCgkZXZlbnQpfX19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtb2RhbC1jb250ZW50IHdpbmRvdyB3aGl0ZVwifSxbX2MoJ2ZpZWxkc2V0JyxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibGVnZW5kMiBob3ZlcnBvaW50ZXJcIixvbjp7XCJjbGlja1wiOl92bS5oaWRlUm9vdE1vZGFsfX0sW192bS5fdihcIiBbXCIpLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJncmVlbnRleHRcIn0sW192bS5fdihcIlhcIildKSxfdm0uX3YoXCJdIFwiKV0pLF9jKCdsZWdlbmQnLFtfdm0uX3YoXCJFeGVjdXRlIHZvdGUgI1wiK192bS5fcyhfdm0udm90ZS52b3RlTnVtYmVyKStcIiBvbiBcIitfdm0uX3MoX3ZtLmFwcE5hbWUpKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbnRlbnRcIn0sW19jKCdkaXYnLFtfYygnc3BhbicsW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLnZvdGVEZXNjcmlwdGlvbikrXCIgXCIpXSksKF92bS52b3RlKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb250ZW50XCJ9LFtfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLnZvdGUuY29udHJhY3ROYW1lKSxleHByZXNzaW9uOlwidm90ZS5jb250cmFjdE5hbWVcIn1dfSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0udm90ZS5jb250cmFjdE5hbWUpK1wiOiBcIiksX2MoJ3NwYW4nLHtkb21Qcm9wczp7XCJpbm5lckhUTUxcIjpfdm0uX3MoX3ZtLnZvdGUuZGVzY3JpcHRpb24pfX0pXSksX2MoJ3NwYW4nLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KCFfdm0udm90ZS5jb250cmFjdE5hbWUgJiYgX3ZtLnZvdGUubWV0YWRhdGEpLGV4cHJlc3Npb246XCIhdm90ZS5jb250cmFjdE5hbWUgJiYgdm90ZS5tZXRhZGF0YVwifV19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS52b3RlLm1ldGFkYXRhKStcIiBcIildKSxfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS52b3RlLmNvbnRyYWN0TmFtZSAmJiBfdm0udm90ZS5kZXNjcmlwdGlvbiksZXhwcmVzc2lvbjpcIiF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLmRlc2NyaXB0aW9uXCJ9XX0sW19jKCdzcGFuJyx7ZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKF92bS52b3RlLmRlc2NyaXB0aW9uKX19KV0pXSk6X3ZtLl9lKCldKSxfYygnaHInKSxfYygncCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS5leGVjdXRlVm90ZSksZXhwcmVzc2lvbjpcIiFleGVjdXRlVm90ZVwifV0sc3RhdGljQ2xhc3M6XCJleHBsYW5hdGlvblwifSxbX3ZtLl92KFwiIFRoaXMgdm90ZSByZXF1aXJlcyBcIitfdm0uX3MoX3ZtLmdldFN1cHBvcnRUZXh0KStcIiUgYWNjZXB0YW5jZSBhbmQgXCIrX3ZtLl9zKF92bS5nZXRRdW9ydW1UZXh0KStcIiUgcXVvcnVtIHRvIGJlIHBhc3NlZCBcIildKSxfYygncCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS53aWxsU3VjY2VlZCksZXhwcmVzc2lvbjpcIiF3aWxsU3VjY2VlZFwifV0sc3RhdGljQ2xhc3M6XCJzaW1wbGUtZXJyb3JcIn0sW192bS5fdihcIiBUaGUgdHJhbnNhY3Rpb24gbWF5IGZhaWwsIHlvdSBtYXkgbm90IGhhdmUgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zIHRvIG1ha2UgdGhlIHRyYW5zYWN0aW9uIFwiKV0pXSksX2MoJ2J1dHRvbicse29uOntcImNsaWNrXCI6X3ZtLmNyZWF0ZVZvdGV9fSxbX3ZtLl92KFwiRXhlY3V0ZVwiKV0pXSldKV0pOl92bS5fZSgpLF9jKCdidXR0b24nLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5jYW5FeGVjdXRlKSxleHByZXNzaW9uOlwiY2FuRXhlY3V0ZVwifV0sb246e1wiY2xpY2tcIjpfdm0uZW5hY3R9fSxbX3ZtLl92KFwiRW5hY3QgXCIpLF9jKCdzcGFuJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOihfdm0ubG9hZGluZyksZXhwcmVzc2lvbjpcImxvYWRpbmdcIn1dLHN0YXRpY0NsYXNzOlwibG9hZGluZyBsaW5lXCJ9KV0pXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cblx0PHNwYW4+XG5cdFx0PGRpdiBpZD0nbW9kYWwnIGNsYXNzPSdtb2RhbCByb290bW9kYWwnIHYtaWY9J3Nob3dSb290TW9kYWwnIEBjbGljay5zZWxmPSdoaWRlUm9vdE1vZGFsJz5cblx0XHRcdDxkaXYgY2xhc3M9J21vZGFsLWNvbnRlbnQgd2luZG93IHdoaXRlJz5cblx0XHRcdFx0PGZpZWxkc2V0PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9J2xlZ2VuZDIgaG92ZXJwb2ludGVyJyBAY2xpY2s9J2hpZGVSb290TW9kYWwnPlxuXHRcdFx0XHRcdFx0WzxzcGFuIGNsYXNzPSdncmVlbnRleHQnPlg8L3NwYW4+XVxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxsZWdlbmQ+RXhlY3V0ZSB2b3RlICN7eyB2b3RlLnZvdGVOdW1iZXIgfX0gb24ge3sgYXBwTmFtZSB9fTwvbGVnZW5kPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9J2NvbnRlbnQnPlxuXHRcdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdFx0PHNwYW4+IHt7IHZvdGVEZXNjcmlwdGlvbiB9fSA8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9J2NvbnRlbnQnIHYtaWY9J3ZvdGUnPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIHYtc2hvdz0ndm90ZS5jb250cmFjdE5hbWUnPlxuXHRcdFx0XHRcdFx0XHRcdFx0e3sgdm90ZS5jb250cmFjdE5hbWUgfX06IDxzcGFuIHYtaHRtbD0ndm90ZS5kZXNjcmlwdGlvbic+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiB2LXNob3c9JyF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLm1ldGFkYXRhJz5cblx0XHRcdFx0XHRcdFx0XHRcdHt7IHZvdGUubWV0YWRhdGEgfX1cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gdi1zaG93PSchdm90ZS5jb250cmFjdE5hbWUgJiYgdm90ZS5kZXNjcmlwdGlvbic+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiB2LWh0bWw9J3ZvdGUuZGVzY3JpcHRpb24nPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8aHI+XG5cdFx0XHRcdFx0XHQ8cCBjbGFzcz0nZXhwbGFuYXRpb24nIHYtc2hvdz0nIWV4ZWN1dGVWb3RlJz5cblx0XHRcdFx0XHRcdFx0VGhpcyB2b3RlIHJlcXVpcmVzIHt7IGdldFN1cHBvcnRUZXh0IH19JSBhY2NlcHRhbmNlIGFuZCB7eyBnZXRRdW9ydW1UZXh0IH19JSBxdW9ydW0gdG8gYmUgcGFzc2VkXG5cdFx0XHRcdFx0XHQ8L3A+XG5cdFx0XHRcdFx0XHQ8cCBjbGFzcz0nc2ltcGxlLWVycm9yJyB2LXNob3c9JyF3aWxsU3VjY2VlZCc+XG5cdFx0XHRcdFx0XHRcdFRoZSB0cmFuc2FjdGlvbiBtYXkgZmFpbCwgeW91IG1heSBub3QgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbnMgdG8gbWFrZSB0aGUgdHJhbnNhY3Rpb25cblx0XHRcdFx0XHRcdDwvcD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8YnV0dG9uIEBjbGljaz0nY3JlYXRlVm90ZSc+RXhlY3V0ZTwvYnV0dG9uPlxuXHRcdFx0XHQ8L2ZpZWxkc2V0PlxuXHRcdFx0PC9kaXY+XG5cdFx0PC9kaXY+XG5cblx0XHQ8YnV0dG9uIHYtc2hvdz0nY2FuRXhlY3V0ZScgQGNsaWNrPSdlbmFjdCc+RW5hY3QgPHNwYW4gY2xhc3M9J2xvYWRpbmcgbGluZScgdi1zaG93PSdsb2FkaW5nJz48L3NwYW4+PC9idXR0b24+XG5cdDwvc3Bhbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IGNvbnRyYWN0IH0gZnJvbSAnLi4vLi4vLi4vY29udHJhY3QnXG5cblx0aW1wb3J0IHsgc3RhdGUsIE9XTkVSU0hJUF9BUFBfQUREUkVTUywgUEFSQU1FVEVSX0FQUF9BRERSRVNTLCBoZWxwZXJzIGFzIHZvdGVIZWxwZXJzLCBjYW5FeGVjdXRlIH0gZnJvbSAnLi4vdm90ZVN0b3JlJ1xuXG5cdGltcG9ydCBSb290TW9kYWxNaXhpbiBmcm9tICcuLi9jb21tb24vUm9vdE1vZGFsTWl4aW4nXG5cblx0ZXhwb3J0IGRlZmF1bHQge1xuXHRcdHByb3BzOiBbJ3ZvdGUnXSxcblxuXHRcdG1peGluczogW1Jvb3RNb2RhbE1peGluXSxcblxuXHRcdGRhdGE6ICgpID0+ICh7XG5cdFx0XHRsb2FkaW5nOiBmYWxzZSxcblx0XHR9KSxcblxuXHRcdG1ldGhvZHM6IHtcblx0XHRcdGNhbkV4ZWN1dGUsXG5cdFx0XHRhc3luYyBlbmFjdCgpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXCJFTkFDVFwiKVxuXHRcdFx0XHR0aGlzLmxvYWRpbmcgPSB0cnVlXG5cdFx0XHRcdGxldCBpbnRlbnRcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpbnRlbnQgPSBhd2FpdCBzdGF0ZS5vcmcuYXBwSW50ZW50KHRoaXMudm90ZS5hcHBBZGRyZXNzLnRvTG93ZXJDYXNlKCksICdleGVjdXRlVm90ZSh1aW50MjU2KScsIFt0aGlzLnZvdGUudm90ZU51bWJlcl0pXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2goZXJyKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnIpXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IHBhdGhzID0gYXdhaXQgaW50ZW50LnBhdGhzKGNvbnRyYWN0LmRlZmF1bHRfYWNjb3VudClcblxuXHRcdFx0XHRzdGF0ZS50cmFuc2FjdGlvbkludGVudCA9IHBhdGhzXG5cblx0XHRcdFx0dGhpcy5sb2FkaW5nID0gZmFsc2Vcblx0XHRcdFx0c3RhdGUuc2hvd01vZGFsID0gZmFsc2VcblxuXHRcdFx0XHR0aGlzLnNob3dSb290TW9kYWwgPSB0cnVlXG5cdFx0XHRcdHN0YXRlLmV4ZWN1dGVWb3RlID0gdHJ1ZVxuXG5cblx0XHRcdFx0Y29uc29sZS5sb2cocGF0aHMsIFwiVEhFUEFUSFwiKVxuXHRcdFx0fSxcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXHRcbjwvc3R5bGU+IiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9FbmFjdFZvdGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0VuYWN0Vm90ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL0VuYWN0Vm90ZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MDY5MjA2M2Mmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vRW5hY3RWb3RlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vRW5hY3RWb3RlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMDY5MjA2M2NcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7197\n')},"71b1":function(module,exports){eval("//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoL2Rpc3QvZXNtL3R5cGVzLmpzPzcxYjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNzFiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///71b1\n")},"73c7":function(module){eval('module.exports = JSON.parse("{\\"appName\\":\\"acl.aragonpm.eth\\",\\"roles\\":[{\\"name\\":\\"Create permissions\\",\\"id\\":\\"CREATE_PERMISSIONS_ROLE\\",\\"bytes\\":\\"0x0b719b33c83b8e5d300c521cb8b54ae9bd933996a14bef8c2f4e0285d2d2400a\\"}],\\"functions\\":[{\\"sig\\":\\"initialize(address)\\",\\"roles\\":[],\\"notice\\":\\"Initializes an ACL instance and sets `_permissionsCreator` as the entity that can create other permissions\\"},{\\"sig\\":\\"createPermission(address,address,bytes32,address)\\",\\"roles\\":[\\"CREATE_PERMISSIONS_ROLE\\"],\\"notice\\":\\"Create a new permission granting `_entity` the ability to perform actions of role `_role` on `_app` (setting `_manager` as the permission manager)\\"},{\\"sig\\":\\"grantPermission(address,address,bytes32)\\",\\"roles\\":[],\\"notice\\":\\"Grants `_entity` the ability to perform actions of role `_role` on `_app`\\"},{\\"sig\\":\\"grantPermissionP(address,address,bytes32,uint256[])\\",\\"roles\\":[],\\"notice\\":\\"Grants `_entity` the ability to perform actions of role `_role` on `_app`\\"},{\\"sig\\":\\"revokePermission(address,address,bytes32)\\",\\"roles\\":[],\\"notice\\":\\"Revokes `_entity` the ability to perform actions of role `_role` on `_app`\\"},{\\"sig\\":\\"setPermissionManager(address,address,bytes32)\\",\\"roles\\":[],\\"notice\\":\\"Sets `_newManager` as the manager of the permission `_role` in `_app`\\"},{\\"sig\\":\\"removePermissionManager(address,bytes32)\\",\\"roles\\":[],\\"notice\\":\\"Removes the manager of the permission `_role` in `_app`\\"},{\\"sig\\":\\"getPermissionParam(address,address,address)\\",\\"roles\\":[],\\"notice\\":\\"Get parameter for permission\\"},{\\"sig\\":\\"_evalLogic(address,bytes32,address,address,bytes32,uint256[])\\",\\"roles\\":[],\\"notice\\":null},{\\"sig\\":\\"transferToVault(address)\\",\\"roles\\":[],\\"notice\\":\\"Send funds to recovery Vault. This contract should never receive funds, but in case it does, this function allows one to recover them.\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI3M2M3LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///73c7\n')},"7f03":function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL0NvdW50ZG93bi52dWU/ODUxYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI3ZjAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7f03\n")},"81e0":function(module,exports,__webpack_require__){"use strict";eval('\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n    o["default"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nconst connect_thegraph_1 = __webpack_require__("b758");\nconst queries = __importStar(__webpack_require__("e707"));\nconst parsers_1 = __webpack_require__("d1ac");\nclass VotingConnectorTheGraph extends connect_thegraph_1.GraphQLWrapper {\n    async votesForApp(appAddress, first, skip) {\n        return this.performQueryWithParser(queries.ALL_VOTES(\'query\'), { appAddress, first, skip }, parsers_1.parseVotes);\n    }\n    onVotesForApp(appAddress, callback) {\n        return this.subscribeToQueryWithParser(queries.ALL_VOTES(\'subscription\'), { appAddress, first: 1000, skip: 0 }, callback, parsers_1.parseVotes);\n    }\n    async castsForVote(voteId, first, skip) {\n        return this.performQueryWithParser(queries.CASTS_FOR_VOTE(\'query\'), { voteId, first, skip }, parsers_1.parseCasts);\n    }\n    onCastsForVote(voteId, callback) {\n        return this.subscribeToQueryWithParser(queries.CASTS_FOR_VOTE(\'subscription\'), { voteId, first: 1000, skip: 0 }, callback, parsers_1.parseCasts);\n    }\n}\nexports.default = VotingConnectorTheGraph;\n//# sourceMappingURL=connector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L2Nvbm5lY3Rvci5qcz84MWUwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBLGtDQUFrQyxvQ0FBb0MsYUFBYSxFQUFFLEVBQUU7QUFDdkYsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSx5Q0FBeUMsNkJBQTZCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVELDJCQUEyQixtQkFBTyxDQUFDLE1BQTBCO0FBQzdELDZCQUE2QixtQkFBTyxDQUFDLE1BQVc7QUFDaEQsa0JBQWtCLG1CQUFPLENBQUMsTUFBVztBQUNyQztBQUNBO0FBQ0Esd0VBQXdFLDBCQUEwQjtBQUNsRztBQUNBO0FBQ0EsbUZBQW1GLG1DQUFtQztBQUN0SDtBQUNBO0FBQ0EsNkVBQTZFLHNCQUFzQjtBQUNuRztBQUNBO0FBQ0Esd0ZBQXdGLCtCQUErQjtBQUN2SDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4MWUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29ubmVjdF90aGVncmFwaF8xID0gcmVxdWlyZShcIkBhcmFnb24vY29ubmVjdC10aGVncmFwaFwiKTtcbmNvbnN0IHF1ZXJpZXMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcXVlcmllc1wiKSk7XG5jb25zdCBwYXJzZXJzXzEgPSByZXF1aXJlKFwiLi9wYXJzZXJzXCIpO1xuY2xhc3MgVm90aW5nQ29ubmVjdG9yVGhlR3JhcGggZXh0ZW5kcyBjb25uZWN0X3RoZWdyYXBoXzEuR3JhcGhRTFdyYXBwZXIge1xuICAgIGFzeW5jIHZvdGVzRm9yQXBwKGFwcEFkZHJlc3MsIGZpcnN0LCBza2lwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcmZvcm1RdWVyeVdpdGhQYXJzZXIocXVlcmllcy5BTExfVk9URVMoJ3F1ZXJ5JyksIHsgYXBwQWRkcmVzcywgZmlyc3QsIHNraXAgfSwgcGFyc2Vyc18xLnBhcnNlVm90ZXMpO1xuICAgIH1cbiAgICBvblZvdGVzRm9yQXBwKGFwcEFkZHJlc3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZVRvUXVlcnlXaXRoUGFyc2VyKHF1ZXJpZXMuQUxMX1ZPVEVTKCdzdWJzY3JpcHRpb24nKSwgeyBhcHBBZGRyZXNzLCBmaXJzdDogMTAwMCwgc2tpcDogMCB9LCBjYWxsYmFjaywgcGFyc2Vyc18xLnBhcnNlVm90ZXMpO1xuICAgIH1cbiAgICBhc3luYyBjYXN0c0ZvclZvdGUodm90ZUlkLCBmaXJzdCwgc2tpcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtUXVlcnlXaXRoUGFyc2VyKHF1ZXJpZXMuQ0FTVFNfRk9SX1ZPVEUoJ3F1ZXJ5JyksIHsgdm90ZUlkLCBmaXJzdCwgc2tpcCB9LCBwYXJzZXJzXzEucGFyc2VDYXN0cyk7XG4gICAgfVxuICAgIG9uQ2FzdHNGb3JWb3RlKHZvdGVJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaWJlVG9RdWVyeVdpdGhQYXJzZXIocXVlcmllcy5DQVNUU19GT1JfVk9URSgnc3Vic2NyaXB0aW9uJyksIHsgdm90ZUlkLCBmaXJzdDogMTAwMCwgc2tpcDogMCB9LCBjYWxsYmFjaywgcGFyc2Vyc18xLnBhcnNlQ2FzdHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZvdGluZ0Nvbm5lY3RvclRoZUdyYXBoO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdG9yLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///81e0\n')},"91ac":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Vote_vue_vue_type_style_index_0_id_22e6bba6_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a3ed");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Vote_vue_vue_type_style_index_0_id_22e6bba6_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Vote_vue_vue_type_style_index_0_id_22e6bba6_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Vote_vue_vue_type_style_index_0_id_22e6bba6_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvVm90ZS52dWU/YTkxMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBdWYsQ0FBZ0IsaWdCQUFHLEVBQUMiLCJmaWxlIjoiOTFhYy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTYtb25lT2YtMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtb25lT2YtMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTYtb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vVm90ZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yMmU2YmJhNiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vZGlzdC9sb2FkZXIuanM/P3JlZi0tNi1vbmVPZi0xLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tNi1vbmVPZi0xLTEhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3JlZi0tNi1vbmVPZi0xLTIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Wb3RlLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTIyZTZiYmE2JnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///91ac\n')},"924f":function(module){eval('module.exports = JSON.parse("{\\"abi\\":[{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"hasInitialized\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"NO_PERMISSION\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_script\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"getEVMScriptExecutor\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getRecoveryVault\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"CREATE_PERMISSIONS_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"allowRecoverability\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"appId\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getInitializationBlock\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"transferToVault\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_sender\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_params\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"canPerform\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getEVMScriptRegistry\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"ANY_ENTITY\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"EMPTY_PARAM_HASH\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"kernel\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"isPetrified\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"BURN_ENTITY\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"entity\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"app\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"role\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"allowed\\",\\"type\\":\\"bool\\"}],\\"name\\":\\"SetPermission\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"entity\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"app\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"role\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"paramsHash\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"SetPermissionParams\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"app\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"role\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":true,\\"name\\":\\"manager\\",\\"type\\":\\"address\\"}],\\"name\\":\\"ChangePermissionManager\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"executor\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"script\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"input\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"returnData\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"ScriptResult\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"vault\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"token\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"amount\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"RecoverToVault\\",\\"type\\":\\"event\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_permissionsCreator\\",\\"type\\":\\"address\\"}],\\"name\\":\\"initialize\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_entity\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_manager\\",\\"type\\":\\"address\\"}],\\"name\\":\\"createPermission\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_entity\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"grantPermission\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_entity\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_params\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"grantPermissionP\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_entity\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"revokePermission\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_newManager\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"setPermissionManager\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"removePermissionManager\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"createBurnedPermission\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"burnPermissionManager\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_entity\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"getPermissionParamsLength\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_entity\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_index\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"getPermissionParam\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint8\\"},{\\"name\\":\\"\\",\\"type\\":\\"uint8\\"},{\\"name\\":\\"\\",\\"type\\":\\"uint240\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_app\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"getPermissionManager\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_who\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_where\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_what\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"hasPermission\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_who\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_where\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_what\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_how\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"hasPermission\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_who\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_where\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_what\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_how\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"hasPermission\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_paramsHash\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_who\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_where\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_what\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_how\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"evalParams\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiI5MjRmLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///924f\n')},9698:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvTmV3VGV4dFZvdGUudnVlPzgyNWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiOTY5OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9698\n")},"97ad":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Countdown_vue_vue_type_style_index_0_id_f66a7640_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("7f03");\n/* harmony import */ var _node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Countdown_vue_vue_type_style_index_0_id_f66a7640_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Countdown_vue_vue_type_style_index_0_id_f66a7640_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__);\n/* unused harmony reexport * */\n /* unused harmony default export */ var _unused_webpack_default_export = (_node_modules_mini_css_extract_plugin_dist_loader_js_ref_6_oneOf_1_0_node_modules_css_loader_dist_cjs_js_ref_6_oneOf_1_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_src_index_js_ref_6_oneOf_1_2_node_modules_cache_loader_dist_cjs_js_ref_0_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Countdown_vue_vue_type_style_index_0_id_f66a7640_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0___default.a); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL0NvdW50ZG93bi52dWU/ZWM2MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBNGYsQ0FBZ0Isc2dCQUFHLEVBQUMiLCJmaWxlIjoiOTdhZC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2Rpc3QvbG9hZGVyLmpzPz9yZWYtLTYtb25lT2YtMS0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTYtb25lT2YtMS0xIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3N0eWxlUG9zdExvYWRlci5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9yZWYtLTYtb25lT2YtMS0yIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ291bnRkb3duLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWY2NmE3NjQwJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9taW5pLWNzcy1leHRyYWN0LXBsdWdpbi9kaXN0L2xvYWRlci5qcz8/cmVmLS02LW9uZU9mLTEtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS02LW9uZU9mLTEtMSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cmVmLS02LW9uZU9mLTEtMiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0NvdW50ZG93bi52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD1mNjZhNzY0MCZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97ad\n')},"9abc":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/Votes.vue?vue&type=template&id=5848e871&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{staticClass:"window white"},[_c(\'fieldset\',[_c(\'legend\',[_vm._v("Votes")]),_c(\'new-text-vote\'),_c(\'div\',{staticClass:"filter"},[_c(\'fieldset\',[_c(\'legend\',[_vm._v("Filter")]),_c(\'div\',[_c(\'span\',[_vm._v("Status:")]),_c(\'select\',{directives:[{name:"model",rawName:"v-model",value:(_vm.filterStatus),expression:"filterStatus"}],staticClass:"tvision",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.filterStatus=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},_vm._l((_vm.allStatus),function(status){return _c(\'option\',{domProps:{"value":status.val}},[_vm._v(" "+_vm._s(status.text)+" ")])}),0),_c(\'span\',[_vm._v("Outcome:")]),_c(\'select\',{directives:[{name:"model",rawName:"v-model",value:(_vm.filterOutcome),expression:"filterOutcome"}],staticClass:"tvision",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.filterOutcome=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},_vm._l((_vm.allOutcome),function(outcome){return _c(\'option\',{domProps:{"value":outcome.val}},[_vm._v(" "+_vm._s(outcome.text)+" ")])}),0),_c(\'span\',[_vm._v("App:")]),_c(\'select\',{directives:[{name:"model",rawName:"v-model",value:(_vm.filterApp),expression:"filterApp"}],staticClass:"tvision",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.filterApp=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},_vm._l((_vm.allApp),function(app){return _c(\'option\',{domProps:{"value":app.val}},[_vm._v(" "+_vm._s(app.text)+" ")])}),0)])])]),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.customFilter),expression:"!customFilter"}],staticClass:"votes-wrapper header"},[_c(\'fieldset\',[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.loadedVotes),expression:"!loadedVotes"}],staticClass:"loading matrix"}),_c(\'legend\',[_vm._v("Open votes ("+_vm._s(_vm.openVotes.length)+")")]),_c(\'div\',{staticClass:"votes open"},_vm._l((_vm.openVotes),function(vote){return _c(\'vote\',{key:vote.id,staticClass:"vote",attrs:{"vote":vote}})}),1)])]),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.customFilter),expression:"!customFilter"}],staticClass:"votes-wrapper header"},[_c(\'fieldset\',[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.loadedVotes),expression:"!loadedVotes"}],staticClass:"loading matrix"}),_c(\'legend\',[_vm._v("Closed votes ("+_vm._s(_vm.closedVotes.length)+")")]),_c(\'div\',{staticClass:"votes closed"},_vm._l((_vm.closedVotes),function(vote){return _c(\'vote\',{key:vote.id,staticClass:"vote",attrs:{"vote":vote}})}),1)])]),(_vm.customFilter)?_c(\'div\',{staticClass:"votes-wrapper header"},[_c(\'fieldset\',[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.loadedVotes),expression:"!loadedVotes"}],staticClass:"loading matrix"}),_c(\'legend\',[_vm._v(_vm._s(_vm.customFilterText)+" ("+_vm._s(_vm.customFilterVotes.length)+")")]),_c(\'div\',{staticClass:"votes closed"},_vm._l((_vm.filterPagination),function(vote){return _c(\'vote\',{key:vote.id,staticClass:"vote",attrs:{"vote":vote}})}),1)])]):_vm._e(),_c(\'pagination\')],1)])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/votes/Votes.vue?vue&type=template&id=5848e871&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js\nvar es_array_find = __webpack_require__("7db0");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.date.now.js\nvar es_date_now = __webpack_require__("6eba");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.date.to-string.js\nvar es_date_to_string = __webpack_require__("0d03");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js\nvar objectSpread2 = __webpack_require__("5530");\n\n// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__("96cf");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__("1da1");\n\n// EXTERNAL MODULE: ./src/contract.js\nvar contract = __webpack_require__("51bf");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph/dist/esm/index.js\nvar esm = __webpack_require__("d25d");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect/dist/esm/index.js\nvar dist_esm = __webpack_require__("99ca");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/dist/index.js\nvar dist = __webpack_require__("aa9a");\n\n// EXTERNAL MODULE: ./src/components/dao/voteStore.js\nvar voteStore = __webpack_require__("3f2c");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/Vote.vue?vue&type=template&id=22e6bba6&scoped=true&\nvar Votevue_type_template_id_22e6bba6_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',[_c(\'fieldset\',[_c(\'legend\',[_vm._v(" "+_vm._s(_vm.vote.votingAppName)+" ("+_vm._s(_vm.getSupportRequiredPct)+"% / "+_vm._s(_vm.getMinAcceptQuorum)+"%) ")]),_c(\'div\',{staticClass:"voteTitle"},[_c(\'router-link\',{attrs:{"to":\'/dao/vote/\' + _vm.vote.votingAppName.toLowerCase() + \'/\' + _vm.vote.voteNumber}},[_c(\'b\',[_vm._v(" #"+_vm._s(_vm.vote.voteCountSeq)+" ")])]),_c(\'span\',{staticClass:"userCastVote tooltip"},[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.casts && _vm.vote.casts.length && _vm.vote.casts[0].supports),expression:"vote.casts && vote.casts.length && vote.casts[0].supports"}],staticClass:"userVotedYes"},[_vm._v("")]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.casts && _vm.vote.casts.length && !_vm.vote.casts[0].supports),expression:"vote.casts && vote.casts.length && !vote.casts[0].supports"}],staticClass:"userVotedNo"},[_vm._v("X")]),_c(\'span\',{staticClass:"tooltiptext"},[_vm._v(" You voted "+_vm._s(_vm.vote.casts && _vm.vote.casts.length && _vm.vote.casts[0].supports ? \'Yes\' : \'No\')+" ")])])],1),_c(\'div\',{staticClass:"description"},[_c(\'router-link\',{attrs:{"to":\'/dao/vote/\' + _vm.vote.votingAppName.toLowerCase() + \'/\' + _vm.vote.voteNumber}},[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.contractName),expression:"vote.contractName"}]},[_vm._v(" "+_vm._s(_vm.vote.contractName)+": "),_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.metadata),expression:"!vote.contractName && vote.metadata"}]},[_vm._v(" "+_vm._s(_vm.formattedMetadata)+" ")]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.description),expression:"!vote.contractName && vote.description"}]},[_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})])])],1),_c(\'countdown\',{directives:[{name:"show",rawName:"v-show",value:(_vm.isOpen(_vm.vote) && !_vm.vote.executed),expression:"isOpen(vote) && !vote.executed"}],attrs:{"timestamp":_vm.vote.startDate,"vote":_vm.vote}}),_c(\'div\',{staticClass:"tui-progress-bar"},[_c(\'span\',{staticClass:"yestext"},[_vm._v("Yes:")]),_c(\'span\',{staticClass:"tui-progress-label"},[_vm._v(_vm._s(_vm.vote.yeap)+"%")]),_c(\'span\',{staticClass:"tui-progress yes",style:({width: _vm.vote.yeap + \'%\'})})]),_c(\'div\',{staticClass:"tui-progress-bar"},[_c(\'span\',{staticClass:"notext"},[_vm._v("No:")]),_c(\'span\',{staticClass:"tui-progress-label"},[_vm._v(_vm._s(_vm.vote.nop)+"%")]),_c(\'span\',{staticClass:"tui-progress no",style:({width: _vm.vote.nop + \'%\'})})]),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.executed),expression:"vote.executed"}],staticClass:"enacted"},[_vm._v("  Passed(enacted) ")]),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(_vm.canExecute),expression:"canExecute"}],staticClass:"canexecute"},[_vm._v("  Passed "),_c(\'enact-vote\',{attrs:{"vote":_vm.vote}})],1),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(_vm.isRejected),expression:"isRejected"}],staticClass:"rejected"},[_vm._v(" X Rejected ("+_vm._s(_vm.rejectedReasonText)+") ")]),_c(\'div\',{staticClass:"createdon"},[_c(\'img\',{staticClass:"icon small",attrs:{"src":_vm.publicPath + \'clock-regular.svg\'}}),_vm._v(" "+_vm._s(_vm.startDateFormat)+" ")])],1)])}\nvar Votevue_type_template_id_22e6bba6_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/votes/Vote.vue?vue&type=template&id=22e6bba6&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/radspec/dist/index.js\nvar radspec_dist = __webpack_require__("8076");\n\n// EXTERNAL MODULE: ./src/components/dao/common/Countdown.vue + 4 modules\nvar Countdown = __webpack_require__("c6ba");\n\n// EXTERNAL MODULE: ./src/components/dao/allabis.js\nvar allabis = __webpack_require__("04ef");\n\n// EXTERNAL MODULE: ./src/utils/helpers.js\nvar helpers = __webpack_require__("2fa3");\n\n// EXTERNAL MODULE: ./src/components/dao/votes/EnactVote.vue + 4 modules\nvar EnactVote = __webpack_require__("7197");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/Vote.vue?vue&type=script&lang=js&\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n/* harmony default export */ var Votevue_type_script_lang_js_ = ({\n  components: {\n    Countdown: Countdown["a" /* default */],\n    EnactVote: EnactVote["a" /* default */]\n  },\n  props: [\'vote\'],\n  data: function data() {\n    return {//description: null,\n    };\n  },\n  created: function created() {//this.description = await this.decodeCall()\n\n    return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  computed: {\n    getSupportRequiredPct: function getSupportRequiredPct() {\n      return this.vote.supportRequiredPct / 1e16;\n    },\n    getMinAcceptQuorum: function getMinAcceptQuorum() {\n      return this.vote.minAcceptQuorum / 1e16;\n    },\n    // contractCalled() {\n    // \tif(this.vote.script.substr(90,40) == allabis.poolproxy_address.substr(2).toLowerCase()) \n    // \t\treturn \'poolproxy\'\n    // \tif(this.vote.script.substr(90,40) == allabis.votingescrow_address.substr(2).toLowerCase()) \n    // \t\treturn \'votingescrow\'\n    // \tif(this.vote.script.substr(90,40) == allabis.gaugecontroller_address.substr(2).toLowerCase()) \n    // \t\treturn \'gaugecontroller\'\n    // \treturn null\n    // },\n    // contractName() {\n    // \tif(this.contractCalled == \'poolproxy\') \n    // \t\treturn \'Pool Proxy\'\n    // \tif(this.contractCalled == \'votingescrow\')\n    // \t\treturn \'Voting Escrow\'\n    // \tif(this.contractCalled == \'gaugecontroller\')\n    // \t\treturn \'Gauge Controller\'\n    // \treturn null\n    // },\n    startDateFormat: function startDateFormat() {\n      return helpers["c" /* formatDateToHuman */](this.vote.startDate);\n    },\n    canExecute: function canExecute() {\n      return voteStore["m" /* helpers */].canExecute(this.vote);\n    },\n    isRejected: function isRejected() {\n      return voteStore["m" /* helpers */].isRejected(this.vote);\n    },\n    rejectedReasonText: function rejectedReasonText() {\n      if (this.vote.rejectedReason == 1) return \'No support\';\n      if (this.vote.rejectedReason == 2) return \'No quorum\';\n      return \'\';\n    },\n    publicPath: function publicPath() {\n      return "";\n    },\n    formattedMetadata: function formattedMetadata() {\n      return this.vote.metadata && helpers["i" /* truncate */](this.vote.metadata, 100, true);\n    }\n  },\n  methods: {\n    isOpen: function isOpen(vote) {\n      return voteStore["m" /* helpers */].isVoteOpen(vote);\n    } // async decodeCall() {\n    // \tif(this.contractCalled !== null) {\n    // \t\tlet natspec = allabis[this.contractCalled+\'_natspec\'].methods\n    // \t\tlet abi = allabis[this.contractCalled+\'_abi\']\n    // \t\tlet signature = \'0x\'+this.vote.script.substr(322, 8)\n    // \t\tlet method = Object.keys(natspec).find(key => web3.eth.abi.encodeFunctionSignature(key) == signature)\n    // \t\tconsole.log(method, "THE METHOD")\n    // \t\t// let signatures = Object.values(natspec).map(m => m.signature.substr(2))\n    // \t\t// let match = signatures.map(sig => this.vote.script.indexOf(sig)).find(idx => idx > -1)\n    // \t\t// let method = Object.keys(natspec).find(key => \n    // \t\t// \tnatspec[key].signature.substr(2) == signatures.filter(sig => this.vote.script.indexOf(sig) > -1))\n    // \t\t// if(method === undefined) return null;\n    // \t\t// let data = this.vote.script.substr(match)\n    // \t\tlet data = this.vote.script.substr(322)\n    // \t\tlet expression = natspec[method].notice\n    // \t\tlet call = {\n    // \t\t\tabi: [abi.find(v => v.name == method.split(\'(\')[0])],\n    // \t\t\ttransaction: {\n    // \t\t\t\tdata: \'0x\' + data,\n    // \t\t\t}\n    // \t\t}\n    // \t\tlet desc = await radspec.evaluate(expression, call)\n    // \t\treturn desc\n    // \t}\n    // \telse if(!this.vote.metadata) {\n    // \t\ttry {\n    // \t\t\tlet desc = await describeScript(this.vote.script, state.apps)\n    // \t\t\treturn desc[0].description\n    // \t\t}\n    // \t\tcatch(err) {\n    // \t\t\tconsole.error(err)\n    // \t\t}\n    // \t}\n    // },\n\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/votes/Vote.vue?vue&type=script&lang=js&\n /* harmony default export */ var votes_Votevue_type_script_lang_js_ = (Votevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/dao/votes/Vote.vue?vue&type=style&index=0&id=22e6bba6&scoped=true&lang=css&\nvar Votevue_type_style_index_0_id_22e6bba6_scoped_true_lang_css_ = __webpack_require__("91ac");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// CONCATENATED MODULE: ./src/components/dao/votes/Vote.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  votes_Votevue_type_script_lang_js_,\n  Votevue_type_template_id_22e6bba6_scoped_true_render,\n  Votevue_type_template_id_22e6bba6_scoped_true_staticRenderFns,\n  false,\n  null,\n  "22e6bba6",\n  null\n  \n)\n\n/* harmony default export */ var Vote = (component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/NewTextVote.vue?vue&type=template&id=391d3732&scoped=true&\nvar NewTextVotevue_type_template_id_391d3732_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',[(_vm.showRootModal)?_c(\'div\',{staticClass:"modal rootmodal",attrs:{"id":"modal"},on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.hideRootModal($event)}}},[_c(\'div\',{staticClass:"modal-content window white"},[_c(\'fieldset\',[_c(\'div\',{staticClass:"legend2 hoverpointer",on:{"click":_vm.hideRootModal}},[_vm._v(" ["),_c(\'span\',{staticClass:"greentext"},[_vm._v("X")]),_vm._v("] ")]),_c(\'legend\',[_vm._v("Create a text vote on "+_vm._s(_vm.appName))]),_c(\'div\',{staticClass:"content"},[_c(\'div\',[_c(\'span\',[_vm._v(" "+_vm._s(_vm.voteDescription)+" ")]),_c(\'div\',[_c(\'span\',[_vm._v(" "+_vm._s(_vm.description)+" ")])]),(_vm.vote)?_c(\'div\',{staticClass:"content"},[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.contractName),expression:"vote.contractName"}]},[_vm._v(" "+_vm._s(_vm.vote.contractName)+": "),_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.metadata),expression:"!vote.contractName && vote.metadata"}]},[_vm._v(" "+_vm._s(_vm.vote.metadata)+" ")]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.description),expression:"!vote.contractName && vote.description"}]},[_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})])]):_vm._e()]),_c(\'hr\'),_c(\'p\',{staticClass:"explanation"},[_vm._v(" This vote requires "+_vm._s(_vm.getSupportText)+"% acceptance and "+_vm._s(_vm.getQuorumText)+"% quorum to be passed ")]),_c(\'p\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.willSucceed),expression:"!willSucceed"}],staticClass:"simple-error"},[_vm._v(" The transaction may fail, you may not have the required permissions to make the transaction ")])]),_c(\'button\',{on:{"click":_vm.createVote}},[_vm._v("Create Text Vote")])])])]):_vm._e(),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(_vm.canCreateNewVote),expression:"canCreateNewVote"}]},[_c(\'modal\',{scopedSlots:_vm._u([{key:"activate",fn:function(ref){\nvar show = ref.show;\nreturn [_c(\'div\',{on:{"click":show}},[_c(\'button\',{staticClass:"simplebutton"},[_vm._v("New text vote")])])]}},{key:"title",fn:function(){return [_vm._v(" Create new vote ")]},proxy:true},{key:"submit",fn:function(){return [_c(\'span\',{staticClass:"simplebutton",on:{"click":_vm.submit}},[_vm._v("Submit "),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.loading),expression:"loading"}],staticClass:"loading line"})])]},proxy:true}])},[_c(\'div\',{staticClass:"content"},[_c(\'div\',[_c(\'select\',{directives:[{name:"model",rawName:"v-model",value:(_vm.selectedApp),expression:"selectedApp"}],staticClass:"tvision",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.selectedApp=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},_vm._l((_vm.apps),function(app){return _c(\'option\',{domProps:{"value":app}},[_vm._v(" "+_vm._s(app.name)+" ")])}),0)]),_c(\'div\',[_c(\'label\',{attrs:{"for":"newtextvote"}},[_vm._v("Vote description:")]),_c(\'textarea\',{directives:[{name:"model",rawName:"v-model",value:(_vm.description),expression:"description"}],attrs:{"id":"newtextvote"},domProps:{"value":(_vm.description)},on:{"input":function($event){if($event.target.composing){ return; }_vm.description=$event.target.value}}})])])]),_c(\'button\',{staticClass:"simplebutton createvotebutton"},[_c(\'router-link\',{attrs:{"to":"/dao/createvote"}},[_vm._v(" Create Vote ")])],1)],1),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.canCreateNewVote && _vm.canCreateLoaded),expression:"!canCreateNewVote && canCreateLoaded"}]},[_c(\'p\',{staticClass:"info-message gentle-message"},[_vm._v(" You have to have at least 2500veSWRV(the equivalent of 10000 SWRV locked for a year) to be able to create a new vote ")]),_c(\'voting-escrow\',{staticClass:"votingescrow",attrs:{"showvelock":false}},[_c(\'p\',[_c(\'router-link\',{attrs:{"to":"/dao/locker"}},[_vm._v("Manage locking in Locker")])],1)])],1)])}\nvar NewTextVotevue_type_template_id_391d3732_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/votes/NewTextVote.vue?vue&type=template&id=391d3732&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js\nvar es_symbol = __webpack_require__("a4d3");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js\nvar es_symbol_description = __webpack_require__("e01a");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js\nvar es_object_to_string = __webpack_require__("d3b7");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js\nvar es_string_iterator = __webpack_require__("3ca3");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js\nvar web_dom_collections_iterator = __webpack_require__("ddb0");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/common/Modal.vue?vue&type=template&id=0382e763&scoped=true&\nvar Modalvue_type_template_id_0382e763_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',[_vm._t("activate",null,{"show":_vm.show}),_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(_vm.showModal),expression:"showModal"}],staticClass:"modal",attrs:{"id":"modal"},on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }_vm.showModal = false}}},[_c(\'div\',{staticClass:"modal-content window white"},[_c(\'fieldset\',[_c(\'div\',{staticClass:"legend2 hoverpointer",on:{"click":function($event){_vm.showModal = false}}},[_vm._v(" ["),_c(\'span\',{staticClass:"greentext"},[_vm._v("X")]),_vm._v("] ")]),_c(\'legend\',[_vm._t("title")],2),_c(\'div\',[_vm._t("default")],2),_c(\'button\',[_vm._t("submit")],2)])])])],2)}\nvar Modalvue_type_template_id_0382e763_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/common/Modal.vue?vue&type=template&id=0382e763&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/common/Modal.vue?vue&type=script&lang=js&\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var Modalvue_type_script_lang_js_ = ({\n  data: function data() {\n    return {};\n  },\n  computed: {\n    showModal: {\n      get: function get() {\n        return voteStore["n" /* state */].showModal;\n      },\n      set: function set(value) {\n        voteStore["n" /* state */].showModal = value;\n      }\n    }\n  },\n  methods: {\n    show: function show() {\n      this.showModal = true;\n    },\n    hide: function hide() {\n      this.showModal = false;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/common/Modal.vue?vue&type=script&lang=js&\n /* harmony default export */ var common_Modalvue_type_script_lang_js_ = (Modalvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/dao/common/Modal.vue?vue&type=style&index=0&id=0382e763&scoped=true&lang=css&\nvar Modalvue_type_style_index_0_id_0382e763_scoped_true_lang_css_ = __webpack_require__("5ac7");\n\n// CONCATENATED MODULE: ./src/components/dao/common/Modal.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar Modal_component = Object(componentNormalizer["a" /* default */])(\n  common_Modalvue_type_script_lang_js_,\n  Modalvue_type_template_id_0382e763_scoped_true_render,\n  Modalvue_type_template_id_0382e763_scoped_true_staticRenderFns,\n  false,\n  null,\n  "0382e763",\n  null\n  \n)\n\n/* harmony default export */ var Modal = (Modal_component.exports);\n// EXTERNAL MODULE: ./src/components/dao/common/RootModalMixin.js\nvar RootModalMixin = __webpack_require__("f655");\n\n// EXTERNAL MODULE: ./src/components/minter/VotingEscrow.vue + 5 modules\nvar VotingEscrow = __webpack_require__("79ab");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/NewTextVote.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n/* harmony default export */ var NewTextVotevue_type_script_lang_js_ = ({\n  components: {\n    Modal: Modal,\n    VotingEscrow: VotingEscrow["default"]\n  },\n  mixins: [RootModalMixin["a" /* default */]],\n  data: function data() {\n    return {\n      canCreateLoaded: false,\n      description: \'\',\n      loading: false,\n      selectedApp: null,\n      apps: [],\n      canCreateNewVote: false\n    };\n  },\n  created: function created() {\n    var _this = this;\n\n    return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this.$watch(function () {\n                return voteStore["n" /* state */].initialized;\n              }, function (val) {\n                if (val) _this.created();\n              }, {\n                immediate: true\n              });\n\n              _this.$watch(function () {\n                return voteStore["n" /* state */].lastCreated !== null;\n              }, function (val) {\n                if (val) _this.canCreate();\n              }, {\n                immediate: true\n              });\n\n              _this.$watch(function () {\n                return voteStore["n" /* state */].showModal;\n              }, function (val) {\n                if (!val) _this.description = \'\';\n              });\n\n            case 3:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  computed: {\n    initialized: function initialized() {\n      return voteStore["n" /* state */].initialized;\n    },\n    votingApps: function votingApps() {\n      return voteStore["n" /* state */].votingApps;\n    }\n  },\n  methods: {\n    created: function created() {\n      var _this2 = this;\n\n      return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this2.app = _this2.apps[0];\n\n              case 1:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    canCreate: function canCreate() {\n      var _this3 = this;\n\n      return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n        var canCreateVoteOn;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return Promise.all([voteStore["m" /* helpers */].canCreateNewVoteOn(voteStore["c" /* OWNERSHIP_APP_ADDRESS */]), voteStore["m" /* helpers */].canCreateNewVoteOn(voteStore["e" /* PARAMETER_APP_ADDRESS */])]);\n\n              case 2:\n                canCreateVoteOn = _context3.sent;\n                if (canCreateVoteOn[0]) _this3.apps.push({\n                  address: voteStore["c" /* OWNERSHIP_APP_ADDRESS */],\n                  name: \'Ownership\'\n                });\n                if (canCreateVoteOn[1]) _this3.apps.push({\n                  address: voteStore["e" /* PARAMETER_APP_ADDRESS */],\n                  name: \'Parameter\'\n                });\n                _this3.selectedApp = _this3.apps[0];\n                _this3.canCreateNewVote = canCreateVoteOn.find(function (v) {\n                  return v;\n                });\n                _this3.canCreateLoaded = true;\n\n              case 8:\n              case "end":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }))();\n    },\n    submit: function submit() {\n      var _this4 = this;\n\n      return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n        var ipfshash, intent, paths;\n        return regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _this4.loading = true;\n                _context4.next = 3;\n                return fetch(\'https://api.pinata.cloud/pinning/pinJSONToIPFS\', {\n                  method: \'POST\',\n                  headers: {\n                    \'Content-type\': \'application/json\',\n                    \'pinata_api_key\': \'96f26e75bb20557ba498\',\n                    \'pinata_secret_api_key\': \'72e9f3f6b9c4a9f3bc4d91e1a101a3893384054f65cf6d6089e62c22feade751\'\n                  },\n                  body: JSON.stringify({\n                    text: _this4.description\n                  })\n                });\n\n              case 3:\n                ipfshash = _context4.sent;\n                _context4.next = 6;\n                return ipfshash.json();\n\n              case 6:\n                ipfshash = _context4.sent;\n                ipfshash = \'ipfs:\' + ipfshash.IpfsHash;\n                console.log(ipfshash, "IPFS HASH");\n                _context4.prev = 9;\n                _context4.next = 12;\n                return voteStore["n" /* state */].org.appIntent(_this4.selectedApp.address.toLowerCase(), \'newVote(bytes,string,bool,bool)\', [\'0x00000001\', ipfshash, false, false]);\n\n              case 12:\n                intent = _context4.sent;\n                _context4.next = 18;\n                break;\n\n              case 15:\n                _context4.prev = 15;\n                _context4.t0 = _context4["catch"](9);\n                console.error(_context4.t0);\n\n              case 18:\n                _context4.next = 20;\n                return intent.paths(contract["b" /* contract */].default_account);\n\n              case 20:\n                paths = _context4.sent;\n                voteStore["n" /* state */].transactionIntent = paths;\n                _this4.loading = false;\n                voteStore["n" /* state */].showModal = false;\n                _this4.showRootModal = true;\n                console.log(paths, "THEPATH");\n\n              case 26:\n              case "end":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, null, [[9, 15]]);\n      }))();\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/votes/NewTextVote.vue?vue&type=script&lang=js&\n /* harmony default export */ var votes_NewTextVotevue_type_script_lang_js_ = (NewTextVotevue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/dao/votes/NewTextVote.vue?vue&type=style&index=0&id=391d3732&scoped=true&lang=css&\nvar NewTextVotevue_type_style_index_0_id_391d3732_scoped_true_lang_css_ = __webpack_require__("0789");\n\n// CONCATENATED MODULE: ./src/components/dao/votes/NewTextVote.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar NewTextVote_component = Object(componentNormalizer["a" /* default */])(\n  votes_NewTextVotevue_type_script_lang_js_,\n  NewTextVotevue_type_template_id_391d3732_scoped_true_render,\n  NewTextVotevue_type_template_id_391d3732_scoped_true_staticRenderFns,\n  false,\n  null,\n  "391d3732",\n  null\n  \n)\n\n/* harmony default export */ var NewTextVote = (NewTextVote_component.exports);\n// EXTERNAL MODULE: ./src/components/dao/common/RootModal.vue + 4 modules\nvar RootModal = __webpack_require__("c3e3");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/Pagination.vue?vue&type=template&id=0e07d546&scoped=true&\nvar Paginationvue_type_template_id_0e07d546_scoped_true_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(_vm.votesLength > 0),expression:"votesLength > 0"}],staticClass:"pagination"},[_c(\'div\',[_c(\'button\',{staticClass:"simplebutton",attrs:{"disabled":_vm.page == 0},on:{"click":_vm.prev}},[_vm._v("Prev")]),_c(\'span\',[_vm._v(" "+_vm._s(_vm.page)+" (of "+_vm._s(_vm.pages)+") ")]),_c(\'button\',{staticClass:"simplebutton",attrs:{"disabled":_vm.page == this.pages},on:{"click":_vm.next}},[_vm._v("Next")])]),_c(\'div\',{staticClass:"perpage"},[_vm._v(" Per page: "),_c(\'select\',{directives:[{name:"model",rawName:"v-model",value:(_vm.perPage),expression:"perPage"}],staticClass:"tvision",on:{"change":function($event){var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return val}); _vm.perPage=$event.target.multiple ? $$selectedVal : $$selectedVal[0]}}},_vm._l((_vm.perPageOptions),function(perPageNum){return _c(\'option\',[_vm._v(" "+_vm._s(perPageNum)+" ")])}),0)])])}\nvar Paginationvue_type_template_id_0e07d546_scoped_true_staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/votes/Pagination.vue?vue&type=template&id=0e07d546&scoped=true&\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/Pagination.vue?vue&type=script&lang=js&\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var Paginationvue_type_script_lang_js_ = ({\n  data: function data() {\n    return {\n      perPageOptions: [10, 20, 30, 50, 100]\n    };\n  },\n  computed: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, voteStore["l" /* getters */]), {}, {\n    perPage: {\n      get: function get() {\n        return voteStore["n" /* state */].pagination.perPage;\n      },\n      set: function set(val) {\n        voteStore["n" /* state */].pagination.perPage = val;\n      }\n    },\n    votesLength: function votesLength() {\n      return this.customFilterVotes.length;\n    },\n    page: function page() {\n      return voteStore["n" /* state */].pagination.page;\n    },\n    pages: function pages() {\n      return this.customFilterVotes.length && Math.ceil(this.customFilterVotes.length / voteStore["n" /* state */].pagination.perPage) - 1;\n    }\n  }),\n  methods: {\n    prev: function prev() {\n      if (this.page == 0) return;\n      voteStore["n" /* state */].pagination.page -= 1;\n    },\n    next: function next() {\n      if (this.page < this.pages) voteStore["n" /* state */].pagination.page += 1;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/votes/Pagination.vue?vue&type=script&lang=js&\n /* harmony default export */ var votes_Paginationvue_type_script_lang_js_ = (Paginationvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/dao/votes/Pagination.vue?vue&type=style&index=0&id=0e07d546&scoped=true&lang=css&\nvar Paginationvue_type_style_index_0_id_0e07d546_scoped_true_lang_css_ = __webpack_require__("205c");\n\n// CONCATENATED MODULE: ./src/components/dao/votes/Pagination.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar Pagination_component = Object(componentNormalizer["a" /* default */])(\n  votes_Paginationvue_type_script_lang_js_,\n  Paginationvue_type_template_id_0e07d546_scoped_true_render,\n  Paginationvue_type_template_id_0e07d546_scoped_true_staticRenderFns,\n  false,\n  null,\n  "0e07d546",\n  null\n  \n)\n\n/* harmony default export */ var Pagination = (Pagination_component.exports);\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/votes/Votes.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ var Votesvue_type_script_lang_js_ = ({\n  components: {\n    Vote: Vote,\n    NewTextVote: NewTextVote,\n    RootModal: RootModal["a" /* default */],\n    Pagination: Pagination\n  },\n  created: function created() {\n    var _this = this;\n\n    return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this.$watch(function () {\n                return voteStore["n" /* state */].initialized;\n              }, function (val) {\n                if (val) _this.mounted();\n              }, {\n                immediate: true\n              });\n\n            case 1:\n            case "end":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  watch: {\n    changedFilter: function changedFilter() {\n      voteStore["n" /* state */].pagination.page = 0;\n      this.changeFilter();\n    }\n  },\n  data: function data() {\n    return {\n      loadedVotes: false,\n      allStatus: [{\n        val: 3,\n        text: \'All\'\n      }, {\n        val: 1,\n        text: \'Open\'\n      }, {\n        val: 2,\n        text: \'Closed\'\n      }],\n      allOutcome: [{\n        val: 5,\n        text: \'All\'\n      }, {\n        val: 1,\n        text: \'Passed\'\n      }, {\n        val: 2,\n        text: \'Rejected\'\n      }, {\n        val: 3,\n        text: \'Enacted\'\n      }, {\n        val: 4,\n        text: \'Pending\'\n      }],\n      allApp: [{\n        val: 3,\n        text: \'All\'\n      }, {\n        val: 1,\n        text: \'Voting\'\n      }, {\n        val: 2,\n        text: \'Parameter\'\n      }]\n    };\n  },\n  computed: Object(objectSpread2["a" /* default */])(Object(objectSpread2["a" /* default */])({}, voteStore["l" /* getters */]), {}, {\n    showRootModal: function showRootModal() {\n      return voteStore["n" /* state */].showRootModal;\n    },\n    filterStatus: {\n      get: function get() {\n        return voteStore["n" /* state */].filters.status;\n      },\n      set: function set(val) {\n        voteStore["n" /* state */].filters.status = val;\n      }\n    },\n    filterOutcome: {\n      get: function get() {\n        return voteStore["n" /* state */].filters.outcome;\n      },\n      set: function set(val) {\n        voteStore["n" /* state */].filters.outcome = val;\n      }\n    },\n    filterApp: {\n      get: function get() {\n        return voteStore["n" /* state */].filters.app;\n      },\n      set: function set(val) {\n        voteStore["n" /* state */].filters.app = val;\n      }\n    },\n    customFilterText: function customFilterText() {\n      var _this2 = this;\n\n      var statusText = this.allStatus.find(function (val) {\n        return val.val == _this2.filterStatus;\n      }).text;\n      var outcomeText = this.allOutcome.find(function (val) {\n        return val.val == _this2.filterOutcome;\n      }).text;\n      var appText = this.allApp.find(function (val) {\n        return val.val == _this2.filterApp;\n      }).text;\n      return statusText + \' \' + outcomeText + \' \' + appText;\n    },\n    changedFilter: function changedFilter() {\n      return this.filterStatus, this.filterOutcome, this.filterApp, Date.now();\n    }\n  }),\n  methods: {\n    mounted: function mounted() {\n      var _this3 = this;\n\n      return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var account, calls;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                account = contract["b" /* contract */].default_account || \'0x0000000000000000000000000000000000000000\';\n                calls = [[voteStore["n" /* state */].votingEscrow._address, voteStore["n" /* state */].votingEscrow.methods.balanceOf(account).encodeABI()], [voteStore["n" /* state */].votingEscrow._address, voteStore["n" /* state */].votingEscrow.methods.locked__end(account).encodeABI()], [voteStore["n" /* state */].SWRV._address, voteStore["n" /* state */].SWRV.methods.balanceOf(account).encodeABI()]];\n                _context2.next = 4;\n                return Object(voteStore["h" /* getAllVotes */])();\n\n              case 4:\n                _this3.loadedVotes = true;\n\n              case 5:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }))();\n    },\n    changeFilter: function changeFilter() {\n      Object(voteStore["g" /* changeFilter */])();\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/votes/Votes.vue?vue&type=script&lang=js&\n /* harmony default export */ var votes_Votesvue_type_script_lang_js_ = (Votesvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/dao/votes/Votes.vue?vue&type=style&index=0&id=5848e871&scoped=true&lang=css&\nvar Votesvue_type_style_index_0_id_5848e871_scoped_true_lang_css_ = __webpack_require__("3816");\n\n// CONCATENATED MODULE: ./src/components/dao/votes/Votes.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar Votes_component = Object(componentNormalizer["a" /* default */])(\n  votes_Votesvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "5848e871",\n  null\n  \n)\n\n/* harmony default export */ var Votes = __webpack_exports__["default"] = (Votes_component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvVm90ZXMudnVlPzk3ODgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL3ZvdGVzL1ZvdGUudnVlPzZmNDgiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9Wb3RlLnZ1ZT81YWJlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9Wb3RlLnZ1ZT81NDUyIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9Wb3RlLnZ1ZT81NTlmIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9OZXdUZXh0Vm90ZS52dWU/YWM1MSIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL01vZGFsLnZ1ZT8yNzUyIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL01vZGFsLnZ1ZT84MTBlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby9jb21tb24vTW9kYWwudnVlPzU3YmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL2NvbW1vbi9Nb2RhbC52dWU/ZDQzMiIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvZGFvL3ZvdGVzL05ld1RleHRWb3RlLnZ1ZT9lYmZlIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9OZXdUZXh0Vm90ZS52dWU/ZGZmYiIsIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvTmV3VGV4dFZvdGUudnVlPzc5YzYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL3ZvdGVzL1BhZ2luYXRpb24udnVlPzNlMmUiLCJ3ZWJwYWNrOi8vL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9QYWdpbmF0aW9uLnZ1ZT8zMmYwIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9QYWdpbmF0aW9uLnZ1ZT9jNmNkIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9QYWdpbmF0aW9uLnZ1ZT9mZTNiIiwid2VicGFjazovLy9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvVm90ZXMudnVlPzUzNGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL3ZvdGVzL1ZvdGVzLnZ1ZT8zNDljIiwid2VicGFjazovLy8uL3NyYy9jb21wb25lbnRzL2Rhby92b3Rlcy9Wb3Rlcy52dWU/NjdjMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsMEJBQTBCLGFBQWEsMEJBQTBCLHdCQUF3QixpQkFBaUIsMkJBQTJCLDhFQUE4RSxxQkFBcUIsdUdBQXVHLGFBQWEsa0ZBQWtGLDRCQUE0QiwwQkFBMEIsa0ZBQWtGLGtCQUFrQixrQkFBa0IsNkNBQTZDLFdBQVcsRUFBRSw4RUFBOEUseUNBQXlDLG9CQUFvQixVQUFVLG9CQUFvQix3Q0FBd0Msa0RBQWtELGFBQWEsb0ZBQW9GLDRCQUE0QiwwQkFBMEIsa0ZBQWtGLGtCQUFrQixrQkFBa0IsNkNBQTZDLFdBQVcsRUFBRSwrRUFBK0UsMkNBQTJDLG9CQUFvQixVQUFVLHFCQUFxQix5Q0FBeUMsOENBQThDLGFBQWEsNEVBQTRFLDRCQUE0QiwwQkFBMEIsa0ZBQWtGLGtCQUFrQixrQkFBa0IsNkNBQTZDLFdBQVcsRUFBRSwyRUFBMkUsbUNBQW1DLG9CQUFvQixVQUFVLGlCQUFpQixxQ0FBcUMscUJBQXFCLGFBQWEsa0ZBQWtGLHFDQUFxQyw0QkFBNEIsYUFBYSxnRkFBZ0YsK0JBQStCLG1GQUFtRix5QkFBeUIsdUNBQXVDLGtCQUFrQixzQ0FBc0MsYUFBYSxFQUFFLG1CQUFtQixhQUFhLGtGQUFrRixxQ0FBcUMsNEJBQTRCLGFBQWEsZ0ZBQWdGLCtCQUErQix1RkFBdUYsMkJBQTJCLHlDQUF5QyxrQkFBa0Isc0NBQXNDLGFBQWEsRUFBRSxzQ0FBc0MsbUNBQW1DLDRCQUE0QixhQUFhLGdGQUFnRiwrQkFBK0IsOEdBQThHLDJCQUEyQiw4Q0FBOEMsa0JBQWtCLHNDQUFzQyxhQUFhLEVBQUU7QUFDOTlHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQSxJQUFJLG9EQUFNLGdCQUFnQixhQUFhLDBCQUEwQix3QkFBd0IsdUxBQXVMLHdCQUF3QixvQkFBb0IsT0FBTyxzRkFBc0Ysd0VBQXdFLG1DQUFtQyxhQUFhLGFBQWEsa0xBQWtMLDZCQUE2QiwyQkFBMkIsYUFBYSxvTEFBb0wsNEJBQTRCLDJCQUEyQiwwQkFBMEIsMklBQTJJLDBCQUEwQixvQkFBb0IsT0FBTyxzRkFBc0YsYUFBYSxhQUFhLDBGQUEwRixFQUFFLDREQUE0RCxVQUFVLDBDQUEwQyxlQUFlLGFBQWEsa0lBQWtJLEVBQUUsNkRBQTZELGFBQWEsd0lBQXdJLEVBQUUsYUFBYSxVQUFVLDBDQUEwQywwQkFBMEIsYUFBYSw0SEFBNEgsU0FBUyxnREFBZ0QsWUFBWSwrQkFBK0IsYUFBYSxzQkFBc0IsOEJBQThCLGlDQUFpQyxpREFBaUQsdUNBQXVDLDJCQUEyQixFQUFFLGNBQWMsK0JBQStCLGFBQWEscUJBQXFCLDZCQUE2QixpQ0FBaUMsZ0RBQWdELHNDQUFzQywwQkFBMEIsRUFBRSxjQUFjLGFBQWEsa0ZBQWtGLHdCQUF3Qiw0Q0FBNEMsYUFBYSw0RUFBNEUsMkJBQTJCLHdDQUF3QyxPQUFPLGlCQUFpQixnQkFBZ0IsYUFBYSw0RUFBNEUseUJBQXlCLDBFQUEwRSx3QkFBd0IsWUFBWSxnQ0FBZ0MsNENBQTRDO0FBQ3owRyxJQUFJLDZEQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOERuQjtBQUVBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBLDJDQURBO0FBRUE7QUFGQSxHQURBO0FBTUEsaUJBTkE7QUFRQTtBQUFBLFlBQ0E7QUFEQTtBQUFBLEdBUkE7QUFZQSxTQVpBLHFCQVlBLENBQ0E7O0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVBLEdBZEE7QUFnQkE7QUFDQSx5QkFEQSxtQ0FDQTtBQUNBO0FBQ0EsS0FIQTtBQUlBLHNCQUpBLGdDQUlBO0FBQ0E7QUFDQSxLQU5BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBekJBLDZCQXlCQTtBQUNBO0FBQ0EsS0EzQkE7QUE0QkEsY0E1QkEsd0JBNEJBO0FBQ0E7QUFDQSxLQTlCQTtBQStCQSxjQS9CQSx3QkErQkE7QUFDQTtBQUNBLEtBakNBO0FBa0NBLHNCQWxDQSxnQ0FrQ0E7QUFDQSx5Q0FDQTtBQUNBLHlDQUNBO0FBQ0E7QUFDQSxLQXhDQTtBQXlDQSxjQXpDQSx3QkF5Q0E7QUFDQTtBQUNBLEtBM0NBO0FBNENBLHFCQTVDQSwrQkE0Q0E7QUFDQTtBQUNBO0FBOUNBLEdBaEJBO0FBaUVBO0FBQ0EsVUFEQSxrQkFDQSxJQURBLEVBQ0E7QUFDQTtBQUNBLEtBSEEsQ0FJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFyQ0E7QUFqRUEsRzs7QUM1RTRWLENBQWdCLG1HQUFHLEVBQUMsQzs7Ozs7Ozs7QUNBalI7QUFDdkM7QUFDTDtBQUNxQzs7O0FBR3hGO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLGtDQUFNO0FBQ1IsRUFBRSxvREFBTTtBQUNSLEVBQUUsNkRBQWU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWUsMEQ7O0FDbkJmLElBQUksMkRBQU0sZ0JBQWdCLGFBQWEsMEJBQTBCLHdCQUF3QiwrQ0FBK0MscUNBQXFDLGFBQWEsS0FBSyx5QkFBeUIsMkNBQTJDLGFBQWEsRUFBRSxtQ0FBbUMsWUFBWSx5Q0FBeUMsMkJBQTJCLHVDQUF1QywyQkFBMkIsMEJBQTBCLHdCQUF3Qiw2R0FBNkcsc0JBQXNCLDJKQUEySixzQkFBc0IsYUFBYSxhQUFhLDBGQUEwRixFQUFFLDREQUE0RCxVQUFVLDBDQUEwQyxlQUFlLGFBQWEsa0lBQWtJLEVBQUUseURBQXlELGFBQWEsd0lBQXdJLEVBQUUsYUFBYSxVQUFVLDBDQUEwQyxrQ0FBa0MsMEJBQTBCLDZJQUE2SSxhQUFhLGdGQUFnRiw2QkFBNkIsMkhBQTJILElBQUksd0JBQXdCLHdEQUF3RCxhQUFhLHdGQUF3RixFQUFFLGNBQWMscUJBQXFCO0FBQ2htRTtBQUNBLGtCQUFrQixJQUFJLGNBQWMsZUFBZSwyQkFBMkIsZ0NBQWdDLEVBQUUsMEJBQTBCLHFDQUFxQyxZQUFZLEVBQUUsMkJBQTJCLG1CQUFtQiwrQkFBK0Isb0JBQW9CLCtCQUErQixhQUFhLHNFQUFzRSw2QkFBNkIsS0FBSyxZQUFZLEdBQUcsWUFBWSxzQkFBc0IseUJBQXlCLGFBQWEsZ0ZBQWdGLDRCQUE0QiwwQkFBMEIsa0ZBQWtGLGtCQUFrQixrQkFBa0IsNkNBQTZDLFdBQVcsRUFBRSw2RUFBNkUsaUNBQWlDLG9CQUFvQixVQUFVLGFBQWEscUNBQXFDLDZCQUE2QixPQUFPLHFCQUFxQiwrQ0FBK0MsYUFBYSxnRkFBZ0YsU0FBUyxtQkFBbUIsV0FBVywwQkFBMEIsS0FBSyx5QkFBeUIsNEJBQTRCLFFBQVEsRUFBRSxzQ0FBc0MscUJBQXFCLDRDQUE0QyxvQkFBb0IsT0FBTyx3QkFBd0IsOENBQThDLGFBQWEsb0lBQW9JLEVBQUUsVUFBVSwwQ0FBMEMseUpBQXlKLGtDQUFrQyxvQkFBb0IsNEJBQTRCLE9BQU8sb0JBQW9CO0FBQzU5RCxJQUFJLG9FQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNIbkIsSUFBSSxxREFBTSxnQkFBZ0IsYUFBYSwwQkFBMEIsd0JBQXdCLHlDQUF5QyxnQkFBZ0IsWUFBWSxhQUFhLDBFQUEwRSw2QkFBNkIsYUFBYSxLQUFLLHlCQUF5QiwyQ0FBMkMsYUFBYSxFQUFFLHdCQUF3QixZQUFZLHlDQUF5QywyQkFBMkIsdUNBQXVDLHlCQUF5Qix3QkFBd0IsMEJBQTBCLHdCQUF3QjtBQUN6bUIsSUFBSSw4REFBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDd0JuQjtBQUVBO0FBQ0E7QUFBQTtBQUFBLEdBREE7QUFLQTtBQUNBO0FBQ0EsU0FEQSxpQkFDQTtBQUNBO0FBQ0EsT0FIQTtBQUlBLFNBSkEsZUFJQSxLQUpBLEVBSUE7QUFDQTtBQUNBO0FBTkE7QUFEQSxHQUxBO0FBZ0JBO0FBQ0EsUUFEQSxrQkFDQTtBQUNBO0FBQ0EsS0FIQTtBQUlBLFFBSkEsa0JBSUE7QUFDQTtBQUNBO0FBTkE7QUFoQkEsRzs7QUMzQjZWLENBQWdCLHNHQUFHLEVBQUMsQzs7Ozs7QUNBalI7QUFDdkM7QUFDTDtBQUNxQzs7O0FBR3pGO0FBQ2dHO0FBQ2hHLElBQUksZUFBUyxHQUFHLDhDQUFVO0FBQzFCLEVBQUUsb0NBQU07QUFDUixFQUFFLHFEQUFNO0FBQ1IsRUFBRSw4REFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSx5REFBUyxROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNvRXhCO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFDQSxnQkFEQTtBQUVBO0FBRkEsR0FGQTtBQU9BLDZDQVBBO0FBU0E7QUFBQTtBQUNBLDRCQURBO0FBRUEscUJBRkE7QUFHQSxvQkFIQTtBQUtBLHVCQUxBO0FBTUEsY0FOQTtBQVFBO0FBUkE7QUFBQSxHQVRBO0FBb0JBLFNBcEJBLHFCQW9CQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBLGVBRkEsRUFFQTtBQUNBO0FBREEsZUFGQTs7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBLGVBRkEsRUFFQTtBQUNBO0FBREEsZUFGQTs7QUFNQTtBQUFBO0FBQUE7QUFDQTtBQUNBLGVBRkE7O0FBYkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFnQkEsR0FwQ0E7QUFzQ0E7QUFDQSxlQURBLHlCQUNBO0FBQ0E7QUFDQSxLQUhBO0FBSUEsY0FKQSx3QkFJQTtBQUNBO0FBQ0E7QUFOQSxHQXRDQTtBQStDQTtBQUNBLFdBREEscUJBQ0E7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFQSxLQUhBO0FBSUEsYUFKQSx1QkFJQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBQ0EsdU1BREE7O0FBQUE7QUFDQSwrQkFEQTtBQUVBLHdDQUNBO0FBQ0EscUVBREE7QUFFQTtBQUZBO0FBSUEsd0NBQ0E7QUFDQSxxRUFEQTtBQUVBO0FBRkE7QUFJQTtBQUNBO0FBQUE7QUFBQTtBQUNBOztBQWRBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZUEsS0FuQkE7QUFvQkEsVUFwQkEsb0JBb0JBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUFBLHVCQUdBO0FBQ0EsZ0NBREE7QUFFQTtBQUNBLHNEQURBO0FBRUEsNERBRkE7QUFHQTtBQUhBLG1CQUZBO0FBT0E7QUFDQTtBQURBO0FBUEEsa0JBSEE7O0FBQUE7QUFHQSx3QkFIQTtBQUFBO0FBQUEsdUJBZUEsZUFmQTs7QUFBQTtBQWVBLHdCQWZBO0FBZ0JBO0FBRUE7QUFsQkE7QUFBQTtBQUFBLHVCQXNCQSw2SkF0QkE7O0FBQUE7QUFzQkEsc0JBdEJBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUF5QkE7O0FBekJBO0FBQUE7QUFBQSx1QkEyQkEsMERBM0JBOztBQUFBO0FBMkJBLHFCQTNCQTtBQTZCQTtBQUVBO0FBQ0E7QUFFQTtBQUdBOztBQXJDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXNDQTtBQTFEQTtBQS9DQSxHOztBQ25HbVcsQ0FBZ0IsaUhBQUcsRUFBQyxDOzs7OztBQ0FqUjtBQUN2QztBQUNMO0FBQ3FDOzs7QUFHL0Y7QUFDZ0c7QUFDaEcsSUFBSSxxQkFBUyxHQUFHLDhDQUFVO0FBQzFCLEVBQUUseUNBQU07QUFDUixFQUFFLDJEQUFNO0FBQ1IsRUFBRSxvRUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSxxRUFBUyxROzs7OztBQ25CeEIsSUFBSSwwREFBTSxnQkFBZ0IsYUFBYSwwQkFBMEIsd0JBQXdCLGlCQUFpQixhQUFhLHNGQUFzRiwyQkFBMkIseUJBQXlCLGtDQUFrQyx5QkFBeUIsS0FBSyxrQkFBa0IseUdBQXlHLGtDQUFrQyxrQ0FBa0MsS0FBSyxrQkFBa0IsK0JBQStCLHNCQUFzQixxQ0FBcUMsYUFBYSx3RUFBd0UsNEJBQTRCLDBCQUEwQixrRkFBa0Ysa0JBQWtCLGtCQUFrQiw2Q0FBNkMsV0FBVyxFQUFFLHlFQUF5RSxrREFBa0QseURBQXlEO0FBQ2htQyxJQUFJLG1FQUFlOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ21CbkI7QUFFQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQUEsR0FEQTtBQUtBLGtHQUNBLDRCQURBO0FBRUE7QUFDQSxTQURBLGlCQUNBO0FBQ0E7QUFDQSxPQUhBO0FBSUEsU0FKQSxlQUlBLEdBSkEsRUFJQTtBQUNBO0FBQ0E7QUFOQSxLQUZBO0FBVUEsZUFWQSx5QkFVQTtBQUNBO0FBQ0EsS0FaQTtBQWFBLFFBYkEsa0JBYUE7QUFDQTtBQUNBLEtBZkE7QUFnQkEsU0FoQkEsbUJBZ0JBO0FBQ0E7QUFDQTtBQWxCQSxJQUxBO0FBMEJBO0FBQ0EsUUFEQSxrQkFDQTtBQUNBO0FBQ0E7QUFDQSxLQUpBO0FBS0EsUUFMQSxrQkFLQTtBQUNBLGtDQUNBO0FBQ0E7QUFSQTtBQTFCQSxHOztBQ3RCa1csQ0FBZ0IsK0dBQUcsRUFBQyxDOzs7OztBQ0FqUjtBQUN2QztBQUNMO0FBQ3FDOzs7QUFHOUY7QUFDZ0c7QUFDaEcsSUFBSSxvQkFBUyxHQUFHLDhDQUFVO0FBQzFCLEVBQUUsd0NBQU07QUFDUixFQUFFLDBEQUFNO0FBQ1IsRUFBRSxtRUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSxtRUFBUyxROzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNkN4QjtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUVBO0FBQ0E7QUFDQSxjQURBO0FBRUEsNEJBRkE7QUFHQSwyQ0FIQTtBQUlBO0FBSkEsR0FEQTtBQVFBLFNBUkEscUJBUUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQSxlQUZBLEVBRUE7QUFDQTtBQURBLGVBRkE7O0FBREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFNQSxHQWRBO0FBZ0JBO0FBQ0EsaUJBREEsMkJBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQSxHQWhCQTtBQXVCQTtBQUFBO0FBQ0Esd0JBREE7QUFHQSxrQkFDQTtBQUNBLGNBREE7QUFFQTtBQUZBLE9BREEsRUFLQTtBQUNBLGNBREE7QUFFQTtBQUZBLE9BTEEsRUFTQTtBQUNBLGNBREE7QUFFQTtBQUZBLE9BVEEsQ0FIQTtBQWtCQSxtQkFDQTtBQUNBLGNBREE7QUFFQTtBQUZBLE9BREEsRUFLQTtBQUNBLGNBREE7QUFFQTtBQUZBLE9BTEEsRUFTQTtBQUNBLGNBREE7QUFFQTtBQUZBLE9BVEEsRUFhQTtBQUNBLGNBREE7QUFFQTtBQUZBLE9BYkEsRUFpQkE7QUFDQSxjQURBO0FBRUE7QUFGQSxPQWpCQSxDQWxCQTtBQXlDQSxlQUNBO0FBQ0EsY0FEQTtBQUVBO0FBRkEsT0FEQSxFQUtBO0FBQ0EsY0FEQTtBQUVBO0FBRkEsT0FMQSxFQVNBO0FBQ0EsY0FEQTtBQUVBO0FBRkEsT0FUQTtBQXpDQTtBQUFBLEdBdkJBO0FBZ0ZBLGtHQUNBLDRCQURBO0FBRUEsaUJBRkEsMkJBRUE7QUFDQTtBQUNBLEtBSkE7QUFLQTtBQUNBLFNBREEsaUJBQ0E7QUFDQTtBQUNBLE9BSEE7QUFJQSxTQUpBLGVBSUEsR0FKQSxFQUlBO0FBQ0E7QUFDQTtBQU5BLEtBTEE7QUFhQTtBQUNBLFNBREEsaUJBQ0E7QUFDQTtBQUNBLE9BSEE7QUFJQSxTQUpBLGVBSUEsR0FKQSxFQUlBO0FBQ0E7QUFDQTtBQU5BLEtBYkE7QUFxQkE7QUFDQSxTQURBLGlCQUNBO0FBQ0E7QUFDQSxPQUhBO0FBSUEsU0FKQSxlQUlBLEdBSkEsRUFJQTtBQUNBO0FBQ0E7QUFOQSxLQXJCQTtBQTZCQSxvQkE3QkEsOEJBNkJBO0FBQUE7O0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBRUE7QUFDQSxLQW5DQTtBQW9DQSxpQkFwQ0EsMkJBb0NBO0FBQ0E7QUFDQTtBQXRDQSxJQWhGQTtBQXlIQTtBQUNBLFdBREEscUJBQ0E7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSx1QkFEQSxHQUNBLDRGQURBO0FBRUEscUJBRkEsR0FFQSxDQUNBLGtJQURBLEVBRUEsb0lBRkEsRUFHQSxrSEFIQSxDQUZBO0FBQUE7QUFBQSx1QkFPQSwwQ0FQQTs7QUFBQTtBQVFBOztBQVJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBU0EsS0FWQTtBQVdBLGdCQVhBLDBCQVdBO0FBQ0E7QUFDQTtBQWJBO0FBekhBLEc7O0FDakY2VixDQUFnQixxR0FBRyxFQUFDLEM7Ozs7O0FDQWpSO0FBQ3ZDO0FBQ0w7QUFDcUM7OztBQUd6RjtBQUNnRztBQUNoRyxJQUFJLGVBQVMsR0FBRyw4Q0FBVTtBQUMxQixFQUFFLG1DQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLDBGQUFTLFEiLCJmaWxlIjoiOWFiYy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcIndpbmRvdyB3aGl0ZVwifSxbX2MoJ2ZpZWxkc2V0JyxbX2MoJ2xlZ2VuZCcsW192bS5fdihcIlZvdGVzXCIpXSksX2MoJ25ldy10ZXh0LXZvdGUnKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJmaWx0ZXJcIn0sW19jKCdmaWVsZHNldCcsW19jKCdsZWdlbmQnLFtfdm0uX3YoXCJGaWx0ZXJcIildKSxfYygnZGl2JyxbX2MoJ3NwYW4nLFtfdm0uX3YoXCJTdGF0dXM6XCIpXSksX2MoJ3NlbGVjdCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwibW9kZWxcIixyYXdOYW1lOlwidi1tb2RlbFwiLHZhbHVlOihfdm0uZmlsdGVyU3RhdHVzKSxleHByZXNzaW9uOlwiZmlsdGVyU3RhdHVzXCJ9XSxzdGF0aWNDbGFzczpcInR2aXNpb25cIixvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3ZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO3JldHVybiB2YWx9KTsgX3ZtLmZpbHRlclN0YXR1cz0kZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF19fX0sX3ZtLl9sKChfdm0uYWxsU3RhdHVzKSxmdW5jdGlvbihzdGF0dXMpe3JldHVybiBfYygnb3B0aW9uJyx7ZG9tUHJvcHM6e1widmFsdWVcIjpzdGF0dXMudmFsfX0sW192bS5fdihcIiBcIitfdm0uX3Moc3RhdHVzLnRleHQpK1wiIFwiKV0pfSksMCksX2MoJ3NwYW4nLFtfdm0uX3YoXCJPdXRjb21lOlwiKV0pLF9jKCdzZWxlY3QnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLmZpbHRlck91dGNvbWUpLGV4cHJlc3Npb246XCJmaWx0ZXJPdXRjb21lXCJ9XSxzdGF0aWNDbGFzczpcInR2aXNpb25cIixvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3ZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO3JldHVybiB2YWx9KTsgX3ZtLmZpbHRlck91dGNvbWU9JGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdfX19LF92bS5fbCgoX3ZtLmFsbE91dGNvbWUpLGZ1bmN0aW9uKG91dGNvbWUpe3JldHVybiBfYygnb3B0aW9uJyx7ZG9tUHJvcHM6e1widmFsdWVcIjpvdXRjb21lLnZhbH19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKG91dGNvbWUudGV4dCkrXCIgXCIpXSl9KSwwKSxfYygnc3BhbicsW192bS5fdihcIkFwcDpcIildKSxfYygnc2VsZWN0Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJtb2RlbFwiLHJhd05hbWU6XCJ2LW1vZGVsXCIsdmFsdWU6KF92bS5maWx0ZXJBcHApLGV4cHJlc3Npb246XCJmaWx0ZXJBcHBcIn1dLHN0YXRpY0NsYXNzOlwidHZpc2lvblwiLG9uOntcImNoYW5nZVwiOmZ1bmN0aW9uKCRldmVudCl7dmFyICQkc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSkubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcIl92YWx1ZVwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7cmV0dXJuIHZhbH0pOyBfdm0uZmlsdGVyQXBwPSRldmVudC50YXJnZXQubXVsdGlwbGUgPyAkJHNlbGVjdGVkVmFsIDogJCRzZWxlY3RlZFZhbFswXX19fSxfdm0uX2woKF92bS5hbGxBcHApLGZ1bmN0aW9uKGFwcCl7cmV0dXJuIF9jKCdvcHRpb24nLHtkb21Qcm9wczp7XCJ2YWx1ZVwiOmFwcC52YWx9fSxbX3ZtLl92KFwiIFwiK192bS5fcyhhcHAudGV4dCkrXCIgXCIpXSl9KSwwKV0pXSldKSxfYygnZGl2Jyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOighX3ZtLmN1c3RvbUZpbHRlciksZXhwcmVzc2lvbjpcIiFjdXN0b21GaWx0ZXJcIn1dLHN0YXRpY0NsYXNzOlwidm90ZXMtd3JhcHBlciBoZWFkZXJcIn0sW19jKCdmaWVsZHNldCcsW19jKCdzcGFuJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOighX3ZtLmxvYWRlZFZvdGVzKSxleHByZXNzaW9uOlwiIWxvYWRlZFZvdGVzXCJ9XSxzdGF0aWNDbGFzczpcImxvYWRpbmcgbWF0cml4XCJ9KSxfYygnbGVnZW5kJyxbX3ZtLl92KFwiT3BlbiB2b3RlcyAoXCIrX3ZtLl9zKF92bS5vcGVuVm90ZXMubGVuZ3RoKStcIilcIildKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJ2b3RlcyBvcGVuXCJ9LF92bS5fbCgoX3ZtLm9wZW5Wb3RlcyksZnVuY3Rpb24odm90ZSl7cmV0dXJuIF9jKCd2b3RlJyx7a2V5OnZvdGUuaWQsc3RhdGljQ2xhc3M6XCJ2b3RlXCIsYXR0cnM6e1widm90ZVwiOnZvdGV9fSl9KSwxKV0pXSksX2MoJ2Rpdicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS5jdXN0b21GaWx0ZXIpLGV4cHJlc3Npb246XCIhY3VzdG9tRmlsdGVyXCJ9XSxzdGF0aWNDbGFzczpcInZvdGVzLXdyYXBwZXIgaGVhZGVyXCJ9LFtfYygnZmllbGRzZXQnLFtfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS5sb2FkZWRWb3RlcyksZXhwcmVzc2lvbjpcIiFsb2FkZWRWb3Rlc1wifV0sc3RhdGljQ2xhc3M6XCJsb2FkaW5nIG1hdHJpeFwifSksX2MoJ2xlZ2VuZCcsW192bS5fdihcIkNsb3NlZCB2b3RlcyAoXCIrX3ZtLl9zKF92bS5jbG9zZWRWb3Rlcy5sZW5ndGgpK1wiKVwiKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZvdGVzIGNsb3NlZFwifSxfdm0uX2woKF92bS5jbG9zZWRWb3RlcyksZnVuY3Rpb24odm90ZSl7cmV0dXJuIF9jKCd2b3RlJyx7a2V5OnZvdGUuaWQsc3RhdGljQ2xhc3M6XCJ2b3RlXCIsYXR0cnM6e1widm90ZVwiOnZvdGV9fSl9KSwxKV0pXSksKF92bS5jdXN0b21GaWx0ZXIpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZvdGVzLXdyYXBwZXIgaGVhZGVyXCJ9LFtfYygnZmllbGRzZXQnLFtfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS5sb2FkZWRWb3RlcyksZXhwcmVzc2lvbjpcIiFsb2FkZWRWb3Rlc1wifV0sc3RhdGljQ2xhc3M6XCJsb2FkaW5nIG1hdHJpeFwifSksX2MoJ2xlZ2VuZCcsW192bS5fdihfdm0uX3MoX3ZtLmN1c3RvbUZpbHRlclRleHQpK1wiIChcIitfdm0uX3MoX3ZtLmN1c3RvbUZpbHRlclZvdGVzLmxlbmd0aCkrXCIpXCIpXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidm90ZXMgY2xvc2VkXCJ9LF92bS5fbCgoX3ZtLmZpbHRlclBhZ2luYXRpb24pLGZ1bmN0aW9uKHZvdGUpe3JldHVybiBfYygndm90ZScse2tleTp2b3RlLmlkLHN0YXRpY0NsYXNzOlwidm90ZVwiLGF0dHJzOntcInZvdGVcIjp2b3RlfX0pfSksMSldKV0pOl92bS5fZSgpLF9jKCdwYWdpbmF0aW9uJyldLDEpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLFtfYygnZmllbGRzZXQnLFtfYygnbGVnZW5kJyxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0udm90ZS52b3RpbmdBcHBOYW1lKStcIiAoXCIrX3ZtLl9zKF92bS5nZXRTdXBwb3J0UmVxdWlyZWRQY3QpK1wiJSAvIFwiK192bS5fcyhfdm0uZ2V0TWluQWNjZXB0UXVvcnVtKStcIiUpIFwiKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInZvdGVUaXRsZVwifSxbX2MoJ3JvdXRlci1saW5rJyx7YXR0cnM6e1widG9cIjonL2Rhby92b3RlLycgKyBfdm0udm90ZS52b3RpbmdBcHBOYW1lLnRvTG93ZXJDYXNlKCkgKyAnLycgKyBfdm0udm90ZS52b3RlTnVtYmVyfX0sW19jKCdiJyxbX3ZtLl92KFwiICNcIitfdm0uX3MoX3ZtLnZvdGUudm90ZUNvdW50U2VxKStcIiBcIildKV0pLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJ1c2VyQ2FzdFZvdGUgdG9vbHRpcFwifSxbX2MoJ3NwYW4nLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS52b3RlLmNhc3RzICYmIF92bS52b3RlLmNhc3RzLmxlbmd0aCAmJiBfdm0udm90ZS5jYXN0c1swXS5zdXBwb3J0cyksZXhwcmVzc2lvbjpcInZvdGUuY2FzdHMgJiYgdm90ZS5jYXN0cy5sZW5ndGggJiYgdm90ZS5jYXN0c1swXS5zdXBwb3J0c1wifV0sc3RhdGljQ2xhc3M6XCJ1c2VyVm90ZWRZZXNcIn0sW192bS5fdihcIuKImlwiKV0pLF9jKCdzcGFuJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOihfdm0udm90ZS5jYXN0cyAmJiBfdm0udm90ZS5jYXN0cy5sZW5ndGggJiYgIV92bS52b3RlLmNhc3RzWzBdLnN1cHBvcnRzKSxleHByZXNzaW9uOlwidm90ZS5jYXN0cyAmJiB2b3RlLmNhc3RzLmxlbmd0aCAmJiAhdm90ZS5jYXN0c1swXS5zdXBwb3J0c1wifV0sc3RhdGljQ2xhc3M6XCJ1c2VyVm90ZWROb1wifSxbX3ZtLl92KFwiWFwiKV0pLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJ0b29sdGlwdGV4dFwifSxbX3ZtLl92KFwiIFlvdSB2b3RlZCBcIitfdm0uX3MoX3ZtLnZvdGUuY2FzdHMgJiYgX3ZtLnZvdGUuY2FzdHMubGVuZ3RoICYmIF92bS52b3RlLmNhc3RzWzBdLnN1cHBvcnRzID8gJ1llcycgOiAnTm8nKStcIiBcIildKV0pXSwxKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJkZXNjcmlwdGlvblwifSxbX2MoJ3JvdXRlci1saW5rJyx7YXR0cnM6e1widG9cIjonL2Rhby92b3RlLycgKyBfdm0udm90ZS52b3RpbmdBcHBOYW1lLnRvTG93ZXJDYXNlKCkgKyAnLycgKyBfdm0udm90ZS52b3RlTnVtYmVyfX0sW19jKCdzcGFuJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOihfdm0udm90ZS5jb250cmFjdE5hbWUpLGV4cHJlc3Npb246XCJ2b3RlLmNvbnRyYWN0TmFtZVwifV19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS52b3RlLmNvbnRyYWN0TmFtZSkrXCI6IFwiKSxfYygnc3Bhbicse2RvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhfdm0udm90ZS5kZXNjcmlwdGlvbil9fSldKSxfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS52b3RlLmNvbnRyYWN0TmFtZSAmJiBfdm0udm90ZS5tZXRhZGF0YSksZXhwcmVzc2lvbjpcIiF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLm1ldGFkYXRhXCJ9XX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLmZvcm1hdHRlZE1ldGFkYXRhKStcIiBcIildKSxfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS52b3RlLmNvbnRyYWN0TmFtZSAmJiBfdm0udm90ZS5kZXNjcmlwdGlvbiksZXhwcmVzc2lvbjpcIiF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLmRlc2NyaXB0aW9uXCJ9XX0sW19jKCdzcGFuJyx7ZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKF92bS52b3RlLmRlc2NyaXB0aW9uKX19KV0pXSldLDEpLF9jKCdjb3VudGRvd24nLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5pc09wZW4oX3ZtLnZvdGUpICYmICFfdm0udm90ZS5leGVjdXRlZCksZXhwcmVzc2lvbjpcImlzT3Blbih2b3RlKSAmJiAhdm90ZS5leGVjdXRlZFwifV0sYXR0cnM6e1widGltZXN0YW1wXCI6X3ZtLnZvdGUuc3RhcnREYXRlLFwidm90ZVwiOl92bS52b3RlfX0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInR1aS1wcm9ncmVzcy1iYXJcIn0sW19jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJ5ZXN0ZXh0XCJ9LFtfdm0uX3YoXCJZZXM6XCIpXSksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcInR1aS1wcm9ncmVzcy1sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhfdm0udm90ZS55ZWFwKStcIiVcIildKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwidHVpLXByb2dyZXNzIHllc1wiLHN0eWxlOih7d2lkdGg6IF92bS52b3RlLnllYXAgKyAnJSd9KX0pXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwidHVpLXByb2dyZXNzLWJhclwifSxbX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcIm5vdGV4dFwifSxbX3ZtLl92KFwiTm86XCIpXSksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcInR1aS1wcm9ncmVzcy1sYWJlbFwifSxbX3ZtLl92KF92bS5fcyhfdm0udm90ZS5ub3ApK1wiJVwiKV0pLF9jKCdzcGFuJyx7c3RhdGljQ2xhc3M6XCJ0dWktcHJvZ3Jlc3Mgbm9cIixzdHlsZTooe3dpZHRoOiBfdm0udm90ZS5ub3AgKyAnJSd9KX0pXSksX2MoJ2Rpdicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLnZvdGUuZXhlY3V0ZWQpLGV4cHJlc3Npb246XCJ2b3RlLmV4ZWN1dGVkXCJ9XSxzdGF0aWNDbGFzczpcImVuYWN0ZWRcIn0sW192bS5fdihcIiDiiJogUGFzc2VkKGVuYWN0ZWQpIFwiKV0pLF9jKCdkaXYnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5jYW5FeGVjdXRlKSxleHByZXNzaW9uOlwiY2FuRXhlY3V0ZVwifV0sc3RhdGljQ2xhc3M6XCJjYW5leGVjdXRlXCJ9LFtfdm0uX3YoXCIg4oiaIFBhc3NlZCBcIiksX2MoJ2VuYWN0LXZvdGUnLHthdHRyczp7XCJ2b3RlXCI6X3ZtLnZvdGV9fSldLDEpLF9jKCdkaXYnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5pc1JlamVjdGVkKSxleHByZXNzaW9uOlwiaXNSZWplY3RlZFwifV0sc3RhdGljQ2xhc3M6XCJyZWplY3RlZFwifSxbX3ZtLl92KFwiIFggUmVqZWN0ZWQgKFwiK192bS5fcyhfdm0ucmVqZWN0ZWRSZWFzb25UZXh0KStcIikgXCIpXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY3JlYXRlZG9uXCJ9LFtfYygnaW1nJyx7c3RhdGljQ2xhc3M6XCJpY29uIHNtYWxsXCIsYXR0cnM6e1wic3JjXCI6X3ZtLnB1YmxpY1BhdGggKyAnY2xvY2stcmVndWxhci5zdmcnfX0pLF92bS5fdihcIiBcIitfdm0uX3MoX3ZtLnN0YXJ0RGF0ZUZvcm1hdCkrXCIgXCIpXSldLDEpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cblx0PGRpdj5cblx0XHQ8ZmllbGRzZXQ+XG5cdFx0XHQ8bGVnZW5kPlxuXHRcdFx0XHR7eyB2b3RlLnZvdGluZ0FwcE5hbWUgfX0gKHt7Z2V0U3VwcG9ydFJlcXVpcmVkUGN0fX0lIC8ge3tnZXRNaW5BY2NlcHRRdW9ydW19fSUpXG5cdFx0XHQ8L2xlZ2VuZD5cblx0XHRcdDxkaXYgY2xhc3M9J3ZvdGVUaXRsZSc+XG5cdFx0XHRcdDxyb3V0ZXItbGluayA6dG89XCInL2Rhby92b3RlLycgKyB2b3RlLnZvdGluZ0FwcE5hbWUudG9Mb3dlckNhc2UoKSArICcvJyArIHZvdGUudm90ZU51bWJlclwiPlxuXHRcdFx0XHRcdDxiPiAje3sgdm90ZS52b3RlQ291bnRTZXEgfX0gPC9iPlxuXHRcdFx0XHQ8L3JvdXRlci1saW5rPiBcblx0XHRcdFx0PHNwYW4gY2xhc3M9J3VzZXJDYXN0Vm90ZSB0b29sdGlwJz5cblx0XHRcdFx0XHQ8c3BhbiB2LXNob3c9J3ZvdGUuY2FzdHMgJiYgdm90ZS5jYXN0cy5sZW5ndGggJiYgdm90ZS5jYXN0c1swXS5zdXBwb3J0cycgY2xhc3M9J3VzZXJWb3RlZFllcyc+4oiaPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIHYtc2hvdz0ndm90ZS5jYXN0cyAmJiB2b3RlLmNhc3RzLmxlbmd0aCAmJiAhdm90ZS5jYXN0c1swXS5zdXBwb3J0cycgY2xhc3M9J3VzZXJWb3RlZE5vJz5YPC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPSd0b29sdGlwdGV4dCc+XG5cdFx0XHRcdFx0XHRZb3Ugdm90ZWQge3t2b3RlLmNhc3RzICYmIHZvdGUuY2FzdHMubGVuZ3RoICYmIHZvdGUuY2FzdHNbMF0uc3VwcG9ydHMgPyAnWWVzJyA6ICdObyd9fVxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdkZXNjcmlwdGlvbic+XG5cdFx0XHRcdDxyb3V0ZXItbGluayA6dG89XCInL2Rhby92b3RlLycgKyB2b3RlLnZvdGluZ0FwcE5hbWUudG9Mb3dlckNhc2UoKSArICcvJyArIHZvdGUudm90ZU51bWJlclwiPlxuXHRcdFx0XHRcdDxzcGFuIHYtc2hvdz0ndm90ZS5jb250cmFjdE5hbWUnPlxuXHRcdFx0XHRcdFx0e3sgdm90ZS5jb250cmFjdE5hbWUgfX06IDxzcGFuIHYtaHRtbD0ndm90ZS5kZXNjcmlwdGlvbic+PC9zcGFuPlxuXHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHQ8c3BhbiB2LXNob3c9JyF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLm1ldGFkYXRhJz5cblx0XHRcdFx0XHRcdHt7IGZvcm1hdHRlZE1ldGFkYXRhIH19XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHRcdDxzcGFuIHYtc2hvdz0nIXZvdGUuY29udHJhY3ROYW1lICYmIHZvdGUuZGVzY3JpcHRpb24nPlxuXHRcdFx0XHRcdFx0PHNwYW4gdi1odG1sPSd2b3RlLmRlc2NyaXB0aW9uJz48L3NwYW4+XG5cdFx0XHRcdFx0PC9zcGFuPlxuXHRcdFx0XHQ8L3JvdXRlci1saW5rPlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8Y291bnRkb3duIDp0aW1lc3RhbXAgPSAndm90ZS5zdGFydERhdGUnIDp2b3RlID0gJ3ZvdGUnIHYtc2hvdz0naXNPcGVuKHZvdGUpICYmICF2b3RlLmV4ZWN1dGVkJz48L2NvdW50ZG93bj5cblx0XHRcdDxkaXYgY2xhc3M9XCJ0dWktcHJvZ3Jlc3MtYmFyXCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPSd5ZXN0ZXh0Jz5ZZXM6PC9zcGFuPlxuXHRcdFx0ICAgIDxzcGFuIGNsYXNzPVwidHVpLXByb2dyZXNzLWxhYmVsXCI+e3sgdm90ZS55ZWFwIH19JTwvc3Bhbj5cblx0XHRcdCAgICA8c3BhbiBjbGFzcz1cInR1aS1wcm9ncmVzcyB5ZXNcIiA6c3R5bGU9XCJ7d2lkdGg6IHZvdGUueWVhcCArICclJ31cIj48L3NwYW4+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9XCJ0dWktcHJvZ3Jlc3MtYmFyXCI+XG5cdFx0XHRcdDxzcGFuIGNsYXNzPSdub3RleHQnPk5vOjwvc3Bhbj5cblx0XHRcdCAgICA8c3BhbiBjbGFzcz1cInR1aS1wcm9ncmVzcy1sYWJlbFwiPnt7IHZvdGUubm9wIH19JTwvc3Bhbj5cblx0XHRcdCAgICA8c3BhbiBjbGFzcz1cInR1aS1wcm9ncmVzcyBub1wiIDpzdHlsZT1cInt3aWR0aDogdm90ZS5ub3AgKyAnJSd9XCI+PC9zcGFuPlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdlbmFjdGVkJyB2LXNob3c9J3ZvdGUuZXhlY3V0ZWQnPlxuXHRcdFx0XHTiiJogUGFzc2VkKGVuYWN0ZWQpXG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9J2NhbmV4ZWN1dGUnIHYtc2hvdz0nY2FuRXhlY3V0ZSc+XG5cdFx0XHRcdOKImiBQYXNzZWQgPGVuYWN0LXZvdGUgOnZvdGU9J3ZvdGUnPjwvZW5hY3Qtdm90ZT5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz0ncmVqZWN0ZWQnIHYtc2hvdz0naXNSZWplY3RlZCc+XG5cdFx0XHRcdFggUmVqZWN0ZWQgKHt7IHJlamVjdGVkUmVhc29uVGV4dCB9fSlcblx0XHRcdDwvZGl2PlxuXHRcdFx0PGRpdiBjbGFzcz0nY3JlYXRlZG9uJz5cblx0XHRcdFx0PGltZyBcblx0XHRcdFx0XHQ6c3JjPVwicHVibGljUGF0aCArICdjbG9jay1yZWd1bGFyLnN2ZydcIiBcblx0XHRcdFx0XHRjbGFzcz0naWNvbiBzbWFsbCdcblx0XHRcdFx0PiBcblx0XHRcdFx0e3sgc3RhcnREYXRlRm9ybWF0IH19XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2ZpZWxkc2V0PlxuXHQ8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IGNvbm5lY3QsIGRlc2NyaWJlU2NyaXB0LCBBcHAgfSBmcm9tICdAYXJhZ29uL2Nvbm5lY3QnXG5cblx0aW1wb3J0IHsgc3RhdGUsIGdldHRlcnMgfSBmcm9tICcuLi92b3RlU3RvcmUnXG5cdFxuXHRpbXBvcnQgKiBhcyByYWRzcGVjIGZyb20gJ3JhZHNwZWMnXG5cblx0aW1wb3J0IENvdW50ZG93biBmcm9tICcuLi9jb21tb24vQ291bnRkb3duLnZ1ZSdcblx0aW1wb3J0IHsgaGVscGVycyBhcyB2b3RlSGVscGVycywgT1dORVJTSElQX0FQUF9BRERSRVNTLCBQQVJBTUVURVJfQVBQX0FERFJFU1MsIGNvbnRyYWN0TWFwIH0gZnJvbSAnLi4vdm90ZVN0b3JlJ1xuXHRpbXBvcnQgKiBhcyBhbGxhYmlzIGZyb20gJy4uL2FsbGFiaXMnXG5cdGltcG9ydCAqIGFzIGhlbHBlcnMgZnJvbSAnLi4vLi4vLi4vdXRpbHMvaGVscGVycydcblxuXHRpbXBvcnQgRW5hY3RWb3RlIGZyb20gJy4vRW5hY3RWb3RlJ1xuXG5cdGV4cG9ydCBkZWZhdWx0IHtcblx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHRDb3VudGRvd24sXG5cdFx0XHRFbmFjdFZvdGUsXG5cdFx0fSxcblxuXHRcdHByb3BzOiBbJ3ZvdGUnXSxcblxuXHRcdGRhdGE6ICgpID0+ICh7XG5cdFx0XHQvL2Rlc2NyaXB0aW9uOiBudWxsLFxuXHRcdH0pLFxuXG5cdFx0YXN5bmMgY3JlYXRlZCgpIHtcblx0XHRcdC8vdGhpcy5kZXNjcmlwdGlvbiA9IGF3YWl0IHRoaXMuZGVjb2RlQ2FsbCgpXG5cdFx0fSxcblxuXHRcdGNvbXB1dGVkOiB7XG5cdFx0XHRnZXRTdXBwb3J0UmVxdWlyZWRQY3QoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZvdGUuc3VwcG9ydFJlcXVpcmVkUGN0IC8gMWUxNlxuXHRcdFx0fSxcblx0XHRcdGdldE1pbkFjY2VwdFF1b3J1bSgpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudm90ZS5taW5BY2NlcHRRdW9ydW0gLyAxZTE2XG5cdFx0XHR9LFxuXHRcdFx0Ly8gY29udHJhY3RDYWxsZWQoKSB7XG5cdFx0XHQvLyBcdGlmKHRoaXMudm90ZS5zY3JpcHQuc3Vic3RyKDkwLDQwKSA9PSBhbGxhYmlzLnBvb2xwcm94eV9hZGRyZXNzLnN1YnN0cigyKS50b0xvd2VyQ2FzZSgpKSBcblx0XHRcdC8vIFx0XHRyZXR1cm4gJ3Bvb2xwcm94eSdcblx0XHRcdC8vIFx0aWYodGhpcy52b3RlLnNjcmlwdC5zdWJzdHIoOTAsNDApID09IGFsbGFiaXMudm90aW5nZXNjcm93X2FkZHJlc3Muc3Vic3RyKDIpLnRvTG93ZXJDYXNlKCkpIFxuXHRcdFx0Ly8gXHRcdHJldHVybiAndm90aW5nZXNjcm93J1xuXHRcdFx0Ly8gXHRpZih0aGlzLnZvdGUuc2NyaXB0LnN1YnN0cig5MCw0MCkgPT0gYWxsYWJpcy5nYXVnZWNvbnRyb2xsZXJfYWRkcmVzcy5zdWJzdHIoMikudG9Mb3dlckNhc2UoKSkgXG5cdFx0XHQvLyBcdFx0cmV0dXJuICdnYXVnZWNvbnRyb2xsZXInXG5cdFx0XHQvLyBcdHJldHVybiBudWxsXG5cdFx0XHQvLyB9LFxuXHRcdFx0Ly8gY29udHJhY3ROYW1lKCkge1xuXHRcdFx0Ly8gXHRpZih0aGlzLmNvbnRyYWN0Q2FsbGVkID09ICdwb29scHJveHknKSBcblx0XHRcdC8vIFx0XHRyZXR1cm4gJ1Bvb2wgUHJveHknXG5cdFx0XHQvLyBcdGlmKHRoaXMuY29udHJhY3RDYWxsZWQgPT0gJ3ZvdGluZ2VzY3JvdycpXG5cdFx0XHQvLyBcdFx0cmV0dXJuICdWb3RpbmcgRXNjcm93J1xuXHRcdFx0Ly8gXHRpZih0aGlzLmNvbnRyYWN0Q2FsbGVkID09ICdnYXVnZWNvbnRyb2xsZXInKVxuXHRcdFx0Ly8gXHRcdHJldHVybiAnR2F1Z2UgQ29udHJvbGxlcidcblx0XHRcdC8vIFx0cmV0dXJuIG51bGxcblx0XHRcdC8vIH0sXG5cdFx0XHRzdGFydERhdGVGb3JtYXQoKSB7XG5cdFx0XHRcdHJldHVybiBoZWxwZXJzLmZvcm1hdERhdGVUb0h1bWFuKHRoaXMudm90ZS5zdGFydERhdGUpXG5cdFx0XHR9LFxuXHRcdFx0Y2FuRXhlY3V0ZSgpIHtcblx0XHRcdFx0cmV0dXJuIHZvdGVIZWxwZXJzLmNhbkV4ZWN1dGUodGhpcy52b3RlKVxuXHRcdFx0fSxcblx0XHRcdGlzUmVqZWN0ZWQoKSB7XG5cdFx0XHRcdHJldHVybiB2b3RlSGVscGVycy5pc1JlamVjdGVkKHRoaXMudm90ZSlcblx0XHRcdH0sXG5cdFx0XHRyZWplY3RlZFJlYXNvblRleHQoKSB7XG5cdFx0XHRcdGlmKHRoaXMudm90ZS5yZWplY3RlZFJlYXNvbiA9PSAxKVxuXHRcdFx0XHRcdHJldHVybiAnTm8gc3VwcG9ydCdcblx0XHRcdFx0aWYodGhpcy52b3RlLnJlamVjdGVkUmVhc29uID09IDIpXG5cdFx0XHRcdFx0cmV0dXJuICdObyBxdW9ydW0nXG5cdFx0XHRcdHJldHVybiAnJ1xuXHRcdFx0fSxcblx0XHRcdHB1YmxpY1BhdGgoKSB7XG5cdFx0XHRcdHJldHVybiBwcm9jZXNzLmVudi5CQVNFX1VSTFxuXHRcdFx0fSxcblx0XHRcdGZvcm1hdHRlZE1ldGFkYXRhKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52b3RlLm1ldGFkYXRhICYmIGhlbHBlcnMudHJ1bmNhdGUodGhpcy52b3RlLm1ldGFkYXRhLCAxMDAsIHRydWUpXG5cdFx0XHR9LFxuXHRcdH0sXG5cblx0XHRtZXRob2RzOiB7XG5cdFx0XHRpc09wZW4odm90ZSkge1xuXHRcdFx0XHRyZXR1cm4gdm90ZUhlbHBlcnMuaXNWb3RlT3Blbih2b3RlKVxuXHRcdFx0fSxcblx0XHRcdC8vIGFzeW5jIGRlY29kZUNhbGwoKSB7XG5cdFx0XHQvLyBcdGlmKHRoaXMuY29udHJhY3RDYWxsZWQgIT09IG51bGwpIHtcblx0XHRcdC8vIFx0XHRsZXQgbmF0c3BlYyA9IGFsbGFiaXNbdGhpcy5jb250cmFjdENhbGxlZCsnX25hdHNwZWMnXS5tZXRob2RzXG5cdFx0XHQvLyBcdFx0bGV0IGFiaSA9IGFsbGFiaXNbdGhpcy5jb250cmFjdENhbGxlZCsnX2FiaSddXG5cdFx0XHQvLyBcdFx0bGV0IHNpZ25hdHVyZSA9ICcweCcrdGhpcy52b3RlLnNjcmlwdC5zdWJzdHIoMzIyLCA4KVxuXHRcdFx0Ly8gXHRcdGxldCBtZXRob2QgPSBPYmplY3Qua2V5cyhuYXRzcGVjKS5maW5kKGtleSA9PiB3ZWIzLmV0aC5hYmkuZW5jb2RlRnVuY3Rpb25TaWduYXR1cmUoa2V5KSA9PSBzaWduYXR1cmUpXG5cdFx0XHQvLyBcdFx0Y29uc29sZS5sb2cobWV0aG9kLCBcIlRIRSBNRVRIT0RcIilcblx0XHRcdC8vIFx0XHQvLyBsZXQgc2lnbmF0dXJlcyA9IE9iamVjdC52YWx1ZXMobmF0c3BlYykubWFwKG0gPT4gbS5zaWduYXR1cmUuc3Vic3RyKDIpKVxuXHRcdFx0Ly8gXHRcdC8vIGxldCBtYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZyA9PiB0aGlzLnZvdGUuc2NyaXB0LmluZGV4T2Yoc2lnKSkuZmluZChpZHggPT4gaWR4ID4gLTEpXG5cdFx0XHQvLyBcdFx0Ly8gbGV0IG1ldGhvZCA9IE9iamVjdC5rZXlzKG5hdHNwZWMpLmZpbmQoa2V5ID0+IFxuXHRcdFx0Ly8gXHRcdC8vIFx0bmF0c3BlY1trZXldLnNpZ25hdHVyZS5zdWJzdHIoMikgPT0gc2lnbmF0dXJlcy5maWx0ZXIoc2lnID0+IHRoaXMudm90ZS5zY3JpcHQuaW5kZXhPZihzaWcpID4gLTEpKVxuXHRcdFx0Ly8gXHRcdC8vIGlmKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblx0XHRcdC8vIFx0XHQvLyBsZXQgZGF0YSA9IHRoaXMudm90ZS5zY3JpcHQuc3Vic3RyKG1hdGNoKVxuXHRcdFx0Ly8gXHRcdGxldCBkYXRhID0gdGhpcy52b3RlLnNjcmlwdC5zdWJzdHIoMzIyKVxuXHRcdFx0Ly8gXHRcdGxldCBleHByZXNzaW9uID0gbmF0c3BlY1ttZXRob2RdLm5vdGljZVxuXHRcdFx0Ly8gXHRcdGxldCBjYWxsID0ge1xuXHRcdFx0Ly8gXHRcdFx0YWJpOiBbYWJpLmZpbmQodiA9PiB2Lm5hbWUgPT0gbWV0aG9kLnNwbGl0KCcoJylbMF0pXSxcblx0XHRcdC8vIFx0XHRcdHRyYW5zYWN0aW9uOiB7XG5cdFx0XHQvLyBcdFx0XHRcdGRhdGE6ICcweCcgKyBkYXRhLFxuXHRcdFx0Ly8gXHRcdFx0fVxuXHRcdFx0Ly8gXHRcdH1cblx0XHRcdC8vIFx0XHRsZXQgZGVzYyA9IGF3YWl0IHJhZHNwZWMuZXZhbHVhdGUoZXhwcmVzc2lvbiwgY2FsbClcblx0XHRcdC8vIFx0XHRyZXR1cm4gZGVzY1xuXHRcdFx0Ly8gXHR9XG5cdFx0XHQvLyBcdGVsc2UgaWYoIXRoaXMudm90ZS5tZXRhZGF0YSkge1xuXHRcdFx0Ly8gXHRcdHRyeSB7XG5cdFx0XHQvLyBcdFx0XHRsZXQgZGVzYyA9IGF3YWl0IGRlc2NyaWJlU2NyaXB0KHRoaXMudm90ZS5zY3JpcHQsIHN0YXRlLmFwcHMpXG5cdFx0XHQvLyBcdFx0XHRyZXR1cm4gZGVzY1swXS5kZXNjcmlwdGlvblxuXHRcdFx0Ly8gXHRcdH1cblx0XHRcdC8vIFx0XHRjYXRjaChlcnIpIHtcblx0XHRcdC8vIFx0XHRcdGNvbnNvbGUuZXJyb3IoZXJyKVxuXHRcdFx0Ly8gXHRcdH1cblx0XHRcdC8vIFx0fVxuXHRcdFx0Ly8gfSxcblxuXHRcdH0sXG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXHRmaWVsZHNldCB7XG5cdFx0aGVpZ2h0OiAxMDAlO1xuXHR9XG5cdGxlZ2VuZCB7XG5cdFx0dGV4dC1hbGlnbjogY2VudGVyO1xuXHR9XG5cdC5wcm9ncmVzcyB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdH1cblx0LnR1aS1wcm9ncmVzcy1iYXIge1xuXHRcdGJhY2tncm91bmQ6IGdyYXk7XG5cdFx0bWFyZ2luLXRvcDogMC40ZW07XG5cdH1cblx0LnR1aS1wcm9ncmVzcy55ZXMge1xuXHRcdGJhY2tncm91bmQ6ICM4NmZjZTc7XG5cdH1cblx0LnR1aS1wcm9ncmVzcy5ubyB7XG5cdFx0YmFja2dyb3VuZDogZGFya3JlZDtcblx0fVxuXHQueWVzdGV4dCwgLm5vdGV4dCB7XG5cdFx0cG9zaXRpb246IGFic29sdXRlO1xuXHRcdHRvcDogNTAlO1xuXHRcdHotaW5kZXg6IDE7XG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGVZKC01MCUpO1xuXHRcdHBhZGRpbmctbGVmdDogM3B4O1xuXHR9XG5cdC5jYW5leGVjdXRlLCAuZW5hY3RlZCB7XG5cdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdGNvbG9yOiAjODZmY2U3O1xuXHR9XG5cdC5yZWplY3RlZCB7XG5cdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdGNvbG9yOiBkYXJrcmVkO1xuXHR9XG5cdC5jcmVhdGVkb24ge1xuXHRcdG1hcmdpbi10b3A6IDAuNGVtO1xuXHR9XG5cdC51c2VyQ2FzdFZvdGUge1xuXHRcdGN1cnNvcjogcG9pbnRlcjtcblx0fVxuXHQudXNlclZvdGVkWWVzIHtcblx0XHRjb2xvcjogZ3JlZW47XG5cdH1cblx0LnVzZXJWb3RlZE5vIHtcblx0XHRjb2xvcjogZGFya3JlZDtcblx0fVxuXHQudm90ZVRpdGxlIHtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHRcdGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2Vlbjtcblx0fVxuXHQuZGVzY3JpcHRpb24ge1xuXHRcdG1hcmdpbi10b3A6IDAuMWVtO1xuXHR9XG5cdC8qLmRlc2NyaXB0aW9uIHtcblx0XHRoZWlnaHQ6IDMwcHg7XG5cdFx0ZGlzcGxheTogLXdlYmtpdC1ib3g7XG5cdFx0LXdlYmtpdC1ib3gtb3JpZW50OiB2ZXJ0aWNhbDtcblx0XHQtd2Via2l0LWxpbmUtY2xhbXA6IDM7XG5cdFx0b3ZlcmZsb3c6IGhpZGRlbjtcblx0fSovXG5cdC51c2VyQ2FzdFZvdGUgLnRvb2x0aXB0ZXh0IHtcblx0XHRwYWRkaW5nOiAwLjRlbTtcblx0fVxuPC9zdHlsZT4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1ZvdGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1ZvdGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Wb3RlLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0yMmU2YmJhNiZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Wb3RlLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vVm90ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vVm90ZS52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0yMmU2YmJhNiZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiMjJlNmJiYTZcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiLCJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2JyxbKF92bS5zaG93Um9vdE1vZGFsKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtb2RhbCByb290bW9kYWxcIixhdHRyczp7XCJpZFwiOlwibW9kYWxcIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0KXsgcmV0dXJuIG51bGw7IH1yZXR1cm4gX3ZtLmhpZGVSb290TW9kYWwoJGV2ZW50KX19fSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibW9kYWwtY29udGVudCB3aW5kb3cgd2hpdGVcIn0sW19jKCdmaWVsZHNldCcsW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImxlZ2VuZDIgaG92ZXJwb2ludGVyXCIsb246e1wiY2xpY2tcIjpfdm0uaGlkZVJvb3RNb2RhbH19LFtfdm0uX3YoXCIgW1wiKSxfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwiZ3JlZW50ZXh0XCJ9LFtfdm0uX3YoXCJYXCIpXSksX3ZtLl92KFwiXSBcIildKSxfYygnbGVnZW5kJyxbX3ZtLl92KFwiQ3JlYXRlIGEgdGV4dCB2b3RlIG9uIFwiK192bS5fcyhfdm0uYXBwTmFtZSkpXSksX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29udGVudFwifSxbX2MoJ2RpdicsW19jKCdzcGFuJyxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0udm90ZURlc2NyaXB0aW9uKStcIiBcIildKSxfYygnZGl2JyxbX2MoJ3NwYW4nLFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS5kZXNjcmlwdGlvbikrXCIgXCIpXSldKSwoX3ZtLnZvdGUpP19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImNvbnRlbnRcIn0sW19jKCdzcGFuJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOihfdm0udm90ZS5jb250cmFjdE5hbWUpLGV4cHJlc3Npb246XCJ2b3RlLmNvbnRyYWN0TmFtZVwifV19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS52b3RlLmNvbnRyYWN0TmFtZSkrXCI6IFwiKSxfYygnc3Bhbicse2RvbVByb3BzOntcImlubmVySFRNTFwiOl92bS5fcyhfdm0udm90ZS5kZXNjcmlwdGlvbil9fSldKSxfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS52b3RlLmNvbnRyYWN0TmFtZSAmJiBfdm0udm90ZS5tZXRhZGF0YSksZXhwcmVzc2lvbjpcIiF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLm1ldGFkYXRhXCJ9XX0sW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLnZvdGUubWV0YWRhdGEpK1wiIFwiKV0pLF9jKCdzcGFuJyx7ZGlyZWN0aXZlczpbe25hbWU6XCJzaG93XCIscmF3TmFtZTpcInYtc2hvd1wiLHZhbHVlOighX3ZtLnZvdGUuY29udHJhY3ROYW1lICYmIF92bS52b3RlLmRlc2NyaXB0aW9uKSxleHByZXNzaW9uOlwiIXZvdGUuY29udHJhY3ROYW1lICYmIHZvdGUuZGVzY3JpcHRpb25cIn1dfSxbX2MoJ3NwYW4nLHtkb21Qcm9wczp7XCJpbm5lckhUTUxcIjpfdm0uX3MoX3ZtLnZvdGUuZGVzY3JpcHRpb24pfX0pXSldKTpfdm0uX2UoKV0pLF9jKCdocicpLF9jKCdwJyx7c3RhdGljQ2xhc3M6XCJleHBsYW5hdGlvblwifSxbX3ZtLl92KFwiIFRoaXMgdm90ZSByZXF1aXJlcyBcIitfdm0uX3MoX3ZtLmdldFN1cHBvcnRUZXh0KStcIiUgYWNjZXB0YW5jZSBhbmQgXCIrX3ZtLl9zKF92bS5nZXRRdW9ydW1UZXh0KStcIiUgcXVvcnVtIHRvIGJlIHBhc3NlZCBcIildKSxfYygncCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS53aWxsU3VjY2VlZCksZXhwcmVzc2lvbjpcIiF3aWxsU3VjY2VlZFwifV0sc3RhdGljQ2xhc3M6XCJzaW1wbGUtZXJyb3JcIn0sW192bS5fdihcIiBUaGUgdHJhbnNhY3Rpb24gbWF5IGZhaWwsIHlvdSBtYXkgbm90IGhhdmUgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zIHRvIG1ha2UgdGhlIHRyYW5zYWN0aW9uIFwiKV0pXSksX2MoJ2J1dHRvbicse29uOntcImNsaWNrXCI6X3ZtLmNyZWF0ZVZvdGV9fSxbX3ZtLl92KFwiQ3JlYXRlIFRleHQgVm90ZVwiKV0pXSldKV0pOl92bS5fZSgpLF9jKCdkaXYnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5jYW5DcmVhdGVOZXdWb3RlKSxleHByZXNzaW9uOlwiY2FuQ3JlYXRlTmV3Vm90ZVwifV19LFtfYygnbW9kYWwnLHtzY29wZWRTbG90czpfdm0uX3UoW3trZXk6XCJhY3RpdmF0ZVwiLGZuOmZ1bmN0aW9uKHJlZil7XG52YXIgc2hvdyA9IHJlZi5zaG93O1xucmV0dXJuIFtfYygnZGl2Jyx7b246e1wiY2xpY2tcIjpzaG93fX0sW19jKCdidXR0b24nLHtzdGF0aWNDbGFzczpcInNpbXBsZWJ1dHRvblwifSxbX3ZtLl92KFwiTmV3IHRleHQgdm90ZVwiKV0pXSldfX0se2tleTpcInRpdGxlXCIsZm46ZnVuY3Rpb24oKXtyZXR1cm4gW192bS5fdihcIiBDcmVhdGUgbmV3IHZvdGUgXCIpXX0scHJveHk6dHJ1ZX0se2tleTpcInN1Ym1pdFwiLGZuOmZ1bmN0aW9uKCl7cmV0dXJuIFtfYygnc3Bhbicse3N0YXRpY0NsYXNzOlwic2ltcGxlYnV0dG9uXCIsb246e1wiY2xpY2tcIjpfdm0uc3VibWl0fX0sW192bS5fdihcIlN1Ym1pdCBcIiksX2MoJ3NwYW4nLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5sb2FkaW5nKSxleHByZXNzaW9uOlwibG9hZGluZ1wifV0sc3RhdGljQ2xhc3M6XCJsb2FkaW5nIGxpbmVcIn0pXSldfSxwcm94eTp0cnVlfV0pfSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwiY29udGVudFwifSxbX2MoJ2RpdicsW19jKCdzZWxlY3QnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLnNlbGVjdGVkQXBwKSxleHByZXNzaW9uOlwic2VsZWN0ZWRBcHBcIn1dLHN0YXRpY0NsYXNzOlwidHZpc2lvblwiLG9uOntcImNoYW5nZVwiOmZ1bmN0aW9uKCRldmVudCl7dmFyICQkc2VsZWN0ZWRWYWwgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLGZ1bmN0aW9uKG8pe3JldHVybiBvLnNlbGVjdGVkfSkubWFwKGZ1bmN0aW9uKG8pe3ZhciB2YWwgPSBcIl92YWx1ZVwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7cmV0dXJuIHZhbH0pOyBfdm0uc2VsZWN0ZWRBcHA9JGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdfX19LF92bS5fbCgoX3ZtLmFwcHMpLGZ1bmN0aW9uKGFwcCl7cmV0dXJuIF9jKCdvcHRpb24nLHtkb21Qcm9wczp7XCJ2YWx1ZVwiOmFwcH19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKGFwcC5uYW1lKStcIiBcIildKX0pLDApXSksX2MoJ2RpdicsW19jKCdsYWJlbCcse2F0dHJzOntcImZvclwiOlwibmV3dGV4dHZvdGVcIn19LFtfdm0uX3YoXCJWb3RlIGRlc2NyaXB0aW9uOlwiKV0pLF9jKCd0ZXh0YXJlYScse2RpcmVjdGl2ZXM6W3tuYW1lOlwibW9kZWxcIixyYXdOYW1lOlwidi1tb2RlbFwiLHZhbHVlOihfdm0uZGVzY3JpcHRpb24pLGV4cHJlc3Npb246XCJkZXNjcmlwdGlvblwifV0sYXR0cnM6e1wiaWRcIjpcIm5ld3RleHR2b3RlXCJ9LGRvbVByb3BzOntcInZhbHVlXCI6KF92bS5kZXNjcmlwdGlvbil9LG9uOntcImlucHV0XCI6ZnVuY3Rpb24oJGV2ZW50KXtpZigkZXZlbnQudGFyZ2V0LmNvbXBvc2luZyl7IHJldHVybjsgfV92bS5kZXNjcmlwdGlvbj0kZXZlbnQudGFyZ2V0LnZhbHVlfX19KV0pXSldKSxfYygnYnV0dG9uJyx7c3RhdGljQ2xhc3M6XCJzaW1wbGVidXR0b24gY3JlYXRldm90ZWJ1dHRvblwifSxbX2MoJ3JvdXRlci1saW5rJyx7YXR0cnM6e1widG9cIjpcIi9kYW8vY3JlYXRldm90ZVwifX0sW192bS5fdihcIiBDcmVhdGUgVm90ZSBcIildKV0sMSldLDEpLF9jKCdkaXYnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KCFfdm0uY2FuQ3JlYXRlTmV3Vm90ZSAmJiBfdm0uY2FuQ3JlYXRlTG9hZGVkKSxleHByZXNzaW9uOlwiIWNhbkNyZWF0ZU5ld1ZvdGUgJiYgY2FuQ3JlYXRlTG9hZGVkXCJ9XX0sW19jKCdwJyx7c3RhdGljQ2xhc3M6XCJpbmZvLW1lc3NhZ2UgZ2VudGxlLW1lc3NhZ2VcIn0sW192bS5fdihcIiBZb3UgaGF2ZSB0byBoYXZlIGF0IGxlYXN0IDI1MDB2ZVNXUlYodGhlIGVxdWl2YWxlbnQgb2YgMTAwMDAgU1dSViBsb2NrZWQgZm9yIGEgeWVhcikgdG8gYmUgYWJsZSB0byBjcmVhdGUgYSBuZXcgdm90ZSBcIildKSxfYygndm90aW5nLWVzY3Jvdycse3N0YXRpY0NsYXNzOlwidm90aW5nZXNjcm93XCIsYXR0cnM6e1wic2hvd3ZlbG9ja1wiOmZhbHNlfX0sW19jKCdwJyxbX2MoJ3JvdXRlci1saW5rJyx7YXR0cnM6e1widG9cIjpcIi9kYW8vbG9ja2VyXCJ9fSxbX3ZtLl92KFwiTWFuYWdlIGxvY2tpbmcgaW4gTG9ja2VyXCIpXSldLDEpXSldLDEpXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsInZhciByZW5kZXIgPSBmdW5jdGlvbiAoKSB7dmFyIF92bT10aGlzO3ZhciBfaD1fdm0uJGNyZWF0ZUVsZW1lbnQ7dmFyIF9jPV92bS5fc2VsZi5fY3x8X2g7cmV0dXJuIF9jKCdkaXYnLFtfdm0uX3QoXCJhY3RpdmF0ZVwiLG51bGwse1wic2hvd1wiOl92bS5zaG93fSksX2MoJ2Rpdicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLnNob3dNb2RhbCksZXhwcmVzc2lvbjpcInNob3dNb2RhbFwifV0sc3RhdGljQ2xhc3M6XCJtb2RhbFwiLGF0dHJzOntcImlkXCI6XCJtb2RhbFwifSxvbjp7XCJjbGlja1wiOmZ1bmN0aW9uKCRldmVudCl7aWYoJGV2ZW50LnRhcmdldCAhPT0gJGV2ZW50LmN1cnJlbnRUYXJnZXQpeyByZXR1cm4gbnVsbDsgfV92bS5zaG93TW9kYWwgPSBmYWxzZX19fSxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibW9kYWwtY29udGVudCB3aW5kb3cgd2hpdGVcIn0sW19jKCdmaWVsZHNldCcsW19jKCdkaXYnLHtzdGF0aWNDbGFzczpcImxlZ2VuZDIgaG92ZXJwb2ludGVyXCIsb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpe192bS5zaG93TW9kYWwgPSBmYWxzZX19fSxbX3ZtLl92KFwiIFtcIiksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImdyZWVudGV4dFwifSxbX3ZtLl92KFwiWFwiKV0pLF92bS5fdihcIl0gXCIpXSksX2MoJ2xlZ2VuZCcsW192bS5fdChcInRpdGxlXCIpXSwyKSxfYygnZGl2JyxbX3ZtLl90KFwiZGVmYXVsdFwiKV0sMiksX2MoJ2J1dHRvbicsW192bS5fdChcInN1Ym1pdFwiKV0sMildKV0pXSldLDIpfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG5cdDxkaXY+XG5cdFx0PHNsb3QgbmFtZT0nYWN0aXZhdGUnIDpzaG93ID0gJ3Nob3cnPjwvc2xvdD5cblx0XHQ8ZGl2IGlkPSdtb2RhbCcgY2xhc3M9J21vZGFsJyB2LXNob3c9J3Nob3dNb2RhbCcgQGNsaWNrLnNlbGY9J3Nob3dNb2RhbCA9IGZhbHNlJz5cblx0XHRcdDxkaXYgY2xhc3M9J21vZGFsLWNvbnRlbnQgd2luZG93IHdoaXRlJz5cblx0XHRcdFx0PGZpZWxkc2V0PlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9J2xlZ2VuZDIgaG92ZXJwb2ludGVyJyBAY2xpY2s9J3Nob3dNb2RhbCA9IGZhbHNlJz5cblx0XHRcdFx0XHRcdFs8c3BhbiBjbGFzcz0nZ3JlZW50ZXh0Jz5YPC9zcGFuPl1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8bGVnZW5kPlxuXHRcdFx0XHRcdFx0PHNsb3QgbmFtZT0ndGl0bGUnPjwvc2xvdD5cblx0XHRcdFx0XHQ8L2xlZ2VuZD5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0PHNsb3Q+PC9zbG90PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxidXR0b24+XG5cdFx0XHRcdFx0XHQ8c2xvdCBuYW1lPSdzdWJtaXQnPjwvc2xvdD5cblx0XHRcdFx0XHQ8L2J1dHRvbj5cblx0XHRcdFx0PC9maWVsZHNldD5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IHN0YXRlIH0gZnJvbSAnLi4vdm90ZVN0b3JlJ1xuXG5cdGV4cG9ydCBkZWZhdWx0IHtcblx0XHRkYXRhOiAoKSA9PiAoe1xuXG5cdFx0fSksXG5cblx0XHRjb21wdXRlZDoge1xuXHRcdFx0c2hvd01vZGFsOiB7XG4gICAgICAgIFx0XHRnZXQoKSB7XG4gICAgICAgIFx0XHRcdHJldHVybiBzdGF0ZS5zaG93TW9kYWxcbiAgICAgICAgXHRcdH0sXG4gICAgICAgIFx0XHRzZXQodmFsdWUpIHtcbiAgICAgICAgXHRcdFx0c3RhdGUuc2hvd01vZGFsID0gdmFsdWVcbiAgICAgICAgXHRcdH0sXG4gICAgICAgIFx0fSxcblx0XHR9LFxuXG5cdFx0bWV0aG9kczoge1xuXHRcdFx0c2hvdygpIHtcblx0XHRcdFx0dGhpcy5zaG93TW9kYWwgPSB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0aGlkZSgpIHtcblx0XHRcdFx0dGhpcy5zaG93TW9kYWwgPSBmYWxzZVxuXHRcdFx0fSxcblx0XHR9XG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXHQjbW9kYWwge1xuXHRcdHotaW5kZXg6IDM7XG5cdH1cblx0Lm1vZGFsLWNvbnRlbnQge1xuXHRcdHRleHQtYWxpZ246IGNlbnRlcjtcblx0XHRwYWRkaW5nOiAwO1xuXHRcdGJvcmRlcjogbm9uZTtcblx0XHR3aWR0aDogNDYwcHg7XG5cdH1cblx0Lm1vZGFsLWNvbnRlbnQgZmllbGRzZXQge1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0XHRmb250LXdlaWdodDogYm9sZGVyO1xuXHRcdGJvcmRlcjogNnB4IGRvdWJsZSB3aGl0ZTtcblx0XHRwYWRkaW5nLWJsb2NrLXN0YXJ0OiAxZW07XG5cdFx0cGFkZGluZy1ibG9jay1lbmQ6IDFlbTtcblx0fVxuXHQubW9kYWwtY29udGVudCBidXR0b24ge1xuXHRcdG1hcmdpbi10b3A6IDAuNmVtO1xuXHRcdHBhZGRpbmc6IDAgMmVtO1xuXHR9XG5cdC5sZWdlbmQyIHtcblx0ICBwb3NpdGlvbjogYWJzb2x1dGU7XG5cdCAgdG9wOiAwO1xuXHQgIGxlZnQ6IDJlbTtcblx0ICBiYWNrZ3JvdW5kOiAjYzBjMGMwO1xuXHQgIGxpbmUtaGVpZ2h0OjEuMmVtO1xuXHR9XG5cdC5ncmVlbnRleHQge1xuXHRcdGNvbG9yOiBncmVlbjtcblx0fVxuXHQubGVnZW5kMiAuZ3JlZW50ZXh0IHtcblx0XHRkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG5cdFx0dHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLC0wLjFlbSwxMGVtKTtcblx0fVxuXHQubGVnZW5kMiAuZ3JlZW50ZXh0OmhvdmVyIHtcblx0XHR0cmFuc2Zvcm06IG5vbmU7XG5cdH1cblx0LmhvdmVycG9pbnRlciB7XG5cdFx0Y3Vyc29yOiBwb2ludGVyO1xuXHR9XG48L3N0eWxlPiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTW9kYWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL01vZGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIiIsImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vTW9kYWwudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTAzODJlNzYzJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL01vZGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vTW9kYWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5pbXBvcnQgc3R5bGUwIGZyb20gXCIuL01vZGFsLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTAzODJlNzYzJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIwMzgyZTc2M1wiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsIjx0ZW1wbGF0ZT5cblx0PGRpdj5cblx0XHQ8ZGl2IGlkPSdtb2RhbCcgY2xhc3M9J21vZGFsIHJvb3Rtb2RhbCcgdi1pZj0nc2hvd1Jvb3RNb2RhbCcgQGNsaWNrLnNlbGY9J2hpZGVSb290TW9kYWwnPlxuXHRcdFx0PGRpdiBjbGFzcz0nbW9kYWwtY29udGVudCB3aW5kb3cgd2hpdGUnPlxuXHRcdFx0XHQ8ZmllbGRzZXQ+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz0nbGVnZW5kMiBob3ZlcnBvaW50ZXInIEBjbGljaz0naGlkZVJvb3RNb2RhbCc+XG5cdFx0XHRcdFx0XHRbPHNwYW4gY2xhc3M9J2dyZWVudGV4dCc+WDwvc3Bhbj5dXG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGxlZ2VuZD5DcmVhdGUgYSB0ZXh0IHZvdGUgb24ge3sgYXBwTmFtZSB9fTwvbGVnZW5kPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9J2NvbnRlbnQnPlxuXHRcdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdFx0PHNwYW4+IHt7IHZvdGVEZXNjcmlwdGlvbiB9fSA8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4+IHt7IGRlc2NyaXB0aW9uIH19IDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9J2NvbnRlbnQnIHYtaWY9J3ZvdGUnPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIHYtc2hvdz0ndm90ZS5jb250cmFjdE5hbWUnPlxuXHRcdFx0XHRcdFx0XHRcdFx0e3sgdm90ZS5jb250cmFjdE5hbWUgfX06IDxzcGFuIHYtaHRtbD0ndm90ZS5kZXNjcmlwdGlvbic+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiB2LXNob3c9JyF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLm1ldGFkYXRhJz5cblx0XHRcdFx0XHRcdFx0XHRcdHt7IHZvdGUubWV0YWRhdGEgfX1cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gdi1zaG93PSchdm90ZS5jb250cmFjdE5hbWUgJiYgdm90ZS5kZXNjcmlwdGlvbic+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiB2LWh0bWw9J3ZvdGUuZGVzY3JpcHRpb24nPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8aHI+XG5cdFx0XHRcdFx0XHQ8cCBjbGFzcz0nZXhwbGFuYXRpb24nPlxuXHRcdFx0XHRcdFx0XHRUaGlzIHZvdGUgcmVxdWlyZXMge3sgZ2V0U3VwcG9ydFRleHQgfX0lIGFjY2VwdGFuY2UgYW5kIHt7IGdldFF1b3J1bVRleHQgfX0lIHF1b3J1bSB0byBiZSBwYXNzZWRcblx0XHRcdFx0XHRcdDwvcD5cblx0XHRcdFx0XHRcdDxwIGNsYXNzPSdzaW1wbGUtZXJyb3InIHYtc2hvdz0nIXdpbGxTdWNjZWVkJz5cblx0XHRcdFx0XHRcdFx0VGhlIHRyYW5zYWN0aW9uIG1heSBmYWlsLCB5b3UgbWF5IG5vdCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9ucyB0byBtYWtlIHRoZSB0cmFuc2FjdGlvblxuXHRcdFx0XHRcdFx0PC9wPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdDxidXR0b24gQGNsaWNrPSdjcmVhdGVWb3RlJz5DcmVhdGUgVGV4dCBWb3RlPC9idXR0b24+XG5cdFx0XHRcdDwvZmllbGRzZXQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHQ8L2Rpdj5cblxuXHRcdDxkaXYgdi1zaG93PSdjYW5DcmVhdGVOZXdWb3RlJz5cblx0XHRcdDxtb2RhbD5cblx0XHRcdFx0PHRlbXBsYXRlIHYtc2xvdDphY3RpdmF0ZT0neyBzaG93IH0nPlxuXHRcdFx0XHRcdDxkaXYgQGNsaWNrPSdzaG93Jz5cblx0XHRcdFx0XHRcdDxidXR0b24gY2xhc3M9J3NpbXBsZWJ1dHRvbic+TmV3IHRleHQgdm90ZTwvYnV0dG9uPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L3RlbXBsYXRlPlxuXHRcdFx0XHQ8dGVtcGxhdGUgdi1zbG90OnRpdGxlPlxuXHRcdFx0XHRcdENyZWF0ZSBuZXcgdm90ZVxuXHRcdFx0XHQ8L3RlbXBsYXRlPlxuXHRcdFx0XHQ8ZGl2IGNsYXNzPSdjb250ZW50Jz5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0PHNlbGVjdCBjbGFzcz0ndHZpc2lvbicgdi1tb2RlbD0nc2VsZWN0ZWRBcHAnPlxuXHRcdFx0XHRcdFx0XHQ8b3B0aW9uIHYtZm9yPSdhcHAgaW4gYXBwcycgOnZhbHVlPSdhcHAnPlxuXHRcdFx0XHRcdFx0XHRcdHt7IGFwcC5uYW1lIH19XG5cdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0PC9zZWxlY3Q+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0PGRpdj5cblx0XHRcdFx0XHRcdDxsYWJlbCBmb3I9J25ld3RleHR2b3RlJz5Wb3RlIGRlc2NyaXB0aW9uOjwvbGFiZWw+XG5cdFx0XHRcdFx0XHQ8dGV4dGFyZWEgaWQ9J25ld3RleHR2b3RlJyB2LW1vZGVsPSdkZXNjcmlwdGlvbic+PC90ZXh0YXJlYT5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDx0ZW1wbGF0ZSB2LXNsb3Q6c3VibWl0PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPVwic2ltcGxlYnV0dG9uXCIgQGNsaWNrPSdzdWJtaXQnPlN1Ym1pdCA8c3BhbiBjbGFzcz0nbG9hZGluZyBsaW5lJyB2LXNob3c9J2xvYWRpbmcnPjwvc3Bhbj48L3NwYW4+XG5cdFx0XHRcdDwvdGVtcGxhdGU+XG5cdFx0XHQ8L21vZGFsPlxuXHRcdFx0PCEtLSA8cCBjbGFzcz0naW5mby1tZXNzYWdlIGdlbnRsZS1tZXNzYWdlIGNyZWF0ZXZvdGUnPiAtLT5cblx0XHRcdDxidXR0b24gY2xhc3M9J3NpbXBsZWJ1dHRvbiBjcmVhdGV2b3RlYnV0dG9uJz5cblx0XHRcdFx0PHJvdXRlci1saW5rIHRvPScvZGFvL2NyZWF0ZXZvdGUnPiBDcmVhdGUgVm90ZSA8L3JvdXRlci1saW5rPlxuXHRcdFx0PC9idXR0b24+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiB2LXNob3c9JyFjYW5DcmVhdGVOZXdWb3RlICYmIGNhbkNyZWF0ZUxvYWRlZCc+XG5cdFx0XHQ8cCBjbGFzcz0naW5mby1tZXNzYWdlIGdlbnRsZS1tZXNzYWdlJz5cblx0XHRcdFx0WW91IGhhdmUgdG8gaGF2ZSBhdCBsZWFzdCAyNTAwdmVTV1JWKHRoZSBlcXVpdmFsZW50IG9mIDEwMDAwIFNXUlYgbG9ja2VkIGZvciBhIHllYXIpIHRvIGJlIGFibGUgdG8gY3JlYXRlIGEgbmV3IHZvdGVcblx0XHRcdDwvcD5cblx0XHRcdDx2b3RpbmctZXNjcm93IDpzaG93dmVsb2NrID0gJ2ZhbHNlJyBjbGFzcz0ndm90aW5nZXNjcm93Jz5cblx0XHRcdFx0PHA+XG5cdFx0XHRcdFx0PHJvdXRlci1saW5rIHRvPScvZGFvL2xvY2tlcic+TWFuYWdlIGxvY2tpbmcgaW4gTG9ja2VyPC9yb3V0ZXItbGluaz5cblx0XHRcdFx0PC9wPlx0XG5cdFx0XHQ8L3ZvdGluZy1lc2Nyb3c+XG5cdFx0PC9kaXY+XG5cdFx0PCEtLSA8L3A+IC0tPlxuXHQ8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCB7IGNvbnRyYWN0IH0gZnJvbSAnLi4vLi4vLi4vY29udHJhY3QnXG5cblx0aW1wb3J0IHsgVm90aW5nIH0gZnJvbSAnQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZydcblxuXHRpbXBvcnQgTW9kYWwgZnJvbSAnLi4vY29tbW9uL01vZGFsJ1xuXG5cdGltcG9ydCB7IHN0YXRlLCBPV05FUlNISVBfQVBQX0FERFJFU1MsIFBBUkFNRVRFUl9BUFBfQUREUkVTUywgaGVscGVycyBhcyB2b3RlSGVscGVycyB9IGZyb20gJy4uL3ZvdGVTdG9yZSdcblxuXHRpbXBvcnQgUm9vdE1vZGFsTWl4aW4gZnJvbSAnLi4vY29tbW9uL1Jvb3RNb2RhbE1peGluJ1xuXG5cdGltcG9ydCBWb3RpbmdFc2Nyb3cgZnJvbSAnLi4vLi4vbWludGVyL1ZvdGluZ0VzY3JvdydcblxuXHRleHBvcnQgZGVmYXVsdCB7XG5cblx0XHRjb21wb25lbnRzOiB7XG5cdFx0XHRNb2RhbCxcblx0XHRcdFZvdGluZ0VzY3Jvdyxcblx0XHR9LFxuXG5cdFx0bWl4aW5zOiBbUm9vdE1vZGFsTWl4aW5dLFxuXG5cdFx0ZGF0YTogKCkgPT4gKHtcblx0XHRcdGNhbkNyZWF0ZUxvYWRlZDogZmFsc2UsXG5cdFx0XHRkZXNjcmlwdGlvbjogJycsXG5cdFx0XHRsb2FkaW5nOiBmYWxzZSxcblxuXHRcdFx0c2VsZWN0ZWRBcHA6IG51bGwsXG5cdFx0XHRhcHBzOiBbXSxcblxuXHRcdFx0Y2FuQ3JlYXRlTmV3Vm90ZTogZmFsc2UsXG5cdFx0fSksXG5cblx0XHRhc3luYyBjcmVhdGVkKCkge1xuXHRcdFx0dGhpcy4kd2F0Y2goKCkgPT4gc3RhdGUuaW5pdGlhbGl6ZWQsIHZhbCA9PiB7XG5cdFx0XHRcdGlmKHZhbCkgdGhpcy5jcmVhdGVkKClcblx0XHRcdH0sIHtcblx0XHRcdFx0aW1tZWRpYXRlOiB0cnVlLFxuXHRcdFx0fSlcblxuXHRcdFx0dGhpcy4kd2F0Y2goKCkgPT4gc3RhdGUubGFzdENyZWF0ZWQgIT09IG51bGwsIHZhbCA9PiB7XG5cdFx0XHRcdGlmKHZhbCkgdGhpcy5jYW5DcmVhdGUoKVxuXHRcdFx0fSwge1xuXHRcdFx0XHRpbW1lZGlhdGU6IHRydWUsXG5cdFx0XHR9KVxuXG5cdFx0XHR0aGlzLiR3YXRjaCgoKSA9PiBzdGF0ZS5zaG93TW9kYWwsIHZhbCA9PiB7XG5cdFx0XHRcdGlmKCF2YWwpIHRoaXMuZGVzY3JpcHRpb24gPSAnJ1xuXHRcdFx0fSlcblx0XHR9LFxuXG5cdFx0Y29tcHV0ZWQ6IHtcblx0XHRcdGluaXRpYWxpemVkKCkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGUuaW5pdGlhbGl6ZWRcblx0XHRcdH0sXG5cdFx0XHR2b3RpbmdBcHBzKCkge1xuXHRcdFx0XHRyZXR1cm4gc3RhdGUudm90aW5nQXBwc1xuXHRcdFx0fSxcblx0XHR9LFxuXG5cdFx0bWV0aG9kczoge1xuXHRcdFx0YXN5bmMgY3JlYXRlZCgpIHtcblx0XHRcdFx0dGhpcy5hcHAgPSB0aGlzLmFwcHNbMF1cblx0XHRcdH0sXG5cdFx0XHRhc3luYyBjYW5DcmVhdGUoKSB7XG5cdFx0XHRcdGxldCBjYW5DcmVhdGVWb3RlT24gPSBhd2FpdCBQcm9taXNlLmFsbChbdm90ZUhlbHBlcnMuY2FuQ3JlYXRlTmV3Vm90ZU9uKE9XTkVSU0hJUF9BUFBfQUREUkVTUyksIHZvdGVIZWxwZXJzLmNhbkNyZWF0ZU5ld1ZvdGVPbihQQVJBTUVURVJfQVBQX0FERFJFU1MpXSlcblx0XHRcdFx0aWYoY2FuQ3JlYXRlVm90ZU9uWzBdKVxuXHRcdFx0XHRcdHRoaXMuYXBwcy5wdXNoKHtcblx0XHRcdFx0XHRcdGFkZHJlc3M6IE9XTkVSU0hJUF9BUFBfQUREUkVTUyxcblx0XHRcdFx0XHRcdG5hbWU6ICdPd25lcnNoaXAnXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0aWYoY2FuQ3JlYXRlVm90ZU9uWzFdKVxuXHRcdFx0XHRcdHRoaXMuYXBwcy5wdXNoKHtcblx0XHRcdFx0XHRcdGFkZHJlc3M6IFBBUkFNRVRFUl9BUFBfQUREUkVTUyxcblx0XHRcdFx0XHRcdG5hbWU6ICdQYXJhbWV0ZXInXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0dGhpcy5zZWxlY3RlZEFwcCA9IHRoaXMuYXBwc1swXVxuXHRcdFx0XHR0aGlzLmNhbkNyZWF0ZU5ld1ZvdGUgPSBjYW5DcmVhdGVWb3RlT24uZmluZCh2ID0+IHYpXG5cdFx0XHRcdHRoaXMuY2FuQ3JlYXRlTG9hZGVkID0gdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGFzeW5jIHN1Ym1pdCgpIHtcblx0XHRcdFx0dGhpcy5sb2FkaW5nID0gdHJ1ZVxuXG5cdFx0XHRcdGxldCBpcGZzaGFzaCA9IGF3YWl0IGZldGNoKCdodHRwczovL2FwaS5waW5hdGEuY2xvdWQvcGlubmluZy9waW5KU09OVG9JUEZTJywge1xuXHRcdFx0XHRcdG1ldGhvZDogJ1BPU1QnLFxuXHRcdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHRcdCdDb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG5cdFx0XHRcdFx0XHQncGluYXRhX2FwaV9rZXknOiAnOTZmMjZlNzViYjIwNTU3YmE0OTgnLFxuXHRcdFx0XHRcdFx0J3BpbmF0YV9zZWNyZXRfYXBpX2tleSc6ICc3MmU5ZjNmNmI5YzRhOWYzYmM0ZDkxZTFhMTAxYTM4OTMzODQwNTRmNjVjZjZkNjA4OWU2MmMyMmZlYWRlNzUxJ1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Ym9keTogSlNPTi5zdHJpbmdpZnkoe1xuXHRcdFx0XHRcdFx0dGV4dDogdGhpcy5kZXNjcmlwdGlvbixcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9KVxuXG5cdFx0XHRcdGlwZnNoYXNoID0gYXdhaXQgaXBmc2hhc2guanNvbigpXG5cdFx0XHRcdGlwZnNoYXNoID0gJ2lwZnM6JyArIGlwZnNoYXNoLklwZnNIYXNoXG5cblx0XHRcdFx0Y29uc29sZS5sb2coaXBmc2hhc2gsIFwiSVBGUyBIQVNIXCIpXG5cblx0XHRcdFx0bGV0IGludGVudFxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGludGVudCA9IGF3YWl0IHN0YXRlLm9yZy5hcHBJbnRlbnQodGhpcy5zZWxlY3RlZEFwcC5hZGRyZXNzLnRvTG93ZXJDYXNlKCksICduZXdWb3RlKGJ5dGVzLHN0cmluZyxib29sLGJvb2wpJywgWycweDAwMDAwMDAxJywgaXBmc2hhc2gsIGZhbHNlLCBmYWxzZV0pXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2goZXJyKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnIpXG5cdFx0XHRcdH1cblx0XHRcdFx0bGV0IHBhdGhzID0gYXdhaXQgaW50ZW50LnBhdGhzKGNvbnRyYWN0LmRlZmF1bHRfYWNjb3VudClcblxuXHRcdFx0XHRzdGF0ZS50cmFuc2FjdGlvbkludGVudCA9IHBhdGhzXG5cblx0XHRcdFx0dGhpcy5sb2FkaW5nID0gZmFsc2Vcblx0XHRcdFx0c3RhdGUuc2hvd01vZGFsID0gZmFsc2VcblxuXHRcdFx0XHR0aGlzLnNob3dSb290TW9kYWwgPSB0cnVlXG5cblxuXHRcdFx0XHRjb25zb2xlLmxvZyhwYXRocywgXCJUSEVQQVRIXCIpXG5cdFx0XHR9LFxuXHRcdH0sXG5cdH1cbjwvc2NyaXB0PlxuXG48c3R5bGUgc2NvcGVkPlxuXHQuY29udGVudCA+IGRpdiB7XG5cdFx0ZGlzcGxheTogZmxleDtcblx0XHRmbGV4LXdyYXA6IHdyYXA7XG5cdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdGNvbG9yOiB3aGl0ZTtcblx0fVxuXHQuY29udGVudCA+IGRpdjpudGgtb2YtdHlwZSgxKSB7XG5cdFx0bWFyZ2luLXRvcDogMDtcblx0fVxuXHQuY29udGVudCBpbnB1dCB7XG5cdFx0XG5cdH1cblx0dGV4dGFyZWEge1xuXHRcdG1hcmdpbi10b3A6IDFlbTtcblx0XHRmb250LXNpemU6IDFlbTtcblx0XHRoZWlnaHQ6IDRlbTtcblx0fVxuXHRzZWxlY3QudHZpc2lvbiB7XG5cdFx0Ym94LXNoYWRvdzogbm9uZVxuXHR9XG5cdC5jcmVhdGV2b3RlIHtcblx0XHR3aWR0aDogMTAwcHg7XG5cdFx0bWFyZ2luLXRvcDogMWVtO1xuXHRcdHBhZGRpbmctdG9wOiAwLjRlbTtcblx0XHRwYWRkaW5nLWJvdHRvbTogMC40ZW07XG5cdH1cblx0LmNyZWF0ZXZvdGUgYSB7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHR9XG5cdC5jcmVhdGV2b3RlYnV0dG9uIHtcblx0XHRtYXJnaW4tdG9wOiAxZW07XG5cdH1cblx0LmNyZWF0ZXZvdGVidXR0b24gYSwgLmNyZWF0ZXZvdGVidXR0b24gYTp2aXNpdGVkIHtcblx0XHRjb2xvcjogYmxhY2s7XG5cdH1cblx0LnZvdGluZ2VzY3JvdyB7XG5cdFx0bWFyZ2luLXRvcDogMC40ZW07XG5cdH1cbjwvc3R5bGU+IiwiaW1wb3J0IG1vZCBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9OZXdUZXh0Vm90ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vTmV3VGV4dFZvdGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9OZXdUZXh0Vm90ZS52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MzkxZDM3MzImc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vTmV3VGV4dFZvdGUudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9OZXdUZXh0Vm90ZS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vTmV3VGV4dFZvdGUudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MzkxZDM3MzImc2NvcGVkPXRydWUmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjM5MWQzNzMyXCIsXG4gIG51bGxcbiAgXG4pXG5cbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2Rpdicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLnZvdGVzTGVuZ3RoID4gMCksZXhwcmVzc2lvbjpcInZvdGVzTGVuZ3RoID4gMFwifV0sc3RhdGljQ2xhc3M6XCJwYWdpbmF0aW9uXCJ9LFtfYygnZGl2JyxbX2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwic2ltcGxlYnV0dG9uXCIsYXR0cnM6e1wiZGlzYWJsZWRcIjpfdm0ucGFnZSA9PSAwfSxvbjp7XCJjbGlja1wiOl92bS5wcmV2fX0sW192bS5fdihcIlByZXZcIildKSxfYygnc3BhbicsW192bS5fdihcIiBcIitfdm0uX3MoX3ZtLnBhZ2UpK1wiIChvZiBcIitfdm0uX3MoX3ZtLnBhZ2VzKStcIikgXCIpXSksX2MoJ2J1dHRvbicse3N0YXRpY0NsYXNzOlwic2ltcGxlYnV0dG9uXCIsYXR0cnM6e1wiZGlzYWJsZWRcIjpfdm0ucGFnZSA9PSB0aGlzLnBhZ2VzfSxvbjp7XCJjbGlja1wiOl92bS5uZXh0fX0sW192bS5fdihcIk5leHRcIildKV0pLF9jKCdkaXYnLHtzdGF0aWNDbGFzczpcInBlcnBhZ2VcIn0sW192bS5fdihcIiBQZXIgcGFnZTogXCIpLF9jKCdzZWxlY3QnLHtkaXJlY3RpdmVzOlt7bmFtZTpcIm1vZGVsXCIscmF3TmFtZTpcInYtbW9kZWxcIix2YWx1ZTooX3ZtLnBlclBhZ2UpLGV4cHJlc3Npb246XCJwZXJQYWdlXCJ9XSxzdGF0aWNDbGFzczpcInR2aXNpb25cIixvbjp7XCJjaGFuZ2VcIjpmdW5jdGlvbigkZXZlbnQpe3ZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKCRldmVudC50YXJnZXQub3B0aW9ucyxmdW5jdGlvbihvKXtyZXR1cm4gby5zZWxlY3RlZH0pLm1hcChmdW5jdGlvbihvKXt2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlO3JldHVybiB2YWx9KTsgX3ZtLnBlclBhZ2U9JGV2ZW50LnRhcmdldC5tdWx0aXBsZSA/ICQkc2VsZWN0ZWRWYWwgOiAkJHNlbGVjdGVkVmFsWzBdfX19LF92bS5fbCgoX3ZtLnBlclBhZ2VPcHRpb25zKSxmdW5jdGlvbihwZXJQYWdlTnVtKXtyZXR1cm4gX2MoJ29wdGlvbicsW192bS5fdihcIiBcIitfdm0uX3MocGVyUGFnZU51bSkrXCIgXCIpXSl9KSwwKV0pXSl9XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSIsIjx0ZW1wbGF0ZT5cblx0PGRpdiB2LXNob3c9J3ZvdGVzTGVuZ3RoID4gMCcgY2xhc3M9J3BhZ2luYXRpb24nPlxuXHRcdDxkaXY+XG5cdFx0XHQ8YnV0dG9uIGNsYXNzPSdzaW1wbGVidXR0b24nIEBjbGljaz0ncHJldicgOmRpc2FibGVkPSdwYWdlID09IDAnPlByZXY8L2J1dHRvbj5cblx0XHRcdDxzcGFuPiB7eyBwYWdlIH19IChvZiB7eyBwYWdlcyB9fSkgPC9zcGFuPlxuXHRcdFx0PGJ1dHRvbiBjbGFzcz0nc2ltcGxlYnV0dG9uJyBAY2xpY2s9J25leHQnIDpkaXNhYmxlZD0ncGFnZSA9PSB0aGlzLnBhZ2VzJz5OZXh0PC9idXR0b24+XG5cdFx0PC9kaXY+XG5cdFx0PGRpdiBjbGFzcz0ncGVycGFnZSc+XG5cdFx0XHRQZXIgcGFnZTpcblx0XHRcdDxzZWxlY3QgY2xhc3M9J3R2aXNpb24nIHYtbW9kZWw9J3BlclBhZ2UnPlxuXHRcdFx0XHQ8b3B0aW9uIHYtZm9yPSdwZXJQYWdlTnVtIGluIHBlclBhZ2VPcHRpb25zJz5cblx0XHRcdFx0XHR7eyBwZXJQYWdlTnVtIH19XG5cdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0PC9zZWxlY3Q+XG5cdFx0PC9kaXY+XG5cblx0PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuXHRpbXBvcnQgeyBnZXRBbGxWb3Rlcywgc3RhdGUsIGdldHRlcnMsIGNoYW5nZUZpbHRlciB9IGZyb20gJy4uL3ZvdGVTdG9yZSdcblx0XG5cdGV4cG9ydCBkZWZhdWx0IHtcblx0XHRkYXRhOiAoKSA9PiAoe1xuXHRcdFx0cGVyUGFnZU9wdGlvbnM6IFsxMCwgMjAsIDMwLCA1MCwgMTAwXSxcblx0XHR9KSxcblxuXHRcdGNvbXB1dGVkOiB7XG5cdFx0XHQuLi5nZXR0ZXJzLFxuXHRcdFx0cGVyUGFnZToge1xuXHRcdFx0XHRnZXQoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlLnBhZ2luYXRpb24ucGVyUGFnZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQodmFsKSB7XG5cdFx0XHRcdFx0c3RhdGUucGFnaW5hdGlvbi5wZXJQYWdlID0gdmFsXG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0dm90ZXNMZW5ndGgoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmN1c3RvbUZpbHRlclZvdGVzLmxlbmd0aFxuXHRcdFx0fSxcblx0XHRcdHBhZ2UoKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZS5wYWdpbmF0aW9uLnBhZ2Vcblx0XHRcdH0sXG5cdFx0XHRwYWdlcygpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY3VzdG9tRmlsdGVyVm90ZXMubGVuZ3RoICYmIE1hdGguY2VpbCh0aGlzLmN1c3RvbUZpbHRlclZvdGVzLmxlbmd0aCAvIHN0YXRlLnBhZ2luYXRpb24ucGVyUGFnZSkgLSAxXG5cdFx0XHR9LFxuXHRcdH0sXG5cblx0XHRtZXRob2RzOiB7XG5cdFx0XHRwcmV2KCkge1xuXHRcdFx0XHRpZih0aGlzLnBhZ2UgPT0gMCkgcmV0dXJuO1xuXHRcdFx0XHRzdGF0ZS5wYWdpbmF0aW9uLnBhZ2UgLT0gMVxuXHRcdFx0fSxcblx0XHRcdG5leHQoKSB7XG5cdFx0XHRcdGlmKHRoaXMucGFnZSA8IHRoaXMucGFnZXMpXG5cdFx0XHRcdHN0YXRlLnBhZ2luYXRpb24ucGFnZSArPSAxXG5cdFx0XHR9LFxuXHRcdH0sXG5cblx0fVxuPC9zY3JpcHQ+XG5cbjxzdHlsZSBzY29wZWQ+XG5cdC5wYWdpbmF0aW9uIHtcblx0XHRtYXJnaW4tdG9wOiAwLjRlbTtcblx0XHRkaXNwbGF5OiBmbGV4O1xuXHR9XG5cdHNlbGVjdC50dmlzaW9uIHtcblx0XHRib3gtc2hhZG93OiBub25lO1xuXHR9XG5cdC5wZXJwYWdlIHtcblx0XHRtYXJnaW4tbGVmdDogM2VtO1xuXHR9XG48L3N0eWxlPiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUGFnaW5hdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUGFnaW5hdGlvbi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1BhZ2luYXRpb24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBlMDdkNTQ2JnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1BhZ2luYXRpb24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9QYWdpbmF0aW9uLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9QYWdpbmF0aW9uLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTBlMDdkNTQ2JnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCIwZTA3ZDU0NlwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyIsIjx0ZW1wbGF0ZT5cblx0PGRpdiBjbGFzcz0nd2luZG93IHdoaXRlJz5cblx0XHQ8ZmllbGRzZXQ+XG5cdFx0XHQ8bGVnZW5kPlZvdGVzPC9sZWdlbmQ+XG5cdFx0XHQ8bmV3LXRleHQtdm90ZT48L25ldy10ZXh0LXZvdGU+XG5cdFx0XHQ8ZGl2IGNsYXNzPSdmaWx0ZXInPlxuXHRcdFx0XHQ8ZmllbGRzZXQ+XG5cdFx0XHRcdFx0PGxlZ2VuZD5GaWx0ZXI8L2xlZ2VuZD5cblx0XHRcdFx0XHQ8ZGl2PlxuXHRcdFx0XHRcdFx0PHNwYW4+U3RhdHVzOjwvc3Bhbj5cblx0XHRcdFx0XHRcdDxzZWxlY3QgY2xhc3M9J3R2aXNpb24nIHYtbW9kZWw9J2ZpbHRlclN0YXR1cyc+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdi1mb3I9J3N0YXR1cyBpbiBhbGxTdGF0dXMnIDp2YWx1ZT0nc3RhdHVzLnZhbCc+XG5cdFx0XHRcdFx0XHRcdFx0e3sgc3RhdHVzLnRleHQgfX1cblx0XHRcdFx0XHRcdFx0PC9vcHRpb24+XG5cdFx0XHRcdFx0XHQ8L3NlbGVjdD5cblx0XHRcdFx0XHRcdDxzcGFuPk91dGNvbWU6PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNlbGVjdCBjbGFzcz0ndHZpc2lvbicgdi1tb2RlbD0nZmlsdGVyT3V0Y29tZSc+XG5cdFx0XHRcdFx0XHRcdDxvcHRpb24gdi1mb3I9J291dGNvbWUgaW4gYWxsT3V0Y29tZScgOnZhbHVlPSdvdXRjb21lLnZhbCc+XG5cdFx0XHRcdFx0XHRcdFx0e3sgb3V0Y29tZS50ZXh0IH19XG5cdFx0XHRcdFx0XHRcdDwvb3B0aW9uPlxuXHRcdFx0XHRcdFx0PC9zZWxlY3Q+XG5cdFx0XHRcdFx0XHQ8c3Bhbj5BcHA6PC9zcGFuPlxuXHRcdFx0XHRcdFx0PHNlbGVjdCBjbGFzcz0ndHZpc2lvbicgdi1tb2RlbD0nZmlsdGVyQXBwJz5cblx0XHRcdFx0XHRcdFx0PG9wdGlvbiB2LWZvcj0nYXBwIGluIGFsbEFwcCcgOnZhbHVlPSdhcHAudmFsJz5cblx0XHRcdFx0XHRcdFx0XHR7eyBhcHAudGV4dCB9fVxuXHRcdFx0XHRcdFx0XHQ8L29wdGlvbj5cblx0XHRcdFx0XHRcdDwvc2VsZWN0PlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2ZpZWxkc2V0PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPSd2b3Rlcy13cmFwcGVyIGhlYWRlcicgdi1zaG93PSchY3VzdG9tRmlsdGVyJz5cblx0XHRcdFx0PGZpZWxkc2V0PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPSdsb2FkaW5nIG1hdHJpeCcgdi1zaG93PSchbG9hZGVkVm90ZXMnPjwvc3Bhbj5cblx0XHRcdFx0XHQ8bGVnZW5kPk9wZW4gdm90ZXMgKHt7IG9wZW5Wb3Rlcy5sZW5ndGggfX0pPC9sZWdlbmQ+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz0ndm90ZXMgb3Blbic+XG5cdFx0XHRcdFx0XHQ8dm90ZSB2LWZvcj0ndm90ZSBpbiBvcGVuVm90ZXMnIDprZXk9J3ZvdGUuaWQnIDp2b3RlPSd2b3RlJyBjbGFzcz0ndm90ZSc+PC92b3RlPlxuXHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHQ8L2ZpZWxkc2V0PlxuXHRcdFx0PC9kaXY+XG5cdFx0XHQ8ZGl2IGNsYXNzPSd2b3Rlcy13cmFwcGVyIGhlYWRlcicgdi1zaG93PSchY3VzdG9tRmlsdGVyJz5cblx0XHRcdFx0PGZpZWxkc2V0PlxuXHRcdFx0XHRcdDxzcGFuIGNsYXNzPSdsb2FkaW5nIG1hdHJpeCcgdi1zaG93PSchbG9hZGVkVm90ZXMnPjwvc3Bhbj5cblx0XHRcdFx0XHQ8bGVnZW5kPkNsb3NlZCB2b3RlcyAoe3sgY2xvc2VkVm90ZXMubGVuZ3RoIH19KTwvbGVnZW5kPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9J3ZvdGVzIGNsb3NlZCc+XG5cdFx0XHRcdFx0XHQ8dm90ZSB2LWZvcj0ndm90ZSBpbiBjbG9zZWRWb3RlcycgOmtleT0ndm90ZS5pZCcgOnZvdGU9J3ZvdGUnIGNsYXNzPSd2b3RlJz48L3ZvdGU+XG5cdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdDwvZmllbGRzZXQ+XG5cdFx0XHQ8L2Rpdj5cblx0XHRcdDxkaXYgY2xhc3M9J3ZvdGVzLXdyYXBwZXIgaGVhZGVyJyB2LWlmPSdjdXN0b21GaWx0ZXInPlxuXHRcdFx0XHQ8ZmllbGRzZXQ+XG5cdFx0XHRcdFx0PHNwYW4gY2xhc3M9J2xvYWRpbmcgbWF0cml4JyB2LXNob3c9JyFsb2FkZWRWb3Rlcyc+PC9zcGFuPlxuXHRcdFx0XHRcdDxsZWdlbmQ+e3sgY3VzdG9tRmlsdGVyVGV4dCB9fSAoe3sgY3VzdG9tRmlsdGVyVm90ZXMubGVuZ3RoIH19KTwvbGVnZW5kPlxuXHRcdFx0XHRcdDxkaXYgY2xhc3M9J3ZvdGVzIGNsb3NlZCc+XG5cdFx0XHRcdFx0XHQ8dm90ZSB2LWZvcj0ndm90ZSBpbiBmaWx0ZXJQYWdpbmF0aW9uJyA6a2V5PSd2b3RlLmlkJyA6dm90ZT0ndm90ZScgY2xhc3M9J3ZvdGUnPjwvdm90ZT5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0PC9maWVsZHNldD5cblx0XHRcdDwvZGl2PlxuXHRcdFx0PHBhZ2luYXRpb24+PC9wYWdpbmF0aW9uPlxuXHRcdDwvZmllbGRzZXQ+XG5cdDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblxuXHRpbXBvcnQgeyBjb250cmFjdCB9IGZyb20gJy4uLy4uLy4uL2NvbnRyYWN0J1xuXG5cdGltcG9ydCBncWwgZnJvbSAnZ3JhcGhxbC10YWcnXG5cdGltcG9ydCB7IEdyYXBoUUxXcmFwcGVyIH0gZnJvbSAnQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoJ1xuXG5cdGltcG9ydCB7IGNvbm5lY3QsIGRlc2NyaWJlU2NyaXB0IH0gZnJvbSAnQGFyYWdvbi9jb25uZWN0J1xuXHRpbXBvcnQgeyBWb3RpbmcgfSBmcm9tICdAYXJhZ29uL2Nvbm5lY3QtdGhlZ3JhcGgtdm90aW5nJ1xuXG5cdGltcG9ydCB7IGdldEFsbFZvdGVzLCBzdGF0ZSwgZ2V0dGVycywgY2hhbmdlRmlsdGVyIH0gZnJvbSAnLi4vdm90ZVN0b3JlJ1xuXG5cdGltcG9ydCBWb3RlIGZyb20gJy4vVm90ZSdcblx0aW1wb3J0IE5ld1RleHRWb3RlIGZyb20gJy4vTmV3VGV4dFZvdGUnXG5cblx0aW1wb3J0IFJvb3RNb2RhbCBmcm9tICcuLi9jb21tb24vUm9vdE1vZGFsJ1xuXG5cdGltcG9ydCBQYWdpbmF0aW9uIGZyb20gJy4vUGFnaW5hdGlvbidcblxuXHRleHBvcnQgZGVmYXVsdCB7XG5cdFx0Y29tcG9uZW50czoge1xuXHRcdFx0Vm90ZSxcblx0XHRcdE5ld1RleHRWb3RlLFxuXHRcdFx0Um9vdE1vZGFsLFxuXHRcdFx0UGFnaW5hdGlvbixcblx0XHR9LFxuXG5cdFx0YXN5bmMgY3JlYXRlZCgpIHtcblx0XHRcdHRoaXMuJHdhdGNoKCgpID0+IHN0YXRlLmluaXRpYWxpemVkLCB2YWwgPT4ge1xuXHRcdFx0XHRpZih2YWwpIHRoaXMubW91bnRlZCgpXG5cdFx0XHR9LCB7XG5cdFx0XHRcdGltbWVkaWF0ZTogdHJ1ZSxcblx0XHRcdH0pXG5cdFx0fSxcblxuXHRcdHdhdGNoOiB7XG5cdFx0XHRjaGFuZ2VkRmlsdGVyKCkge1xuXHRcdFx0XHRzdGF0ZS5wYWdpbmF0aW9uLnBhZ2UgPSAwXG5cdFx0XHRcdHRoaXMuY2hhbmdlRmlsdGVyKClcblx0XHRcdH0sXG5cdFx0fSxcblxuXHRcdGRhdGE6ICgpID0+ICh7XG5cdFx0XHRsb2FkZWRWb3RlczogZmFsc2UsXG5cblx0XHRcdGFsbFN0YXR1czogW1xuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFsOiAzLFxuXHRcdFx0XHRcdHRleHQ6ICdBbGwnLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFsOiAxLFxuXHRcdFx0XHRcdHRleHQ6ICdPcGVuJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogMixcblx0XHRcdFx0XHR0ZXh0OiAnQ2xvc2VkJyxcblx0XHRcdFx0fSxcblx0XHRcdF0sXG5cblx0XHRcdGFsbE91dGNvbWU6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogNSxcblx0XHRcdFx0XHR0ZXh0OiAnQWxsJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogMSxcblx0XHRcdFx0XHR0ZXh0OiAnUGFzc2VkJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogMixcblx0XHRcdFx0XHR0ZXh0OiAnUmVqZWN0ZWQnLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dmFsOiAzLFxuXHRcdFx0XHRcdHRleHQ6ICdFbmFjdGVkJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogNCxcblx0XHRcdFx0XHR0ZXh0OiAnUGVuZGluZycsXG5cdFx0XHRcdH0sXG5cdFx0XHRdLFxuXG5cdFx0XHRhbGxBcHA6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogMyxcblx0XHRcdFx0XHR0ZXh0OiAnQWxsJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogMSxcblx0XHRcdFx0XHR0ZXh0OiAnVm90aW5nJyxcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHZhbDogMixcblx0XHRcdFx0XHR0ZXh0OiAnUGFyYW1ldGVyJyxcblx0XHRcdFx0fSxcblx0XHRcdF0sXG5cdFx0fSksXG5cblx0XHRjb21wdXRlZDoge1xuXHRcdFx0Li4uZ2V0dGVycyxcblx0XHRcdHNob3dSb290TW9kYWwoKSB7XG5cdFx0XHRcdHJldHVybiBzdGF0ZS5zaG93Um9vdE1vZGFsXG5cdFx0XHR9LFxuXHRcdFx0ZmlsdGVyU3RhdHVzOiB7XG5cdFx0XHRcdGdldCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUuZmlsdGVycy5zdGF0dXNcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0KHZhbCkge1xuXHRcdFx0XHRcdHN0YXRlLmZpbHRlcnMuc3RhdHVzID0gdmFsXG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0ZmlsdGVyT3V0Y29tZToge1xuXHRcdFx0XHRnZXQoKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0YXRlLmZpbHRlcnMub3V0Y29tZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQodmFsKSB7XG5cdFx0XHRcdFx0c3RhdGUuZmlsdGVycy5vdXRjb21lID0gdmFsXG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0ZmlsdGVyQXBwOiB7XG5cdFx0XHRcdGdldCgpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGUuZmlsdGVycy5hcHBcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0KHZhbCkge1xuXHRcdFx0XHRcdHN0YXRlLmZpbHRlcnMuYXBwID0gdmFsXG5cdFx0XHRcdH0sXG5cdFx0XHR9LFxuXHRcdFx0Y3VzdG9tRmlsdGVyVGV4dCgpIHtcblx0XHRcdFx0bGV0IHN0YXR1c1RleHQgPSB0aGlzLmFsbFN0YXR1cy5maW5kKHZhbCA9PiB2YWwudmFsID09IHRoaXMuZmlsdGVyU3RhdHVzKS50ZXh0XG5cdFx0XHRcdGxldCBvdXRjb21lVGV4dCA9IHRoaXMuYWxsT3V0Y29tZS5maW5kKHZhbCA9PiB2YWwudmFsID09IHRoaXMuZmlsdGVyT3V0Y29tZSkudGV4dFxuXHRcdFx0XHRsZXQgYXBwVGV4dCA9IHRoaXMuYWxsQXBwLmZpbmQodmFsID0+IHZhbC52YWwgPT0gdGhpcy5maWx0ZXJBcHApLnRleHRcblxuXHRcdFx0XHRyZXR1cm4gc3RhdHVzVGV4dCArICcgJyArIG91dGNvbWVUZXh0ICsgJyAnICsgYXBwVGV4dFxuXHRcdFx0fSxcblx0XHRcdGNoYW5nZWRGaWx0ZXIoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZpbHRlclN0YXR1cywgdGhpcy5maWx0ZXJPdXRjb21lLCB0aGlzLmZpbHRlckFwcCwgRGF0ZS5ub3coKVxuXHRcdFx0fSxcblx0XHR9LFxuXG5cdFx0bWV0aG9kczoge1xuXHRcdFx0YXN5bmMgbW91bnRlZCgpIHtcblx0XHRcdFx0bGV0IGFjY291bnQgPSBjb250cmFjdC5kZWZhdWx0X2FjY291bnQgfHwgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcblx0XHRcdFx0bGV0IGNhbGxzID0gW1xuXHRcdFx0XHRcdFtzdGF0ZS52b3RpbmdFc2Nyb3cuX2FkZHJlc3MsIHN0YXRlLnZvdGluZ0VzY3Jvdy5tZXRob2RzLmJhbGFuY2VPZihhY2NvdW50KS5lbmNvZGVBQkkoKV0sXG5cdFx0XHRcdFx0W3N0YXRlLnZvdGluZ0VzY3Jvdy5fYWRkcmVzcywgc3RhdGUudm90aW5nRXNjcm93Lm1ldGhvZHMubG9ja2VkX19lbmQoYWNjb3VudCkuZW5jb2RlQUJJKCldLFxuXHRcdFx0XHRcdFtzdGF0ZS5TV1JWLl9hZGRyZXNzLCBzdGF0ZS5TV1JWLm1ldGhvZHMuYmFsYW5jZU9mKGFjY291bnQpLmVuY29kZUFCSSgpXSxcblx0XHRcdFx0XVxuXHRcdFx0XHRhd2FpdCBnZXRBbGxWb3RlcygpXG5cdFx0XHRcdHRoaXMubG9hZGVkVm90ZXMgPSB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Y2hhbmdlRmlsdGVyKCkge1xuXHRcdFx0XHRjaGFuZ2VGaWx0ZXIoKVxuXHRcdFx0fSxcblx0XHR9LFxuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblx0bGVnZW5kIHtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdH1cblx0LnZvdGVzIHtcblx0XHRkaXNwbGF5OiBncmlkO1xuXHRcdGdyaWQtdGVtcGxhdGUtY29sdW1uczogcmVwZWF0KGF1dG8tZmlsbCwgbWlubWF4KDMwMHB4LCAxZnIpKTtcblx0XHRncmlkLWdhcDogMWVtO1xuXHRcdHdvcmQtYnJlYWs6IGJyZWFrLWFsbDtcblx0fVxuXHQudm90ZXMgLnZvdGUge1xuXHRcdC8qaGVpZ2h0OiAxNTBweDsqL1xuXHRcdC8qIGZpeCBmb3IgZmllbGRzZXQgaGVpZ2h0IDEwMCUgaXNzdWUgKi9cblx0XHRtYXJnaW4tYm90dG9tOiAxZW07XG5cdH1cblx0LnZvdGVzLWNsb3NlZCB7XG5cdFx0bWFyZ2luLXRvcDogMWVtO1xuXHR9XG5cdHNlbGVjdC50dmlzaW9uIHtcblx0XHRib3gtc2hhZG93OiBub25lXG5cdH1cblx0LmZpbHRlciBzZWxlY3Qge1xuXHRcdG1hcmdpbi1yaWdodDogMWVtO1xuXHR9XG5cdC5maWx0ZXIgZGl2IHNwYW4ge1xuXHRcdG1hcmdpbi1yaWdodDogMC40ZW07XG5cdH1cblx0LmZpbHRlciBidXR0b24ge1xuXHRcdGJveC1zaGFkb3c6IG5vbmU7XG5cdH1cblx0cCBkaXYge1xuXHRcdG1hcmdpbi10b3A6IDAuNGVtO1xuXHR9XG5cdC5iaWxsYm9hcmQge1xuXHRcdHRleHQtYWxpZ246Y2VudGVyOyBcblx0XHRtYXJnaW4tdG9wOiA1cmVtOyBcblx0XHR0ZXh0LXRyYW5zZm9ybTogbm9uZTtcblx0fVxuXHQuaGVhZGVyIHtcblx0XHRwYWRkaW5nLXRvcDogMnJlbTtcblx0fVxuPC9zdHlsZT4iLCJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMTItMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdGhyZWFkLWxvYWRlci9kaXN0L2Nqcy5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcyEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTAtMCEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL1ZvdGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Wb3Rlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiLCJpbXBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9IGZyb20gXCIuL1ZvdGVzLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD01ODQ4ZTg3MSZzY29wZWQ9dHJ1ZSZcIlxuaW1wb3J0IHNjcmlwdCBmcm9tIFwiLi9Wb3Rlcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1ZvdGVzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuaW1wb3J0IHN0eWxlMCBmcm9tIFwiLi9Wb3Rlcy52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD01ODQ4ZTg3MSZzY29wZWQ9dHJ1ZSZsYW5nPWNzcyZcIlxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cbmltcG9ydCBub3JtYWxpemVyIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1wiXG52YXIgY29tcG9uZW50ID0gbm9ybWFsaXplcihcbiAgc2NyaXB0LFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZmFsc2UsXG4gIG51bGwsXG4gIFwiNTg0OGU4NzFcIixcbiAgbnVsbFxuICBcbilcblxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9abc\n')},"9b5a":function(module,__webpack_exports__,__webpack_require__){"use strict";eval("\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/params.js\nconst DEFAULT_IPFS_GATEWAY = 'https://ipfs.eth.aragon.network';\nconst NETWORKS = [\n    {\n        chainId: 1,\n        name: 'ethereum',\n        ensAddress: '0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e',\n    },\n    {\n        chainId: 4,\n        name: 'rinkeby',\n        ensAddress: '0x98df287b6c145399aaa709692c8d308357bc085d',\n    },\n    {\n        chainId: 100,\n        name: 'xdai',\n        ensAddress: '0xaafca6b0c89521752e559650206d7c925fd0e530',\n    },\n];\n//# sourceMappingURL=params.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/network.js\n\nfunction networkFromChainId(chainId) {\n    return NETWORKS.find((network) => network.chainId === chainId) || null;\n}\nfunction networkFromName(name) {\n    return NETWORKS.find((network) => network.name === name) || null;\n}\nfunction networkFromObject({ chainId, ensAddress, name, }) {\n    var _a;\n    if (name === undefined && chainId === undefined) {\n        throw new Error(`Network: no name or chainId passed. ` +\n            `Please provide at least one of these.`);\n    }\n    // Handle the case of having a name but no chainId.\n    if (name !== undefined && chainId === undefined) {\n        chainId = (_a = networkFromName(name)) === null || _a === void 0 ? void 0 : _a.chainId;\n        if (chainId === undefined) {\n            throw new Error(`Network: invalid name provided: ${name}. ` +\n                `Please use provide a chainId or use one of the following names: ` +\n                NETWORKS.map((network) => network.chainId).join(', ') +\n                `.`);\n        }\n    }\n    // Just a little help for TypeScript, at this\n    // point we know that chainId cannot be undefined.\n    chainId = chainId;\n    const chainIdNetwork = networkFromChainId(chainId);\n    if (!chainIdNetwork) {\n        throw new Error(`Network: invalid chainId provided: ${chainId}. ` +\n            `Please use one of the following: ` +\n            NETWORKS.map((network) => network.chainId).join(', ') +\n            `.`);\n    }\n    // We compare with undefined to accept empty strings.\n    if (name === undefined) {\n        name = chainIdNetwork.name;\n    }\n    if (!ensAddress) {\n        ensAddress = chainIdNetwork.ensAddress;\n    }\n    return { chainId, ensAddress, name };\n}\nfunction toNetwork(network) {\n    if (!network) {\n        throw new Error(`Network: incorrect value provided.`);\n    }\n    if (typeof network === 'string') {\n        return networkFromObject({ name: network });\n    }\n    if (typeof network === 'number') {\n        return networkFromObject({ chainId: network });\n    }\n    return networkFromObject(network);\n}\n//# sourceMappingURL=network.js.map\n// EXTERNAL MODULE: ./node_modules/graphql-tag/src/index.js\nvar src = __webpack_require__(\"9530\");\nvar src_default = /*#__PURE__*/__webpack_require__.n(src);\n\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/queries/fragments.js\n\nconst PERMISSION_FRAGMENT = src_default.a `\n  fragment Permission_permission on Permission {\n    appAddress\n    allowed\n    granteeAddress\n    roleHash\n    params {\n      argumentId\n      operationType\n      argumentValue\n    }\n  }\n`;\nconst ROLE_FRAGMENT = src_default.a `\n  fragment Role_role on Role {\n    roleHash\n    manager\n    appAddress\n    grantees {\n      ...Permission_permission\n    }\n  }\n  ${PERMISSION_FRAGMENT}\n`;\nconst VERSION_FRAGMENT = src_default.a `\n  fragment Version_version on Version {\n    semanticVersion\n    codeAddress\n    contentUri\n    artifact\n    manifest\n  }\n`;\nconst REPO_FRAGMENT = src_default.a `\n  fragment Repo_repo on Repo {\n    address\n    name\n    node\n    registry {\n      address\n    }\n    lastVersion {\n      ...Version_version\n    }\n    versions {\n      ...Version_version\n    }\n  }\n  ${VERSION_FRAGMENT}\n`;\nconst APP_FRAGMENT = src_default.a `\n  fragment App_app on App {\n    address\n    appId\n    isForwarder\n    isUpgradeable\n    repoName\n    implementation {\n      address\n    }\n    organization {\n      address\n    }\n    version {\n      ...Version_version\n    }\n    repo {\n      ...Repo_repo\n    }\n    roles {\n      ...Role_role\n    }\n  }\n  ${ /* VERSION_FRAGMENT is already included in REPO_FRAGMENT */''}\n  ${REPO_FRAGMENT}\n  ${ROLE_FRAGMENT}\n`;\n//# sourceMappingURL=fragments.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/queries/index.js\n\n\nconst ORGANIZATION_APPS = (type) => src_default.a `\n  ${type} Organization($orgAddress: String!, $appFilter: App_filter!, $first: Int) {\n    organization(id: $orgAddress) {\n      apps(where: $appFilter, first: $first) {\n        ...App_app\n      }\n    }\n  }\n  ${APP_FRAGMENT}\n`;\nconst APP_BY_ADDRESS = (type) => src_default.a `\n  ${type} App($appAddress: String!) {\n    app(id: $appAddress) {\n      ...App_app\n    }\n  }\n  ${APP_FRAGMENT}\n`;\nconst REPO_BY_APP_ADDRESS = (type) => src_default.a `\n  ${type} App($appAddress: String!) {\n    app(id: $appAddress) {\n      repo {\n        ...Repo_repo\n      }\n      version {\n        ...Version_version\n      }\n    }\n  }\n  ${REPO_FRAGMENT}\n  ${VERSION_FRAGMENT}\n`;\nconst ORGANIZATION_PERMISSIONS = (type) => src_default.a `\n  ${type} Organization($orgAddress: String!) {\n    organization(id: $orgAddress) {\n      permissions {\n        ...Permission_permission\n      }\n    }\n  }\n  ${PERMISSION_FRAGMENT}\n`;\nconst ROLE_BY_APP_ADDRESS = (type) => src_default.a `\n  ${type} App($appAddress: String!) {\n    app(id: $appAddress) {\n      appId\n      version{\n        ...Version_version\n      }\n      roles {\n        ...Role_role\n      }\n    }\n  }\n  ${VERSION_FRAGMENT}\n  ${ROLE_FRAGMENT}\n`;\n//# sourceMappingURL=index.js.map\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/core/GraphQLWrapper.js\nvar GraphQLWrapper = __webpack_require__(\"c0dd\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/ethers/dist/ethers.umd.js\nvar ethers_umd = __webpack_require__(\"ebc9\");\n\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/app.js\n\nconst apmAppId = (appName) => ethers_umd[\"utils\"].namehash(`${appName}.aragonpm.eth`);\n// Is the given method a full signature, e.g. 'foo(arg1,arg2,...)'\nconst isFullMethodSignature = (methodSignature) => {\n    return (Boolean(methodSignature) &&\n        methodSignature.includes('(') &&\n        methodSignature.includes(')'));\n};\nfunction validateMethod(destination, methodSignature, destinationApp) {\n    const methods = destinationApp.intents;\n    if (!methods) {\n        throw new Error(`No functions specified in artifact for ${destination}`);\n    }\n    // Find the relevant method information\n    const method = methods.find((method) => isFullMethodSignature(methodSignature)\n        ? method.sig === methodSignature\n        : // If the full signature isn't given, just select the first overload declared\n            method.sig.split('(')[0] === methodSignature);\n    if (!method) {\n        throw new Error(`No method named ${methodSignature} on ${destination}`);\n    }\n    return method;\n}\n/**\n * Find the method descriptor corresponding to the data component of a\n * transaction sent to `app`.\n *\n * @param  {Object} app App artifact\n * @param  {Object} data Data component of a transaction to app\n * @return {Object|void} Method with radspec notice and function signature, or undefined if none was found\n */\nfunction findAppMethodFromIntent(app, transaction) {\n    const methodId = transaction.data.substring(0, 10);\n    const checkMethodSignature = (siganture) => {\n        // Hash signature with Ethereum Identity and silce bytes\n        const sigHash = ethers_umd[\"utils\"].hexDataSlice(ethers_umd[\"utils\"].id(siganture), 0, 4);\n        return sigHash === methodId;\n    };\n    const { deprecatedIntents, intents } = app || {};\n    let method;\n    // First try to find the method in the current functions\n    if (Array.isArray(intents)) {\n        method = intents.find((method) => checkMethodSignature(method.sig));\n    }\n    if (!method) {\n        // The current functions didn't have it; try with each deprecated version's functions\n        const deprecatedFunctionsFromVersions = Object.values(deprecatedIntents || {});\n        if (deprecatedFunctionsFromVersions.every(Array.isArray)) {\n            // Flatten all the deprecated functions\n            const allDeprecatedFunctions = [].concat(...deprecatedFunctionsFromVersions);\n            method = allDeprecatedFunctions.find((method) => checkMethodSignature(method.sig));\n        }\n    }\n    return method;\n}\n//# sourceMappingURL=app.js.map\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/abi/ACL.json\nvar ACL = __webpack_require__(\"924f\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/abi/Kernel.json\nvar Kernel = __webpack_require__(\"4cd3\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/abi/EVMScriptRegistry.json\nvar EVMScriptRegistry = __webpack_require__(\"e575\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/abi/APMRegistry.json\nvar APMRegistry = __webpack_require__(\"dfda\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/abi/Repo.json\nvar abi_Repo = __webpack_require__(\"5d16\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/abi/ENSSubdomainRegistrar.json\nvar ENSSubdomainRegistrar = __webpack_require__(\"25d7\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/artifacts/aragon/ACL.json\nvar aragon_ACL = __webpack_require__(\"73c7\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/artifacts/aragon/Kernel.json\nvar aragon_Kernel = __webpack_require__(\"5872\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/artifacts/aragon/EVMScriptRegistry.json\nvar aragon_EVMScriptRegistry = __webpack_require__(\"a06e\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/artifacts/apm/APMRegistry.json\nvar apm_APMRegistry = __webpack_require__(\"c6f3\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/artifacts/apm/Repo.json\nvar apm_Repo = __webpack_require__(\"cd6f\");\n\n// EXTERNAL MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/artifacts/apm/ENSSubdomainRegistrar.json\nvar apm_ENSSubdomainRegistrar = __webpack_require__(\"1186\");\n\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/interfaces.js\n\n// ABIs\n\n\n\n\n\n\n// Artifacts\n\n\n\n\n\n\nconst ABIS = {\n    'aragon/ACL': ACL.abi,\n    'aragon/Kernel': Kernel.abi,\n    'aragon/EVM Script Registry': EVMScriptRegistry.abi,\n    'apm/APM Registry': APMRegistry.abi,\n    'apm/Repo': abi_Repo.abi,\n    'apm/ENS Subdomain Registrar': ENSSubdomainRegistrar.abi,\n};\nconst ARTIFACTS = {\n    'aragon/ACL': aragon_ACL,\n    'aragon/Kernel': aragon_Kernel,\n    'aragon/EVM Script Registry': aragon_EVMScriptRegistry,\n    'apm/APM Registry': apm_APMRegistry,\n    'apm/Repo': apm_Repo,\n    'apm/ENS Subdomain Registrar': apm_ENSSubdomainRegistrar,\n};\nconst SYSTEM_APP_MAPPINGS = new Map([\n    [apmAppId('acl'), 'ACL'],\n    [apmAppId('evmreg'), 'EVM Script Registry'],\n    [apmAppId('kernel'), 'Kernel'],\n]);\nconst APM_APP_MAPPINGS = new Map([\n    [apmAppId('apm-registry'), 'APM Registry'],\n    [apmAppId('apm-repo'), 'Repo'],\n    [apmAppId('apm-enssub'), 'ENS Subdomain Registrar'],\n    // Support open.aragonpm.eth's native packages\n    // Note that these were erroneously deployed on the open.aragonpm.eth instance rather than\n    // reusing the aragonpm.eth versions\n    [apmAppId('apm-registry.open'), 'APM Registry'],\n    [apmAppId('apm-repo.open'), 'Repo'],\n    [apmAppId('apm-enssub.open'), 'ENS Subdomain Registrar'],\n    // Support hatch.aragonpm.eth's native packages (see note above for `open.aragonpm.eth`)\n    [apmAppId('apm-registry.hatch'), 'APM Registry'],\n    [apmAppId('apm-repo.hatch'), 'Repo'],\n    [apmAppId('apm-enssub.hatch'), 'ENS Subdomain Registrar'],\n]);\nconst APP_NAMESPACE_MAPPINGS = new Map([\n    ['aragon', SYSTEM_APP_MAPPINGS],\n    ['apm', APM_APP_MAPPINGS],\n]);\nconst getAbi = (name) => ABIS[name] || null;\nconst getArtifact = (name) => ARTIFACTS[name] || null;\nfunction getAppInfo(appId, namespace) {\n    const nameMapping = APP_NAMESPACE_MAPPINGS.get(namespace);\n    if (!nameMapping || !nameMapping.has(appId)) {\n        return null;\n    }\n    const appName = nameMapping.get(appId);\n    const app = `${namespace}/${appName}`;\n    const abi = getAbi(app);\n    const artifact = getArtifact(app);\n    return {\n        abi,\n        appName,\n        ...artifact,\n    };\n}\nfunction hasAppInfo(appId, namespace) {\n    const mapping = APP_NAMESPACE_MAPPINGS.get(namespace);\n    if (mapping)\n        return Boolean(mapping) && mapping.has(appId);\n    return false;\n}\n//# sourceMappingURL=interfaces.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/overrides/index.js\n\nfunction getAragonOsInternalAppInfo(appId) {\n    return getAppInfo(appId, 'aragon');\n}\nfunction getApmInternalAppInfo(appId) {\n    return getAppInfo(appId, 'apm');\n}\n\n//# sourceMappingURL=index.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/utils/metadata.js\n\n\n\nfunction parseMetadata(name, metadata) {\n    try {\n        return JSON.parse(metadata);\n    }\n    catch (error) {\n        throw new Error(`Can't parse ${name} file, invalid JSON.`);\n    }\n}\nasync function fetchMetadata(fileName, contentUri) {\n    const contentHashRegEx = contentUri.match(/ipfs:(.*)/);\n    if (contentHashRegEx) {\n        const url = `${DEFAULT_IPFS_GATEWAY}/ipfs/${contentHashRegEx[1]}/${fileName}`;\n        let metadata;\n        try {\n            metadata = await ethers_umd[\"utils\"].fetchJson(url);\n        }\n        catch (error) {\n            throw new Error(`Can't fetch ${url}, failed with error: {error}.`);\n        }\n        return metadata;\n    }\n    return {};\n}\nasync function resolveMetadata(fileName, contentUri, metadata) {\n    if (metadata) {\n        return parseMetadata(fileName, metadata);\n    }\n    if (contentUri) {\n        return fetchMetadata(fileName, contentUri);\n    }\n    return {};\n}\nasync function resolveManifest(data) {\n    return resolveMetadata('manifest.json', data.contentUri, data.manifest);\n}\nasync function resolveArtifact(data) {\n    if (hasAppInfo(data.appId, 'apm')) {\n        return getApmInternalAppInfo(data.appId);\n    }\n    if (hasAppInfo(data.appId, 'aragon')) {\n        return getAragonOsInternalAppInfo(data.appId);\n    }\n    return resolveMetadata('artifact.json', data.contentUri, data.artifact);\n}\n//# sourceMappingURL=metadata.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/entities/Permission.js\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _organization;\nclass Permission {\n    constructor(data, organization) {\n        _organization.set(this, void 0);\n        __classPrivateFieldSet(this, _organization, organization);\n        this.allowed = data.allowed;\n        this.appAddress = data.appAddress;\n        this.granteeAddress = data.granteeAddress;\n        this.params = data.params;\n        this.roleHash = data.roleHash;\n    }\n    orgConnector() {\n        return __classPrivateFieldGet(this, _organization).connection.orgConnector;\n    }\n    async app() {\n        return this.orgConnector().appByAddress(__classPrivateFieldGet(this, _organization), this.appAddress);\n    }\n    async role() {\n        const roles = await this.orgConnector().rolesForAddress(__classPrivateFieldGet(this, _organization), this.appAddress);\n        return roles.find((role) => role.hash === this.roleHash);\n    }\n}\n_organization = new WeakMap();\n//# sourceMappingURL=Permission.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/entities/Role.js\n\n\nclass Role_Role {\n    constructor(data, metadata, organization) {\n        var _a;\n        const { roles } = metadata[0];\n        const role = roles === null || roles === void 0 ? void 0 : roles.find((role) => role.bytes === data.hash);\n        this.appAddress = data.appAddress;\n        this.description = role === null || role === void 0 ? void 0 : role.name;\n        this.hash = data.hash;\n        this.manager = data.manager;\n        this.name = role === null || role === void 0 ? void 0 : role.id;\n        this.params = role === null || role === void 0 ? void 0 : role.params;\n        this.permissions = (_a = data.grantees) === null || _a === void 0 ? void 0 : _a.map((grantee) => new Permission(grantee, organization));\n    }\n    static async create(data, organization) {\n        const artifact = await resolveArtifact(data);\n        const metadata = [artifact];\n        return new Role_Role(data, metadata, organization);\n    }\n}\n//# sourceMappingURL=Role.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/parsers/roles.js\n\nasync function _parseRole(role, app, organization) {\n    var _a, _b, _c;\n    const grantees = (_a = role === null || role === void 0 ? void 0 : role.grantees) === null || _a === void 0 ? void 0 : _a.map((permission) => {\n        var _a;\n        return ({\n            appAddress: permission === null || permission === void 0 ? void 0 : permission.appAddress,\n            allowed: permission === null || permission === void 0 ? void 0 : permission.allowed,\n            granteeAddress: permission === null || permission === void 0 ? void 0 : permission.granteeAddress,\n            params: ((_a = permission === null || permission === void 0 ? void 0 : permission.params) === null || _a === void 0 ? void 0 : _a.map((param) => ({\n                argumentId: param === null || param === void 0 ? void 0 : param.argumentId,\n                operationType: param === null || param === void 0 ? void 0 : param.operationType,\n                argumentValue: param === null || param === void 0 ? void 0 : param.argumentValue,\n            }))) || [],\n            roleHash: permission === null || permission === void 0 ? void 0 : permission.roleHash,\n        });\n    });\n    const roleData = {\n        appAddress: role === null || role === void 0 ? void 0 : role.appAddress,\n        appId: app === null || app === void 0 ? void 0 : app.appId,\n        artifact: (_b = app === null || app === void 0 ? void 0 : app.version) === null || _b === void 0 ? void 0 : _b.artifact,\n        contentUri: (_c = app === null || app === void 0 ? void 0 : app.version) === null || _c === void 0 ? void 0 : _c.contentUri,\n        grantees: grantees || [],\n        hash: role === null || role === void 0 ? void 0 : role.roleHash,\n        manager: role === null || role === void 0 ? void 0 : role.manager,\n    };\n    return Role_Role.create(roleData, organization);\n}\nasync function parseRole(result, organization) {\n    var _a, _b;\n    const app = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.app;\n    const role = (_b = result === null || result === void 0 ? void 0 : result.data) === null || _b === void 0 ? void 0 : _b.role;\n    if (!app || !role) {\n        throw new Error('Unable to parse role.');\n    }\n    return _parseRole(role, app, organization);\n}\nasync function parseRoles(result, organization) {\n    var _a;\n    const app = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.app;\n    const roles = app === null || app === void 0 ? void 0 : app.roles;\n    if (!app || !Array.isArray(roles)) {\n        throw new Error('Unable to parse roles.');\n    }\n    return Promise.all(roles.map(async (role) => {\n        return _parseRole(role, app, organization);\n    }));\n}\n//# sourceMappingURL=roles.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/parsers/permissions.js\n\nfunction parsePermissions(result, organization) {\n    var _a, _b;\n    const permissions = (_b = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.organization) === null || _b === void 0 ? void 0 : _b.permissions;\n    if (!Array.isArray(permissions)) {\n        throw new Error('Unable to parse permissions.');\n    }\n    const datas = permissions.map((permission) => {\n        var _a, _b;\n        return ({\n            appAddress: permission === null || permission === void 0 ? void 0 : permission.appAddress,\n            allowed: permission === null || permission === void 0 ? void 0 : permission.allowed,\n            granteeAddress: permission === null || permission === void 0 ? void 0 : permission.granteeAddress,\n            params: ((_b = (_a = permission === null || permission === void 0 ? void 0 : permission.params) === null || _a === void 0 ? void 0 : _a.map) === null || _b === void 0 ? void 0 : _b.call(_a, (param) => ({\n                argumentId: param === null || param === void 0 ? void 0 : param.argumentId,\n                operationType: param === null || param === void 0 ? void 0 : param.operationType,\n                argumentValue: param === null || param === void 0 ? void 0 : param.argumentValue,\n            }))) || [],\n            roleHash: permission === null || permission === void 0 ? void 0 : permission.roleHash,\n        });\n    });\n    const allowedPermissions = datas.filter((data) => data.allowed);\n    return allowedPermissions.map((data) => {\n        return new Permission(data, organization);\n    });\n}\n//# sourceMappingURL=permissions.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/entities/App.js\nvar App_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar App_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _metadata;\n\nclass App_App {\n    constructor(data, metadata, organization) {\n        _metadata.set(this, void 0);\n        App_classPrivateFieldSet(this, _metadata, metadata);\n        this.address = data.address;\n        this.appId = data.appId;\n        this.codeAddress = data.codeAddress;\n        this.contentUri = data.contentUri;\n        this.isForwarder = data.isForwarder;\n        this.isUpgradeable = data.isUpgradeable;\n        this.kernelAddress = data.kernelAddress;\n        this.name = data.name;\n        this.organization = organization;\n        this.registry = data.registry;\n        this.registryAddress = data.registryAddress;\n        this.repoAddress = data.repoAddress;\n        this.version = data.version;\n    }\n    static async create(data, organization) {\n        const artifact = await resolveArtifact(data);\n        const manifest = await resolveManifest(data);\n        const metadata = [artifact, manifest];\n        return new App_App(data, metadata, organization);\n    }\n    orgConnector() {\n        return this.organization.connection.orgConnector;\n    }\n    async repo() {\n        return this.orgConnector().repoForApp(this.organization, this.address);\n    }\n    async roles() {\n        return this.orgConnector().rolesForAddress(this.organization, this.address);\n    }\n    get artifact() {\n        return App_classPrivateFieldGet(this, _metadata)[0];\n    }\n    get manifest() {\n        return App_classPrivateFieldGet(this, _metadata)[1];\n    }\n    get abi() {\n        return this.artifact.abi;\n    }\n    get intents() {\n        return this.artifact.functions;\n    }\n    get deprecatedIntents() {\n        return this.artifact.deprecatedFunctions;\n    }\n    get appName() {\n        return this.artifact.appName;\n    }\n    toJSON() {\n        return {\n            ...this,\n            // Organization creates a cycling reference that makes\n            // the object impossible to pass through JSON.stringify().\n            organization: null,\n        };\n    }\n}\n_metadata = new WeakMap();\n//# sourceMappingURL=App.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/parsers/apps.js\n\nasync function _parseApp(app, organization) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    const data = {\n        address: app.address,\n        appId: app.appId,\n        artifact: (_a = app.version) === null || _a === void 0 ? void 0 : _a.artifact,\n        codeAddress: app.implementation.address,\n        contentUri: (_b = app.version) === null || _b === void 0 ? void 0 : _b.contentUri,\n        isForwarder: app.isForwarder,\n        isUpgradeable: app.isUpgradeable,\n        kernelAddress: (_c = app.organization) === null || _c === void 0 ? void 0 : _c.address,\n        manifest: (_d = app.version) === null || _d === void 0 ? void 0 : _d.manifest,\n        name: app.repoName,\n        registry: (_f = (_e = app.repo) === null || _e === void 0 ? void 0 : _e.registry) === null || _f === void 0 ? void 0 : _f.name,\n        registryAddress: (_h = (_g = app.repo) === null || _g === void 0 ? void 0 : _g.registry) === null || _h === void 0 ? void 0 : _h.address,\n        repoAddress: (_j = app.repo) === null || _j === void 0 ? void 0 : _j.address,\n        version: (_k = app.version) === null || _k === void 0 ? void 0 : _k.semanticVersion.replace(/,/g, '.'),\n    };\n    return App_App.create(data, organization);\n}\nasync function parseApp(result, organization) {\n    var _a;\n    const app = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.app;\n    if (!app) {\n        throw new Error('Unable to parse app.');\n    }\n    return _parseApp(app, organization);\n}\nasync function parseApps(result, organization) {\n    var _a;\n    const data = result === null || result === void 0 ? void 0 : result.data;\n    const apps = (_a = data === null || data === void 0 ? void 0 : data.organization) === null || _a === void 0 ? void 0 : _a.apps;\n    if ((data === null || data === void 0 ? void 0 : data.organization) === null || (apps === null || apps === void 0 ? void 0 : apps.length) === 0) {\n        throw new Error('No apps found with the current filters.');\n    }\n    if (!apps) {\n        throw new Error('Unable to parse apps.');\n    }\n    return Promise.all(apps.map(async (app) => {\n        return _parseApp(app, organization);\n    }));\n}\n//# sourceMappingURL=apps.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-core/dist/esm/entities/Repo.js\nvar Repo_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar Repo_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar Repo_metadata;\n\nclass Repo_Repo {\n    constructor(data, metadata, organization) {\n        Repo_metadata.set(this, void 0);\n        Repo_classPrivateFieldSet(this, Repo_metadata, metadata);\n        Repo_classPrivateFieldSet(this, Repo_metadata, metadata);\n        this.address = data.address;\n        this.contentUri = data.contentUri;\n        this.name = data.name;\n        this.registry = data.registry;\n        this.registryAddress = data.registryAddress;\n    }\n    static async create(data, organization) {\n        const artifact = await resolveMetadata('artifact.json', data.contentUri, data.artifact);\n        const manifest = await resolveManifest(data);\n        const metadata = [artifact, manifest];\n        return new Repo_Repo(data, metadata, organization);\n    }\n    get artifact() {\n        return Repo_classPrivateFieldGet(this, Repo_metadata)[0];\n    }\n    get manifest() {\n        return Repo_classPrivateFieldGet(this, Repo_metadata)[1];\n    }\n    get roles() {\n        return this.artifact.roles;\n    }\n}\nRepo_metadata = new WeakMap();\n//# sourceMappingURL=Repo.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/parsers/repos.js\n\nasync function parseRepo(result, organization) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const repo = (_b = (_a = result === null || result === void 0 ? void 0 : result.data) === null || _a === void 0 ? void 0 : _a.app) === null || _b === void 0 ? void 0 : _b.repo;\n    if (!repo) {\n        throw new Error('Unable to parse repo.');\n    }\n    const data = {\n        address: repo === null || repo === void 0 ? void 0 : repo.address,\n        artifact: (_c = repo === null || repo === void 0 ? void 0 : repo.lastVersion) === null || _c === void 0 ? void 0 : _c.artifact,\n        contentUri: (_d = repo === null || repo === void 0 ? void 0 : repo.lastVersion) === null || _d === void 0 ? void 0 : _d.contentUri,\n        manifest: (_e = repo === null || repo === void 0 ? void 0 : repo.lastVersion) === null || _e === void 0 ? void 0 : _e.manifest,\n        name: repo === null || repo === void 0 ? void 0 : repo.name,\n        registry: (_f = repo === null || repo === void 0 ? void 0 : repo.registry) === null || _f === void 0 ? void 0 : _f.name,\n        registryAddress: (_g = repo === null || repo === void 0 ? void 0 : repo.registry) === null || _g === void 0 ? void 0 : _g.address,\n    };\n    return Repo_Repo.create(data, organization);\n}\n//# sourceMappingURL=repos.js.map\n// CONCATENATED MODULE: ./node_modules/@aragon/connect-thegraph-voting/node_modules/@aragon/connect-thegraph/dist/esm/connector.js\nvar connector_classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar connector_classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _gql;\n\n\n\n\nfunction getOrgSubgraphUrl(network) {\n    if (network.chainId === 1) {\n        return 'https://api.thegraph.com/subgraphs/name/aragon/aragon-mainnet';\n    }\n    if (network.chainId === 4) {\n        return 'https://api.thegraph.com/subgraphs/name/aragon/aragon-rinkeby';\n    }\n    if (network.chainId === 100) {\n        return 'https://api.thegraph.com/subgraphs/name/1hive/aragon-xdai';\n    }\n    return null;\n}\nfunction appFiltersToQueryFilter(appFilters) {\n    const queryFilter = {};\n    if (appFilters.name) {\n        queryFilter.repoName_in = appFilters.name.map((name) => name.replace(/\\.aragonpm\\.eth$/, ''));\n    }\n    if (appFilters.address) {\n        queryFilter.address_in = appFilters.address;\n    }\n    return queryFilter;\n}\nclass connector_ConnectorTheGraph {\n    constructor(config) {\n        _gql.set(this, void 0);\n        this.name = 'thegraph';\n        this.config = config;\n        this.network = toNetwork(config.network);\n        const orgSubgraphUrl = config.orgSubgraphUrl || getOrgSubgraphUrl(this.network);\n        if (!orgSubgraphUrl) {\n            throw new Error(`The chainId ${this.network.chainId} is not supported by the TheGraph connector.`);\n        }\n        connector_classPrivateFieldSet(this, _gql, new GraphQLWrapper[\"a\" /* default */](orgSubgraphUrl, {\n            pollInterval: config.pollInterval,\n            verbose: config.verbose,\n        }));\n    }\n    async connect(connection) {\n        this.connection = connection;\n    }\n    async disconnect() {\n        connector_classPrivateFieldGet(this, _gql).close();\n        delete this.connection;\n    }\n    async rolesForAddress(organization, appAddress) {\n        return connector_classPrivateFieldGet(this, _gql).performQueryWithParser(ROLE_BY_APP_ADDRESS('query'), { appAddress: appAddress.toLowerCase() }, (result) => parseRoles(result, organization));\n    }\n    async permissionsForOrg(organization) {\n        return connector_classPrivateFieldGet(this, _gql).performQueryWithParser(ORGANIZATION_PERMISSIONS('query'), { orgAddress: organization.address.toLowerCase() }, (result) => parsePermissions(result, organization));\n    }\n    onPermissionsForOrg(organization, callback) {\n        return connector_classPrivateFieldGet(this, _gql).subscribeToQueryWithParser(ORGANIZATION_PERMISSIONS('subscription'), { orgAddress: organization.address.toLowerCase() }, callback, (result) => parsePermissions(result, organization));\n    }\n    async appByAddress(organization, appAddress) {\n        return connector_classPrivateFieldGet(this, _gql).performQueryWithParser(APP_BY_ADDRESS('query'), { appAddress: appAddress.toLowerCase() }, (result) => parseApp(result, organization));\n    }\n    async appForOrg(organization, filters) {\n        const apps = await connector_classPrivateFieldGet(this, _gql).performQueryWithParser(ORGANIZATION_APPS('query'), {\n            appFilter: appFiltersToQueryFilter(filters),\n            first: 1,\n            orgAddress: organization.address.toLowerCase(),\n        }, (result) => parseApps(result, organization));\n        return apps[0];\n    }\n    onAppForOrg(organization, filters, callback) {\n        return connector_classPrivateFieldGet(this, _gql).subscribeToQueryWithParser(ORGANIZATION_APPS('subscription'), {\n            appFilter: appFiltersToQueryFilter(filters),\n            first: 1,\n            orgAddress: organization.address.toLowerCase(),\n        }, callback, async (result) => {\n            const apps = await parseApps(result, organization);\n            return apps[0];\n        });\n    }\n    async appsForOrg(organization, filters) {\n        return connector_classPrivateFieldGet(this, _gql).performQueryWithParser(ORGANIZATION_APPS('query'), {\n            appFilter: appFiltersToQueryFilter(filters),\n            orgAddress: organization.address.toLowerCase(),\n        }, (result) => parseApps(result, organization));\n    }\n    onAppsForOrg(organization, filters, callback) {\n        return connector_classPrivateFieldGet(this, _gql).subscribeToQueryWithParser(ORGANIZATION_APPS('subscription'), {\n            appFilter: appFiltersToQueryFilter(filters),\n            orgAddress: organization.address.toLowerCase(),\n        }, callback, (result) => parseApps(result, organization));\n    }\n    async repoForApp(organization, appAddress) {\n        return connector_classPrivateFieldGet(this, _gql).performQueryWithParser(REPO_BY_APP_ADDRESS('query'), { appAddress: appAddress.toLowerCase() }, (result) => parseRepo(result, organization));\n    }\n}\n_gql = new WeakMap();\n/* harmony default export */ var connector = __webpack_exports__[\"a\"] = (connector_ConnectorTheGraph);\n//# sourceMappingURL=connector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LWNvcmUvZGlzdC9lc20vcGFyYW1zLmpzP2M1NDEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC12b3Rpbmcvbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC1jb3JlL2Rpc3QvZXNtL3V0aWxzL25ldHdvcmsuanM/MjMwMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoL2Rpc3QvZXNtL3F1ZXJpZXMvZnJhZ21lbnRzLmpzPzMwMTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC12b3Rpbmcvbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC9kaXN0L2VzbS9xdWVyaWVzL2luZGV4LmpzPzE4YjUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC12b3Rpbmcvbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC1jb3JlL2Rpc3QvZXNtL3V0aWxzL2FwcC5qcz82YWZlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtdGhlZ3JhcGgtdm90aW5nL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtY29yZS9kaXN0L2VzbS91dGlscy9vdmVycmlkZXMvaW50ZXJmYWNlcy5qcz9jZWE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtdGhlZ3JhcGgtdm90aW5nL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtY29yZS9kaXN0L2VzbS91dGlscy9vdmVycmlkZXMvaW5kZXguanM/MDNlMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LWNvcmUvZGlzdC9lc20vdXRpbHMvbWV0YWRhdGEuanM/MTAxNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LWNvcmUvZGlzdC9lc20vZW50aXRpZXMvUGVybWlzc2lvbi5qcz9hMmM0Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtdGhlZ3JhcGgtdm90aW5nL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtY29yZS9kaXN0L2VzbS9lbnRpdGllcy9Sb2xlLmpzPzAxNDgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC12b3Rpbmcvbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC9kaXN0L2VzbS9wYXJzZXJzL3JvbGVzLmpzPzRkNTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC12b3Rpbmcvbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC9kaXN0L2VzbS9wYXJzZXJzL3Blcm1pc3Npb25zLmpzPzU3ZjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC12b3Rpbmcvbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC1jb3JlL2Rpc3QvZXNtL2VudGl0aWVzL0FwcC5qcz81MWYxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtdGhlZ3JhcGgtdm90aW5nL25vZGVfbW9kdWxlcy9AYXJhZ29uL2Nvbm5lY3QtdGhlZ3JhcGgvZGlzdC9lc20vcGFyc2Vycy9hcHBzLmpzPzAwMTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC10aGVncmFwaC12b3Rpbmcvbm9kZV9tb2R1bGVzL0BhcmFnb24vY29ubmVjdC1jb3JlL2Rpc3QvZXNtL2VudGl0aWVzL1JlcG8uanM/Y2M4YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoL2Rpc3QvZXNtL3BhcnNlcnMvcmVwb3MuanM/YWJiZCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoL2Rpc3QvZXNtL2Nvbm5lY3Rvci5qcz85YjVhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQU87QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0M7O0FDbEJxQztBQUM5QjtBQUNQLFdBQVcsUUFBUTtBQUNuQjtBQUNPO0FBQ1AsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsNEJBQTRCLDZCQUE2QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsUUFBUTtBQUN0RTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FB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O0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQXNCLG9DQUFvQyxtQkFBMkIsWUFBWSx1Q0FBdUMsY0FBYyxVQUFVO0FBQy9LO0FBQ0E7QUFDQSxlQUFlLDhCQUFzQixvQ0FBb0Msd0JBQWdDLFlBQVksaURBQWlELGNBQWMsZ0JBQWdCO0FBQ3BNO0FBQ0E7QUFDQSxlQUFlLDhCQUFzQix3Q0FBd0Msd0JBQWdDLG1CQUFtQixpREFBaUQsd0JBQXdCLGdCQUFnQjtBQUN6TjtBQUNBO0FBQ0EsZUFBZSw4QkFBc0Isb0NBQW9DLGNBQXNCLFlBQVksdUNBQXVDLGNBQWMsUUFBUTtBQUN4SztBQUNBO0FBQ0EsMkJBQTJCLDhCQUFzQixvQ0FBb0MsaUJBQXlCO0FBQzlHO0FBQ0E7QUFDQTtBQUNBLFNBQVMsY0FBYyxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQXNCLHdDQUF3QyxpQkFBeUI7QUFDdEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULCtCQUErQixTQUFTO0FBQ3hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxlQUFlLDhCQUFzQixvQ0FBb0MsaUJBQXlCO0FBQ2xHO0FBQ0E7QUFDQSxTQUFTLGNBQWMsU0FBUztBQUNoQztBQUNBO0FBQ0EsZUFBZSw4QkFBc0Isd0NBQXdDLGlCQUF5QjtBQUN0RztBQUNBO0FBQ0EsU0FBUyx3QkFBd0IsU0FBUztBQUMxQztBQUNBO0FBQ0EsZUFBZSw4QkFBc0Isb0NBQW9DLG1CQUEyQixZQUFZLHVDQUF1QyxjQUFjLFNBQVM7QUFDOUs7QUFDQTtBQUNBO0FBQ2Usb0dBQWlCLEVBQUM7QUFDakMiLCJmaWxlIjoiOWI1YS5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBERUZBVUxUX0lQRlNfR0FURVdBWSA9ICdodHRwczovL2lwZnMuZXRoLmFyYWdvbi5uZXR3b3JrJztcbmV4cG9ydCBjb25zdCBORVRXT1JLUyA9IFtcbiAgICB7XG4gICAgICAgIGNoYWluSWQ6IDEsXG4gICAgICAgIG5hbWU6ICdldGhlcmV1bScsXG4gICAgICAgIGVuc0FkZHJlc3M6ICcweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWUnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBjaGFpbklkOiA0LFxuICAgICAgICBuYW1lOiAncmlua2VieScsXG4gICAgICAgIGVuc0FkZHJlc3M6ICcweDk4ZGYyODdiNmMxNDUzOTlhYWE3MDk2OTJjOGQzMDgzNTdiYzA4NWQnLFxuICAgIH0sXG4gICAge1xuICAgICAgICBjaGFpbklkOiAxMDAsXG4gICAgICAgIG5hbWU6ICd4ZGFpJyxcbiAgICAgICAgZW5zQWRkcmVzczogJzB4YWFmY2E2YjBjODk1MjE3NTJlNTU5NjUwMjA2ZDdjOTI1ZmQwZTUzMCcsXG4gICAgfSxcbl07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbXMuanMubWFwIiwiaW1wb3J0IHsgTkVUV09SS1MgfSBmcm9tICcuLi9wYXJhbXMnO1xuZXhwb3J0IGZ1bmN0aW9uIG5ldHdvcmtGcm9tQ2hhaW5JZChjaGFpbklkKSB7XG4gICAgcmV0dXJuIE5FVFdPUktTLmZpbmQoKG5ldHdvcmspID0+IG5ldHdvcmsuY2hhaW5JZCA9PT0gY2hhaW5JZCkgfHwgbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBuZXR3b3JrRnJvbU5hbWUobmFtZSkge1xuICAgIHJldHVybiBORVRXT1JLUy5maW5kKChuZXR3b3JrKSA9PiBuZXR3b3JrLm5hbWUgPT09IG5hbWUpIHx8IG51bGw7XG59XG5mdW5jdGlvbiBuZXR3b3JrRnJvbU9iamVjdCh7IGNoYWluSWQsIGVuc0FkZHJlc3MsIG5hbWUsIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCAmJiBjaGFpbklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrOiBubyBuYW1lIG9yIGNoYWluSWQgcGFzc2VkLiBgICtcbiAgICAgICAgICAgIGBQbGVhc2UgcHJvdmlkZSBhdCBsZWFzdCBvbmUgb2YgdGhlc2UuYCk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSBvZiBoYXZpbmcgYSBuYW1lIGJ1dCBubyBjaGFpbklkLlxuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQgJiYgY2hhaW5JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNoYWluSWQgPSAoX2EgPSBuZXR3b3JrRnJvbU5hbWUobmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGFpbklkO1xuICAgICAgICBpZiAoY2hhaW5JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcms6IGludmFsaWQgbmFtZSBwcm92aWRlZDogJHtuYW1lfS4gYCArXG4gICAgICAgICAgICAgICAgYFBsZWFzZSB1c2UgcHJvdmlkZSBhIGNoYWluSWQgb3IgdXNlIG9uZSBvZiB0aGUgZm9sbG93aW5nIG5hbWVzOiBgICtcbiAgICAgICAgICAgICAgICBORVRXT1JLUy5tYXAoKG5ldHdvcmspID0+IG5ldHdvcmsuY2hhaW5JZCkuam9pbignLCAnKSArXG4gICAgICAgICAgICAgICAgYC5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBKdXN0IGEgbGl0dGxlIGhlbHAgZm9yIFR5cGVTY3JpcHQsIGF0IHRoaXNcbiAgICAvLyBwb2ludCB3ZSBrbm93IHRoYXQgY2hhaW5JZCBjYW5ub3QgYmUgdW5kZWZpbmVkLlxuICAgIGNoYWluSWQgPSBjaGFpbklkO1xuICAgIGNvbnN0IGNoYWluSWROZXR3b3JrID0gbmV0d29ya0Zyb21DaGFpbklkKGNoYWluSWQpO1xuICAgIGlmICghY2hhaW5JZE5ldHdvcmspIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOZXR3b3JrOiBpbnZhbGlkIGNoYWluSWQgcHJvdmlkZWQ6ICR7Y2hhaW5JZH0uIGAgK1xuICAgICAgICAgICAgYFBsZWFzZSB1c2Ugb25lIG9mIHRoZSBmb2xsb3dpbmc6IGAgK1xuICAgICAgICAgICAgTkVUV09SS1MubWFwKChuZXR3b3JrKSA9PiBuZXR3b3JrLmNoYWluSWQpLmpvaW4oJywgJykgK1xuICAgICAgICAgICAgYC5gKTtcbiAgICB9XG4gICAgLy8gV2UgY29tcGFyZSB3aXRoIHVuZGVmaW5lZCB0byBhY2NlcHQgZW1wdHkgc3RyaW5ncy5cbiAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5hbWUgPSBjaGFpbklkTmV0d29yay5uYW1lO1xuICAgIH1cbiAgICBpZiAoIWVuc0FkZHJlc3MpIHtcbiAgICAgICAgZW5zQWRkcmVzcyA9IGNoYWluSWROZXR3b3JrLmVuc0FkZHJlc3M7XG4gICAgfVxuICAgIHJldHVybiB7IGNoYWluSWQsIGVuc0FkZHJlc3MsIG5hbWUgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b05ldHdvcmsobmV0d29yaykge1xuICAgIGlmICghbmV0d29yaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5ldHdvcms6IGluY29ycmVjdCB2YWx1ZSBwcm92aWRlZC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXR3b3JrID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbmV0d29ya0Zyb21PYmplY3QoeyBuYW1lOiBuZXR3b3JrIH0pO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ldHdvcmsgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBuZXR3b3JrRnJvbU9iamVjdCh7IGNoYWluSWQ6IG5ldHdvcmsgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXR3b3JrRnJvbU9iamVjdChuZXR3b3JrKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldHdvcmsuanMubWFwIiwiaW1wb3J0IGdxbCBmcm9tICdncmFwaHFsLXRhZyc7XG5leHBvcnQgY29uc3QgUEVSTUlTU0lPTl9GUkFHTUVOVCA9IGdxbCBgXG4gIGZyYWdtZW50IFBlcm1pc3Npb25fcGVybWlzc2lvbiBvbiBQZXJtaXNzaW9uIHtcbiAgICBhcHBBZGRyZXNzXG4gICAgYWxsb3dlZFxuICAgIGdyYW50ZWVBZGRyZXNzXG4gICAgcm9sZUhhc2hcbiAgICBwYXJhbXMge1xuICAgICAgYXJndW1lbnRJZFxuICAgICAgb3BlcmF0aW9uVHlwZVxuICAgICAgYXJndW1lbnRWYWx1ZVxuICAgIH1cbiAgfVxuYDtcbmV4cG9ydCBjb25zdCBST0xFX0ZSQUdNRU5UID0gZ3FsIGBcbiAgZnJhZ21lbnQgUm9sZV9yb2xlIG9uIFJvbGUge1xuICAgIHJvbGVIYXNoXG4gICAgbWFuYWdlclxuICAgIGFwcEFkZHJlc3NcbiAgICBncmFudGVlcyB7XG4gICAgICAuLi5QZXJtaXNzaW9uX3Blcm1pc3Npb25cbiAgICB9XG4gIH1cbiAgJHtQRVJNSVNTSU9OX0ZSQUdNRU5UfVxuYDtcbmV4cG9ydCBjb25zdCBWRVJTSU9OX0ZSQUdNRU5UID0gZ3FsIGBcbiAgZnJhZ21lbnQgVmVyc2lvbl92ZXJzaW9uIG9uIFZlcnNpb24ge1xuICAgIHNlbWFudGljVmVyc2lvblxuICAgIGNvZGVBZGRyZXNzXG4gICAgY29udGVudFVyaVxuICAgIGFydGlmYWN0XG4gICAgbWFuaWZlc3RcbiAgfVxuYDtcbmV4cG9ydCBjb25zdCBSRVBPX0ZSQUdNRU5UID0gZ3FsIGBcbiAgZnJhZ21lbnQgUmVwb19yZXBvIG9uIFJlcG8ge1xuICAgIGFkZHJlc3NcbiAgICBuYW1lXG4gICAgbm9kZVxuICAgIHJlZ2lzdHJ5IHtcbiAgICAgIGFkZHJlc3NcbiAgICB9XG4gICAgbGFzdFZlcnNpb24ge1xuICAgICAgLi4uVmVyc2lvbl92ZXJzaW9uXG4gICAgfVxuICAgIHZlcnNpb25zIHtcbiAgICAgIC4uLlZlcnNpb25fdmVyc2lvblxuICAgIH1cbiAgfVxuICAke1ZFUlNJT05fRlJBR01FTlR9XG5gO1xuZXhwb3J0IGNvbnN0IEFQUF9GUkFHTUVOVCA9IGdxbCBgXG4gIGZyYWdtZW50IEFwcF9hcHAgb24gQXBwIHtcbiAgICBhZGRyZXNzXG4gICAgYXBwSWRcbiAgICBpc0ZvcndhcmRlclxuICAgIGlzVXBncmFkZWFibGVcbiAgICByZXBvTmFtZVxuICAgIGltcGxlbWVudGF0aW9uIHtcbiAgICAgIGFkZHJlc3NcbiAgICB9XG4gICAgb3JnYW5pemF0aW9uIHtcbiAgICAgIGFkZHJlc3NcbiAgICB9XG4gICAgdmVyc2lvbiB7XG4gICAgICAuLi5WZXJzaW9uX3ZlcnNpb25cbiAgICB9XG4gICAgcmVwbyB7XG4gICAgICAuLi5SZXBvX3JlcG9cbiAgICB9XG4gICAgcm9sZXMge1xuICAgICAgLi4uUm9sZV9yb2xlXG4gICAgfVxuICB9XG4gICR7IC8qIFZFUlNJT05fRlJBR01FTlQgaXMgYWxyZWFkeSBpbmNsdWRlZCBpbiBSRVBPX0ZSQUdNRU5UICovJyd9XG4gICR7UkVQT19GUkFHTUVOVH1cbiAgJHtST0xFX0ZSQUdNRU5UfVxuYDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZyYWdtZW50cy5qcy5tYXAiLCJpbXBvcnQgZ3FsIGZyb20gJ2dyYXBocWwtdGFnJztcbmltcG9ydCAqIGFzIGZyYWdtZW50cyBmcm9tICcuL2ZyYWdtZW50cyc7XG5leHBvcnQgY29uc3QgT1JHQU5JWkFUSU9OX0FQUFMgPSAodHlwZSkgPT4gZ3FsIGBcbiAgJHt0eXBlfSBPcmdhbml6YXRpb24oJG9yZ0FkZHJlc3M6IFN0cmluZyEsICRhcHBGaWx0ZXI6IEFwcF9maWx0ZXIhLCAkZmlyc3Q6IEludCkge1xuICAgIG9yZ2FuaXphdGlvbihpZDogJG9yZ0FkZHJlc3MpIHtcbiAgICAgIGFwcHMod2hlcmU6ICRhcHBGaWx0ZXIsIGZpcnN0OiAkZmlyc3QpIHtcbiAgICAgICAgLi4uQXBwX2FwcFxuICAgICAgfVxuICAgIH1cbiAgfVxuICAke2ZyYWdtZW50cy5BUFBfRlJBR01FTlR9XG5gO1xuZXhwb3J0IGNvbnN0IEFQUF9CWV9BRERSRVNTID0gKHR5cGUpID0+IGdxbCBgXG4gICR7dHlwZX0gQXBwKCRhcHBBZGRyZXNzOiBTdHJpbmchKSB7XG4gICAgYXBwKGlkOiAkYXBwQWRkcmVzcykge1xuICAgICAgLi4uQXBwX2FwcFxuICAgIH1cbiAgfVxuICAke2ZyYWdtZW50cy5BUFBfRlJBR01FTlR9XG5gO1xuZXhwb3J0IGNvbnN0IFJFUE9fQllfQVBQX0FERFJFU1MgPSAodHlwZSkgPT4gZ3FsIGBcbiAgJHt0eXBlfSBBcHAoJGFwcEFkZHJlc3M6IFN0cmluZyEpIHtcbiAgICBhcHAoaWQ6ICRhcHBBZGRyZXNzKSB7XG4gICAgICByZXBvIHtcbiAgICAgICAgLi4uUmVwb19yZXBvXG4gICAgICB9XG4gICAgICB2ZXJzaW9uIHtcbiAgICAgICAgLi4uVmVyc2lvbl92ZXJzaW9uXG4gICAgICB9XG4gICAgfVxuICB9XG4gICR7ZnJhZ21lbnRzLlJFUE9fRlJBR01FTlR9XG4gICR7ZnJhZ21lbnRzLlZFUlNJT05fRlJBR01FTlR9XG5gO1xuZXhwb3J0IGNvbnN0IE9SR0FOSVpBVElPTl9QRVJNSVNTSU9OUyA9ICh0eXBlKSA9PiBncWwgYFxuICAke3R5cGV9IE9yZ2FuaXphdGlvbigkb3JnQWRkcmVzczogU3RyaW5nISkge1xuICAgIG9yZ2FuaXphdGlvbihpZDogJG9yZ0FkZHJlc3MpIHtcbiAgICAgIHBlcm1pc3Npb25zIHtcbiAgICAgICAgLi4uUGVybWlzc2lvbl9wZXJtaXNzaW9uXG4gICAgICB9XG4gICAgfVxuICB9XG4gICR7ZnJhZ21lbnRzLlBFUk1JU1NJT05fRlJBR01FTlR9XG5gO1xuZXhwb3J0IGNvbnN0IFJPTEVfQllfQVBQX0FERFJFU1MgPSAodHlwZSkgPT4gZ3FsIGBcbiAgJHt0eXBlfSBBcHAoJGFwcEFkZHJlc3M6IFN0cmluZyEpIHtcbiAgICBhcHAoaWQ6ICRhcHBBZGRyZXNzKSB7XG4gICAgICBhcHBJZFxuICAgICAgdmVyc2lvbntcbiAgICAgICAgLi4uVmVyc2lvbl92ZXJzaW9uXG4gICAgICB9XG4gICAgICByb2xlcyB7XG4gICAgICAgIC4uLlJvbGVfcm9sZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAke2ZyYWdtZW50cy5WRVJTSU9OX0ZSQUdNRU5UfVxuICAke2ZyYWdtZW50cy5ST0xFX0ZSQUdNRU5UfVxuYDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IHV0aWxzIGFzIGV0aGVyc1V0aWxzIH0gZnJvbSAnZXRoZXJzJztcbmV4cG9ydCBjb25zdCBhcG1BcHBJZCA9IChhcHBOYW1lKSA9PiBldGhlcnNVdGlscy5uYW1laGFzaChgJHthcHBOYW1lfS5hcmFnb25wbS5ldGhgKTtcbi8vIElzIHRoZSBnaXZlbiBtZXRob2QgYSBmdWxsIHNpZ25hdHVyZSwgZS5nLiAnZm9vKGFyZzEsYXJnMiwuLi4pJ1xuZXhwb3J0IGNvbnN0IGlzRnVsbE1ldGhvZFNpZ25hdHVyZSA9IChtZXRob2RTaWduYXR1cmUpID0+IHtcbiAgICByZXR1cm4gKEJvb2xlYW4obWV0aG9kU2lnbmF0dXJlKSAmJlxuICAgICAgICBtZXRob2RTaWduYXR1cmUuaW5jbHVkZXMoJygnKSAmJlxuICAgICAgICBtZXRob2RTaWduYXR1cmUuaW5jbHVkZXMoJyknKSk7XG59O1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTWV0aG9kKGRlc3RpbmF0aW9uLCBtZXRob2RTaWduYXR1cmUsIGRlc3RpbmF0aW9uQXBwKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IGRlc3RpbmF0aW9uQXBwLmludGVudHM7XG4gICAgaWYgKCFtZXRob2RzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gZnVuY3Rpb25zIHNwZWNpZmllZCBpbiBhcnRpZmFjdCBmb3IgJHtkZXN0aW5hdGlvbn1gKTtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgcmVsZXZhbnQgbWV0aG9kIGluZm9ybWF0aW9uXG4gICAgY29uc3QgbWV0aG9kID0gbWV0aG9kcy5maW5kKChtZXRob2QpID0+IGlzRnVsbE1ldGhvZFNpZ25hdHVyZShtZXRob2RTaWduYXR1cmUpXG4gICAgICAgID8gbWV0aG9kLnNpZyA9PT0gbWV0aG9kU2lnbmF0dXJlXG4gICAgICAgIDogLy8gSWYgdGhlIGZ1bGwgc2lnbmF0dXJlIGlzbid0IGdpdmVuLCBqdXN0IHNlbGVjdCB0aGUgZmlyc3Qgb3ZlcmxvYWQgZGVjbGFyZWRcbiAgICAgICAgICAgIG1ldGhvZC5zaWcuc3BsaXQoJygnKVswXSA9PT0gbWV0aG9kU2lnbmF0dXJlKTtcbiAgICBpZiAoIW1ldGhvZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCAke21ldGhvZFNpZ25hdHVyZX0gb24gJHtkZXN0aW5hdGlvbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG1ldGhvZDtcbn1cbi8qKlxuICogRmluZCB0aGUgbWV0aG9kIGRlc2NyaXB0b3IgY29ycmVzcG9uZGluZyB0byB0aGUgZGF0YSBjb21wb25lbnQgb2YgYVxuICogdHJhbnNhY3Rpb24gc2VudCB0byBgYXBwYC5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGFwcCBBcHAgYXJ0aWZhY3RcbiAqIEBwYXJhbSAge09iamVjdH0gZGF0YSBEYXRhIGNvbXBvbmVudCBvZiBhIHRyYW5zYWN0aW9uIHRvIGFwcFxuICogQHJldHVybiB7T2JqZWN0fHZvaWR9IE1ldGhvZCB3aXRoIHJhZHNwZWMgbm90aWNlIGFuZCBmdW5jdGlvbiBzaWduYXR1cmUsIG9yIHVuZGVmaW5lZCBpZiBub25lIHdhcyBmb3VuZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEFwcE1ldGhvZEZyb21JbnRlbnQoYXBwLCB0cmFuc2FjdGlvbikge1xuICAgIGNvbnN0IG1ldGhvZElkID0gdHJhbnNhY3Rpb24uZGF0YS5zdWJzdHJpbmcoMCwgMTApO1xuICAgIGNvbnN0IGNoZWNrTWV0aG9kU2lnbmF0dXJlID0gKHNpZ2FudHVyZSkgPT4ge1xuICAgICAgICAvLyBIYXNoIHNpZ25hdHVyZSB3aXRoIEV0aGVyZXVtIElkZW50aXR5IGFuZCBzaWxjZSBieXRlc1xuICAgICAgICBjb25zdCBzaWdIYXNoID0gZXRoZXJzVXRpbHMuaGV4RGF0YVNsaWNlKGV0aGVyc1V0aWxzLmlkKHNpZ2FudHVyZSksIDAsIDQpO1xuICAgICAgICByZXR1cm4gc2lnSGFzaCA9PT0gbWV0aG9kSWQ7XG4gICAgfTtcbiAgICBjb25zdCB7IGRlcHJlY2F0ZWRJbnRlbnRzLCBpbnRlbnRzIH0gPSBhcHAgfHwge307XG4gICAgbGV0IG1ldGhvZDtcbiAgICAvLyBGaXJzdCB0cnkgdG8gZmluZCB0aGUgbWV0aG9kIGluIHRoZSBjdXJyZW50IGZ1bmN0aW9uc1xuICAgIGlmIChBcnJheS5pc0FycmF5KGludGVudHMpKSB7XG4gICAgICAgIG1ldGhvZCA9IGludGVudHMuZmluZCgobWV0aG9kKSA9PiBjaGVja01ldGhvZFNpZ25hdHVyZShtZXRob2Quc2lnKSk7XG4gICAgfVxuICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IGZ1bmN0aW9ucyBkaWRuJ3QgaGF2ZSBpdDsgdHJ5IHdpdGggZWFjaCBkZXByZWNhdGVkIHZlcnNpb24ncyBmdW5jdGlvbnNcbiAgICAgICAgY29uc3QgZGVwcmVjYXRlZEZ1bmN0aW9uc0Zyb21WZXJzaW9ucyA9IE9iamVjdC52YWx1ZXMoZGVwcmVjYXRlZEludGVudHMgfHwge30pO1xuICAgICAgICBpZiAoZGVwcmVjYXRlZEZ1bmN0aW9uc0Zyb21WZXJzaW9ucy5ldmVyeShBcnJheS5pc0FycmF5KSkge1xuICAgICAgICAgICAgLy8gRmxhdHRlbiBhbGwgdGhlIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gICAgICAgICAgICBjb25zdCBhbGxEZXByZWNhdGVkRnVuY3Rpb25zID0gW10uY29uY2F0KC4uLmRlcHJlY2F0ZWRGdW5jdGlvbnNGcm9tVmVyc2lvbnMpO1xuICAgICAgICAgICAgbWV0aG9kID0gYWxsRGVwcmVjYXRlZEZ1bmN0aW9ucy5maW5kKChtZXRob2QpID0+IGNoZWNrTWV0aG9kU2lnbmF0dXJlKG1ldGhvZC5zaWcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWV0aG9kO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLmpzLm1hcCIsImltcG9ydCB7IGFwbUFwcElkIH0gZnJvbSAnLi4vYXBwJztcbi8vIEFCSXNcbmltcG9ydCBhYmlBcmFnb25BQ0wgZnJvbSAnLi9hYmkvQUNMLmpzb24nO1xuaW1wb3J0IGFiaUFyYWdvbktlcm5lbCBmcm9tICcuL2FiaS9LZXJuZWwuanNvbic7XG5pbXBvcnQgYWJpQXJhZ29uRVZNU2NyaXB0UmVnaXN0cnkgZnJvbSAnLi9hYmkvRVZNU2NyaXB0UmVnaXN0cnkuanNvbic7XG5pbXBvcnQgYWJpQXBtUmVnaXN0cnkgZnJvbSAnLi9hYmkvQVBNUmVnaXN0cnkuanNvbic7XG5pbXBvcnQgYWJpQXBtUmVwbyBmcm9tICcuL2FiaS9SZXBvLmpzb24nO1xuaW1wb3J0IGFiaUFwbUVuc1N1YmRvbWFpblJlZ2lzdHJhciBmcm9tICcuL2FiaS9FTlNTdWJkb21haW5SZWdpc3RyYXIuanNvbic7XG4vLyBBcnRpZmFjdHNcbmltcG9ydCBhcnRpZmFjdHNBcmFnb25BQ0wgZnJvbSAnLi9hcnRpZmFjdHMvYXJhZ29uL0FDTC5qc29uJztcbmltcG9ydCBhcnRpZmFjdHNBcmFnb25LZXJuZWwgZnJvbSAnLi9hcnRpZmFjdHMvYXJhZ29uL0tlcm5lbC5qc29uJztcbmltcG9ydCBhcnRpZmFjdHNBcmFnb25FVk1TY3JpcHRSZWdpc3RyeSBmcm9tICcuL2FydGlmYWN0cy9hcmFnb24vRVZNU2NyaXB0UmVnaXN0cnkuanNvbic7XG5pbXBvcnQgYXJ0aWZhY3RzQXBtUmVnaXN0cnkgZnJvbSAnLi9hcnRpZmFjdHMvYXBtL0FQTVJlZ2lzdHJ5Lmpzb24nO1xuaW1wb3J0IGFydGlmYWN0c0FwbVJlcG8gZnJvbSAnLi9hcnRpZmFjdHMvYXBtL1JlcG8uanNvbic7XG5pbXBvcnQgYXJ0aWZhY3RzQXBtRW5zU3ViZG9tYWluUmVnaXN0cmFyIGZyb20gJy4vYXJ0aWZhY3RzL2FwbS9FTlNTdWJkb21haW5SZWdpc3RyYXIuanNvbic7XG5jb25zdCBBQklTID0ge1xuICAgICdhcmFnb24vQUNMJzogYWJpQXJhZ29uQUNMLmFiaSxcbiAgICAnYXJhZ29uL0tlcm5lbCc6IGFiaUFyYWdvbktlcm5lbC5hYmksXG4gICAgJ2FyYWdvbi9FVk0gU2NyaXB0IFJlZ2lzdHJ5JzogYWJpQXJhZ29uRVZNU2NyaXB0UmVnaXN0cnkuYWJpLFxuICAgICdhcG0vQVBNIFJlZ2lzdHJ5JzogYWJpQXBtUmVnaXN0cnkuYWJpLFxuICAgICdhcG0vUmVwbyc6IGFiaUFwbVJlcG8uYWJpLFxuICAgICdhcG0vRU5TIFN1YmRvbWFpbiBSZWdpc3RyYXInOiBhYmlBcG1FbnNTdWJkb21haW5SZWdpc3RyYXIuYWJpLFxufTtcbmNvbnN0IEFSVElGQUNUUyA9IHtcbiAgICAnYXJhZ29uL0FDTCc6IGFydGlmYWN0c0FyYWdvbkFDTCxcbiAgICAnYXJhZ29uL0tlcm5lbCc6IGFydGlmYWN0c0FyYWdvbktlcm5lbCxcbiAgICAnYXJhZ29uL0VWTSBTY3JpcHQgUmVnaXN0cnknOiBhcnRpZmFjdHNBcmFnb25FVk1TY3JpcHRSZWdpc3RyeSxcbiAgICAnYXBtL0FQTSBSZWdpc3RyeSc6IGFydGlmYWN0c0FwbVJlZ2lzdHJ5LFxuICAgICdhcG0vUmVwbyc6IGFydGlmYWN0c0FwbVJlcG8sXG4gICAgJ2FwbS9FTlMgU3ViZG9tYWluIFJlZ2lzdHJhcic6IGFydGlmYWN0c0FwbUVuc1N1YmRvbWFpblJlZ2lzdHJhcixcbn07XG5jb25zdCBTWVNURU1fQVBQX01BUFBJTkdTID0gbmV3IE1hcChbXG4gICAgW2FwbUFwcElkKCdhY2wnKSwgJ0FDTCddLFxuICAgIFthcG1BcHBJZCgnZXZtcmVnJyksICdFVk0gU2NyaXB0IFJlZ2lzdHJ5J10sXG4gICAgW2FwbUFwcElkKCdrZXJuZWwnKSwgJ0tlcm5lbCddLFxuXSk7XG5jb25zdCBBUE1fQVBQX01BUFBJTkdTID0gbmV3IE1hcChbXG4gICAgW2FwbUFwcElkKCdhcG0tcmVnaXN0cnknKSwgJ0FQTSBSZWdpc3RyeSddLFxuICAgIFthcG1BcHBJZCgnYXBtLXJlcG8nKSwgJ1JlcG8nXSxcbiAgICBbYXBtQXBwSWQoJ2FwbS1lbnNzdWInKSwgJ0VOUyBTdWJkb21haW4gUmVnaXN0cmFyJ10sXG4gICAgLy8gU3VwcG9ydCBvcGVuLmFyYWdvbnBtLmV0aCdzIG5hdGl2ZSBwYWNrYWdlc1xuICAgIC8vIE5vdGUgdGhhdCB0aGVzZSB3ZXJlIGVycm9uZW91c2x5IGRlcGxveWVkIG9uIHRoZSBvcGVuLmFyYWdvbnBtLmV0aCBpbnN0YW5jZSByYXRoZXIgdGhhblxuICAgIC8vIHJldXNpbmcgdGhlIGFyYWdvbnBtLmV0aCB2ZXJzaW9uc1xuICAgIFthcG1BcHBJZCgnYXBtLXJlZ2lzdHJ5Lm9wZW4nKSwgJ0FQTSBSZWdpc3RyeSddLFxuICAgIFthcG1BcHBJZCgnYXBtLXJlcG8ub3BlbicpLCAnUmVwbyddLFxuICAgIFthcG1BcHBJZCgnYXBtLWVuc3N1Yi5vcGVuJyksICdFTlMgU3ViZG9tYWluIFJlZ2lzdHJhciddLFxuICAgIC8vIFN1cHBvcnQgaGF0Y2guYXJhZ29ucG0uZXRoJ3MgbmF0aXZlIHBhY2thZ2VzIChzZWUgbm90ZSBhYm92ZSBmb3IgYG9wZW4uYXJhZ29ucG0uZXRoYClcbiAgICBbYXBtQXBwSWQoJ2FwbS1yZWdpc3RyeS5oYXRjaCcpLCAnQVBNIFJlZ2lzdHJ5J10sXG4gICAgW2FwbUFwcElkKCdhcG0tcmVwby5oYXRjaCcpLCAnUmVwbyddLFxuICAgIFthcG1BcHBJZCgnYXBtLWVuc3N1Yi5oYXRjaCcpLCAnRU5TIFN1YmRvbWFpbiBSZWdpc3RyYXInXSxcbl0pO1xuY29uc3QgQVBQX05BTUVTUEFDRV9NQVBQSU5HUyA9IG5ldyBNYXAoW1xuICAgIFsnYXJhZ29uJywgU1lTVEVNX0FQUF9NQVBQSU5HU10sXG4gICAgWydhcG0nLCBBUE1fQVBQX01BUFBJTkdTXSxcbl0pO1xuZXhwb3J0IGNvbnN0IGdldEFiaSA9IChuYW1lKSA9PiBBQklTW25hbWVdIHx8IG51bGw7XG5leHBvcnQgY29uc3QgZ2V0QXJ0aWZhY3QgPSAobmFtZSkgPT4gQVJUSUZBQ1RTW25hbWVdIHx8IG51bGw7XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXBwSW5mbyhhcHBJZCwgbmFtZXNwYWNlKSB7XG4gICAgY29uc3QgbmFtZU1hcHBpbmcgPSBBUFBfTkFNRVNQQUNFX01BUFBJTkdTLmdldChuYW1lc3BhY2UpO1xuICAgIGlmICghbmFtZU1hcHBpbmcgfHwgIW5hbWVNYXBwaW5nLmhhcyhhcHBJZCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGFwcE5hbWUgPSBuYW1lTWFwcGluZy5nZXQoYXBwSWQpO1xuICAgIGNvbnN0IGFwcCA9IGAke25hbWVzcGFjZX0vJHthcHBOYW1lfWA7XG4gICAgY29uc3QgYWJpID0gZ2V0QWJpKGFwcCk7XG4gICAgY29uc3QgYXJ0aWZhY3QgPSBnZXRBcnRpZmFjdChhcHApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFiaSxcbiAgICAgICAgYXBwTmFtZSxcbiAgICAgICAgLi4uYXJ0aWZhY3QsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNBcHBJbmZvKGFwcElkLCBuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBtYXBwaW5nID0gQVBQX05BTUVTUEFDRV9NQVBQSU5HUy5nZXQobmFtZXNwYWNlKTtcbiAgICBpZiAobWFwcGluZylcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4obWFwcGluZykgJiYgbWFwcGluZy5oYXMoYXBwSWQpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZXMuanMubWFwIiwiaW1wb3J0IHsgZ2V0QXBwSW5mbyB9IGZyb20gJy4vaW50ZXJmYWNlcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0QXJhZ29uT3NJbnRlcm5hbEFwcEluZm8oYXBwSWQpIHtcbiAgICByZXR1cm4gZ2V0QXBwSW5mbyhhcHBJZCwgJ2FyYWdvbicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFwbUludGVybmFsQXBwSW5mbyhhcHBJZCkge1xuICAgIHJldHVybiBnZXRBcHBJbmZvKGFwcElkLCAnYXBtJyk7XG59XG5leHBvcnQgeyBoYXNBcHBJbmZvLCBnZXRBcHBJbmZvIH0gZnJvbSAnLi9pbnRlcmZhY2VzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IHV0aWxzIGFzIGV0aGVyc1V0aWxzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IGdldEFwbUludGVybmFsQXBwSW5mbywgZ2V0QXJhZ29uT3NJbnRlcm5hbEFwcEluZm8sIGhhc0FwcEluZm8sIH0gZnJvbSAnLi9vdmVycmlkZXMvaW5kZXgnO1xuaW1wb3J0IHsgREVGQVVMVF9JUEZTX0dBVEVXQVkgfSBmcm9tICcuLi9wYXJhbXMnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTWV0YWRhdGEobmFtZSwgbWV0YWRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShtZXRhZGF0YSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHBhcnNlICR7bmFtZX0gZmlsZSwgaW52YWxpZCBKU09OLmApO1xuICAgIH1cbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE1ldGFkYXRhKGZpbGVOYW1lLCBjb250ZW50VXJpKSB7XG4gICAgY29uc3QgY29udGVudEhhc2hSZWdFeCA9IGNvbnRlbnRVcmkubWF0Y2goL2lwZnM6KC4qKS8pO1xuICAgIGlmIChjb250ZW50SGFzaFJlZ0V4KSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGAke0RFRkFVTFRfSVBGU19HQVRFV0FZfS9pcGZzLyR7Y29udGVudEhhc2hSZWdFeFsxXX0vJHtmaWxlTmFtZX1gO1xuICAgICAgICBsZXQgbWV0YWRhdGE7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtZXRhZGF0YSA9IGF3YWl0IGV0aGVyc1V0aWxzLmZldGNoSnNvbih1cmwpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmZXRjaCAke3VybH0sIGZhaWxlZCB3aXRoIGVycm9yOiB7ZXJyb3J9LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVNZXRhZGF0YShmaWxlTmFtZSwgY29udGVudFVyaSwgbWV0YWRhdGEpIHtcbiAgICBpZiAobWV0YWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlTWV0YWRhdGEoZmlsZU5hbWUsIG1ldGFkYXRhKTtcbiAgICB9XG4gICAgaWYgKGNvbnRlbnRVcmkpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoTWV0YWRhdGEoZmlsZU5hbWUsIGNvbnRlbnRVcmkpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZU1hbmlmZXN0KGRhdGEpIHtcbiAgICByZXR1cm4gcmVzb2x2ZU1ldGFkYXRhKCdtYW5pZmVzdC5qc29uJywgZGF0YS5jb250ZW50VXJpLCBkYXRhLm1hbmlmZXN0KTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXNvbHZlQXJ0aWZhY3QoZGF0YSkge1xuICAgIGlmIChoYXNBcHBJbmZvKGRhdGEuYXBwSWQsICdhcG0nKSkge1xuICAgICAgICByZXR1cm4gZ2V0QXBtSW50ZXJuYWxBcHBJbmZvKGRhdGEuYXBwSWQpO1xuICAgIH1cbiAgICBpZiAoaGFzQXBwSW5mbyhkYXRhLmFwcElkLCAnYXJhZ29uJykpIHtcbiAgICAgICAgcmV0dXJuIGdldEFyYWdvbk9zSW50ZXJuYWxBcHBJbmZvKGRhdGEuYXBwSWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzb2x2ZU1ldGFkYXRhKCdhcnRpZmFjdC5qc29uJywgZGF0YS5jb250ZW50VXJpLCBkYXRhLmFydGlmYWN0KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1ldGFkYXRhLmpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX29yZ2FuaXphdGlvbjtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFBlcm1pc3Npb24ge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIG9yZ2FuaXphdGlvbikge1xuICAgICAgICBfb3JnYW5pemF0aW9uLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9vcmdhbml6YXRpb24sIG9yZ2FuaXphdGlvbik7XG4gICAgICAgIHRoaXMuYWxsb3dlZCA9IGRhdGEuYWxsb3dlZDtcbiAgICAgICAgdGhpcy5hcHBBZGRyZXNzID0gZGF0YS5hcHBBZGRyZXNzO1xuICAgICAgICB0aGlzLmdyYW50ZWVBZGRyZXNzID0gZGF0YS5ncmFudGVlQWRkcmVzcztcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBkYXRhLnBhcmFtcztcbiAgICAgICAgdGhpcy5yb2xlSGFzaCA9IGRhdGEucm9sZUhhc2g7XG4gICAgfVxuICAgIG9yZ0Nvbm5lY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX29yZ2FuaXphdGlvbikuY29ubmVjdGlvbi5vcmdDb25uZWN0b3I7XG4gICAgfVxuICAgIGFzeW5jIGFwcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3JnQ29ubmVjdG9yKCkuYXBwQnlBZGRyZXNzKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX29yZ2FuaXphdGlvbiksIHRoaXMuYXBwQWRkcmVzcyk7XG4gICAgfVxuICAgIGFzeW5jIHJvbGUoKSB7XG4gICAgICAgIGNvbnN0IHJvbGVzID0gYXdhaXQgdGhpcy5vcmdDb25uZWN0b3IoKS5yb2xlc0ZvckFkZHJlc3MoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfb3JnYW5pemF0aW9uKSwgdGhpcy5hcHBBZGRyZXNzKTtcbiAgICAgICAgcmV0dXJuIHJvbGVzLmZpbmQoKHJvbGUpID0+IHJvbGUuaGFzaCA9PT0gdGhpcy5yb2xlSGFzaCk7XG4gICAgfVxufVxuX29yZ2FuaXphdGlvbiA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1QZXJtaXNzaW9uLmpzLm1hcCIsImltcG9ydCB7IHJlc29sdmVBcnRpZmFjdCB9IGZyb20gJy4uL3V0aWxzL21ldGFkYXRhJztcbmltcG9ydCBQZXJtaXNzaW9uIGZyb20gJy4vUGVybWlzc2lvbic7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb2xlIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBtZXRhZGF0YSwgb3JnYW5pemF0aW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyByb2xlcyB9ID0gbWV0YWRhdGFbMF07XG4gICAgICAgIGNvbnN0IHJvbGUgPSByb2xlcyA9PT0gbnVsbCB8fCByb2xlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9sZXMuZmluZCgocm9sZSkgPT4gcm9sZS5ieXRlcyA9PT0gZGF0YS5oYXNoKTtcbiAgICAgICAgdGhpcy5hcHBBZGRyZXNzID0gZGF0YS5hcHBBZGRyZXNzO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gcm9sZSA9PT0gbnVsbCB8fCByb2xlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb2xlLm5hbWU7XG4gICAgICAgIHRoaXMuaGFzaCA9IGRhdGEuaGFzaDtcbiAgICAgICAgdGhpcy5tYW5hZ2VyID0gZGF0YS5tYW5hZ2VyO1xuICAgICAgICB0aGlzLm5hbWUgPSByb2xlID09PSBudWxsIHx8IHJvbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvbGUuaWQ7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcm9sZSA9PT0gbnVsbCB8fCByb2xlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb2xlLnBhcmFtcztcbiAgICAgICAgdGhpcy5wZXJtaXNzaW9ucyA9IChfYSA9IGRhdGEuZ3JhbnRlZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKGdyYW50ZWUpID0+IG5ldyBQZXJtaXNzaW9uKGdyYW50ZWUsIG9yZ2FuaXphdGlvbikpO1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgY3JlYXRlKGRhdGEsIG9yZ2FuaXphdGlvbikge1xuICAgICAgICBjb25zdCBhcnRpZmFjdCA9IGF3YWl0IHJlc29sdmVBcnRpZmFjdChkYXRhKTtcbiAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBbYXJ0aWZhY3RdO1xuICAgICAgICByZXR1cm4gbmV3IFJvbGUoZGF0YSwgbWV0YWRhdGEsIG9yZ2FuaXphdGlvbik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Um9sZS5qcy5tYXAiLCJpbXBvcnQgeyBSb2xlLCB9IGZyb20gJ0BhcmFnb24vY29ubmVjdC1jb3JlJztcbmFzeW5jIGZ1bmN0aW9uIF9wYXJzZVJvbGUocm9sZSwgYXBwLCBvcmdhbml6YXRpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBncmFudGVlcyA9IChfYSA9IHJvbGUgPT09IG51bGwgfHwgcm9sZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcm9sZS5ncmFudGVlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgocGVybWlzc2lvbikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoe1xuICAgICAgICAgICAgYXBwQWRkcmVzczogcGVybWlzc2lvbiA9PT0gbnVsbCB8fCBwZXJtaXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJtaXNzaW9uLmFwcEFkZHJlc3MsXG4gICAgICAgICAgICBhbGxvd2VkOiBwZXJtaXNzaW9uID09PSBudWxsIHx8IHBlcm1pc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcm1pc3Npb24uYWxsb3dlZCxcbiAgICAgICAgICAgIGdyYW50ZWVBZGRyZXNzOiBwZXJtaXNzaW9uID09PSBudWxsIHx8IHBlcm1pc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcm1pc3Npb24uZ3JhbnRlZUFkZHJlc3MsXG4gICAgICAgICAgICBwYXJhbXM6ICgoX2EgPSBwZXJtaXNzaW9uID09PSBudWxsIHx8IHBlcm1pc3Npb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBlcm1pc3Npb24ucGFyYW1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKChwYXJhbSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudElkOiBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0uYXJndW1lbnRJZCxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0ub3BlcmF0aW9uVHlwZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudFZhbHVlOiBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0uYXJndW1lbnRWYWx1ZSxcbiAgICAgICAgICAgIH0pKSkgfHwgW10sXG4gICAgICAgICAgICByb2xlSGFzaDogcGVybWlzc2lvbiA9PT0gbnVsbCB8fCBwZXJtaXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJtaXNzaW9uLnJvbGVIYXNoLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCByb2xlRGF0YSA9IHtcbiAgICAgICAgYXBwQWRkcmVzczogcm9sZSA9PT0gbnVsbCB8fCByb2xlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb2xlLmFwcEFkZHJlc3MsXG4gICAgICAgIGFwcElkOiBhcHAgPT09IG51bGwgfHwgYXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHAuYXBwSWQsXG4gICAgICAgIGFydGlmYWN0OiAoX2IgPSBhcHAgPT09IG51bGwgfHwgYXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHAudmVyc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFydGlmYWN0LFxuICAgICAgICBjb250ZW50VXJpOiAoX2MgPSBhcHAgPT09IG51bGwgfHwgYXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHAudmVyc2lvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNvbnRlbnRVcmksXG4gICAgICAgIGdyYW50ZWVzOiBncmFudGVlcyB8fCBbXSxcbiAgICAgICAgaGFzaDogcm9sZSA9PT0gbnVsbCB8fCByb2xlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByb2xlLnJvbGVIYXNoLFxuICAgICAgICBtYW5hZ2VyOiByb2xlID09PSBudWxsIHx8IHJvbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvbGUubWFuYWdlcixcbiAgICB9O1xuICAgIHJldHVybiBSb2xlLmNyZWF0ZShyb2xlRGF0YSwgb3JnYW5pemF0aW9uKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVJvbGUocmVzdWx0LCBvcmdhbml6YXRpb24pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGFwcCA9IChfYSA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwO1xuICAgIGNvbnN0IHJvbGUgPSAoX2IgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJvbGU7XG4gICAgaWYgKCFhcHAgfHwgIXJvbGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2Ugcm9sZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIF9wYXJzZVJvbGUocm9sZSwgYXBwLCBvcmdhbml6YXRpb24pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlUm9sZXMocmVzdWx0LCBvcmdhbml6YXRpb24pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXBwID0gKF9hID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHA7XG4gICAgY29uc3Qgcm9sZXMgPSBhcHAgPT09IG51bGwgfHwgYXBwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcHAucm9sZXM7XG4gICAgaWYgKCFhcHAgfHwgIUFycmF5LmlzQXJyYXkocm9sZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIHJvbGVzLicpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocm9sZXMubWFwKGFzeW5jIChyb2xlKSA9PiB7XG4gICAgICAgIHJldHVybiBfcGFyc2VSb2xlKHJvbGUsIGFwcCwgb3JnYW5pemF0aW9uKTtcbiAgICB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb2xlcy5qcy5tYXAiLCJpbXBvcnQgeyBQZXJtaXNzaW9uIH0gZnJvbSAnQGFyYWdvbi9jb25uZWN0LWNvcmUnO1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUGVybWlzc2lvbnMocmVzdWx0LCBvcmdhbml6YXRpb24pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHBlcm1pc3Npb25zID0gKF9iID0gKF9hID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcmdhbml6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wZXJtaXNzaW9ucztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocGVybWlzc2lvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHBhcnNlIHBlcm1pc3Npb25zLicpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhcyA9IHBlcm1pc3Npb25zLm1hcCgocGVybWlzc2lvbikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKHtcbiAgICAgICAgICAgIGFwcEFkZHJlc3M6IHBlcm1pc3Npb24gPT09IG51bGwgfHwgcGVybWlzc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVybWlzc2lvbi5hcHBBZGRyZXNzLFxuICAgICAgICAgICAgYWxsb3dlZDogcGVybWlzc2lvbiA9PT0gbnVsbCB8fCBwZXJtaXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJtaXNzaW9uLmFsbG93ZWQsXG4gICAgICAgICAgICBncmFudGVlQWRkcmVzczogcGVybWlzc2lvbiA9PT0gbnVsbCB8fCBwZXJtaXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJtaXNzaW9uLmdyYW50ZWVBZGRyZXNzLFxuICAgICAgICAgICAgcGFyYW1zOiAoKF9iID0gKF9hID0gcGVybWlzc2lvbiA9PT0gbnVsbCB8fCBwZXJtaXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJtaXNzaW9uLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIChwYXJhbSkgPT4gKHtcbiAgICAgICAgICAgICAgICBhcmd1bWVudElkOiBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0uYXJndW1lbnRJZCxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25UeXBlOiBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0ub3BlcmF0aW9uVHlwZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudFZhbHVlOiBwYXJhbSA9PT0gbnVsbCB8fCBwYXJhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW0uYXJndW1lbnRWYWx1ZSxcbiAgICAgICAgICAgIH0pKSkgfHwgW10sXG4gICAgICAgICAgICByb2xlSGFzaDogcGVybWlzc2lvbiA9PT0gbnVsbCB8fCBwZXJtaXNzaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwZXJtaXNzaW9uLnJvbGVIYXNoLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBhbGxvd2VkUGVybWlzc2lvbnMgPSBkYXRhcy5maWx0ZXIoKGRhdGEpID0+IGRhdGEuYWxsb3dlZCk7XG4gICAgcmV0dXJuIGFsbG93ZWRQZXJtaXNzaW9ucy5tYXAoKGRhdGEpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQZXJtaXNzaW9uKGRhdGEsIG9yZ2FuaXphdGlvbik7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZXJtaXNzaW9ucy5qcy5tYXAiLCJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwLCB2YWx1ZSkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gc2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICAgIH1cbiAgICBwcml2YXRlTWFwLnNldChyZWNlaXZlciwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBwcml2YXRlTWFwKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBnZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuICAgIHJldHVybiBwcml2YXRlTWFwLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9tZXRhZGF0YTtcbmltcG9ydCB7IHJlc29sdmVNYW5pZmVzdCwgcmVzb2x2ZUFydGlmYWN0IH0gZnJvbSAnLi4vdXRpbHMvbWV0YWRhdGEnO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBtZXRhZGF0YSwgb3JnYW5pemF0aW9uKSB7XG4gICAgICAgIF9tZXRhZGF0YS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfbWV0YWRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gZGF0YS5hZGRyZXNzO1xuICAgICAgICB0aGlzLmFwcElkID0gZGF0YS5hcHBJZDtcbiAgICAgICAgdGhpcy5jb2RlQWRkcmVzcyA9IGRhdGEuY29kZUFkZHJlc3M7XG4gICAgICAgIHRoaXMuY29udGVudFVyaSA9IGRhdGEuY29udGVudFVyaTtcbiAgICAgICAgdGhpcy5pc0ZvcndhcmRlciA9IGRhdGEuaXNGb3J3YXJkZXI7XG4gICAgICAgIHRoaXMuaXNVcGdyYWRlYWJsZSA9IGRhdGEuaXNVcGdyYWRlYWJsZTtcbiAgICAgICAgdGhpcy5rZXJuZWxBZGRyZXNzID0gZGF0YS5rZXJuZWxBZGRyZXNzO1xuICAgICAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgICAgIHRoaXMub3JnYW5pemF0aW9uID0gb3JnYW5pemF0aW9uO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gZGF0YS5yZWdpc3RyeTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeUFkZHJlc3MgPSBkYXRhLnJlZ2lzdHJ5QWRkcmVzcztcbiAgICAgICAgdGhpcy5yZXBvQWRkcmVzcyA9IGRhdGEucmVwb0FkZHJlc3M7XG4gICAgICAgIHRoaXMudmVyc2lvbiA9IGRhdGEudmVyc2lvbjtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIGNyZWF0ZShkYXRhLCBvcmdhbml6YXRpb24pIHtcbiAgICAgICAgY29uc3QgYXJ0aWZhY3QgPSBhd2FpdCByZXNvbHZlQXJ0aWZhY3QoZGF0YSk7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gYXdhaXQgcmVzb2x2ZU1hbmlmZXN0KGRhdGEpO1xuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IFthcnRpZmFjdCwgbWFuaWZlc3RdO1xuICAgICAgICByZXR1cm4gbmV3IEFwcChkYXRhLCBtZXRhZGF0YSwgb3JnYW5pemF0aW9uKTtcbiAgICB9XG4gICAgb3JnQ29ubmVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmdhbml6YXRpb24uY29ubmVjdGlvbi5vcmdDb25uZWN0b3I7XG4gICAgfVxuICAgIGFzeW5jIHJlcG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yZ0Nvbm5lY3RvcigpLnJlcG9Gb3JBcHAodGhpcy5vcmdhbml6YXRpb24sIHRoaXMuYWRkcmVzcyk7XG4gICAgfVxuICAgIGFzeW5jIHJvbGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmdDb25uZWN0b3IoKS5yb2xlc0ZvckFkZHJlc3ModGhpcy5vcmdhbml6YXRpb24sIHRoaXMuYWRkcmVzcyk7XG4gICAgfVxuICAgIGdldCBhcnRpZmFjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX21ldGFkYXRhKVswXTtcbiAgICB9XG4gICAgZ2V0IG1hbmlmZXN0KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfbWV0YWRhdGEpWzFdO1xuICAgIH1cbiAgICBnZXQgYWJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnRpZmFjdC5hYmk7XG4gICAgfVxuICAgIGdldCBpbnRlbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnRpZmFjdC5mdW5jdGlvbnM7XG4gICAgfVxuICAgIGdldCBkZXByZWNhdGVkSW50ZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJ0aWZhY3QuZGVwcmVjYXRlZEZ1bmN0aW9ucztcbiAgICB9XG4gICAgZ2V0IGFwcE5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFydGlmYWN0LmFwcE5hbWU7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnRoaXMsXG4gICAgICAgICAgICAvLyBPcmdhbml6YXRpb24gY3JlYXRlcyBhIGN5Y2xpbmcgcmVmZXJlbmNlIHRoYXQgbWFrZXNcbiAgICAgICAgICAgIC8vIHRoZSBvYmplY3QgaW1wb3NzaWJsZSB0byBwYXNzIHRocm91Z2ggSlNPTi5zdHJpbmdpZnkoKS5cbiAgICAgICAgICAgIG9yZ2FuaXphdGlvbjogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5fbWV0YWRhdGEgPSBuZXcgV2Vha01hcCgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXBwLmpzLm1hcCIsImltcG9ydCB7IEFwcCB9IGZyb20gJ0BhcmFnb24vY29ubmVjdC1jb3JlJztcbmFzeW5jIGZ1bmN0aW9uIF9wYXJzZUFwcChhcHAsIG9yZ2FuaXphdGlvbikge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qLCBfaztcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICBhZGRyZXNzOiBhcHAuYWRkcmVzcyxcbiAgICAgICAgYXBwSWQ6IGFwcC5hcHBJZCxcbiAgICAgICAgYXJ0aWZhY3Q6IChfYSA9IGFwcC52ZXJzaW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXJ0aWZhY3QsXG4gICAgICAgIGNvZGVBZGRyZXNzOiBhcHAuaW1wbGVtZW50YXRpb24uYWRkcmVzcyxcbiAgICAgICAgY29udGVudFVyaTogKF9iID0gYXBwLnZlcnNpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50VXJpLFxuICAgICAgICBpc0ZvcndhcmRlcjogYXBwLmlzRm9yd2FyZGVyLFxuICAgICAgICBpc1VwZ3JhZGVhYmxlOiBhcHAuaXNVcGdyYWRlYWJsZSxcbiAgICAgICAga2VybmVsQWRkcmVzczogKF9jID0gYXBwLm9yZ2FuaXphdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFkZHJlc3MsXG4gICAgICAgIG1hbmlmZXN0OiAoX2QgPSBhcHAudmVyc2lvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm1hbmlmZXN0LFxuICAgICAgICBuYW1lOiBhcHAucmVwb05hbWUsXG4gICAgICAgIHJlZ2lzdHJ5OiAoX2YgPSAoX2UgPSBhcHAucmVwbykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlZ2lzdHJ5KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YubmFtZSxcbiAgICAgICAgcmVnaXN0cnlBZGRyZXNzOiAoX2ggPSAoX2cgPSBhcHAucmVwbykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnJlZ2lzdHJ5KSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guYWRkcmVzcyxcbiAgICAgICAgcmVwb0FkZHJlc3M6IChfaiA9IGFwcC5yZXBvKSA9PT0gbnVsbCB8fCBfaiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2ouYWRkcmVzcyxcbiAgICAgICAgdmVyc2lvbjogKF9rID0gYXBwLnZlcnNpb24pID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5zZW1hbnRpY1ZlcnNpb24ucmVwbGFjZSgvLC9nLCAnLicpLFxuICAgIH07XG4gICAgcmV0dXJuIEFwcC5jcmVhdGUoZGF0YSwgb3JnYW5pemF0aW9uKTtcbn1cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZUFwcChyZXN1bHQsIG9yZ2FuaXphdGlvbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhcHAgPSAoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFwcDtcbiAgICBpZiAoIWFwcCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBhcHAuJyk7XG4gICAgfVxuICAgIHJldHVybiBfcGFyc2VBcHAoYXBwLCBvcmdhbml6YXRpb24pO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlQXBwcyhyZXN1bHQsIG9yZ2FuaXphdGlvbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBkYXRhID0gcmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmRhdGE7XG4gICAgY29uc3QgYXBwcyA9IChfYSA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5vcmdhbml6YXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBzO1xuICAgIGlmICgoZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm9yZ2FuaXphdGlvbikgPT09IG51bGwgfHwgKGFwcHMgPT09IG51bGwgfHwgYXBwcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXBwcy5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYXBwcyBmb3VuZCB3aXRoIHRoZSBjdXJyZW50IGZpbHRlcnMuJyk7XG4gICAgfVxuICAgIGlmICghYXBwcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBwYXJzZSBhcHBzLicpO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXBwcy5tYXAoYXN5bmMgKGFwcCkgPT4ge1xuICAgICAgICByZXR1cm4gX3BhcnNlQXBwKGFwcCwgb3JnYW5pemF0aW9uKTtcbiAgICB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBzLmpzLm1hcCIsInZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXAsIHZhbHVlKSB7XG4gICAgaWYgKCFwcml2YXRlTWFwLmhhcyhyZWNlaXZlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImF0dGVtcHRlZCB0byBzZXQgcHJpdmF0ZSBmaWVsZCBvbiBub24taW5zdGFuY2VcIik7XG4gICAgfVxuICAgIHByaXZhdGVNYXAuc2V0KHJlY2VpdmVyLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHByaXZhdGVNYXApIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHByaXZhdGVNYXAuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX21ldGFkYXRhO1xuaW1wb3J0IHsgcmVzb2x2ZU1ldGFkYXRhLCByZXNvbHZlTWFuaWZlc3QgfSBmcm9tICcuLi91dGlscy9tZXRhZGF0YSc7XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZXBvIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBtZXRhZGF0YSwgb3JnYW5pemF0aW9uKSB7XG4gICAgICAgIF9tZXRhZGF0YS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfbWV0YWRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfbWV0YWRhdGEsIG1ldGFkYXRhKTtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gZGF0YS5hZGRyZXNzO1xuICAgICAgICB0aGlzLmNvbnRlbnRVcmkgPSBkYXRhLmNvbnRlbnRVcmk7XG4gICAgICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IGRhdGEucmVnaXN0cnk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlBZGRyZXNzID0gZGF0YS5yZWdpc3RyeUFkZHJlc3M7XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBjcmVhdGUoZGF0YSwgb3JnYW5pemF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGFydGlmYWN0ID0gYXdhaXQgcmVzb2x2ZU1ldGFkYXRhKCdhcnRpZmFjdC5qc29uJywgZGF0YS5jb250ZW50VXJpLCBkYXRhLmFydGlmYWN0KTtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBhd2FpdCByZXNvbHZlTWFuaWZlc3QoZGF0YSk7XG4gICAgICAgIGNvbnN0IG1ldGFkYXRhID0gW2FydGlmYWN0LCBtYW5pZmVzdF07XG4gICAgICAgIHJldHVybiBuZXcgUmVwbyhkYXRhLCBtZXRhZGF0YSwgb3JnYW5pemF0aW9uKTtcbiAgICB9XG4gICAgZ2V0IGFydGlmYWN0KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfbWV0YWRhdGEpWzBdO1xuICAgIH1cbiAgICBnZXQgbWFuaWZlc3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9tZXRhZGF0YSlbMV07XG4gICAgfVxuICAgIGdldCByb2xlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJ0aWZhY3Qucm9sZXM7XG4gICAgfVxufVxuX21ldGFkYXRhID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJlcG8uanMubWFwIiwiaW1wb3J0IHsgUmVwbyB9IGZyb20gJ0BhcmFnb24vY29ubmVjdC1jb3JlJztcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVJlcG8ocmVzdWx0LCBvcmdhbml6YXRpb24pIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgY29uc3QgcmVwbyA9IChfYiA9IChfYSA9IHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVwbztcbiAgICBpZiAoIXJlcG8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcGFyc2UgcmVwby4nKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHtcbiAgICAgICAgYWRkcmVzczogcmVwbyA9PT0gbnVsbCB8fCByZXBvID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXBvLmFkZHJlc3MsXG4gICAgICAgIGFydGlmYWN0OiAoX2MgPSByZXBvID09PSBudWxsIHx8IHJlcG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcG8ubGFzdFZlcnNpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hcnRpZmFjdCxcbiAgICAgICAgY29udGVudFVyaTogKF9kID0gcmVwbyA9PT0gbnVsbCB8fCByZXBvID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXBvLmxhc3RWZXJzaW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY29udGVudFVyaSxcbiAgICAgICAgbWFuaWZlc3Q6IChfZSA9IHJlcG8gPT09IG51bGwgfHwgcmVwbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVwby5sYXN0VmVyc2lvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLm1hbmlmZXN0LFxuICAgICAgICBuYW1lOiByZXBvID09PSBudWxsIHx8IHJlcG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcG8ubmFtZSxcbiAgICAgICAgcmVnaXN0cnk6IChfZiA9IHJlcG8gPT09IG51bGwgfHwgcmVwbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVwby5yZWdpc3RyeSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLm5hbWUsXG4gICAgICAgIHJlZ2lzdHJ5QWRkcmVzczogKF9nID0gcmVwbyA9PT0gbnVsbCB8fCByZXBvID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXBvLnJlZ2lzdHJ5KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuYWRkcmVzcyxcbiAgICB9O1xuICAgIHJldHVybiBSZXBvLmNyZWF0ZShkYXRhLCBvcmdhbml6YXRpb24pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVwb3MuanMubWFwIiwidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfZ3FsO1xuaW1wb3J0IHsgdG9OZXR3b3JrLCB9IGZyb20gJ0BhcmFnb24vY29ubmVjdC1jb3JlJztcbmltcG9ydCAqIGFzIHF1ZXJpZXMgZnJvbSAnLi9xdWVyaWVzJztcbmltcG9ydCBHcmFwaFFMV3JhcHBlciBmcm9tICcuL2NvcmUvR3JhcGhRTFdyYXBwZXInO1xuaW1wb3J0IHsgcGFyc2VBcHAsIHBhcnNlQXBwcywgcGFyc2VQZXJtaXNzaW9ucywgcGFyc2VSZXBvLCBwYXJzZVJvbGVzLCB9IGZyb20gJy4vcGFyc2Vycyc7XG5mdW5jdGlvbiBnZXRPcmdTdWJncmFwaFVybChuZXR3b3JrKSB7XG4gICAgaWYgKG5ldHdvcmsuY2hhaW5JZCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gJ2h0dHBzOi8vYXBpLnRoZWdyYXBoLmNvbS9zdWJncmFwaHMvbmFtZS9hcmFnb24vYXJhZ29uLW1haW5uZXQnO1xuICAgIH1cbiAgICBpZiAobmV0d29yay5jaGFpbklkID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnaHR0cHM6Ly9hcGkudGhlZ3JhcGguY29tL3N1YmdyYXBocy9uYW1lL2FyYWdvbi9hcmFnb24tcmlua2VieSc7XG4gICAgfVxuICAgIGlmIChuZXR3b3JrLmNoYWluSWQgPT09IDEwMCkge1xuICAgICAgICByZXR1cm4gJ2h0dHBzOi8vYXBpLnRoZWdyYXBoLmNvbS9zdWJncmFwaHMvbmFtZS8xaGl2ZS9hcmFnb24teGRhaSc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gYXBwRmlsdGVyc1RvUXVlcnlGaWx0ZXIoYXBwRmlsdGVycykge1xuICAgIGNvbnN0IHF1ZXJ5RmlsdGVyID0ge307XG4gICAgaWYgKGFwcEZpbHRlcnMubmFtZSkge1xuICAgICAgICBxdWVyeUZpbHRlci5yZXBvTmFtZV9pbiA9IGFwcEZpbHRlcnMubmFtZS5tYXAoKG5hbWUpID0+IG5hbWUucmVwbGFjZSgvXFwuYXJhZ29ucG1cXC5ldGgkLywgJycpKTtcbiAgICB9XG4gICAgaWYgKGFwcEZpbHRlcnMuYWRkcmVzcykge1xuICAgICAgICBxdWVyeUZpbHRlci5hZGRyZXNzX2luID0gYXBwRmlsdGVycy5hZGRyZXNzO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnlGaWx0ZXI7XG59XG5jbGFzcyBDb25uZWN0b3JUaGVHcmFwaCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIF9ncWwuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICd0aGVncmFwaCc7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLm5ldHdvcmsgPSB0b05ldHdvcmsoY29uZmlnLm5ldHdvcmspO1xuICAgICAgICBjb25zdCBvcmdTdWJncmFwaFVybCA9IGNvbmZpZy5vcmdTdWJncmFwaFVybCB8fCBnZXRPcmdTdWJncmFwaFVybCh0aGlzLm5ldHdvcmspO1xuICAgICAgICBpZiAoIW9yZ1N1YmdyYXBoVXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBjaGFpbklkICR7dGhpcy5uZXR3b3JrLmNoYWluSWR9IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIFRoZUdyYXBoIGNvbm5lY3Rvci5gKTtcbiAgICAgICAgfVxuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ncWwsIG5ldyBHcmFwaFFMV3JhcHBlcihvcmdTdWJncmFwaFVybCwge1xuICAgICAgICAgICAgcG9sbEludGVydmFsOiBjb25maWcucG9sbEludGVydmFsLFxuICAgICAgICAgICAgdmVyYm9zZTogY29uZmlnLnZlcmJvc2UsXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgY29ubmVjdChjb25uZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbiA9IGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGFzeW5jIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2dxbCkuY2xvc2UoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29ubmVjdGlvbjtcbiAgICB9XG4gICAgYXN5bmMgcm9sZXNGb3JBZGRyZXNzKG9yZ2FuaXphdGlvbiwgYXBwQWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ3FsKS5wZXJmb3JtUXVlcnlXaXRoUGFyc2VyKHF1ZXJpZXMuUk9MRV9CWV9BUFBfQUREUkVTUygncXVlcnknKSwgeyBhcHBBZGRyZXNzOiBhcHBBZGRyZXNzLnRvTG93ZXJDYXNlKCkgfSwgKHJlc3VsdCkgPT4gcGFyc2VSb2xlcyhyZXN1bHQsIG9yZ2FuaXphdGlvbikpO1xuICAgIH1cbiAgICBhc3luYyBwZXJtaXNzaW9uc0Zvck9yZyhvcmdhbml6YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2dxbCkucGVyZm9ybVF1ZXJ5V2l0aFBhcnNlcihxdWVyaWVzLk9SR0FOSVpBVElPTl9QRVJNSVNTSU9OUygncXVlcnknKSwgeyBvcmdBZGRyZXNzOiBvcmdhbml6YXRpb24uYWRkcmVzcy50b0xvd2VyQ2FzZSgpIH0sIChyZXN1bHQpID0+IHBhcnNlUGVybWlzc2lvbnMocmVzdWx0LCBvcmdhbml6YXRpb24pKTtcbiAgICB9XG4gICAgb25QZXJtaXNzaW9uc0Zvck9yZyhvcmdhbml6YXRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ncWwpLnN1YnNjcmliZVRvUXVlcnlXaXRoUGFyc2VyKHF1ZXJpZXMuT1JHQU5JWkFUSU9OX1BFUk1JU1NJT05TKCdzdWJzY3JpcHRpb24nKSwgeyBvcmdBZGRyZXNzOiBvcmdhbml6YXRpb24uYWRkcmVzcy50b0xvd2VyQ2FzZSgpIH0sIGNhbGxiYWNrLCAocmVzdWx0KSA9PiBwYXJzZVBlcm1pc3Npb25zKHJlc3VsdCwgb3JnYW5pemF0aW9uKSk7XG4gICAgfVxuICAgIGFzeW5jIGFwcEJ5QWRkcmVzcyhvcmdhbml6YXRpb24sIGFwcEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2dxbCkucGVyZm9ybVF1ZXJ5V2l0aFBhcnNlcihxdWVyaWVzLkFQUF9CWV9BRERSRVNTKCdxdWVyeScpLCB7IGFwcEFkZHJlc3M6IGFwcEFkZHJlc3MudG9Mb3dlckNhc2UoKSB9LCAocmVzdWx0KSA9PiBwYXJzZUFwcChyZXN1bHQsIG9yZ2FuaXphdGlvbikpO1xuICAgIH1cbiAgICBhc3luYyBhcHBGb3JPcmcob3JnYW5pemF0aW9uLCBmaWx0ZXJzKSB7XG4gICAgICAgIGNvbnN0IGFwcHMgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ncWwpLnBlcmZvcm1RdWVyeVdpdGhQYXJzZXIocXVlcmllcy5PUkdBTklaQVRJT05fQVBQUygncXVlcnknKSwge1xuICAgICAgICAgICAgYXBwRmlsdGVyOiBhcHBGaWx0ZXJzVG9RdWVyeUZpbHRlcihmaWx0ZXJzKSxcbiAgICAgICAgICAgIGZpcnN0OiAxLFxuICAgICAgICAgICAgb3JnQWRkcmVzczogb3JnYW5pemF0aW9uLmFkZHJlc3MudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgfSwgKHJlc3VsdCkgPT4gcGFyc2VBcHBzKHJlc3VsdCwgb3JnYW5pemF0aW9uKSk7XG4gICAgICAgIHJldHVybiBhcHBzWzBdO1xuICAgIH1cbiAgICBvbkFwcEZvck9yZyhvcmdhbml6YXRpb24sIGZpbHRlcnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ncWwpLnN1YnNjcmliZVRvUXVlcnlXaXRoUGFyc2VyKHF1ZXJpZXMuT1JHQU5JWkFUSU9OX0FQUFMoJ3N1YnNjcmlwdGlvbicpLCB7XG4gICAgICAgICAgICBhcHBGaWx0ZXI6IGFwcEZpbHRlcnNUb1F1ZXJ5RmlsdGVyKGZpbHRlcnMpLFxuICAgICAgICAgICAgZmlyc3Q6IDEsXG4gICAgICAgICAgICBvcmdBZGRyZXNzOiBvcmdhbml6YXRpb24uYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICB9LCBjYWxsYmFjaywgYXN5bmMgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXBwcyA9IGF3YWl0IHBhcnNlQXBwcyhyZXN1bHQsIG9yZ2FuaXphdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYXBwc1swXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwcHNGb3JPcmcob3JnYW5pemF0aW9uLCBmaWx0ZXJzKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ncWwpLnBlcmZvcm1RdWVyeVdpdGhQYXJzZXIocXVlcmllcy5PUkdBTklaQVRJT05fQVBQUygncXVlcnknKSwge1xuICAgICAgICAgICAgYXBwRmlsdGVyOiBhcHBGaWx0ZXJzVG9RdWVyeUZpbHRlcihmaWx0ZXJzKSxcbiAgICAgICAgICAgIG9yZ0FkZHJlc3M6IG9yZ2FuaXphdGlvbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIH0sIChyZXN1bHQpID0+IHBhcnNlQXBwcyhyZXN1bHQsIG9yZ2FuaXphdGlvbikpO1xuICAgIH1cbiAgICBvbkFwcHNGb3JPcmcob3JnYW5pemF0aW9uLCBmaWx0ZXJzLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfZ3FsKS5zdWJzY3JpYmVUb1F1ZXJ5V2l0aFBhcnNlcihxdWVyaWVzLk9SR0FOSVpBVElPTl9BUFBTKCdzdWJzY3JpcHRpb24nKSwge1xuICAgICAgICAgICAgYXBwRmlsdGVyOiBhcHBGaWx0ZXJzVG9RdWVyeUZpbHRlcihmaWx0ZXJzKSxcbiAgICAgICAgICAgIG9yZ0FkZHJlc3M6IG9yZ2FuaXphdGlvbi5hZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIH0sIGNhbGxiYWNrLCAocmVzdWx0KSA9PiBwYXJzZUFwcHMocmVzdWx0LCBvcmdhbml6YXRpb24pKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwb0ZvckFwcChvcmdhbml6YXRpb24sIGFwcEFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2dxbCkucGVyZm9ybVF1ZXJ5V2l0aFBhcnNlcihxdWVyaWVzLlJFUE9fQllfQVBQX0FERFJFU1MoJ3F1ZXJ5JyksIHsgYXBwQWRkcmVzczogYXBwQWRkcmVzcy50b0xvd2VyQ2FzZSgpIH0sIChyZXN1bHQpID0+IHBhcnNlUmVwbyhyZXN1bHQsIG9yZ2FuaXphdGlvbikpO1xuICAgIH1cbn1cbl9ncWwgPSBuZXcgV2Vha01hcCgpO1xuZXhwb3J0IGRlZmF1bHQgQ29ubmVjdG9yVGhlR3JhcGg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25uZWN0b3IuanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///9b5a\n")},a06e:function(module){eval('module.exports = JSON.parse("{\\"appName\\":\\"evmreg.aragonpm.eth\\",\\"roles\\":[{\\"name\\":\\"Add executors\\",\\"id\\":\\"REGISTRY_ADD_EXECUTOR_ROLE\\",\\"bytes\\":\\"0xc4e90f38eea8c4212a009ca7b8947943ba4d4a58d19b683417f65291d1cd9ed2\\"},{\\"name\\":\\"Enable and disable executors\\",\\"id\\":\\"REGISTRY_MANAGER_ROLE\\",\\"bytes\\":\\"0xf7a450ef335e1892cb42c8ca72e7242359d7711924b75db5717410da3f614aa3\\"}],\\"functions\\":[{\\"sig\\":\\"initialize()\\",\\"roles\\":[],\\"notice\\":\\"Initialize the registry\\"},{\\"sig\\":\\"addScriptExecutor(address)\\",\\"roles\\":[\\"REGISTRY_ADD_EXECUTOR_ROLE\\"],\\"notice\\":\\"Add a new script executor with address `_executor` to the registry\\"},{\\"sig\\":\\"disableScriptExecutor(uint256)\\",\\"roles\\":[\\"REGISTRY_MANAGER_ROLE\\"],\\"notice\\":\\"Disable script executor with ID `_executorId`\\"},{\\"sig\\":\\"enableScriptExecutor(uint256)\\",\\"roles\\":[\\"REGISTRY_MANAGER_ROLE\\"],\\"notice\\":\\"Enable script executor with ID `_executorId`\\"},{\\"sig\\":\\"transferToVault(address)\\",\\"roles\\":[],\\"notice\\":\\"Send funds to recovery Vault. This contract should never receive funds, but in case it does, this function allows one to recover them.\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJhMDZlLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a06e\n')},a3ed:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvVm90ZS52dWU/MWYwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJhM2VkLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///a3ed\n")},aa9a:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar connector_1 = __webpack_require__("81e0");\nObject.defineProperty(exports, "VotingConnectorTheGraph", { enumerable: true, get: function () { return connector_1.default; } });\nvar Voting_1 = __webpack_require__("0717");\nObject.defineProperty(exports, "Voting", { enumerable: true, get: function () { return Voting_1.default; } });\nvar Cast_1 = __webpack_require__("4b05");\nObject.defineProperty(exports, "Cast", { enumerable: true, get: function () { return Cast_1.default; } });\nvar Vote_1 = __webpack_require__("fe98");\nObject.defineProperty(exports, "Vote", { enumerable: true, get: function () { return Vote_1.default; } });\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L2luZGV4LmpzP2FhOWEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBOEMsY0FBYztBQUM1RCxrQkFBa0IsbUJBQU8sQ0FBQyxNQUFhO0FBQ3ZDLDJEQUEyRCxxQ0FBcUMsNEJBQTRCLEVBQUUsRUFBRTtBQUNoSSxlQUFlLG1CQUFPLENBQUMsTUFBbUI7QUFDMUMsMENBQTBDLHFDQUFxQyx5QkFBeUIsRUFBRSxFQUFFO0FBQzVHLGFBQWEsbUJBQU8sQ0FBQyxNQUFpQjtBQUN0Qyx3Q0FBd0MscUNBQXFDLHVCQUF1QixFQUFFLEVBQUU7QUFDeEcsYUFBYSxtQkFBTyxDQUFDLE1BQWlCO0FBQ3RDLHdDQUF3QyxxQ0FBcUMsdUJBQXVCLEVBQUUsRUFBRTtBQUN4RyIsImZpbGUiOiJhYTlhLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJWb3RpbmdDb25uZWN0b3JUaGVHcmFwaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ubmVjdG9yXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBWb3RpbmdfMSA9IHJlcXVpcmUoXCIuL2VudGl0aWVzL1ZvdGluZ1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZvdGluZ1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gVm90aW5nXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBDYXN0XzEgPSByZXF1aXJlKFwiLi9lbnRpdGllcy9DYXN0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ2FzdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gQ2FzdF8xLmRlZmF1bHQ7IH0gfSk7XG52YXIgVm90ZV8xID0gcmVxdWlyZShcIi4vZW50aXRpZXMvVm90ZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZvdGVcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFZvdGVfMS5kZWZhdWx0OyB9IH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aa9a\n')},aae3:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL1Jvb3RNb2RhbC52dWU/MmQ0OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJhYWUzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///aae3\n")},ad46:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL01vZGFsLnZ1ZT9mZWFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6ImFkNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///ad46\n")},b758:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_GraphQLWrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("c0dd");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GraphQLWrapper", function() { return _core_GraphQLWrapper__WEBPACK_IMPORTED_MODULE_0__["a"]; });\n\n/* harmony import */ var _connector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("9b5a");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("71b1");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_types__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _types__WEBPACK_IMPORTED_MODULE_2__) if(["default","GraphQLWrapper"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) (function(key) { __webpack_require__.d(__webpack_exports__, key, function() { return _types__WEBPACK_IMPORTED_MODULE_2__[key]; }) }(__WEBPACK_IMPORT_KEY__));\n\n\n/* harmony default export */ __webpack_exports__["default"] = (_connector__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoL2Rpc3QvZXNtL2luZGV4LmpzP2I3NTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFrRTtBQUN0QjtBQUM3Qix5SEFBaUIsRUFBQztBQUNUO0FBQ3hCIiwiZmlsZSI6ImI3NTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIEdyYXBoUUxXcmFwcGVyIH0gZnJvbSAnLi9jb3JlL0dyYXBoUUxXcmFwcGVyJztcbmltcG9ydCBDb25uZWN0b3JUaGVHcmFwaCBmcm9tICcuL2Nvbm5lY3Rvcic7XG5leHBvcnQgZGVmYXVsdCBDb25uZWN0b3JUaGVHcmFwaDtcbmV4cG9ydCAqIGZyb20gJy4vdHlwZXMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///b758\n')},c0dd:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GraphQLWrapper; });\n/* harmony import */ var isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("ce08");\n/* harmony import */ var isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _urql_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("1238");\n/* harmony import */ var wonka__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("2517");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError("attempted to set private field on non-instance");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError("attempted to get private field on non-instance");\n    }\n    return privateMap.get(receiver);\n};\nvar _client, _pollInterval, _verbose;\n\n\n\n// Average block time is about 13 seconds on the 2020-08-14\n// See https://etherscan.io/chart/blocktime\nconst POLL_INTERVAL_DEFAULT = 13 * 1000;\n// Make every operation type a query, until GraphQL subscriptions get added again.\nfunction createRequest(query, args) {\n    if (query.definitions) {\n        query = {\n            ...query,\n            definitions: query.definitions.map((definition) => ({\n                ...definition,\n                operation: \'query\',\n            })),\n        };\n    }\n    return Object(_urql_core__WEBPACK_IMPORTED_MODULE_1__[/* createRequest */ "b"])(query, args);\n}\nclass GraphQLWrapper {\n    constructor(subgraphUrl, options = {}) {\n        var _a, _b;\n        _client.set(this, void 0);\n        _pollInterval.set(this, void 0);\n        _verbose.set(this, void 0);\n        if (typeof options === \'boolean\') {\n            console.warn(\'GraphQLWrapper: please use `new GraphQLWrapper(url, { verbose })` rather than `new GraphQLWrapper(url, verbose)`.\');\n            options = { verbose: options };\n        }\n        options = options;\n        __classPrivateFieldSet(this, _verbose, (_a = options.verbose) !== null && _a !== void 0 ? _a : false);\n        __classPrivateFieldSet(this, _pollInterval, (_b = options.pollInterval) !== null && _b !== void 0 ? _b : POLL_INTERVAL_DEFAULT);\n        __classPrivateFieldSet(this, _client, new _urql_core__WEBPACK_IMPORTED_MODULE_1__[/* Client */ "a"]({ maskTypename: true, url: subgraphUrl, fetch: (isomorphic_unfetch__WEBPACK_IMPORTED_MODULE_0___default()) }));\n    }\n    close() {\n        // Do nothing for now.\n        // Will be used when GraphQL subscriptions will be added again.\n    }\n    subscribeToQuery(query, args = {}, callback) {\n        const request = createRequest(query, args);\n        return Object(wonka__WEBPACK_IMPORTED_MODULE_2__[/* pipe */ "l"])(__classPrivateFieldGet(this, _client).executeQuery(request, {\n            pollInterval: __classPrivateFieldGet(this, _pollInterval),\n            requestPolicy: \'cache-and-network\',\n        }), Object(wonka__WEBPACK_IMPORTED_MODULE_2__[/* subscribe */ "o"])((result) => {\n            if (__classPrivateFieldGet(this, _verbose)) {\n                console.log(this.describeQueryResult(result));\n            }\n            if (result.error) {\n                callback(new Error(\'Error performing subscription.\\n\' +\n                    `${result.error.name}: ${result.error.message} \\n` +\n                    this.describeQueryResult(result)));\n                return;\n            }\n            callback(null, result);\n        }));\n    }\n    subscribeToQueryWithParser(query, args = {}, callback, parser) {\n        return this.subscribeToQuery(query, args, async (error, result) => {\n            var _a, _b;\n            try {\n                if (error || (result === null || result === void 0 ? void 0 : result.error)) {\n                    if (result) {\n                        throw new Error(\'Error performing subscription.\\n\' +\n                            `${(_a = result === null || result === void 0 ? void 0 : result.error) === null || _a === void 0 ? void 0 : _a.name}: ${(_b = result === null || result === void 0 ? void 0 : result.error) === null || _b === void 0 ? void 0 : _b.message}\\n` +\n                            this.describeQueryResult(result));\n                    }\n                    else {\n                        throw error;\n                    }\n                }\n                callback(null, await this.parseQueryResult(parser, result));\n            }\n            catch (error) {\n                callback(error);\n            }\n        });\n    }\n    async performQuery(query, args = {}) {\n        const result = await __classPrivateFieldGet(this, _client).query(query, args).toPromise();\n        if (__classPrivateFieldGet(this, _verbose)) {\n            console.log(this.describeQueryResult(result));\n        }\n        if (result.error) {\n            throw new Error(this.describeQueryResultError(result) + this.describeQueryResult(result));\n        }\n        return result;\n    }\n    async performQueryWithParser(query, args = {}, parser) {\n        const result = await this.performQuery(query, args);\n        return this.parseQueryResult(parser, result);\n    }\n    async parseQueryResult(parser, result) {\n        try {\n            if (result.error) {\n                throw result.error;\n            }\n            return parser(result);\n        }\n        catch (error) {\n            throw new Error(error.message + \'\\n\\n\' + this.describeQueryResult(result));\n        }\n    }\n    describeQueryResultError(result) {\n        if (!result.error) {\n            return \'\';\n        }\n        return `${result.error.name}: ${result.error.message}\\n\\n`;\n    }\n    describeQueryResult(result) {\n        var _a;\n        const queryStr = (_a = result.operation.query.loc) === null || _a === void 0 ? void 0 : _a.source.body;\n        const dataStr = JSON.stringify(result.data, null, 2);\n        const argsStr = JSON.stringify(result.operation.variables, null, 2);\n        const subgraphUrl = result.operation.context.url;\n        return (`Subgraph: ${subgraphUrl}\\n\\n` +\n            `Arguments: ${argsStr}\\n\\n` +\n            `Query: ${queryStr}\\n\\n` +\n            `Returned data: ${dataStr}\\n\\n`);\n    }\n}\n_client = new WeakMap(), _pollInterval = new WeakMap(), _verbose = new WeakMap();\n//# sourceMappingURL=GraphQLWrapper.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoL2Rpc3QvZXNtL2NvcmUvR3JhcGhRTFdyYXBwZXIuanM/YzBkZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDdUM7QUFDa0M7QUFDakM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVyx3RUFBaUI7QUFDNUI7QUFDZTtBQUNmLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLFVBQVU7QUFDekYsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELHlEQUFNLEVBQUUsdUNBQXVDLGtFQUFLLEVBQUU7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBLGVBQWUsMERBQUk7QUFDbkI7QUFDQTtBQUNBLFNBQVMsR0FBRywrREFBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQixJQUFJLHFCQUFxQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUhBQWlILElBQUksb0hBQW9IO0FBQ3hRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0IsSUFBSSxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWTtBQUN6QywwQkFBMEIsUUFBUTtBQUNsQyxzQkFBc0IsU0FBUztBQUMvQiw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJjMGRkLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCwgdmFsdWUpIHtcbiAgICBpZiAoIXByaXZhdGVNYXAuaGFzKHJlY2VpdmVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgICB9XG4gICAgcHJpdmF0ZU1hcC5zZXQocmVjZWl2ZXIsIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgcHJpdmF0ZU1hcCkge1xuICAgIGlmICghcHJpdmF0ZU1hcC5oYXMocmVjZWl2ZXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhdHRlbXB0ZWQgdG8gZ2V0IHByaXZhdGUgZmllbGQgb24gbm9uLWluc3RhbmNlXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJpdmF0ZU1hcC5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfY2xpZW50LCBfcG9sbEludGVydmFsLCBfdmVyYm9zZTtcbmltcG9ydCBmZXRjaCBmcm9tICdpc29tb3JwaGljLXVuZmV0Y2gnO1xuaW1wb3J0IHsgQ2xpZW50LCBjcmVhdGVSZXF1ZXN0IGFzIGNyZWF0ZVJlcXVlc3RVcnFsLCB9IGZyb20gJ0B1cnFsL2NvcmUnO1xuaW1wb3J0IHsgcGlwZSwgc3Vic2NyaWJlIH0gZnJvbSAnd29ua2EnO1xuLy8gQXZlcmFnZSBibG9jayB0aW1lIGlzIGFib3V0IDEzIHNlY29uZHMgb24gdGhlIDIwMjAtMDgtMTRcbi8vIFNlZSBodHRwczovL2V0aGVyc2Nhbi5pby9jaGFydC9ibG9ja3RpbWVcbmNvbnN0IFBPTExfSU5URVJWQUxfREVGQVVMVCA9IDEzICogMTAwMDtcbi8vIE1ha2UgZXZlcnkgb3BlcmF0aW9uIHR5cGUgYSBxdWVyeSwgdW50aWwgR3JhcGhRTCBzdWJzY3JpcHRpb25zIGdldCBhZGRlZCBhZ2Fpbi5cbmZ1bmN0aW9uIGNyZWF0ZVJlcXVlc3QocXVlcnksIGFyZ3MpIHtcbiAgICBpZiAocXVlcnkuZGVmaW5pdGlvbnMpIHtcbiAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAuLi5xdWVyeSxcbiAgICAgICAgICAgIGRlZmluaXRpb25zOiBxdWVyeS5kZWZpbml0aW9ucy5tYXAoKGRlZmluaXRpb24pID0+ICh7XG4gICAgICAgICAgICAgICAgLi4uZGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdxdWVyeScsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0VXJxbChxdWVyeSwgYXJncyk7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaFFMV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3Ioc3ViZ3JhcGhVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBfY2xpZW50LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfcG9sbEludGVydmFsLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfdmVyYm9zZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignR3JhcGhRTFdyYXBwZXI6IHBsZWFzZSB1c2UgYG5ldyBHcmFwaFFMV3JhcHBlcih1cmwsIHsgdmVyYm9zZSB9KWAgcmF0aGVyIHRoYW4gYG5ldyBHcmFwaFFMV3JhcHBlcih1cmwsIHZlcmJvc2UpYC4nKTtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7IHZlcmJvc2U6IG9wdGlvbnMgfTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfdmVyYm9zZSwgKF9hID0gb3B0aW9ucy52ZXJib3NlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX3BvbGxJbnRlcnZhbCwgKF9iID0gb3B0aW9ucy5wb2xsSW50ZXJ2YWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFBPTExfSU5URVJWQUxfREVGQVVMVCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX2NsaWVudCwgbmV3IENsaWVudCh7IG1hc2tUeXBlbmFtZTogdHJ1ZSwgdXJsOiBzdWJncmFwaFVybCwgZmV0Y2ggfSkpO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgLy8gRG8gbm90aGluZyBmb3Igbm93LlxuICAgICAgICAvLyBXaWxsIGJlIHVzZWQgd2hlbiBHcmFwaFFMIHN1YnNjcmlwdGlvbnMgd2lsbCBiZSBhZGRlZCBhZ2Fpbi5cbiAgICB9XG4gICAgc3Vic2NyaWJlVG9RdWVyeShxdWVyeSwgYXJncyA9IHt9LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gY3JlYXRlUmVxdWVzdChxdWVyeSwgYXJncyk7XG4gICAgICAgIHJldHVybiBwaXBlKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX2NsaWVudCkuZXhlY3V0ZVF1ZXJ5KHJlcXVlc3QsIHtcbiAgICAgICAgICAgIHBvbGxJbnRlcnZhbDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfcG9sbEludGVydmFsKSxcbiAgICAgICAgICAgIHJlcXVlc3RQb2xpY3k6ICdjYWNoZS1hbmQtbmV0d29yaycsXG4gICAgICAgIH0pLCBzdWJzY3JpYmUoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX3ZlcmJvc2UpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5kZXNjcmliZVF1ZXJ5UmVzdWx0KHJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcignRXJyb3IgcGVyZm9ybWluZyBzdWJzY3JpcHRpb24uXFxuJyArXG4gICAgICAgICAgICAgICAgICAgIGAke3Jlc3VsdC5lcnJvci5uYW1lfTogJHtyZXN1bHQuZXJyb3IubWVzc2FnZX0gXFxuYCArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzY3JpYmVRdWVyeVJlc3VsdChyZXN1bHQpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVUb1F1ZXJ5V2l0aFBhcnNlcihxdWVyeSwgYXJncyA9IHt9LCBjYWxsYmFjaywgcGFyc2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZVRvUXVlcnkocXVlcnksIGFyZ3MsIGFzeW5jIChlcnJvciwgcmVzdWx0KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgfHwgKHJlc3VsdCA9PT0gbnVsbCB8fCByZXN1bHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3VsdC5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBwZXJmb3JtaW5nIHN1YnNjcmlwdGlvbi5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgJHsoX2EgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lfTogJHsoX2IgPSByZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXN1bHQuZXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tZXNzYWdlfVxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzY3JpYmVRdWVyeVJlc3VsdChyZXN1bHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGF3YWl0IHRoaXMucGFyc2VRdWVyeVJlc3VsdChwYXJzZXIsIHJlc3VsdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcGVyZm9ybVF1ZXJ5KHF1ZXJ5LCBhcmdzID0ge30pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfY2xpZW50KS5xdWVyeShxdWVyeSwgYXJncykudG9Qcm9taXNlKCk7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF92ZXJib3NlKSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5kZXNjcmliZVF1ZXJ5UmVzdWx0KHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0aGlzLmRlc2NyaWJlUXVlcnlSZXN1bHRFcnJvcihyZXN1bHQpICsgdGhpcy5kZXNjcmliZVF1ZXJ5UmVzdWx0KHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGFzeW5jIHBlcmZvcm1RdWVyeVdpdGhQYXJzZXIocXVlcnksIGFyZ3MgPSB7fSwgcGFyc2VyKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucGVyZm9ybVF1ZXJ5KHF1ZXJ5LCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VRdWVyeVJlc3VsdChwYXJzZXIsIHJlc3VsdCk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlUXVlcnlSZXN1bHQocGFyc2VyLCByZXN1bHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSArICdcXG5cXG4nICsgdGhpcy5kZXNjcmliZVF1ZXJ5UmVzdWx0KHJlc3VsdCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc2NyaWJlUXVlcnlSZXN1bHRFcnJvcihyZXN1bHQpIHtcbiAgICAgICAgaWYgKCFyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYCR7cmVzdWx0LmVycm9yLm5hbWV9OiAke3Jlc3VsdC5lcnJvci5tZXNzYWdlfVxcblxcbmA7XG4gICAgfVxuICAgIGRlc2NyaWJlUXVlcnlSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcXVlcnlTdHIgPSAoX2EgPSByZXN1bHQub3BlcmF0aW9uLnF1ZXJ5LmxvYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvdXJjZS5ib2R5O1xuICAgICAgICBjb25zdCBkYXRhU3RyID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0LmRhdGEsIG51bGwsIDIpO1xuICAgICAgICBjb25zdCBhcmdzU3RyID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0Lm9wZXJhdGlvbi52YXJpYWJsZXMsIG51bGwsIDIpO1xuICAgICAgICBjb25zdCBzdWJncmFwaFVybCA9IHJlc3VsdC5vcGVyYXRpb24uY29udGV4dC51cmw7XG4gICAgICAgIHJldHVybiAoYFN1YmdyYXBoOiAke3N1YmdyYXBoVXJsfVxcblxcbmAgK1xuICAgICAgICAgICAgYEFyZ3VtZW50czogJHthcmdzU3RyfVxcblxcbmAgK1xuICAgICAgICAgICAgYFF1ZXJ5OiAke3F1ZXJ5U3RyfVxcblxcbmAgK1xuICAgICAgICAgICAgYFJldHVybmVkIGRhdGE6ICR7ZGF0YVN0cn1cXG5cXG5gKTtcbiAgICB9XG59XG5fY2xpZW50ID0gbmV3IFdlYWtNYXAoKSwgX3BvbGxJbnRlcnZhbCA9IG5ldyBXZWFrTWFwKCksIF92ZXJib3NlID0gbmV3IFdlYWtNYXAoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdyYXBoUUxXcmFwcGVyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///c0dd\n')},c3e3:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/common/RootModal.vue?vue&type=template&id=9b4d4c52&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',[_c(\'div\',{directives:[{name:"show",rawName:"v-show",value:(_vm.showModal),expression:"showModal"}],staticClass:"modal",attrs:{"id":"modal"},on:{"click":function($event){if($event.target !== $event.currentTarget){ return null; }return _vm.hideModal($event)}}},[_c(\'div\',{staticClass:"modal-content window white"},[_c(\'fieldset\',[_c(\'div\',{staticClass:"legend2 hoverpointer",on:{"click":_vm.hideModal}},[_vm._v(" ["),_c(\'span\',{staticClass:"greentext"},[_vm._v("X")]),_vm._v("] ")]),_c(\'legend\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.executeVote),expression:"!executeVote"}]},[_vm._v("Create a vote on "+_vm._s(_vm.appName))]),_c(\'legend\',{directives:[{name:"show",rawName:"v-show",value:(_vm.executeVote),expression:"executeVote"}]},[_vm._v("Execute a vote on "+_vm._s(_vm.appName))]),_c(\'div\',{staticClass:"content"},[_c(\'div\',[_c(\'span\',[_vm._v(" "+_vm._s(_vm.description)+" ")]),(_vm.vote)?_c(\'div\',{staticClass:"content"},[_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.contractName),expression:"vote.contractName"}]},[_vm._v(" "+_vm._s(_vm.vote.contractName)+": "),_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.metadata),expression:"!vote.contractName && vote.metadata"}]},[_vm._v(" "+_vm._s(_vm.vote.metadata)+" ")]),_c(\'span\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.vote.contractName && _vm.vote.description),expression:"!vote.contractName && vote.description"}]},[_c(\'span\',{domProps:{"innerHTML":_vm._s(_vm.vote.description)}})])]):_vm._e()]),_c(\'hr\'),_c(\'p\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.executeVote),expression:"!executeVote"}],staticClass:"explanation"},[_vm._v(" This vote requires "+_vm._s(_vm.getSupportText)+"% acceptance and "+_vm._s(_vm.getQuorumText)+"% quorum to be passed ")]),_c(\'p\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.willSucceed),expression:"!willSucceed"}],staticClass:"simple-error"},[_vm._v(" The transaction may fail, you may not have the required permissions to make the transaction ")])]),_c(\'button\',{directives:[{name:"show",rawName:"v-show",value:(!_vm.executeVote),expression:"!executeVote"}],on:{"click":_vm.createVote}},[_vm._v("Create Vote")]),_c(\'button\',{directives:[{name:"show",rawName:"v-show",value:(_vm.executeVote),expression:"executeVote"}],on:{"click":_vm.createVote}},[_vm._v("Vote")])])])])])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/common/RootModal.vue?vue&type=template&id=9b4d4c52&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js\nvar es_symbol = __webpack_require__("a4d3");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js\nvar es_symbol_description = __webpack_require__("e01a");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.is-array.js\nvar es_array_is_array = __webpack_require__("277d");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js\nvar es_object_to_string = __webpack_require__("d3b7");\n\n// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js\nvar runtime = __webpack_require__("96cf");\n\n// EXTERNAL MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\nvar asyncToGenerator = __webpack_require__("1da1");\n\n// EXTERNAL MODULE: ./src/init.js\nvar init = __webpack_require__("d99e");\n\n// EXTERNAL MODULE: ./src/components/dao/voteStore.js\nvar voteStore = __webpack_require__("3f2c");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/common/RootModal.vue?vue&type=script&lang=js&\n\n\n\n\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\n/* harmony default export */ var RootModalvue_type_script_lang_js_ = ({\n  props: [\'vote\'],\n  data: function data() {\n    return {\n      willSucceed: true\n    };\n  },\n  computed: {\n    showModal: {\n      get: function get() {\n        return voteStore["n" /* state */].showRootModal;\n      },\n      set: function set(value) {\n        voteStore["n" /* state */].showRootModal = value;\n      }\n    },\n    transactionIntent: function transactionIntent() {\n      return voteStore["n" /* state */].transactionIntent;\n    },\n    transactionPath: function transactionPath() {\n      if (Array.isArray(this.transactionIntent)) return this.transactionIntent[0];\n      return this.transactionIntent;\n    },\n    appName: function appName() {\n      return Object(voteStore["k" /* getVotingAppName */])(this.transactionPath.destination.address);\n    },\n    getSupportText: function getSupportText() {\n      return Object(voteStore["i" /* getSupportQuorum */])(this.appName).support;\n    },\n    getQuorumText: function getQuorumText() {\n      return Object(voteStore["i" /* getSupportQuorum */])(this.appName).quorum;\n    },\n    description: function description() {\n      return this.transactionPath.transactions[0].description;\n    },\n    executeVote: function executeVote() {\n      return voteStore["n" /* state */].executeVote;\n    }\n  },\n  methods: {\n    createVote: function createVote() {\n      var _this = this;\n\n      return Object(asyncToGenerator["a" /* default */])( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n        var data;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                data = _this.transactionPath.transactions[0];\n                _context.prev = 1;\n                _context.next = 4;\n                return web3.eth.estimateGas(data);\n\n              case 4:\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context["catch"](1);\n                _this.willSucceed = false;\n\n              case 9:\n                _context.next = 11;\n                return new Promise(function (resolve, reject) {\n                  return web3.eth.sendTransaction(data).once(\'transactionHash\', resolve).on(\'error\', reject);\n                });\n\n              case 11:\n                voteStore["n" /* state */].showRootModal = false;\n\n              case 12:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[1, 6]]);\n      }))();\n    },\n    hideModal: function hideModal() {\n      this.showModal = false;\n      voteStore["n" /* state */].executeVote = false;\n    }\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/common/RootModal.vue?vue&type=script&lang=js&\n /* harmony default export */ var common_RootModalvue_type_script_lang_js_ = (RootModalvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/dao/common/RootModal.vue?vue&type=style&index=0&id=9b4d4c52&scoped=true&lang=css&\nvar RootModalvue_type_style_index_0_id_9b4d4c52_scoped_true_lang_css_ = __webpack_require__("2388");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// CONCATENATED MODULE: ./src/components/dao/common/RootModal.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  common_RootModalvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "9b4d4c52",\n  null\n  \n)\n\n/* harmony default export */ var RootModal = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL1Jvb3RNb2RhbC52dWU/N2Q1MCIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvZGFvL2NvbW1vbi9Sb290TW9kYWwudnVlPzBjYjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL2NvbW1vbi9Sb290TW9kYWwudnVlPzRmMTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL2NvbW1vbi9Sb290TW9kYWwudnVlPzhkZjkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLDJCQUEyQixhQUFhLDBFQUEwRSw2QkFBNkIsYUFBYSxLQUFLLHlCQUF5QiwyQ0FBMkMsYUFBYSxFQUFFLCtCQUErQixZQUFZLHlDQUF5QywyQkFBMkIsdUNBQXVDLHVCQUF1QiwwQkFBMEIsd0JBQXdCLDRDQUE0QyxhQUFhLGdGQUFnRixFQUFFLGlFQUFpRSxhQUFhLDhFQUE4RSxFQUFFLCtEQUErRCxzQkFBc0Isc0ZBQXNGLHNCQUFzQixhQUFhLGFBQWEsMEZBQTBGLEVBQUUsNERBQTRELFVBQVUsMENBQTBDLGVBQWUsYUFBYSxrSUFBa0ksRUFBRSx5REFBeUQsYUFBYSx3SUFBd0ksRUFBRSxhQUFhLFVBQVUsMENBQTBDLGtDQUFrQyxhQUFhLGdGQUFnRiw0QkFBNEIsNklBQTZJLGFBQWEsZ0ZBQWdGLDZCQUE2QiwySEFBMkgsYUFBYSxnRkFBZ0YsTUFBTSx3QkFBd0IsdUNBQXVDLGFBQWEsOEVBQThFLE1BQU0sd0JBQXdCO0FBQ3IrRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN5Q0E7QUFFQTtBQUVBO0FBQ0EsaUJBREE7QUFHQTtBQUFBO0FBQ0E7QUFEQTtBQUFBLEdBSEE7QUFPQTtBQUNBO0FBQ0EsU0FEQSxpQkFDQTtBQUNBO0FBQ0EsT0FIQTtBQUlBLFNBSkEsZUFJQSxLQUpBLEVBSUE7QUFDQTtBQUNBO0FBTkEsS0FEQTtBQVNBLHFCQVRBLCtCQVNBO0FBQ0E7QUFDQSxLQVhBO0FBWUEsbUJBWkEsNkJBWUE7QUFDQSxpREFDQTtBQUNBO0FBQ0EsS0FoQkE7QUFpQkEsV0FqQkEscUJBaUJBO0FBQ0E7QUFDQSxLQW5CQTtBQW9CQSxrQkFwQkEsNEJBb0JBO0FBQ0E7QUFDQSxLQXRCQTtBQXVCQSxpQkF2QkEsMkJBdUJBO0FBQ0E7QUFDQSxLQXpCQTtBQTBCQSxlQTFCQSx5QkEwQkE7QUFDQTtBQUNBLEtBNUJBO0FBNkJBLGVBN0JBLHlCQTZCQTtBQUNBO0FBQ0E7QUEvQkEsR0FQQTtBQTBDQTtBQUNBLGNBREEsd0JBQ0E7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxvQkFEQSxHQUNBLHFDQURBO0FBQUE7QUFBQTtBQUFBLHVCQUtBLDBCQUxBOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFRQTs7QUFSQTtBQUFBO0FBQUEsdUJBV0E7QUFBQSx5QkFDQSwrQkFDQSxJQURBLENBQ0EsaUJBREEsRUFDQSxPQURBLEVBRUEsRUFGQSxDQUVBLE9BRkEsRUFFQSxNQUZBLENBREE7QUFBQSxrQkFYQTs7QUFBQTtBQWlCQTs7QUFqQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFrQkEsS0FuQkE7QUFvQkEsYUFwQkEsdUJBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBdkJBO0FBMUNBLEc7O0FDOUNpVyxDQUFnQiw4R0FBRyxFQUFDLEM7Ozs7Ozs7O0FDQWpSO0FBQ3ZDO0FBQ0w7QUFDcUM7OztBQUc3RjtBQUNnRztBQUNoRyxnQkFBZ0IsOENBQVU7QUFDMUIsRUFBRSx3Q0FBTTtBQUNSLEVBQUUsTUFBTTtBQUNSLEVBQUUsZUFBZTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFZSwwRiIsImZpbGUiOiJjM2UzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHt2YXIgX3ZtPXRoaXM7dmFyIF9oPV92bS4kY3JlYXRlRWxlbWVudDt2YXIgX2M9X3ZtLl9zZWxmLl9jfHxfaDtyZXR1cm4gX2MoJ2RpdicsW19jKCdkaXYnLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5zaG93TW9kYWwpLGV4cHJlc3Npb246XCJzaG93TW9kYWxcIn1dLHN0YXRpY0NsYXNzOlwibW9kYWxcIixhdHRyczp7XCJpZFwiOlwibW9kYWxcIn0sb246e1wiY2xpY2tcIjpmdW5jdGlvbigkZXZlbnQpe2lmKCRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0KXsgcmV0dXJuIG51bGw7IH1yZXR1cm4gX3ZtLmhpZGVNb2RhbCgkZXZlbnQpfX19LFtfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJtb2RhbC1jb250ZW50IHdpbmRvdyB3aGl0ZVwifSxbX2MoJ2ZpZWxkc2V0JyxbX2MoJ2Rpdicse3N0YXRpY0NsYXNzOlwibGVnZW5kMiBob3ZlcnBvaW50ZXJcIixvbjp7XCJjbGlja1wiOl92bS5oaWRlTW9kYWx9fSxbX3ZtLl92KFwiIFtcIiksX2MoJ3NwYW4nLHtzdGF0aWNDbGFzczpcImdyZWVudGV4dFwifSxbX3ZtLl92KFwiWFwiKV0pLF92bS5fdihcIl0gXCIpXSksX2MoJ2xlZ2VuZCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS5leGVjdXRlVm90ZSksZXhwcmVzc2lvbjpcIiFleGVjdXRlVm90ZVwifV19LFtfdm0uX3YoXCJDcmVhdGUgYSB2b3RlIG9uIFwiK192bS5fcyhfdm0uYXBwTmFtZSkpXSksX2MoJ2xlZ2VuZCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLmV4ZWN1dGVWb3RlKSxleHByZXNzaW9uOlwiZXhlY3V0ZVZvdGVcIn1dfSxbX3ZtLl92KFwiRXhlY3V0ZSBhIHZvdGUgb24gXCIrX3ZtLl9zKF92bS5hcHBOYW1lKSldKSxfYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb250ZW50XCJ9LFtfYygnZGl2JyxbX2MoJ3NwYW4nLFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS5kZXNjcmlwdGlvbikrXCIgXCIpXSksKF92bS52b3RlKT9fYygnZGl2Jyx7c3RhdGljQ2xhc3M6XCJjb250ZW50XCJ9LFtfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLnZvdGUuY29udHJhY3ROYW1lKSxleHByZXNzaW9uOlwidm90ZS5jb250cmFjdE5hbWVcIn1dfSxbX3ZtLl92KFwiIFwiK192bS5fcyhfdm0udm90ZS5jb250cmFjdE5hbWUpK1wiOiBcIiksX2MoJ3NwYW4nLHtkb21Qcm9wczp7XCJpbm5lckhUTUxcIjpfdm0uX3MoX3ZtLnZvdGUuZGVzY3JpcHRpb24pfX0pXSksX2MoJ3NwYW4nLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KCFfdm0udm90ZS5jb250cmFjdE5hbWUgJiYgX3ZtLnZvdGUubWV0YWRhdGEpLGV4cHJlc3Npb246XCIhdm90ZS5jb250cmFjdE5hbWUgJiYgdm90ZS5tZXRhZGF0YVwifV19LFtfdm0uX3YoXCIgXCIrX3ZtLl9zKF92bS52b3RlLm1ldGFkYXRhKStcIiBcIildKSxfYygnc3Bhbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS52b3RlLmNvbnRyYWN0TmFtZSAmJiBfdm0udm90ZS5kZXNjcmlwdGlvbiksZXhwcmVzc2lvbjpcIiF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLmRlc2NyaXB0aW9uXCJ9XX0sW19jKCdzcGFuJyx7ZG9tUHJvcHM6e1wiaW5uZXJIVE1MXCI6X3ZtLl9zKF92bS52b3RlLmRlc2NyaXB0aW9uKX19KV0pXSk6X3ZtLl9lKCldKSxfYygnaHInKSxfYygncCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS5leGVjdXRlVm90ZSksZXhwcmVzc2lvbjpcIiFleGVjdXRlVm90ZVwifV0sc3RhdGljQ2xhc3M6XCJleHBsYW5hdGlvblwifSxbX3ZtLl92KFwiIFRoaXMgdm90ZSByZXF1aXJlcyBcIitfdm0uX3MoX3ZtLmdldFN1cHBvcnRUZXh0KStcIiUgYWNjZXB0YW5jZSBhbmQgXCIrX3ZtLl9zKF92bS5nZXRRdW9ydW1UZXh0KStcIiUgcXVvcnVtIHRvIGJlIHBhc3NlZCBcIildKSxfYygncCcse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS53aWxsU3VjY2VlZCksZXhwcmVzc2lvbjpcIiF3aWxsU3VjY2VlZFwifV0sc3RhdGljQ2xhc3M6XCJzaW1wbGUtZXJyb3JcIn0sW192bS5fdihcIiBUaGUgdHJhbnNhY3Rpb24gbWF5IGZhaWwsIHlvdSBtYXkgbm90IGhhdmUgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zIHRvIG1ha2UgdGhlIHRyYW5zYWN0aW9uIFwiKV0pXSksX2MoJ2J1dHRvbicse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooIV92bS5leGVjdXRlVm90ZSksZXhwcmVzc2lvbjpcIiFleGVjdXRlVm90ZVwifV0sb246e1wiY2xpY2tcIjpfdm0uY3JlYXRlVm90ZX19LFtfdm0uX3YoXCJDcmVhdGUgVm90ZVwiKV0pLF9jKCdidXR0b24nLHtkaXJlY3RpdmVzOlt7bmFtZTpcInNob3dcIixyYXdOYW1lOlwidi1zaG93XCIsdmFsdWU6KF92bS5leGVjdXRlVm90ZSksZXhwcmVzc2lvbjpcImV4ZWN1dGVWb3RlXCJ9XSxvbjp7XCJjbGlja1wiOl92bS5jcmVhdGVWb3RlfX0sW192bS5fdihcIlZvdGVcIildKV0pXSldKV0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG5cdDxkaXY+XG5cdFx0PGRpdiBpZD0nbW9kYWwnIGNsYXNzPSdtb2RhbCcgdi1zaG93PSdzaG93TW9kYWwnIEBjbGljay5zZWxmPSdoaWRlTW9kYWwnPlxuXHRcdFx0PGRpdiBjbGFzcz0nbW9kYWwtY29udGVudCB3aW5kb3cgd2hpdGUnPlxuXHRcdFx0XHQ8ZmllbGRzZXQ+XG5cdFx0XHRcdFx0PGRpdiBjbGFzcz0nbGVnZW5kMiBob3ZlcnBvaW50ZXInIEBjbGljaz0naGlkZU1vZGFsJz5cblx0XHRcdFx0XHRcdFs8c3BhbiBjbGFzcz0nZ3JlZW50ZXh0Jz5YPC9zcGFuPl1cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8bGVnZW5kIHYtc2hvdz0nIWV4ZWN1dGVWb3RlJz5DcmVhdGUgYSB2b3RlIG9uIHt7IGFwcE5hbWUgfX08L2xlZ2VuZD5cblx0XHRcdFx0XHQ8bGVnZW5kIHYtc2hvdz0nZXhlY3V0ZVZvdGUnPkV4ZWN1dGUgYSB2b3RlIG9uIHt7IGFwcE5hbWUgfX08L2xlZ2VuZD5cblx0XHRcdFx0XHQ8ZGl2IGNsYXNzPSdjb250ZW50Jz5cblx0XHRcdFx0XHRcdDxkaXY+XG5cdFx0XHRcdFx0XHRcdDxzcGFuPiB7eyBkZXNjcmlwdGlvbiB9fSA8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDxkaXYgY2xhc3M9J2NvbnRlbnQnIHYtaWY9J3ZvdGUnPlxuXHRcdFx0XHRcdFx0XHRcdDxzcGFuIHYtc2hvdz0ndm90ZS5jb250cmFjdE5hbWUnPlxuXHRcdFx0XHRcdFx0XHRcdFx0e3sgdm90ZS5jb250cmFjdE5hbWUgfX06IDxzcGFuIHYtaHRtbD0ndm90ZS5kZXNjcmlwdGlvbic+PC9zcGFuPlxuXHRcdFx0XHRcdFx0XHRcdDwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8c3BhbiB2LXNob3c9JyF2b3RlLmNvbnRyYWN0TmFtZSAmJiB2b3RlLm1ldGFkYXRhJz5cblx0XHRcdFx0XHRcdFx0XHRcdHt7IHZvdGUubWV0YWRhdGEgfX1cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdFx0PHNwYW4gdi1zaG93PSchdm90ZS5jb250cmFjdE5hbWUgJiYgdm90ZS5kZXNjcmlwdGlvbic+XG5cdFx0XHRcdFx0XHRcdFx0XHQ8c3BhbiB2LWh0bWw9J3ZvdGUuZGVzY3JpcHRpb24nPjwvc3Bhbj5cblx0XHRcdFx0XHRcdFx0XHQ8L3NwYW4+XG5cdFx0XHRcdFx0XHRcdDwvZGl2PlxuXHRcdFx0XHRcdFx0PC9kaXY+XG5cdFx0XHRcdFx0XHQ8aHI+XG5cdFx0XHRcdFx0XHQ8cCBjbGFzcz0nZXhwbGFuYXRpb24nIHYtc2hvdz0nIWV4ZWN1dGVWb3RlJz5cblx0XHRcdFx0XHRcdFx0VGhpcyB2b3RlIHJlcXVpcmVzIHt7IGdldFN1cHBvcnRUZXh0IH19JSBhY2NlcHRhbmNlIGFuZCB7eyBnZXRRdW9ydW1UZXh0IH19JSBxdW9ydW0gdG8gYmUgcGFzc2VkXG5cdFx0XHRcdFx0XHQ8L3A+XG5cdFx0XHRcdFx0XHQ8cCBjbGFzcz0nc2ltcGxlLWVycm9yJyB2LXNob3c9JyF3aWxsU3VjY2VlZCc+XG5cdFx0XHRcdFx0XHRcdFRoZSB0cmFuc2FjdGlvbiBtYXkgZmFpbCwgeW91IG1heSBub3QgaGF2ZSB0aGUgcmVxdWlyZWQgcGVybWlzc2lvbnMgdG8gbWFrZSB0aGUgdHJhbnNhY3Rpb25cblx0XHRcdFx0XHRcdDwvcD5cblx0XHRcdFx0XHQ8L2Rpdj5cblx0XHRcdFx0XHQ8YnV0dG9uIEBjbGljaz0nY3JlYXRlVm90ZScgdi1zaG93PSchZXhlY3V0ZVZvdGUnPkNyZWF0ZSBWb3RlPC9idXR0b24+XG5cdFx0XHRcdFx0PGJ1dHRvbiBAY2xpY2s9J2NyZWF0ZVZvdGUnIHYtc2hvdz0nZXhlY3V0ZVZvdGUnPlZvdGU8L2J1dHRvbj5cblx0XHRcdFx0PC9maWVsZHNldD5cblx0XHRcdDwvZGl2PlxuXHRcdDwvZGl2PlxuXHQ8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4gICAgaW1wb3J0IHsgbm90aWZ5LCBub3RpZnlIYW5kbGVyLCBub3RpZnlOb3RpZmljYXRpb24gfSBmcm9tICcuLi8uLi8uLi9pbml0J1xuXG5cdGltcG9ydCB7IHN0YXRlLCBnZXRWb3RpbmdBcHBOYW1lLCBnZXRTdXBwb3J0UXVvcnVtIH0gZnJvbSAnLi4vdm90ZVN0b3JlJ1xuXG5cdGV4cG9ydCBkZWZhdWx0IHtcblx0XHRwcm9wczogWyd2b3RlJ10sXG5cblx0XHRkYXRhOiAoKSA9PiAoe1xuXHRcdFx0d2lsbFN1Y2NlZWQ6IHRydWUsXG5cdFx0fSksXG5cblx0XHRjb21wdXRlZDoge1xuXHRcdFx0c2hvd01vZGFsOiB7XG4gICAgICAgIFx0XHRnZXQoKSB7XG4gICAgICAgIFx0XHRcdHJldHVybiBzdGF0ZS5zaG93Um9vdE1vZGFsXG4gICAgICAgIFx0XHR9LFxuICAgICAgICBcdFx0c2V0KHZhbHVlKSB7XG4gICAgICAgIFx0XHRcdHN0YXRlLnNob3dSb290TW9kYWwgPSB2YWx1ZVxuICAgICAgICBcdFx0fSxcbiAgICAgICAgXHR9LFxuICAgICAgICBcdHRyYW5zYWN0aW9uSW50ZW50KCkge1xuICAgICAgICBcdFx0cmV0dXJuIHN0YXRlLnRyYW5zYWN0aW9uSW50ZW50XG4gICAgICAgIFx0fSxcbiAgICAgICAgXHR0cmFuc2FjdGlvblBhdGgoKSB7XG4gICAgICAgIFx0XHRpZihBcnJheS5pc0FycmF5KHRoaXMudHJhbnNhY3Rpb25JbnRlbnQpKVxuICAgICAgICBcdFx0XHRyZXR1cm4gdGhpcy50cmFuc2FjdGlvbkludGVudFswXVxuICAgICAgICBcdFx0cmV0dXJuIHRoaXMudHJhbnNhY3Rpb25JbnRlbnRcbiAgICAgICAgXHR9LFxuICAgICAgICBcdGFwcE5hbWUoKSB7XG4gICAgICAgIFx0XHRyZXR1cm4gZ2V0Vm90aW5nQXBwTmFtZSh0aGlzLnRyYW5zYWN0aW9uUGF0aC5kZXN0aW5hdGlvbi5hZGRyZXNzKVxuICAgICAgICBcdH0sXG4gICAgICAgIFx0Z2V0U3VwcG9ydFRleHQoKSB7XG4gICAgICAgIFx0XHRyZXR1cm4gZ2V0U3VwcG9ydFF1b3J1bSh0aGlzLmFwcE5hbWUpLnN1cHBvcnRcbiAgICAgICAgXHR9LFxuICAgICAgICBcdGdldFF1b3J1bVRleHQoKSB7XG4gICAgICAgIFx0XHRyZXR1cm4gZ2V0U3VwcG9ydFF1b3J1bSh0aGlzLmFwcE5hbWUpLnF1b3J1bVxuICAgICAgICBcdH0sXG4gICAgICAgIFx0ZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIFx0XHRyZXR1cm4gdGhpcy50cmFuc2FjdGlvblBhdGgudHJhbnNhY3Rpb25zWzBdLmRlc2NyaXB0aW9uXG4gICAgICAgIFx0fSxcbiAgICAgICAgXHRleGVjdXRlVm90ZSgpIHtcbiAgICAgICAgXHRcdHJldHVybiBzdGF0ZS5leGVjdXRlVm90ZVxuICAgICAgICBcdH0sXG5cblx0XHR9LFxuXG5cdFx0bWV0aG9kczoge1xuXHRcdFx0YXN5bmMgY3JlYXRlVm90ZSgpIHtcblx0XHRcdFx0bGV0IGRhdGEgPSB0aGlzLnRyYW5zYWN0aW9uUGF0aC50cmFuc2FjdGlvbnNbMF1cblxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0YXdhaXQgd2ViMy5ldGguZXN0aW1hdGVHYXMoZGF0YSlcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaChlcnIpIHtcblx0XHRcdFx0XHR0aGlzLndpbGxTdWNjZWVkID0gZmFsc2Vcblx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0YXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gXG5cdFx0XHRcdFx0d2ViMy5ldGguc2VuZFRyYW5zYWN0aW9uKGRhdGEpXG5cdFx0XHRcdFx0XHQub25jZSgndHJhbnNhY3Rpb25IYXNoJywgcmVzb2x2ZSlcblx0XHRcdFx0XHRcdC5vbignZXJyb3InLCByZWplY3QpXG5cdFx0XHRcdClcblxuXHRcdFx0XHRzdGF0ZS5zaG93Um9vdE1vZGFsID0gZmFsc2Vcblx0XHRcdH0sXG5cdFx0XHRoaWRlTW9kYWwoKSB7XG5cdFx0XHRcdHRoaXMuc2hvd01vZGFsID0gZmFsc2Vcblx0XHRcdFx0c3RhdGUuZXhlY3V0ZVZvdGUgPSBmYWxzZVxuXHRcdFx0fSxcblx0XHR9LFxuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblx0I21vZGFsIHtcblx0XHR6LWluZGV4OiAzO1xuXHR9XG5cdC5tb2RhbC1jb250ZW50IHtcblx0XHR0ZXh0LWFsaWduOiBjZW50ZXI7XG5cdFx0cGFkZGluZzogMDtcblx0XHRib3JkZXI6IG5vbmU7XG5cdFx0d2lkdGg6IDQ2MHB4O1xuXHR9XG5cdC5tb2RhbC1jb250ZW50IGZpZWxkc2V0IHtcblx0XHRjb2xvcjogd2hpdGU7XG5cdFx0Zm9udC13ZWlnaHQ6IGJvbGRlcjtcblx0XHRib3JkZXI6IDZweCBkb3VibGUgd2hpdGU7XG5cdFx0cGFkZGluZy1ibG9jay1zdGFydDogMWVtO1xuXHRcdHBhZGRpbmctYmxvY2stZW5kOiAxZW07XG5cdH1cblx0Lm1vZGFsLWNvbnRlbnQgbGVnZW5kIHtcblx0XHRjb2xvcjogYmxhY2s7XG5cdH1cblx0Lm1vZGFsLWNvbnRlbnQgYnV0dG9uIHtcblx0XHRtYXJnaW4tdG9wOiAwLjZlbTtcblx0XHRwYWRkaW5nOiAwIDJlbTtcblx0fVxuXHQubGVnZW5kMiB7XG5cdCAgcG9zaXRpb246IGFic29sdXRlO1xuXHQgIHRvcDogMDtcblx0ICBsZWZ0OiAyZW07XG5cdCAgYmFja2dyb3VuZDogI2MwYzBjMDtcblx0ICBsaW5lLWhlaWdodDoxLjJlbTtcblx0fVxuXHQuZ3JlZW50ZXh0IHtcblx0XHRjb2xvcjogZ3JlZW47XG5cdH1cblx0LmxlZ2VuZDIgLmdyZWVudGV4dCB7XG5cdFx0ZGlzcGxheTogaW5saW5lLWJsb2NrO1xuXHRcdHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwtMC4xZW0sMTBlbSk7XG5cdH1cblx0LmxlZ2VuZDIgLmdyZWVudGV4dDpob3ZlciB7XG5cdFx0dHJhbnNmb3JtOiBub25lO1xuXHR9XG5cdC5ob3ZlcnBvaW50ZXIge1xuXHRcdGN1cnNvcjogcG9pbnRlcjtcblx0fVxuXHQuY29udGVudCB7XG5cdFx0Y29sb3I6IHdoaXRlO1xuXHRcdHRleHQtYWxpZ246IGxlZnQ7XG5cdH1cblx0LmV4cGxhbmF0aW9uIHtcblx0XHRmb250LXNpemU6IDAuOGVtO1xuXHR9XG48L3N0eWxlPiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vUm9vdE1vZGFsLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Sb290TW9kYWwudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Sb290TW9kYWwudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTliNGQ0YzUyJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1Jvb3RNb2RhbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL1Jvb3RNb2RhbC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vUm9vdE1vZGFsLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTliNGQ0YzUyJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCI5YjRkNGM1MlwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///c3e3\n')},c6ba:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"2faedd3d-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/common/Countdown.vue?vue&type=template&id=f66a7640&scoped=true&\nvar render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(\'div\',[_c(\'img\',{directives:[{name:"show",rawName:"v-show",value:(_vm.vote.timeLeft > 0),expression:"vote.timeLeft > 0"}],staticClass:"icon small",attrs:{"src":_vm.publicPath + \'hourglass-start-solid.svg\'}}),_vm._v(" "+_vm._s(_vm.formatTime)+" ")])}\nvar staticRenderFns = []\n\n\n// CONCATENATED MODULE: ./src/components/dao/common/Countdown.vue?vue&type=template&id=f66a7640&scoped=true&\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.pad-start.js\nvar es_string_pad_start = __webpack_require__("4d90");\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.timers.js\nvar web_timers = __webpack_require__("4795");\n\n// EXTERNAL MODULE: ./src/utils/helpers.js\nvar helpers = __webpack_require__("2fa3");\n\n// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/dao/common/Countdown.vue?vue&type=script&lang=js&\n\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ var Countdownvue_type_script_lang_js_ = ({\n  props: [\'vote\'],\n  data: function data() {\n    return {\n      interval: null\n    };\n  },\n  watch: {\n    voteNumber: {\n      handler: function handler(val) {\n        this.startTimer();\n      },\n      immediate: true\n    }\n  },\n  computed: {\n    voteNumber: function voteNumber() {\n      return this.vote.voteNumber;\n    },\n    days: function days() {\n      return Math.floor(this.vote.timeLeft / (60 * 60 * 24));\n    },\n    hours: function hours() {\n      return Math.floor(this.vote.timeLeft % (60 * 60 * 24) / (60 * 60));\n    },\n    minutes: function minutes() {\n      return Math.floor(this.vote.timeLeft % (60 * 60) / 60);\n    },\n    seconds: function seconds() {\n      return Math.floor(this.vote.timeLeft % 60);\n    },\n    formatTime: function formatTime() {\n      var str = \'\';\n      if (this.days > 0) str += String(this.days).padStart(2, \'0\') + \'D:\';\n      if (this.hours > 0) str += String(this.hours).padStart(2, \'0\') + \'H:\';\n      if (this.minutes >= 0) str += String(this.minutes).padStart(2, \'0\') + \'M:\';\n      if (this.seconds >= 0) str += String(this.seconds).padStart(2, \'0\') + \'S\';\n      return str;\n    },\n    publicPath: function publicPath() {\n      return "";\n    }\n  },\n  methods: {\n    startTimer: function startTimer() {\n      var _this = this;\n\n      if (this.vote.timeLeft > 0 && !this.vote.executed && this.interval === null) {\n        this.interval = setInterval(function () {\n          _this.vote.timeLeft -= 1;\n          if (_this.vote.timeLeft < 0) clearInterval(_this.interval);\n        }, 1000);\n      }\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    clearInterval(this.interval);\n  }\n});\n// CONCATENATED MODULE: ./src/components/dao/common/Countdown.vue?vue&type=script&lang=js&\n /* harmony default export */ var common_Countdownvue_type_script_lang_js_ = (Countdownvue_type_script_lang_js_); \n// EXTERNAL MODULE: ./src/components/dao/common/Countdown.vue?vue&type=style&index=0&id=f66a7640&scoped=true&lang=css&\nvar Countdownvue_type_style_index_0_id_f66a7640_scoped_true_lang_css_ = __webpack_require__("97ad");\n\n// EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\nvar componentNormalizer = __webpack_require__("2877");\n\n// CONCATENATED MODULE: ./src/components/dao/common/Countdown.vue\n\n\n\n\n\n\n/* normalize component */\n\nvar component = Object(componentNormalizer["a" /* default */])(\n  common_Countdownvue_type_script_lang_js_,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  "f66a7640",\n  null\n  \n)\n\n/* harmony default export */ var Countdown = __webpack_exports__["a"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vY29tbW9uL0NvdW50ZG93bi52dWU/ZDUyZiIsIndlYnBhY2s6Ly8vc3JjL2NvbXBvbmVudHMvZGFvL2NvbW1vbi9Db3VudGRvd24udnVlPzYzMDAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL2NvbW1vbi9Db3VudGRvd24udnVlP2FkYWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbXBvbmVudHMvZGFvL2NvbW1vbi9Db3VudGRvd24udnVlP2FhZjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwwQkFBMEIsYUFBYSwwQkFBMEIsd0JBQXdCLDJCQUEyQixhQUFhLDBGQUEwRixrQ0FBa0Msb0RBQW9EO0FBQ2pUOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNVQTtBQUVBO0FBQ0EsaUJBREE7QUFHQTtBQUNBO0FBQ0E7QUFEQTtBQUdBLEdBUEE7QUFTQTtBQUNBO0FBQ0EsYUFEQSxtQkFDQSxHQURBLEVBQ0E7QUFDQTtBQUNBLE9BSEE7QUFJQTtBQUpBO0FBREEsR0FUQTtBQWtCQTtBQUNBLGNBREEsd0JBQ0E7QUFDQTtBQUNBLEtBSEE7QUFJQSxRQUpBLGtCQUlBO0FBQ0E7QUFDQSxLQU5BO0FBT0EsU0FQQSxtQkFPQTtBQUNBO0FBQ0EsS0FUQTtBQVVBLFdBVkEscUJBVUE7QUFDQTtBQUNBLEtBWkE7QUFhQSxXQWJBLHFCQWFBO0FBQ0E7QUFDQSxLQWZBO0FBZ0JBLGNBaEJBLHdCQWdCQTtBQUNBO0FBQ0EseUJBQ0E7QUFDQSwwQkFDQTtBQUNBLDZCQUNBO0FBQ0EsNkJBQ0E7QUFDQTtBQUNBLEtBM0JBO0FBNEJBLGNBNUJBLHdCQTRCQTtBQUNBO0FBQ0E7QUE5QkEsR0FsQkE7QUFtREE7QUFDQSxjQURBLHdCQUNBO0FBQUE7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUhBLEVBR0EsSUFIQTtBQUlBO0FBQ0E7QUFSQSxHQW5EQTtBQThEQSxlQTlEQSwyQkE4REE7QUFDQTtBQUNBO0FBaEVBLEc7O0FDYmlXLENBQWdCLDhHQUFHLEVBQUMsQzs7Ozs7Ozs7QUNBalI7QUFDdkM7QUFDTDtBQUNxQzs7O0FBRzdGO0FBQ2dHO0FBQ2hHLGdCQUFnQiw4Q0FBVTtBQUMxQixFQUFFLHdDQUFNO0FBQ1IsRUFBRSxNQUFNO0FBQ1IsRUFBRSxlQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVlLDBGIiwiZmlsZSI6ImM2YmEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge3ZhciBfdm09dGhpczt2YXIgX2g9X3ZtLiRjcmVhdGVFbGVtZW50O3ZhciBfYz1fdm0uX3NlbGYuX2N8fF9oO3JldHVybiBfYygnZGl2JyxbX2MoJ2ltZycse2RpcmVjdGl2ZXM6W3tuYW1lOlwic2hvd1wiLHJhd05hbWU6XCJ2LXNob3dcIix2YWx1ZTooX3ZtLnZvdGUudGltZUxlZnQgPiAwKSxleHByZXNzaW9uOlwidm90ZS50aW1lTGVmdCA+IDBcIn1dLHN0YXRpY0NsYXNzOlwiaWNvbiBzbWFsbFwiLGF0dHJzOntcInNyY1wiOl92bS5wdWJsaWNQYXRoICsgJ2hvdXJnbGFzcy1zdGFydC1zb2xpZC5zdmcnfX0pLF92bS5fdihcIiBcIitfdm0uX3MoX3ZtLmZvcm1hdFRpbWUpK1wiIFwiKV0pfVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5cbmV4cG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0iLCI8dGVtcGxhdGU+XG5cdDxkaXY+XG5cdFx0PGltZyBcblx0XHRcdDpzcmM9XCJwdWJsaWNQYXRoICsgJ2hvdXJnbGFzcy1zdGFydC1zb2xpZC5zdmcnXCIgXG5cdFx0XHRjbGFzcz0naWNvbiBzbWFsbCdcblx0XHRcdHYtc2hvdz0ndm90ZS50aW1lTGVmdCA+IDAnXG5cdFx0PiB7eyBmb3JtYXRUaW1lIH19XG5cdDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cblx0aW1wb3J0IHsgZm9ybWF0RGF5VGltZVRvSHVtYW4gfSBmcm9tICcuLi8uLi8uLi91dGlscy9oZWxwZXJzJ1xuXG5cdGV4cG9ydCBkZWZhdWx0IHtcblx0XHRwcm9wczogWyd2b3RlJ10sXG5cblx0XHRkYXRhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGludGVydmFsOiBudWxsLFxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHR3YXRjaDoge1xuXHRcdFx0dm90ZU51bWJlcjoge1xuXHRcdFx0XHRoYW5kbGVyKHZhbCkge1xuXHRcdFx0XHRcdHRoaXMuc3RhcnRUaW1lcigpXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGltbWVkaWF0ZTogdHJ1ZSxcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y29tcHV0ZWQ6IHtcblx0XHRcdHZvdGVOdW1iZXIoKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZvdGUudm90ZU51bWJlclxuXHRcdFx0fSxcblx0XHRcdGRheXMoKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLmZsb29yKHRoaXMudm90ZS50aW1lTGVmdCAvICg2MCAqIDYwICogMjQpKVxuXHRcdFx0fSxcblx0XHRcdGhvdXJzKCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigodGhpcy52b3RlLnRpbWVMZWZ0ICUgKCA2MCAqIDYwICogMjQpKSAvICg2MCAqIDYwKSlcblx0XHRcdH0sXG5cdFx0XHRtaW51dGVzKCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5mbG9vcigodGhpcy52b3RlLnRpbWVMZWZ0ICUgKCA2MCAqIDYwKSkgLyAoNjApKVxuXHRcdFx0fSxcblx0XHRcdHNlY29uZHMoKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLmZsb29yKCh0aGlzLnZvdGUudGltZUxlZnQgJSAoNjApKSApXG5cdFx0XHR9LFxuXHRcdFx0Zm9ybWF0VGltZSgpIHtcblx0XHRcdFx0bGV0IHN0ciA9ICcnXG5cdFx0XHRcdGlmKHRoaXMuZGF5cyA+IDApXG5cdFx0XHRcdFx0c3RyICs9IFN0cmluZyh0aGlzLmRheXMpLnBhZFN0YXJ0KDIsICcwJykgKyAnRDonXG5cdFx0XHRcdGlmKHRoaXMuaG91cnMgPiAwKVxuXHRcdFx0XHRcdHN0ciArPSBTdHJpbmcodGhpcy5ob3VycykucGFkU3RhcnQoMiwgJzAnKSArICdIOidcblx0XHRcdFx0aWYodGhpcy5taW51dGVzID49IDApXG5cdFx0XHRcdFx0c3RyICs9IFN0cmluZyh0aGlzLm1pbnV0ZXMpLnBhZFN0YXJ0KDIsICcwJykgKyAnTTonXG5cdFx0XHRcdGlmKHRoaXMuc2Vjb25kcyA+PSAwKVxuXHRcdFx0XHRcdHN0ciArPSBTdHJpbmcodGhpcy5zZWNvbmRzKS5wYWRTdGFydCgyLCAnMCcpICsgJ1MnXG5cdFx0XHRcdHJldHVybiBzdHJcblx0XHRcdH0sXG5cdFx0XHRwdWJsaWNQYXRoKCkge1xuXHRcdFx0XHRyZXR1cm4gcHJvY2Vzcy5lbnYuQkFTRV9VUkxcblx0XHRcdH0sXG5cdFx0fSxcblxuXHRcdG1ldGhvZHM6IHtcblx0XHRcdHN0YXJ0VGltZXIoKSB7XG5cdFx0XHRcdGlmKHRoaXMudm90ZS50aW1lTGVmdCA+IDAgJiYgIXRoaXMudm90ZS5leGVjdXRlZCAmJiB0aGlzLmludGVydmFsID09PSBudWxsKSB7XG5cdFx0XHRcdFx0dGhpcy5pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcblx0XHRcdFx0XHRcdHRoaXMudm90ZS50aW1lTGVmdCAtPSAxXG5cdFx0XHRcdFx0XHRpZih0aGlzLnZvdGUudGltZUxlZnQgPCAwKSBjbGVhckludGVydmFsKHRoaXMuaW50ZXJ2YWwpXG5cdFx0XHRcdFx0fSwgMTAwMClcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHR9LFxuXG5cdFx0YmVmb3JlRGVzdHJveSgpIHtcblx0XHRcdGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbClcblx0XHR9LFxuXHR9XG48L3NjcmlwdD5cblxuPHN0eWxlIHNjb3BlZD5cblx0aW1nIHtcblx0XHRtYXJnaW4tcmlnaHQ6IDAuNGVtO1xuXHR9XG48L3N0eWxlPiIsImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0xMi0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90aHJlYWQtbG9hZGVyL2Rpc3QvY2pzLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jYWNoZS1sb2FkZXIvZGlzdC9janMuanM/P3JlZi0tMC0wIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vQ291bnRkb3duLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIjsgZXhwb3J0IGRlZmF1bHQgbW9kOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY2FjaGUtbG9hZGVyL2Rpc3QvY2pzLmpzPz9yZWYtLTEyLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RocmVhZC1sb2FkZXIvZGlzdC9janMuanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanMhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2NhY2hlLWxvYWRlci9kaXN0L2Nqcy5qcz8/cmVmLS0wLTAhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9Db3VudGRvd24udnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIiwiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9Db3VudGRvd24udnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPWY2NmE3NjQwJnNjb3BlZD10cnVlJlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0NvdW50ZG93bi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmV4cG9ydCAqIGZyb20gXCIuL0NvdW50ZG93bi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vQ291bnRkb3duLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPWY2NmE3NjQwJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgXCJmNjZhNzY0MFwiLFxuICBudWxsXG4gIFxuKVxuXG5leHBvcnQgZGVmYXVsdCBjb21wb25lbnQuZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///c6ba\n')},c6f3:function(module){eval('module.exports = JSON.parse("{\\"appName\\":\\"apm-registry.aragonpm.eth\\",\\"roles\\":[{\\"id\\":\\"CREATE_REPO_ROLE\\",\\"bytes\\":\\"0x2a9494d64846c9fdbf0158785aa330d8bc9caf45af27fa0e8898eb4d55adcea6\\",\\"name\\":\\"Create repos\\",\\"params\\":[]}],\\"functions\\":[{\\"sig\\":\\"initialize(address)\\",\\"roles\\":[],\\"notice\\":\\"Initialize this APMRegistry instance and set `_registrar` as the ENS subdomain registrar\\"},{\\"sig\\":\\"newRepo(string,address)\\",\\"roles\\":[\\"CREATE_REPO_ROLE\\"],\\"notice\\":\\"Create new repo in registry with `_name`\\"},{\\"sig\\":\\"newRepoWithVersion(string,address,uint16[3],address,bytes)\\",\\"roles\\":[\\"CREATE_REPO_ROLE\\"],\\"notice\\":\\"Create new repo in registry with `_name` and publish a first version with contract `_contractAddress` and content `@fromHex(_contentURI)`\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJjNmYzLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///c6f3\n')},cd6f:function(module){eval('module.exports = JSON.parse("{\\"appName\\":\\"apm-repo.aragonpm.eth\\",\\"roles\\":[{\\"id\\":\\"CREATE_VERSION_ROLE\\",\\"bytes\\":\\"0x1f56cfecd3595a2e6cc1a7e6cb0b20df84cdbd92eff2fee554e70e4e45a9a7d8\\",\\"name\\":\\"Publish versions\\",\\"params\\":[]}],\\"functions\\":[{\\"sig\\":\\"initialize()\\",\\"roles\\":[],\\"notice\\":\\"Initialize this Repo\\"},{\\"sig\\":\\"newVersion(uint16[3],address,bytes)\\",\\"roles\\":[\\"CREATE_VERSION_ROLE\\"],\\"notice\\":\\"Create new version with contract `_contractAddress` and content `@fromHex(_contentURI)`\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJjZDZmLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///cd6f\n')},d0a4:function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9kYW8vdm90ZXMvUGFnaW5hdGlvbi52dWU/YWUwYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiJkMGE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///d0a4\n")},d1ac:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar votes_1 = __webpack_require__("5023");\nObject.defineProperty(exports, "parseVotes", { enumerable: true, get: function () { return votes_1.parseVotes; } });\nvar casts_1 = __webpack_require__("0dad");\nObject.defineProperty(exports, "parseCasts", { enumerable: true, get: function () { return casts_1.parseCasts; } });\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L3BhcnNlcnMvaW5kZXguanM/ZDFhYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE4QyxjQUFjO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxNQUFTO0FBQy9CLDhDQUE4QyxxQ0FBcUMsMkJBQTJCLEVBQUUsRUFBRTtBQUNsSCxjQUFjLG1CQUFPLENBQUMsTUFBUztBQUMvQiw4Q0FBOEMscUNBQXFDLDJCQUEyQixFQUFFLEVBQUU7QUFDbEgiLCJmaWxlIjoiZDFhYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHZvdGVzXzEgPSByZXF1aXJlKFwiLi92b3Rlc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInBhcnNlVm90ZXNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZvdGVzXzEucGFyc2VWb3RlczsgfSB9KTtcbnZhciBjYXN0c18xID0gcmVxdWlyZShcIi4vY2FzdHNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZUNhc3RzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYXN0c18xLnBhcnNlQ2FzdHM7IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///d1ac\n')},dfda:function(module){eval('module.exports = JSON.parse("{\\"abi\\":[{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"hasInitialized\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_script\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"getEVMScriptExecutor\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"registrar\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getRecoveryVault\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"ens\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"CREATE_REPO_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"allowRecoverability\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"appId\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getInitializationBlock\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"transferToVault\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_sender\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_params\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"canPerform\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getEVMScriptRegistry\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_initializePayload\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"newAppProxyPinned\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"kernel\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"isPetrified\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"newAppProxy\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_initializePayload\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"newAppProxy\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_kernel\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_appId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"newAppProxyPinned\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":false,\\"name\\":\\"id\\",\\"type\\":\\"bytes32\\"},{\\"indexed\\":false,\\"name\\":\\"name\\",\\"type\\":\\"string\\"},{\\"indexed\\":false,\\"name\\":\\"repo\\",\\"type\\":\\"address\\"}],\\"name\\":\\"NewRepo\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":false,\\"name\\":\\"proxy\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"isUpgradeable\\",\\"type\\":\\"bool\\"},{\\"indexed\\":false,\\"name\\":\\"appId\\",\\"type\\":\\"bytes32\\"}],\\"name\\":\\"NewAppProxy\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"executor\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"script\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"input\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"returnData\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"ScriptResult\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"vault\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"token\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"amount\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"RecoverToVault\\",\\"type\\":\\"event\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_registrar\\",\\"type\\":\\"address\\"}],\\"name\\":\\"initialize\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_name\\",\\"type\\":\\"string\\"},{\\"name\\":\\"_dev\\",\\"type\\":\\"address\\"}],\\"name\\":\\"newRepo\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_name\\",\\"type\\":\\"string\\"},{\\"name\\":\\"_dev\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_initialSemanticVersion\\",\\"type\\":\\"uint16[3]\\"},{\\"name\\":\\"_contractAddress\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_contentURI\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"newRepoWithVersion\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJkZmRhLmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///dfda\n')},e575:function(module){eval('module.exports = JSON.parse("{\\"abi\\":[{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"hasInitialized\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"REGISTRY_ADD_EXECUTOR_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_script\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"getEVMScriptExecutor\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getRecoveryVault\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"allowRecoverability\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"appId\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getInitializationBlock\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_token\\",\\"type\\":\\"address\\"}],\\"name\\":\\"transferToVault\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_sender\\",\\"type\\":\\"address\\"},{\\"name\\":\\"_role\\",\\"type\\":\\"bytes32\\"},{\\"name\\":\\"_params\\",\\"type\\":\\"uint256[]\\"}],\\"name\\":\\"canPerform\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"getEVMScriptRegistry\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"REGISTRY_MANAGER_ROLE\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bytes32\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"kernel\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[],\\"name\\":\\"isPetrified\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"executors\\",\\"outputs\\":[{\\"name\\":\\"executor\\",\\"type\\":\\"address\\"},{\\"name\\":\\"enabled\\",\\"type\\":\\"bool\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"executorId\\",\\"type\\":\\"uint256\\"},{\\"indexed\\":true,\\"name\\":\\"executorAddress\\",\\"type\\":\\"address\\"}],\\"name\\":\\"EnableExecutor\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"executorId\\",\\"type\\":\\"uint256\\"},{\\"indexed\\":true,\\"name\\":\\"executorAddress\\",\\"type\\":\\"address\\"}],\\"name\\":\\"DisableExecutor\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"executor\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"script\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"input\\",\\"type\\":\\"bytes\\"},{\\"indexed\\":false,\\"name\\":\\"returnData\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"ScriptResult\\",\\"type\\":\\"event\\"},{\\"anonymous\\":false,\\"inputs\\":[{\\"indexed\\":true,\\"name\\":\\"vault\\",\\"type\\":\\"address\\"},{\\"indexed\\":true,\\"name\\":\\"token\\",\\"type\\":\\"address\\"},{\\"indexed\\":false,\\"name\\":\\"amount\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"RecoverToVault\\",\\"type\\":\\"event\\"},{\\"constant\\":false,\\"inputs\\":[],\\"name\\":\\"initialize\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_executor\\",\\"type\\":\\"address\\"}],\\"name\\":\\"addScriptExecutor\\",\\"outputs\\":[{\\"name\\":\\"id\\",\\"type\\":\\"uint256\\"}],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_executorId\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"disableScriptExecutor\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":false,\\"inputs\\":[{\\"name\\":\\"_executorId\\",\\"type\\":\\"uint256\\"}],\\"name\\":\\"enableScriptExecutor\\",\\"outputs\\":[],\\"payable\\":false,\\"stateMutability\\":\\"nonpayable\\",\\"type\\":\\"function\\"},{\\"constant\\":true,\\"inputs\\":[{\\"name\\":\\"_script\\",\\"type\\":\\"bytes\\"}],\\"name\\":\\"getScriptExecutor\\",\\"outputs\\":[{\\"name\\":\\"\\",\\"type\\":\\"address\\"}],\\"payable\\":false,\\"stateMutability\\":\\"view\\",\\"type\\":\\"function\\"}]}");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJlNTc1LmpzIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///e575\n')},e707:function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.CASTS_FOR_VOTE = exports.ALL_VOTES = void 0;\nconst graphql_tag_1 = __importDefault(__webpack_require__("9530"));\nexports.ALL_VOTES = (type) => graphql_tag_1.default `\n  ${type} Votes($appAddress: String!, $first: Int!, $skip: Int!) {\n    votes(where: {\n      appAddress: $appAddress\n    }, first: $first, skip: $skip) {\n      id\n      appAddress\n      orgAddress\n      creator\n      metadata\n      executed\n      startDate\n      snapshotBlock\n      supportRequiredPct\n      minAcceptQuorum\n      yea\n      nay\n      votingPower\n      script\n    }\n  }\n`;\nexports.CASTS_FOR_VOTE = (type) => graphql_tag_1.default `\n  ${type} Casts($voteId: ID!, $first: Int!, $skip: Int!) {\n    casts(where: {\n      voteId: $voteId\n    }, first: $first, skip: $skip) {\n      id\n      voteId\n      voter\n      supports\n    }\n  }\n`;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L3F1ZXJpZXMvaW5kZXguanM/ZTcwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQSxzQ0FBc0MsbUJBQU8sQ0FBQyxNQUFhO0FBQzNEO0FBQ0EsSUFBSSxLQUFLO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEtBQUs7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZTcwNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DQVNUU19GT1JfVk9URSA9IGV4cG9ydHMuQUxMX1ZPVEVTID0gdm9pZCAwO1xuY29uc3QgZ3JhcGhxbF90YWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZ3JhcGhxbC10YWdcIikpO1xuZXhwb3J0cy5BTExfVk9URVMgPSAodHlwZSkgPT4gZ3JhcGhxbF90YWdfMS5kZWZhdWx0IGBcbiAgJHt0eXBlfSBWb3RlcygkYXBwQWRkcmVzczogU3RyaW5nISwgJGZpcnN0OiBJbnQhLCAkc2tpcDogSW50ISkge1xuICAgIHZvdGVzKHdoZXJlOiB7XG4gICAgICBhcHBBZGRyZXNzOiAkYXBwQWRkcmVzc1xuICAgIH0sIGZpcnN0OiAkZmlyc3QsIHNraXA6ICRza2lwKSB7XG4gICAgICBpZFxuICAgICAgYXBwQWRkcmVzc1xuICAgICAgb3JnQWRkcmVzc1xuICAgICAgY3JlYXRvclxuICAgICAgbWV0YWRhdGFcbiAgICAgIGV4ZWN1dGVkXG4gICAgICBzdGFydERhdGVcbiAgICAgIHNuYXBzaG90QmxvY2tcbiAgICAgIHN1cHBvcnRSZXF1aXJlZFBjdFxuICAgICAgbWluQWNjZXB0UXVvcnVtXG4gICAgICB5ZWFcbiAgICAgIG5heVxuICAgICAgdm90aW5nUG93ZXJcbiAgICAgIHNjcmlwdFxuICAgIH1cbiAgfVxuYDtcbmV4cG9ydHMuQ0FTVFNfRk9SX1ZPVEUgPSAodHlwZSkgPT4gZ3JhcGhxbF90YWdfMS5kZWZhdWx0IGBcbiAgJHt0eXBlfSBDYXN0cygkdm90ZUlkOiBJRCEsICRmaXJzdDogSW50ISwgJHNraXA6IEludCEpIHtcbiAgICBjYXN0cyh3aGVyZToge1xuICAgICAgdm90ZUlkOiAkdm90ZUlkXG4gICAgfSwgZmlyc3Q6ICRmaXJzdCwgc2tpcDogJHNraXApIHtcbiAgICAgIGlkXG4gICAgICB2b3RlSWRcbiAgICAgIHZvdGVyXG4gICAgICBzdXBwb3J0c1xuICAgIH1cbiAgfVxuYDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///e707\n')},ebc9:function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, factory) {\n\t true ? factory(exports) :\n\tundefined;\n}(this, function (exports) { \'use strict\';\n\n\tvar commonjsGlobal = typeof globalThis !== \'undefined\' ? globalThis : typeof window !== \'undefined\' ? window : typeof global !== \'undefined\' ? global : typeof self !== \'undefined\' ? self : {};\n\n\tfunction commonjsRequire () {\n\t\tthrow new Error(\'Dynamic requires are not currently supported by rollup-plugin-commonjs\');\n\t}\n\n\tfunction unwrapExports (x) {\n\t\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \'default\') ? x[\'default\'] : x;\n\t}\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tfunction getCjsExportFromNamespace (n) {\n\t\treturn n && n[\'default\'] || n;\n\t}\n\n\tvar _nodeResolve_empty = {};\n\n\tvar _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({\n\t\t\'default\': _nodeResolve_empty\n\t});\n\n\tvar require$$0 = getCjsExportFromNamespace(_nodeResolve_empty$1);\n\n\tvar bn = createCommonjsModule(function (module) {\n\t(function (module, exports) {\n\t  \'use strict\';\n\n\t  // Utils\n\t  function assert (val, msg) {\n\t    if (!val) throw new Error(msg || \'Assertion failed\');\n\t  }\n\n\t  // Could use `inherits` module, but don\'t want to move from single file\n\t  // architecture yet.\n\t  function inherits (ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\n\t  // BN\n\n\t  function BN (number, base, endian) {\n\t    if (BN.isBN(number)) {\n\t      return number;\n\t    }\n\n\t    this.negative = 0;\n\t    this.words = null;\n\t    this.length = 0;\n\n\t    // Reduction context\n\t    this.red = null;\n\n\t    if (number !== null) {\n\t      if (base === \'le\' || base === \'be\') {\n\t        endian = base;\n\t        base = 10;\n\t      }\n\n\t      this._init(number || 0, base || 10, endian || \'be\');\n\t    }\n\t  }\n\t  if (typeof module === \'object\') {\n\t    module.exports = BN;\n\t  } else {\n\t    exports.BN = BN;\n\t  }\n\n\t  BN.BN = BN;\n\t  BN.wordSize = 26;\n\n\t  var Buffer;\n\t  try {\n\t    Buffer = require$$0.Buffer;\n\t  } catch (e) {\n\t  }\n\n\t  BN.isBN = function isBN (num) {\n\t    if (num instanceof BN) {\n\t      return true;\n\t    }\n\n\t    return num !== null && typeof num === \'object\' &&\n\t      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n\t  };\n\n\t  BN.max = function max (left, right) {\n\t    if (left.cmp(right) > 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.min = function min (left, right) {\n\t    if (left.cmp(right) < 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.prototype._init = function init (number, base, endian) {\n\t    if (typeof number === \'number\') {\n\t      return this._initNumber(number, base, endian);\n\t    }\n\n\t    if (typeof number === \'object\') {\n\t      return this._initArray(number, base, endian);\n\t    }\n\n\t    if (base === \'hex\') {\n\t      base = 16;\n\t    }\n\t    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n\t    number = number.toString().replace(/\\s+/g, \'\');\n\t    var start = 0;\n\t    if (number[0] === \'-\') {\n\t      start++;\n\t    }\n\n\t    if (base === 16) {\n\t      this._parseHex(number, start);\n\t    } else {\n\t      this._parseBase(number, base, start);\n\t    }\n\n\t    if (number[0] === \'-\') {\n\t      this.negative = 1;\n\t    }\n\n\t    this.strip();\n\n\t    if (endian !== \'le\') return;\n\n\t    this._initArray(this.toArray(), base, endian);\n\t  };\n\n\t  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n\t    if (number < 0) {\n\t      this.negative = 1;\n\t      number = -number;\n\t    }\n\t    if (number < 0x4000000) {\n\t      this.words = [ number & 0x3ffffff ];\n\t      this.length = 1;\n\t    } else if (number < 0x10000000000000) {\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff\n\t      ];\n\t      this.length = 2;\n\t    } else {\n\t      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff,\n\t        1\n\t      ];\n\t      this.length = 3;\n\t    }\n\n\t    if (endian !== \'le\') return;\n\n\t    // Reverse the bytes\n\t    this._initArray(this.toArray(), base, endian);\n\t  };\n\n\t  BN.prototype._initArray = function _initArray (number, base, endian) {\n\t    // Perhaps a Uint8Array\n\t    assert(typeof number.length === \'number\');\n\t    if (number.length <= 0) {\n\t      this.words = [ 0 ];\n\t      this.length = 1;\n\t      return this;\n\t    }\n\n\t    this.length = Math.ceil(number.length / 3);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    var j, w;\n\t    var off = 0;\n\t    if (endian === \'be\') {\n\t      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n\t        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    } else if (endian === \'le\') {\n\t      for (i = 0, j = 0; i < number.length; i += 3) {\n\t        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    }\n\t    return this.strip();\n\t  };\n\n\t  function parseHex (str, start, end) {\n\t    var r = 0;\n\t    var len = Math.min(str.length, end);\n\t    for (var i = start; i < len; i++) {\n\t      var c = str.charCodeAt(i) - 48;\n\n\t      r <<= 4;\n\n\t      // \'a\' - \'f\'\n\t      if (c >= 49 && c <= 54) {\n\t        r |= c - 49 + 0xa;\n\n\t      // \'A\' - \'F\'\n\t      } else if (c >= 17 && c <= 22) {\n\t        r |= c - 17 + 0xa;\n\n\t      // \'0\' - \'9\'\n\t      } else {\n\t        r |= c & 0xf;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseHex = function _parseHex (number, start) {\n\t    // Create possibly bigger array to ensure that it fits the number\n\t    this.length = Math.ceil((number.length - start) / 6);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    var j, w;\n\t    // Scan 24-bit chunks and add them to the number\n\t    var off = 0;\n\t    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n\t      w = parseHex(number, i, i + 6);\n\t      this.words[j] |= (w << off) & 0x3ffffff;\n\t      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n\t      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n\t      off += 24;\n\t      if (off >= 26) {\n\t        off -= 26;\n\t        j++;\n\t      }\n\t    }\n\t    if (i + 6 !== start) {\n\t      w = parseHex(number, start, i + 6);\n\t      this.words[j] |= (w << off) & 0x3ffffff;\n\t      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n\t    }\n\t    this.strip();\n\t  };\n\n\t  function parseBase (str, start, end, mul) {\n\t    var r = 0;\n\t    var len = Math.min(str.length, end);\n\t    for (var i = start; i < len; i++) {\n\t      var c = str.charCodeAt(i) - 48;\n\n\t      r *= mul;\n\n\t      // \'a\'\n\t      if (c >= 49) {\n\t        r += c - 49 + 0xa;\n\n\t      // \'A\'\n\t      } else if (c >= 17) {\n\t        r += c - 17 + 0xa;\n\n\t      // \'0\' - \'9\'\n\t      } else {\n\t        r += c;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseBase = function _parseBase (number, base, start) {\n\t    // Initialize as zero\n\t    this.words = [ 0 ];\n\t    this.length = 1;\n\n\t    // Find length of limb in base\n\t    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n\t      limbLen++;\n\t    }\n\t    limbLen--;\n\t    limbPow = (limbPow / base) | 0;\n\n\t    var total = number.length - start;\n\t    var mod = total % limbLen;\n\t    var end = Math.min(total, total - mod) + start;\n\n\t    var word = 0;\n\t    for (var i = start; i < end; i += limbLen) {\n\t      word = parseBase(number, i, i + limbLen, base);\n\n\t      this.imuln(limbPow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\n\t    if (mod !== 0) {\n\t      var pow = 1;\n\t      word = parseBase(number, i, number.length, base);\n\n\t      for (i = 0; i < mod; i++) {\n\t        pow *= base;\n\t      }\n\n\t      this.imuln(pow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\t  };\n\n\t  BN.prototype.copy = function copy (dest) {\n\t    dest.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      dest.words[i] = this.words[i];\n\t    }\n\t    dest.length = this.length;\n\t    dest.negative = this.negative;\n\t    dest.red = this.red;\n\t  };\n\n\t  BN.prototype.clone = function clone () {\n\t    var r = new BN(null);\n\t    this.copy(r);\n\t    return r;\n\t  };\n\n\t  BN.prototype._expand = function _expand (size) {\n\t    while (this.length < size) {\n\t      this.words[this.length++] = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  // Remove leading `0` from `this`\n\t  BN.prototype.strip = function strip () {\n\t    while (this.length > 1 && this.words[this.length - 1] === 0) {\n\t      this.length--;\n\t    }\n\t    return this._normSign();\n\t  };\n\n\t  BN.prototype._normSign = function _normSign () {\n\t    // -0 = 0\n\t    if (this.length === 1 && this.words[0] === 0) {\n\t      this.negative = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.inspect = function inspect () {\n\t    return (this.red ? \'<BN-R: \' : \'<BN: \') + this.toString(16) + \'>\';\n\t  };\n\n\t  /*\n\n\t  var zeros = [];\n\t  var groupSizes = [];\n\t  var groupBases = [];\n\n\t  var s = \'\';\n\t  var i = -1;\n\t  while (++i < BN.wordSize) {\n\t    zeros[i] = s;\n\t    s += \'0\';\n\t  }\n\t  groupSizes[0] = 0;\n\t  groupSizes[1] = 0;\n\t  groupBases[0] = 0;\n\t  groupBases[1] = 0;\n\t  var base = 2 - 1;\n\t  while (++base < 36 + 1) {\n\t    var groupSize = 0;\n\t    var groupBase = 1;\n\t    while (groupBase < (1 << BN.wordSize) / base) {\n\t      groupBase *= base;\n\t      groupSize += 1;\n\t    }\n\t    groupSizes[base] = groupSize;\n\t    groupBases[base] = groupBase;\n\t  }\n\n\t  */\n\n\t  var zeros = [\n\t    \'\',\n\t    \'0\',\n\t    \'00\',\n\t    \'000\',\n\t    \'0000\',\n\t    \'00000\',\n\t    \'000000\',\n\t    \'0000000\',\n\t    \'00000000\',\n\t    \'000000000\',\n\t    \'0000000000\',\n\t    \'00000000000\',\n\t    \'000000000000\',\n\t    \'0000000000000\',\n\t    \'00000000000000\',\n\t    \'000000000000000\',\n\t    \'0000000000000000\',\n\t    \'00000000000000000\',\n\t    \'000000000000000000\',\n\t    \'0000000000000000000\',\n\t    \'00000000000000000000\',\n\t    \'000000000000000000000\',\n\t    \'0000000000000000000000\',\n\t    \'00000000000000000000000\',\n\t    \'000000000000000000000000\',\n\t    \'0000000000000000000000000\'\n\t  ];\n\n\t  var groupSizes = [\n\t    0, 0,\n\t    25, 16, 12, 11, 10, 9, 8,\n\t    8, 7, 7, 7, 7, 6, 6,\n\t    6, 6, 6, 6, 6, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5\n\t  ];\n\n\t  var groupBases = [\n\t    0, 0,\n\t    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n\t    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n\t    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n\t    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n\t    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n\t  ];\n\n\t  BN.prototype.toString = function toString (base, padding) {\n\t    base = base || 10;\n\t    padding = padding | 0 || 1;\n\n\t    var out;\n\t    if (base === 16 || base === \'hex\') {\n\t      out = \'\';\n\t      var off = 0;\n\t      var carry = 0;\n\t      for (var i = 0; i < this.length; i++) {\n\t        var w = this.words[i];\n\t        var word = (((w << off) | carry) & 0xffffff).toString(16);\n\t        carry = (w >>> (24 - off)) & 0xffffff;\n\t        if (carry !== 0 || i !== this.length - 1) {\n\t          out = zeros[6 - word.length] + word + out;\n\t        } else {\n\t          out = word + out;\n\t        }\n\t        off += 2;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          i--;\n\t        }\n\t      }\n\t      if (carry !== 0) {\n\t        out = carry.toString(16) + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = \'0\' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = \'-\' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    if (base === (base | 0) && base >= 2 && base <= 36) {\n\t      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n\t      var groupSize = groupSizes[base];\n\t      // var groupBase = Math.pow(base, groupSize);\n\t      var groupBase = groupBases[base];\n\t      out = \'\';\n\t      var c = this.clone();\n\t      c.negative = 0;\n\t      while (!c.isZero()) {\n\t        var r = c.modn(groupBase).toString(base);\n\t        c = c.idivn(groupBase);\n\n\t        if (!c.isZero()) {\n\t          out = zeros[groupSize - r.length] + r + out;\n\t        } else {\n\t          out = r + out;\n\t        }\n\t      }\n\t      if (this.isZero()) {\n\t        out = \'0\' + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = \'0\' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = \'-\' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    assert(false, \'Base should be between 2 and 36\');\n\t  };\n\n\t  BN.prototype.toNumber = function toNumber () {\n\t    var ret = this.words[0];\n\t    if (this.length === 2) {\n\t      ret += this.words[1] * 0x4000000;\n\t    } else if (this.length === 3 && this.words[2] === 0x01) {\n\t      // NOTE: at this stage it is known that the top bit is set\n\t      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n\t    } else if (this.length > 2) {\n\t      assert(false, \'Number can only safely store up to 53 bits\');\n\t    }\n\t    return (this.negative !== 0) ? -ret : ret;\n\t  };\n\n\t  BN.prototype.toJSON = function toJSON () {\n\t    return this.toString(16);\n\t  };\n\n\t  BN.prototype.toBuffer = function toBuffer (endian, length) {\n\t    assert(typeof Buffer !== \'undefined\');\n\t    return this.toArrayLike(Buffer, endian, length);\n\t  };\n\n\t  BN.prototype.toArray = function toArray (endian, length) {\n\t    return this.toArrayLike(Array, endian, length);\n\t  };\n\n\t  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n\t    var byteLength = this.byteLength();\n\t    var reqLength = length || Math.max(1, byteLength);\n\t    assert(byteLength <= reqLength, \'byte array longer than desired length\');\n\t    assert(reqLength > 0, \'Requested array length <= 0\');\n\n\t    this.strip();\n\t    var littleEndian = endian === \'le\';\n\t    var res = new ArrayType(reqLength);\n\n\t    var b, i;\n\t    var q = this.clone();\n\t    if (!littleEndian) {\n\t      // Assume big-endian\n\t      for (i = 0; i < reqLength - byteLength; i++) {\n\t        res[i] = 0;\n\t      }\n\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[reqLength - i - 1] = b;\n\t      }\n\t    } else {\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[i] = b;\n\t      }\n\n\t      for (; i < reqLength; i++) {\n\t        res[i] = 0;\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  if (Math.clz32) {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      return 32 - Math.clz32(w);\n\t    };\n\t  } else {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      var t = w;\n\t      var r = 0;\n\t      if (t >= 0x1000) {\n\t        r += 13;\n\t        t >>>= 13;\n\t      }\n\t      if (t >= 0x40) {\n\t        r += 7;\n\t        t >>>= 7;\n\t      }\n\t      if (t >= 0x8) {\n\t        r += 4;\n\t        t >>>= 4;\n\t      }\n\t      if (t >= 0x02) {\n\t        r += 2;\n\t        t >>>= 2;\n\t      }\n\t      return r + t;\n\t    };\n\t  }\n\n\t  BN.prototype._zeroBits = function _zeroBits (w) {\n\t    // Short-cut\n\t    if (w === 0) return 26;\n\n\t    var t = w;\n\t    var r = 0;\n\t    if ((t & 0x1fff) === 0) {\n\t      r += 13;\n\t      t >>>= 13;\n\t    }\n\t    if ((t & 0x7f) === 0) {\n\t      r += 7;\n\t      t >>>= 7;\n\t    }\n\t    if ((t & 0xf) === 0) {\n\t      r += 4;\n\t      t >>>= 4;\n\t    }\n\t    if ((t & 0x3) === 0) {\n\t      r += 2;\n\t      t >>>= 2;\n\t    }\n\t    if ((t & 0x1) === 0) {\n\t      r++;\n\t    }\n\t    return r;\n\t  };\n\n\t  // Return number of used bits in a BN\n\t  BN.prototype.bitLength = function bitLength () {\n\t    var w = this.words[this.length - 1];\n\t    var hi = this._countBits(w);\n\t    return (this.length - 1) * 26 + hi;\n\t  };\n\n\t  function toBitArray (num) {\n\t    var w = new Array(num.bitLength());\n\n\t    for (var bit = 0; bit < w.length; bit++) {\n\t      var off = (bit / 26) | 0;\n\t      var wbit = bit % 26;\n\n\t      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n\t    }\n\n\t    return w;\n\t  }\n\n\t  // Number of trailing zero bits\n\t  BN.prototype.zeroBits = function zeroBits () {\n\t    if (this.isZero()) return 0;\n\n\t    var r = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var b = this._zeroBits(this.words[i]);\n\t      r += b;\n\t      if (b !== 26) break;\n\t    }\n\t    return r;\n\t  };\n\n\t  BN.prototype.byteLength = function byteLength () {\n\t    return Math.ceil(this.bitLength() / 8);\n\t  };\n\n\t  BN.prototype.toTwos = function toTwos (width) {\n\t    if (this.negative !== 0) {\n\t      return this.abs().inotn(width).iaddn(1);\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.fromTwos = function fromTwos (width) {\n\t    if (this.testn(width - 1)) {\n\t      return this.notn(width).iaddn(1).ineg();\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.isNeg = function isNeg () {\n\t    return this.negative !== 0;\n\t  };\n\n\t  // Return negative clone of `this`\n\t  BN.prototype.neg = function neg () {\n\t    return this.clone().ineg();\n\t  };\n\n\t  BN.prototype.ineg = function ineg () {\n\t    if (!this.isZero()) {\n\t      this.negative ^= 1;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Or `num` with `this` in-place\n\t  BN.prototype.iuor = function iuor (num) {\n\t    while (this.length < num.length) {\n\t      this.words[this.length++] = 0;\n\t    }\n\n\t    for (var i = 0; i < num.length; i++) {\n\t      this.words[i] = this.words[i] | num.words[i];\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ior = function ior (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuor(num);\n\t  };\n\n\t  // Or `num` with `this`\n\t  BN.prototype.or = function or (num) {\n\t    if (this.length > num.length) return this.clone().ior(num);\n\t    return num.clone().ior(this);\n\t  };\n\n\t  BN.prototype.uor = function uor (num) {\n\t    if (this.length > num.length) return this.clone().iuor(num);\n\t    return num.clone().iuor(this);\n\t  };\n\n\t  // And `num` with `this` in-place\n\t  BN.prototype.iuand = function iuand (num) {\n\t    // b = min-length(num, this)\n\t    var b;\n\t    if (this.length > num.length) {\n\t      b = num;\n\t    } else {\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = this.words[i] & num.words[i];\n\t    }\n\n\t    this.length = b.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.iand = function iand (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuand(num);\n\t  };\n\n\t  // And `num` with `this`\n\t  BN.prototype.and = function and (num) {\n\t    if (this.length > num.length) return this.clone().iand(num);\n\t    return num.clone().iand(this);\n\t  };\n\n\t  BN.prototype.uand = function uand (num) {\n\t    if (this.length > num.length) return this.clone().iuand(num);\n\t    return num.clone().iuand(this);\n\t  };\n\n\t  // Xor `num` with `this` in-place\n\t  BN.prototype.iuxor = function iuxor (num) {\n\t    // a.length > b.length\n\t    var a;\n\t    var b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = a.words[i] ^ b.words[i];\n\t    }\n\n\t    if (this !== a) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = a.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ixor = function ixor (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuxor(num);\n\t  };\n\n\t  // Xor `num` with `this`\n\t  BN.prototype.xor = function xor (num) {\n\t    if (this.length > num.length) return this.clone().ixor(num);\n\t    return num.clone().ixor(this);\n\t  };\n\n\t  BN.prototype.uxor = function uxor (num) {\n\t    if (this.length > num.length) return this.clone().iuxor(num);\n\t    return num.clone().iuxor(this);\n\t  };\n\n\t  // Not ``this`` with ``width`` bitwidth\n\t  BN.prototype.inotn = function inotn (width) {\n\t    assert(typeof width === \'number\' && width >= 0);\n\n\t    var bytesNeeded = Math.ceil(width / 26) | 0;\n\t    var bitsLeft = width % 26;\n\n\t    // Extend the buffer with leading zeroes\n\t    this._expand(bytesNeeded);\n\n\t    if (bitsLeft > 0) {\n\t      bytesNeeded--;\n\t    }\n\n\t    // Handle complete words\n\t    for (var i = 0; i < bytesNeeded; i++) {\n\t      this.words[i] = ~this.words[i] & 0x3ffffff;\n\t    }\n\n\t    // Handle the residue\n\t    if (bitsLeft > 0) {\n\t      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n\t    }\n\n\t    // And remove leading zeroes\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.notn = function notn (width) {\n\t    return this.clone().inotn(width);\n\t  };\n\n\t  // Set `bit` of `this`\n\t  BN.prototype.setn = function setn (bit, val) {\n\t    assert(typeof bit === \'number\' && bit >= 0);\n\n\t    var off = (bit / 26) | 0;\n\t    var wbit = bit % 26;\n\n\t    this._expand(off + 1);\n\n\t    if (val) {\n\t      this.words[off] = this.words[off] | (1 << wbit);\n\t    } else {\n\t      this.words[off] = this.words[off] & ~(1 << wbit);\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Add `num` to `this` in-place\n\t  BN.prototype.iadd = function iadd (num) {\n\t    var r;\n\n\t    // negative + positive\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      this.negative = 0;\n\t      r = this.isub(num);\n\t      this.negative ^= 1;\n\t      return this._normSign();\n\n\t    // positive + negative\n\t    } else if (this.negative === 0 && num.negative !== 0) {\n\t      num.negative = 0;\n\t      r = this.isub(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\t    }\n\n\t    // a.length > b.length\n\t    var a, b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\n\t    this.length = a.length;\n\t    if (carry !== 0) {\n\t      this.words[this.length] = carry;\n\t      this.length++;\n\t    // Copy the rest of the words\n\t    } else if (a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Add `num` to `this`\n\t  BN.prototype.add = function add (num) {\n\t    var res;\n\t    if (num.negative !== 0 && this.negative === 0) {\n\t      num.negative = 0;\n\t      res = this.sub(num);\n\t      num.negative ^= 1;\n\t      return res;\n\t    } else if (num.negative === 0 && this.negative !== 0) {\n\t      this.negative = 0;\n\t      res = num.sub(this);\n\t      this.negative = 1;\n\t      return res;\n\t    }\n\n\t    if (this.length > num.length) return this.clone().iadd(num);\n\n\t    return num.clone().iadd(this);\n\t  };\n\n\t  // Subtract `num` from `this` in-place\n\t  BN.prototype.isub = function isub (num) {\n\t    // this - (-num) = this + num\n\t    if (num.negative !== 0) {\n\t      num.negative = 0;\n\t      var r = this.iadd(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\n\t    // -this - num = -(this + num)\n\t    } else if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iadd(num);\n\t      this.negative = 1;\n\t      return this._normSign();\n\t    }\n\n\t    // At this point both numbers are positive\n\t    var cmp = this.cmp(num);\n\n\t    // Optimization - zeroify\n\t    if (cmp === 0) {\n\t      this.negative = 0;\n\t      this.length = 1;\n\t      this.words[0] = 0;\n\t      return this;\n\t    }\n\n\t    // a > b\n\t    var a, b;\n\t    if (cmp > 0) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\n\t    // Copy rest of the words\n\t    if (carry === 0 && i < a.length && a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = Math.max(this.length, i);\n\n\t    if (a !== this) {\n\t      this.negative = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Subtract `num` from `this`\n\t  BN.prototype.sub = function sub (num) {\n\t    return this.clone().isub(num);\n\t  };\n\n\t  function smallMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    var len = (self.length + num.length) | 0;\n\t    out.length = len;\n\t    len = (len - 1) | 0;\n\n\t    // Peel one iteration (compiler can\'t do it, because of code complexity)\n\t    var a = self.words[0] | 0;\n\t    var b = num.words[0] | 0;\n\t    var r = a * b;\n\n\t    var lo = r & 0x3ffffff;\n\t    var carry = (r / 0x4000000) | 0;\n\t    out.words[0] = lo;\n\n\t    for (var k = 1; k < len; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = carry >>> 26;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = (k - j) | 0;\n\t        a = self.words[i] | 0;\n\t        b = num.words[j] | 0;\n\t        r = a * b + rword;\n\t        ncarry += (r / 0x4000000) | 0;\n\t        rword = r & 0x3ffffff;\n\t      }\n\t      out.words[k] = rword | 0;\n\t      carry = ncarry | 0;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry | 0;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  // TODO(indutny): it may be reasonable to omit it for users who don\'t need\n\t  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n\t  // multiplication (like elliptic secp256k1).\n\t  var comb10MulTo = function comb10MulTo (self, num, out) {\n\t    var a = self.words;\n\t    var b = num.words;\n\t    var o = out.words;\n\t    var c = 0;\n\t    var lo;\n\t    var mid;\n\t    var hi;\n\t    var a0 = a[0] | 0;\n\t    var al0 = a0 & 0x1fff;\n\t    var ah0 = a0 >>> 13;\n\t    var a1 = a[1] | 0;\n\t    var al1 = a1 & 0x1fff;\n\t    var ah1 = a1 >>> 13;\n\t    var a2 = a[2] | 0;\n\t    var al2 = a2 & 0x1fff;\n\t    var ah2 = a2 >>> 13;\n\t    var a3 = a[3] | 0;\n\t    var al3 = a3 & 0x1fff;\n\t    var ah3 = a3 >>> 13;\n\t    var a4 = a[4] | 0;\n\t    var al4 = a4 & 0x1fff;\n\t    var ah4 = a4 >>> 13;\n\t    var a5 = a[5] | 0;\n\t    var al5 = a5 & 0x1fff;\n\t    var ah5 = a5 >>> 13;\n\t    var a6 = a[6] | 0;\n\t    var al6 = a6 & 0x1fff;\n\t    var ah6 = a6 >>> 13;\n\t    var a7 = a[7] | 0;\n\t    var al7 = a7 & 0x1fff;\n\t    var ah7 = a7 >>> 13;\n\t    var a8 = a[8] | 0;\n\t    var al8 = a8 & 0x1fff;\n\t    var ah8 = a8 >>> 13;\n\t    var a9 = a[9] | 0;\n\t    var al9 = a9 & 0x1fff;\n\t    var ah9 = a9 >>> 13;\n\t    var b0 = b[0] | 0;\n\t    var bl0 = b0 & 0x1fff;\n\t    var bh0 = b0 >>> 13;\n\t    var b1 = b[1] | 0;\n\t    var bl1 = b1 & 0x1fff;\n\t    var bh1 = b1 >>> 13;\n\t    var b2 = b[2] | 0;\n\t    var bl2 = b2 & 0x1fff;\n\t    var bh2 = b2 >>> 13;\n\t    var b3 = b[3] | 0;\n\t    var bl3 = b3 & 0x1fff;\n\t    var bh3 = b3 >>> 13;\n\t    var b4 = b[4] | 0;\n\t    var bl4 = b4 & 0x1fff;\n\t    var bh4 = b4 >>> 13;\n\t    var b5 = b[5] | 0;\n\t    var bl5 = b5 & 0x1fff;\n\t    var bh5 = b5 >>> 13;\n\t    var b6 = b[6] | 0;\n\t    var bl6 = b6 & 0x1fff;\n\t    var bh6 = b6 >>> 13;\n\t    var b7 = b[7] | 0;\n\t    var bl7 = b7 & 0x1fff;\n\t    var bh7 = b7 >>> 13;\n\t    var b8 = b[8] | 0;\n\t    var bl8 = b8 & 0x1fff;\n\t    var bh8 = b8 >>> 13;\n\t    var b9 = b[9] | 0;\n\t    var bl9 = b9 & 0x1fff;\n\t    var bh9 = b9 >>> 13;\n\n\t    out.negative = self.negative ^ num.negative;\n\t    out.length = 19;\n\t    /* k = 0 */\n\t    lo = Math.imul(al0, bl0);\n\t    mid = Math.imul(al0, bh0);\n\t    mid = (mid + Math.imul(ah0, bl0)) | 0;\n\t    hi = Math.imul(ah0, bh0);\n\t    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n\t    w0 &= 0x3ffffff;\n\t    /* k = 1 */\n\t    lo = Math.imul(al1, bl0);\n\t    mid = Math.imul(al1, bh0);\n\t    mid = (mid + Math.imul(ah1, bl0)) | 0;\n\t    hi = Math.imul(ah1, bh0);\n\t    lo = (lo + Math.imul(al0, bl1)) | 0;\n\t    mid = (mid + Math.imul(al0, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh1)) | 0;\n\t    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n\t    w1 &= 0x3ffffff;\n\t    /* k = 2 */\n\t    lo = Math.imul(al2, bl0);\n\t    mid = Math.imul(al2, bh0);\n\t    mid = (mid + Math.imul(ah2, bl0)) | 0;\n\t    hi = Math.imul(ah2, bh0);\n\t    lo = (lo + Math.imul(al1, bl1)) | 0;\n\t    mid = (mid + Math.imul(al1, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh1)) | 0;\n\t    lo = (lo + Math.imul(al0, bl2)) | 0;\n\t    mid = (mid + Math.imul(al0, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh2)) | 0;\n\t    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n\t    w2 &= 0x3ffffff;\n\t    /* k = 3 */\n\t    lo = Math.imul(al3, bl0);\n\t    mid = Math.imul(al3, bh0);\n\t    mid = (mid + Math.imul(ah3, bl0)) | 0;\n\t    hi = Math.imul(ah3, bh0);\n\t    lo = (lo + Math.imul(al2, bl1)) | 0;\n\t    mid = (mid + Math.imul(al2, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh1)) | 0;\n\t    lo = (lo + Math.imul(al1, bl2)) | 0;\n\t    mid = (mid + Math.imul(al1, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh2)) | 0;\n\t    lo = (lo + Math.imul(al0, bl3)) | 0;\n\t    mid = (mid + Math.imul(al0, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh3)) | 0;\n\t    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n\t    w3 &= 0x3ffffff;\n\t    /* k = 4 */\n\t    lo = Math.imul(al4, bl0);\n\t    mid = Math.imul(al4, bh0);\n\t    mid = (mid + Math.imul(ah4, bl0)) | 0;\n\t    hi = Math.imul(ah4, bh0);\n\t    lo = (lo + Math.imul(al3, bl1)) | 0;\n\t    mid = (mid + Math.imul(al3, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh1)) | 0;\n\t    lo = (lo + Math.imul(al2, bl2)) | 0;\n\t    mid = (mid + Math.imul(al2, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh2)) | 0;\n\t    lo = (lo + Math.imul(al1, bl3)) | 0;\n\t    mid = (mid + Math.imul(al1, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh3)) | 0;\n\t    lo = (lo + Math.imul(al0, bl4)) | 0;\n\t    mid = (mid + Math.imul(al0, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh4)) | 0;\n\t    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n\t    w4 &= 0x3ffffff;\n\t    /* k = 5 */\n\t    lo = Math.imul(al5, bl0);\n\t    mid = Math.imul(al5, bh0);\n\t    mid = (mid + Math.imul(ah5, bl0)) | 0;\n\t    hi = Math.imul(ah5, bh0);\n\t    lo = (lo + Math.imul(al4, bl1)) | 0;\n\t    mid = (mid + Math.imul(al4, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh1)) | 0;\n\t    lo = (lo + Math.imul(al3, bl2)) | 0;\n\t    mid = (mid + Math.imul(al3, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh2)) | 0;\n\t    lo = (lo + Math.imul(al2, bl3)) | 0;\n\t    mid = (mid + Math.imul(al2, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh3)) | 0;\n\t    lo = (lo + Math.imul(al1, bl4)) | 0;\n\t    mid = (mid + Math.imul(al1, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh4)) | 0;\n\t    lo = (lo + Math.imul(al0, bl5)) | 0;\n\t    mid = (mid + Math.imul(al0, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh5)) | 0;\n\t    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n\t    w5 &= 0x3ffffff;\n\t    /* k = 6 */\n\t    lo = Math.imul(al6, bl0);\n\t    mid = Math.imul(al6, bh0);\n\t    mid = (mid + Math.imul(ah6, bl0)) | 0;\n\t    hi = Math.imul(ah6, bh0);\n\t    lo = (lo + Math.imul(al5, bl1)) | 0;\n\t    mid = (mid + Math.imul(al5, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh1)) | 0;\n\t    lo = (lo + Math.imul(al4, bl2)) | 0;\n\t    mid = (mid + Math.imul(al4, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh2)) | 0;\n\t    lo = (lo + Math.imul(al3, bl3)) | 0;\n\t    mid = (mid + Math.imul(al3, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh3)) | 0;\n\t    lo = (lo + Math.imul(al2, bl4)) | 0;\n\t    mid = (mid + Math.imul(al2, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh4)) | 0;\n\t    lo = (lo + Math.imul(al1, bl5)) | 0;\n\t    mid = (mid + Math.imul(al1, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh5)) | 0;\n\t    lo = (lo + Math.imul(al0, bl6)) | 0;\n\t    mid = (mid + Math.imul(al0, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh6)) | 0;\n\t    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n\t    w6 &= 0x3ffffff;\n\t    /* k = 7 */\n\t    lo = Math.imul(al7, bl0);\n\t    mid = Math.imul(al7, bh0);\n\t    mid = (mid + Math.imul(ah7, bl0)) | 0;\n\t    hi = Math.imul(ah7, bh0);\n\t    lo = (lo + Math.imul(al6, bl1)) | 0;\n\t    mid = (mid + Math.imul(al6, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh1)) | 0;\n\t    lo = (lo + Math.imul(al5, bl2)) | 0;\n\t    mid = (mid + Math.imul(al5, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh2)) | 0;\n\t    lo = (lo + Math.imul(al4, bl3)) | 0;\n\t    mid = (mid + Math.imul(al4, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh3)) | 0;\n\t    lo = (lo + Math.imul(al3, bl4)) | 0;\n\t    mid = (mid + Math.imul(al3, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh4)) | 0;\n\t    lo = (lo + Math.imul(al2, bl5)) | 0;\n\t    mid = (mid + Math.imul(al2, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh5)) | 0;\n\t    lo = (lo + Math.imul(al1, bl6)) | 0;\n\t    mid = (mid + Math.imul(al1, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh6)) | 0;\n\t    lo = (lo + Math.imul(al0, bl7)) | 0;\n\t    mid = (mid + Math.imul(al0, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh7)) | 0;\n\t    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n\t    w7 &= 0x3ffffff;\n\t    /* k = 8 */\n\t    lo = Math.imul(al8, bl0);\n\t    mid = Math.imul(al8, bh0);\n\t    mid = (mid + Math.imul(ah8, bl0)) | 0;\n\t    hi = Math.imul(ah8, bh0);\n\t    lo = (lo + Math.imul(al7, bl1)) | 0;\n\t    mid = (mid + Math.imul(al7, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh1)) | 0;\n\t    lo = (lo + Math.imul(al6, bl2)) | 0;\n\t    mid = (mid + Math.imul(al6, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh2)) | 0;\n\t    lo = (lo + Math.imul(al5, bl3)) | 0;\n\t    mid = (mid + Math.imul(al5, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh3)) | 0;\n\t    lo = (lo + Math.imul(al4, bl4)) | 0;\n\t    mid = (mid + Math.imul(al4, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh4)) | 0;\n\t    lo = (lo + Math.imul(al3, bl5)) | 0;\n\t    mid = (mid + Math.imul(al3, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh5)) | 0;\n\t    lo = (lo + Math.imul(al2, bl6)) | 0;\n\t    mid = (mid + Math.imul(al2, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh6)) | 0;\n\t    lo = (lo + Math.imul(al1, bl7)) | 0;\n\t    mid = (mid + Math.imul(al1, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh7)) | 0;\n\t    lo = (lo + Math.imul(al0, bl8)) | 0;\n\t    mid = (mid + Math.imul(al0, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh8)) | 0;\n\t    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n\t    w8 &= 0x3ffffff;\n\t    /* k = 9 */\n\t    lo = Math.imul(al9, bl0);\n\t    mid = Math.imul(al9, bh0);\n\t    mid = (mid + Math.imul(ah9, bl0)) | 0;\n\t    hi = Math.imul(ah9, bh0);\n\t    lo = (lo + Math.imul(al8, bl1)) | 0;\n\t    mid = (mid + Math.imul(al8, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh1)) | 0;\n\t    lo = (lo + Math.imul(al7, bl2)) | 0;\n\t    mid = (mid + Math.imul(al7, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh2)) | 0;\n\t    lo = (lo + Math.imul(al6, bl3)) | 0;\n\t    mid = (mid + Math.imul(al6, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh3)) | 0;\n\t    lo = (lo + Math.imul(al5, bl4)) | 0;\n\t    mid = (mid + Math.imul(al5, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh4)) | 0;\n\t    lo = (lo + Math.imul(al4, bl5)) | 0;\n\t    mid = (mid + Math.imul(al4, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh5)) | 0;\n\t    lo = (lo + Math.imul(al3, bl6)) | 0;\n\t    mid = (mid + Math.imul(al3, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh6)) | 0;\n\t    lo = (lo + Math.imul(al2, bl7)) | 0;\n\t    mid = (mid + Math.imul(al2, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh7)) | 0;\n\t    lo = (lo + Math.imul(al1, bl8)) | 0;\n\t    mid = (mid + Math.imul(al1, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh8)) | 0;\n\t    lo = (lo + Math.imul(al0, bl9)) | 0;\n\t    mid = (mid + Math.imul(al0, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh9)) | 0;\n\t    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n\t    w9 &= 0x3ffffff;\n\t    /* k = 10 */\n\t    lo = Math.imul(al9, bl1);\n\t    mid = Math.imul(al9, bh1);\n\t    mid = (mid + Math.imul(ah9, bl1)) | 0;\n\t    hi = Math.imul(ah9, bh1);\n\t    lo = (lo + Math.imul(al8, bl2)) | 0;\n\t    mid = (mid + Math.imul(al8, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh2)) | 0;\n\t    lo = (lo + Math.imul(al7, bl3)) | 0;\n\t    mid = (mid + Math.imul(al7, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh3)) | 0;\n\t    lo = (lo + Math.imul(al6, bl4)) | 0;\n\t    mid = (mid + Math.imul(al6, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh4)) | 0;\n\t    lo = (lo + Math.imul(al5, bl5)) | 0;\n\t    mid = (mid + Math.imul(al5, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh5)) | 0;\n\t    lo = (lo + Math.imul(al4, bl6)) | 0;\n\t    mid = (mid + Math.imul(al4, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh6)) | 0;\n\t    lo = (lo + Math.imul(al3, bl7)) | 0;\n\t    mid = (mid + Math.imul(al3, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh7)) | 0;\n\t    lo = (lo + Math.imul(al2, bl8)) | 0;\n\t    mid = (mid + Math.imul(al2, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh8)) | 0;\n\t    lo = (lo + Math.imul(al1, bl9)) | 0;\n\t    mid = (mid + Math.imul(al1, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh9)) | 0;\n\t    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n\t    w10 &= 0x3ffffff;\n\t    /* k = 11 */\n\t    lo = Math.imul(al9, bl2);\n\t    mid = Math.imul(al9, bh2);\n\t    mid = (mid + Math.imul(ah9, bl2)) | 0;\n\t    hi = Math.imul(ah9, bh2);\n\t    lo = (lo + Math.imul(al8, bl3)) | 0;\n\t    mid = (mid + Math.imul(al8, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh3)) | 0;\n\t    lo = (lo + Math.imul(al7, bl4)) | 0;\n\t    mid = (mid + Math.imul(al7, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh4)) | 0;\n\t    lo = (lo + Math.imul(al6, bl5)) | 0;\n\t    mid = (mid + Math.imul(al6, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh5)) | 0;\n\t    lo = (lo + Math.imul(al5, bl6)) | 0;\n\t    mid = (mid + Math.imul(al5, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh6)) | 0;\n\t    lo = (lo + Math.imul(al4, bl7)) | 0;\n\t    mid = (mid + Math.imul(al4, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh7)) | 0;\n\t    lo = (lo + Math.imul(al3, bl8)) | 0;\n\t    mid = (mid + Math.imul(al3, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh8)) | 0;\n\t    lo = (lo + Math.imul(al2, bl9)) | 0;\n\t    mid = (mid + Math.imul(al2, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh9)) | 0;\n\t    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n\t    w11 &= 0x3ffffff;\n\t    /* k = 12 */\n\t    lo = Math.imul(al9, bl3);\n\t    mid = Math.imul(al9, bh3);\n\t    mid = (mid + Math.imul(ah9, bl3)) | 0;\n\t    hi = Math.imul(ah9, bh3);\n\t    lo = (lo + Math.imul(al8, bl4)) | 0;\n\t    mid = (mid + Math.imul(al8, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh4)) | 0;\n\t    lo = (lo + Math.imul(al7, bl5)) | 0;\n\t    mid = (mid + Math.imul(al7, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh5)) | 0;\n\t    lo = (lo + Math.imul(al6, bl6)) | 0;\n\t    mid = (mid + Math.imul(al6, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh6)) | 0;\n\t    lo = (lo + Math.imul(al5, bl7)) | 0;\n\t    mid = (mid + Math.imul(al5, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh7)) | 0;\n\t    lo = (lo + Math.imul(al4, bl8)) | 0;\n\t    mid = (mid + Math.imul(al4, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh8)) | 0;\n\t    lo = (lo + Math.imul(al3, bl9)) | 0;\n\t    mid = (mid + Math.imul(al3, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh9)) | 0;\n\t    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n\t    w12 &= 0x3ffffff;\n\t    /* k = 13 */\n\t    lo = Math.imul(al9, bl4);\n\t    mid = Math.imul(al9, bh4);\n\t    mid = (mid + Math.imul(ah9, bl4)) | 0;\n\t    hi = Math.imul(ah9, bh4);\n\t    lo = (lo + Math.imul(al8, bl5)) | 0;\n\t    mid = (mid + Math.imul(al8, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh5)) | 0;\n\t    lo = (lo + Math.imul(al7, bl6)) | 0;\n\t    mid = (mid + Math.imul(al7, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh6)) | 0;\n\t    lo = (lo + Math.imul(al6, bl7)) | 0;\n\t    mid = (mid + Math.imul(al6, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh7)) | 0;\n\t    lo = (lo + Math.imul(al5, bl8)) | 0;\n\t    mid = (mid + Math.imul(al5, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh8)) | 0;\n\t    lo = (lo + Math.imul(al4, bl9)) | 0;\n\t    mid = (mid + Math.imul(al4, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh9)) | 0;\n\t    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n\t    w13 &= 0x3ffffff;\n\t    /* k = 14 */\n\t    lo = Math.imul(al9, bl5);\n\t    mid = Math.imul(al9, bh5);\n\t    mid = (mid + Math.imul(ah9, bl5)) | 0;\n\t    hi = Math.imul(ah9, bh5);\n\t    lo = (lo + Math.imul(al8, bl6)) | 0;\n\t    mid = (mid + Math.imul(al8, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh6)) | 0;\n\t    lo = (lo + Math.imul(al7, bl7)) | 0;\n\t    mid = (mid + Math.imul(al7, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh7)) | 0;\n\t    lo = (lo + Math.imul(al6, bl8)) | 0;\n\t    mid = (mid + Math.imul(al6, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh8)) | 0;\n\t    lo = (lo + Math.imul(al5, bl9)) | 0;\n\t    mid = (mid + Math.imul(al5, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh9)) | 0;\n\t    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n\t    w14 &= 0x3ffffff;\n\t    /* k = 15 */\n\t    lo = Math.imul(al9, bl6);\n\t    mid = Math.imul(al9, bh6);\n\t    mid = (mid + Math.imul(ah9, bl6)) | 0;\n\t    hi = Math.imul(ah9, bh6);\n\t    lo = (lo + Math.imul(al8, bl7)) | 0;\n\t    mid = (mid + Math.imul(al8, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh7)) | 0;\n\t    lo = (lo + Math.imul(al7, bl8)) | 0;\n\t    mid = (mid + Math.imul(al7, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh8)) | 0;\n\t    lo = (lo + Math.imul(al6, bl9)) | 0;\n\t    mid = (mid + Math.imul(al6, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh9)) | 0;\n\t    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n\t    w15 &= 0x3ffffff;\n\t    /* k = 16 */\n\t    lo = Math.imul(al9, bl7);\n\t    mid = Math.imul(al9, bh7);\n\t    mid = (mid + Math.imul(ah9, bl7)) | 0;\n\t    hi = Math.imul(ah9, bh7);\n\t    lo = (lo + Math.imul(al8, bl8)) | 0;\n\t    mid = (mid + Math.imul(al8, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh8)) | 0;\n\t    lo = (lo + Math.imul(al7, bl9)) | 0;\n\t    mid = (mid + Math.imul(al7, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh9)) | 0;\n\t    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n\t    w16 &= 0x3ffffff;\n\t    /* k = 17 */\n\t    lo = Math.imul(al9, bl8);\n\t    mid = Math.imul(al9, bh8);\n\t    mid = (mid + Math.imul(ah9, bl8)) | 0;\n\t    hi = Math.imul(ah9, bh8);\n\t    lo = (lo + Math.imul(al8, bl9)) | 0;\n\t    mid = (mid + Math.imul(al8, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh9)) | 0;\n\t    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n\t    w17 &= 0x3ffffff;\n\t    /* k = 18 */\n\t    lo = Math.imul(al9, bl9);\n\t    mid = Math.imul(al9, bh9);\n\t    mid = (mid + Math.imul(ah9, bl9)) | 0;\n\t    hi = Math.imul(ah9, bh9);\n\t    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n\t    w18 &= 0x3ffffff;\n\t    o[0] = w0;\n\t    o[1] = w1;\n\t    o[2] = w2;\n\t    o[3] = w3;\n\t    o[4] = w4;\n\t    o[5] = w5;\n\t    o[6] = w6;\n\t    o[7] = w7;\n\t    o[8] = w8;\n\t    o[9] = w9;\n\t    o[10] = w10;\n\t    o[11] = w11;\n\t    o[12] = w12;\n\t    o[13] = w13;\n\t    o[14] = w14;\n\t    o[15] = w15;\n\t    o[16] = w16;\n\t    o[17] = w17;\n\t    o[18] = w18;\n\t    if (c !== 0) {\n\t      o[19] = c;\n\t      out.length++;\n\t    }\n\t    return out;\n\t  };\n\n\t  // Polyfill comb\n\t  if (!Math.imul) {\n\t    comb10MulTo = smallMulTo;\n\t  }\n\n\t  function bigMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    out.length = self.length + num.length;\n\n\t    var carry = 0;\n\t    var hncarry = 0;\n\t    for (var k = 0; k < out.length - 1; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = hncarry;\n\t      hncarry = 0;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = k - j;\n\t        var a = self.words[i] | 0;\n\t        var b = num.words[j] | 0;\n\t        var r = a * b;\n\n\t        var lo = r & 0x3ffffff;\n\t        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n\t        lo = (lo + rword) | 0;\n\t        rword = lo & 0x3ffffff;\n\t        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n\t        hncarry += ncarry >>> 26;\n\t        ncarry &= 0x3ffffff;\n\t      }\n\t      out.words[k] = rword;\n\t      carry = ncarry;\n\t      ncarry = hncarry;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  function jumboMulTo (self, num, out) {\n\t    var fftm = new FFTM();\n\t    return fftm.mulp(self, num, out);\n\t  }\n\n\t  BN.prototype.mulTo = function mulTo (num, out) {\n\t    var res;\n\t    var len = this.length + num.length;\n\t    if (this.length === 10 && num.length === 10) {\n\t      res = comb10MulTo(this, num, out);\n\t    } else if (len < 63) {\n\t      res = smallMulTo(this, num, out);\n\t    } else if (len < 1024) {\n\t      res = bigMulTo(this, num, out);\n\t    } else {\n\t      res = jumboMulTo(this, num, out);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Cooley-Tukey algorithm for FFT\n\t  // slightly revisited to rely on looping instead of recursion\n\n\t  function FFTM (x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t  }\n\n\t  FFTM.prototype.makeRBT = function makeRBT (N) {\n\t    var t = new Array(N);\n\t    var l = BN.prototype._countBits(N) - 1;\n\t    for (var i = 0; i < N; i++) {\n\t      t[i] = this.revBin(i, l, N);\n\t    }\n\n\t    return t;\n\t  };\n\n\t  // Returns binary-reversed representation of `x`\n\t  FFTM.prototype.revBin = function revBin (x, l, N) {\n\t    if (x === 0 || x === N - 1) return x;\n\n\t    var rb = 0;\n\t    for (var i = 0; i < l; i++) {\n\t      rb |= (x & 1) << (l - i - 1);\n\t      x >>= 1;\n\t    }\n\n\t    return rb;\n\t  };\n\n\t  // Performs "tweedling" phase, therefore \'emulating\'\n\t  // behaviour of the recursive algorithm\n\t  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n\t    for (var i = 0; i < N; i++) {\n\t      rtws[i] = rws[rbt[i]];\n\t      itws[i] = iws[rbt[i]];\n\t    }\n\t  };\n\n\t  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n\t    this.permute(rbt, rws, iws, rtws, itws, N);\n\n\t    for (var s = 1; s < N; s <<= 1) {\n\t      var l = s << 1;\n\n\t      var rtwdf = Math.cos(2 * Math.PI / l);\n\t      var itwdf = Math.sin(2 * Math.PI / l);\n\n\t      for (var p = 0; p < N; p += l) {\n\t        var rtwdf_ = rtwdf;\n\t        var itwdf_ = itwdf;\n\n\t        for (var j = 0; j < s; j++) {\n\t          var re = rtws[p + j];\n\t          var ie = itws[p + j];\n\n\t          var ro = rtws[p + j + s];\n\t          var io = itws[p + j + s];\n\n\t          var rx = rtwdf_ * ro - itwdf_ * io;\n\n\t          io = rtwdf_ * io + itwdf_ * ro;\n\t          ro = rx;\n\n\t          rtws[p + j] = re + ro;\n\t          itws[p + j] = ie + io;\n\n\t          rtws[p + j + s] = re - ro;\n\t          itws[p + j + s] = ie - io;\n\n\t          /* jshint maxdepth : false */\n\t          if (j !== l) {\n\t            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n\t            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n\t            rtwdf_ = rx;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n\t    var N = Math.max(m, n) | 1;\n\t    var odd = N & 1;\n\t    var i = 0;\n\t    for (N = N / 2 | 0; N; N = N >>> 1) {\n\t      i++;\n\t    }\n\n\t    return 1 << i + 1 + odd;\n\t  };\n\n\t  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n\t    if (N <= 1) return;\n\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var t = rws[i];\n\n\t      rws[i] = rws[N - i - 1];\n\t      rws[N - i - 1] = t;\n\n\t      t = iws[i];\n\n\t      iws[i] = -iws[N - i - 1];\n\t      iws[N - i - 1] = -t;\n\t    }\n\t  };\n\n\t  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n\t        Math.round(ws[2 * i] / N) +\n\t        carry;\n\n\t      ws[i] = w & 0x3ffffff;\n\n\t      if (w < 0x4000000) {\n\t        carry = 0;\n\t      } else {\n\t        carry = w / 0x4000000 | 0;\n\t      }\n\t    }\n\n\t    return ws;\n\t  };\n\n\t  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < len; i++) {\n\t      carry = carry + (ws[i] | 0);\n\n\t      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n\t      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n\t    }\n\n\t    // Pad with zeroes\n\t    for (i = 2 * len; i < N; ++i) {\n\t      rws[i] = 0;\n\t    }\n\n\t    assert(carry === 0);\n\t    assert((carry & ~0x1fff) === 0);\n\t  };\n\n\t  FFTM.prototype.stub = function stub (N) {\n\t    var ph = new Array(N);\n\t    for (var i = 0; i < N; i++) {\n\t      ph[i] = 0;\n\t    }\n\n\t    return ph;\n\t  };\n\n\t  FFTM.prototype.mulp = function mulp (x, y, out) {\n\t    var N = 2 * this.guessLen13b(x.length, y.length);\n\n\t    var rbt = this.makeRBT(N);\n\n\t    var _ = this.stub(N);\n\n\t    var rws = new Array(N);\n\t    var rwst = new Array(N);\n\t    var iwst = new Array(N);\n\n\t    var nrws = new Array(N);\n\t    var nrwst = new Array(N);\n\t    var niwst = new Array(N);\n\n\t    var rmws = out.words;\n\t    rmws.length = N;\n\n\t    this.convert13b(x.words, x.length, rws, N);\n\t    this.convert13b(y.words, y.length, nrws, N);\n\n\t    this.transform(rws, _, rwst, iwst, N, rbt);\n\t    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n\t    for (var i = 0; i < N; i++) {\n\t      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n\t      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n\t      rwst[i] = rx;\n\t    }\n\n\t    this.conjugate(rwst, iwst, N);\n\t    this.transform(rwst, iwst, rmws, _, N, rbt);\n\t    this.conjugate(rmws, _, N);\n\t    this.normalize13b(rmws, N);\n\n\t    out.negative = x.negative ^ y.negative;\n\t    out.length = x.length + y.length;\n\t    return out.strip();\n\t  };\n\n\t  // Multiply `this` by `num`\n\t  BN.prototype.mul = function mul (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return this.mulTo(num, out);\n\t  };\n\n\t  // Multiply employing FFT\n\t  BN.prototype.mulf = function mulf (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return jumboMulTo(this, num, out);\n\t  };\n\n\t  // In-place Multiplication\n\t  BN.prototype.imul = function imul (num) {\n\t    return this.clone().mulTo(num, this);\n\t  };\n\n\t  BN.prototype.imuln = function imuln (num) {\n\t    assert(typeof num === \'number\');\n\t    assert(num < 0x4000000);\n\n\t    // Carry\n\t    var carry = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var w = (this.words[i] | 0) * num;\n\t      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n\t      carry >>= 26;\n\t      carry += (w / 0x4000000) | 0;\n\t      // NOTE: lo is 27bit maximum\n\t      carry += lo >>> 26;\n\t      this.words[i] = lo & 0x3ffffff;\n\t    }\n\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.muln = function muln (num) {\n\t    return this.clone().imuln(num);\n\t  };\n\n\t  // `this` * `this`\n\t  BN.prototype.sqr = function sqr () {\n\t    return this.mul(this);\n\t  };\n\n\t  // `this` * `this` in-place\n\t  BN.prototype.isqr = function isqr () {\n\t    return this.imul(this.clone());\n\t  };\n\n\t  // Math.pow(`this`, `num`)\n\t  BN.prototype.pow = function pow (num) {\n\t    var w = toBitArray(num);\n\t    if (w.length === 0) return new BN(1);\n\n\t    // Skip leading zeroes\n\t    var res = this;\n\t    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n\t      if (w[i] !== 0) break;\n\t    }\n\n\t    if (++i < w.length) {\n\t      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n\t        if (w[i] === 0) continue;\n\n\t        res = res.mul(q);\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Shift-left in-place\n\t  BN.prototype.iushln = function iushln (bits) {\n\t    assert(typeof bits === \'number\' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\t    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n\t    var i;\n\n\t    if (r !== 0) {\n\t      var carry = 0;\n\n\t      for (i = 0; i < this.length; i++) {\n\t        var newCarry = this.words[i] & carryMask;\n\t        var c = ((this.words[i] | 0) - newCarry) << r;\n\t        this.words[i] = c | carry;\n\t        carry = newCarry >>> (26 - r);\n\t      }\n\n\t      if (carry) {\n\t        this.words[i] = carry;\n\t        this.length++;\n\t      }\n\t    }\n\n\t    if (s !== 0) {\n\t      for (i = this.length - 1; i >= 0; i--) {\n\t        this.words[i + s] = this.words[i];\n\t      }\n\n\t      for (i = 0; i < s; i++) {\n\t        this.words[i] = 0;\n\t      }\n\n\t      this.length += s;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishln = function ishln (bits) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushln(bits);\n\t  };\n\n\t  // Shift-right in-place\n\t  // NOTE: `hint` is a lowest bit before trailing zeroes\n\t  // NOTE: if `extended` is present - it will be filled with destroyed bits\n\t  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n\t    assert(typeof bits === \'number\' && bits >= 0);\n\t    var h;\n\t    if (hint) {\n\t      h = (hint - (hint % 26)) / 26;\n\t    } else {\n\t      h = 0;\n\t    }\n\n\t    var r = bits % 26;\n\t    var s = Math.min((bits - r) / 26, this.length);\n\t    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t    var maskedWords = extended;\n\n\t    h -= s;\n\t    h = Math.max(0, h);\n\n\t    // Extended mode, copy masked part\n\t    if (maskedWords) {\n\t      for (var i = 0; i < s; i++) {\n\t        maskedWords.words[i] = this.words[i];\n\t      }\n\t      maskedWords.length = s;\n\t    }\n\n\t    if (s === 0) {\n\t      // No-op, we should not move anything at all\n\t    } else if (this.length > s) {\n\t      this.length -= s;\n\t      for (i = 0; i < this.length; i++) {\n\t        this.words[i] = this.words[i + s];\n\t      }\n\t    } else {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    var carry = 0;\n\t    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n\t      var word = this.words[i] | 0;\n\t      this.words[i] = (carry << (26 - r)) | (word >>> r);\n\t      carry = word & mask;\n\t    }\n\n\t    // Push carried bits as a mask\n\t    if (maskedWords && carry !== 0) {\n\t      maskedWords.words[maskedWords.length++] = carry;\n\t    }\n\n\t    if (this.length === 0) {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushrn(bits, hint, extended);\n\t  };\n\n\t  // Shift-left\n\t  BN.prototype.shln = function shln (bits) {\n\t    return this.clone().ishln(bits);\n\t  };\n\n\t  BN.prototype.ushln = function ushln (bits) {\n\t    return this.clone().iushln(bits);\n\t  };\n\n\t  // Shift-right\n\t  BN.prototype.shrn = function shrn (bits) {\n\t    return this.clone().ishrn(bits);\n\t  };\n\n\t  BN.prototype.ushrn = function ushrn (bits) {\n\t    return this.clone().iushrn(bits);\n\t  };\n\n\t  // Test if n bit is set\n\t  BN.prototype.testn = function testn (bit) {\n\t    assert(typeof bit === \'number\' && bit >= 0);\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) return false;\n\n\t    // Check bit and return\n\t    var w = this.words[s];\n\n\t    return !!(w & q);\n\t  };\n\n\t  // Return only lowers bits of number (in-place)\n\t  BN.prototype.imaskn = function imaskn (bits) {\n\t    assert(typeof bits === \'number\' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\n\t    assert(this.negative === 0, \'imaskn works only with positive numbers\');\n\n\t    if (this.length <= s) {\n\t      return this;\n\t    }\n\n\t    if (r !== 0) {\n\t      s++;\n\t    }\n\t    this.length = Math.min(s, this.length);\n\n\t    if (r !== 0) {\n\t      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t      this.words[this.length - 1] &= mask;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Return only lowers bits of number\n\t  BN.prototype.maskn = function maskn (bits) {\n\t    return this.clone().imaskn(bits);\n\t  };\n\n\t  // Add plain number `num` to `this`\n\t  BN.prototype.iaddn = function iaddn (num) {\n\t    assert(typeof num === \'number\');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.isubn(-num);\n\n\t    // Possible sign change\n\t    if (this.negative !== 0) {\n\t      if (this.length === 1 && (this.words[0] | 0) < num) {\n\t        this.words[0] = num - (this.words[0] | 0);\n\t        this.negative = 0;\n\t        return this;\n\t      }\n\n\t      this.negative = 0;\n\t      this.isubn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    // Add without checks\n\t    return this._iaddn(num);\n\t  };\n\n\t  BN.prototype._iaddn = function _iaddn (num) {\n\t    this.words[0] += num;\n\n\t    // Carry\n\t    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n\t      this.words[i] -= 0x4000000;\n\t      if (i === this.length - 1) {\n\t        this.words[i + 1] = 1;\n\t      } else {\n\t        this.words[i + 1]++;\n\t      }\n\t    }\n\t    this.length = Math.max(this.length, i + 1);\n\n\t    return this;\n\t  };\n\n\t  // Subtract plain number `num` from `this`\n\t  BN.prototype.isubn = function isubn (num) {\n\t    assert(typeof num === \'number\');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.iaddn(-num);\n\n\t    if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iaddn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    this.words[0] -= num;\n\n\t    if (this.length === 1 && this.words[0] < 0) {\n\t      this.words[0] = -this.words[0];\n\t      this.negative = 1;\n\t    } else {\n\t      // Carry\n\t      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n\t        this.words[i] += 0x4000000;\n\t        this.words[i + 1] -= 1;\n\t      }\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.addn = function addn (num) {\n\t    return this.clone().iaddn(num);\n\t  };\n\n\t  BN.prototype.subn = function subn (num) {\n\t    return this.clone().isubn(num);\n\t  };\n\n\t  BN.prototype.iabs = function iabs () {\n\t    this.negative = 0;\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.abs = function abs () {\n\t    return this.clone().iabs();\n\t  };\n\n\t  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n\t    var len = num.length + shift;\n\t    var i;\n\n\t    this._expand(len);\n\n\t    var w;\n\t    var carry = 0;\n\t    for (i = 0; i < num.length; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      var right = (num.words[i] | 0) * mul;\n\t      w -= right & 0x3ffffff;\n\t      carry = (w >> 26) - ((right / 0x4000000) | 0);\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\t    for (; i < this.length - shift; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\n\t    if (carry === 0) return this.strip();\n\n\t    // Subtraction overflow\n\t    assert(carry === -1);\n\t    carry = 0;\n\t    for (i = 0; i < this.length; i++) {\n\t      w = -(this.words[i] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i] = w & 0x3ffffff;\n\t    }\n\t    this.negative = 1;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n\t    var shift = this.length - num.length;\n\n\t    var a = this.clone();\n\t    var b = num;\n\n\t    // Normalize\n\t    var bhi = b.words[b.length - 1] | 0;\n\t    var bhiBits = this._countBits(bhi);\n\t    shift = 26 - bhiBits;\n\t    if (shift !== 0) {\n\t      b = b.ushln(shift);\n\t      a.iushln(shift);\n\t      bhi = b.words[b.length - 1] | 0;\n\t    }\n\n\t    // Initialize quotient\n\t    var m = a.length - b.length;\n\t    var q;\n\n\t    if (mode !== \'mod\') {\n\t      q = new BN(null);\n\t      q.length = m + 1;\n\t      q.words = new Array(q.length);\n\t      for (var i = 0; i < q.length; i++) {\n\t        q.words[i] = 0;\n\t      }\n\t    }\n\n\t    var diff = a.clone()._ishlnsubmul(b, 1, m);\n\t    if (diff.negative === 0) {\n\t      a = diff;\n\t      if (q) {\n\t        q.words[m] = 1;\n\t      }\n\t    }\n\n\t    for (var j = m - 1; j >= 0; j--) {\n\t      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n\t        (a.words[b.length + j - 1] | 0);\n\n\t      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n\t      // (0x7ffffff)\n\t      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n\t      a._ishlnsubmul(b, qj, j);\n\t      while (a.negative !== 0) {\n\t        qj--;\n\t        a.negative = 0;\n\t        a._ishlnsubmul(b, 1, j);\n\t        if (!a.isZero()) {\n\t          a.negative ^= 1;\n\t        }\n\t      }\n\t      if (q) {\n\t        q.words[j] = qj;\n\t      }\n\t    }\n\t    if (q) {\n\t      q.strip();\n\t    }\n\t    a.strip();\n\n\t    // Denormalize\n\t    if (mode !== \'div\' && shift !== 0) {\n\t      a.iushrn(shift);\n\t    }\n\n\t    return {\n\t      div: q || null,\n\t      mod: a\n\t    };\n\t  };\n\n\t  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n\t  //       to `div` to request div only, or be absent to\n\t  //       request both div & mod\n\t  //       2) `positive` is true if unsigned mod is requested\n\t  BN.prototype.divmod = function divmod (num, mode, positive) {\n\t    assert(!num.isZero());\n\n\t    if (this.isZero()) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: new BN(0)\n\t      };\n\t    }\n\n\t    var div, mod, res;\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      res = this.neg().divmod(num, mode);\n\n\t      if (mode !== \'mod\') {\n\t        div = res.div.neg();\n\t      }\n\n\t      if (mode !== \'div\') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.iadd(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    if (this.negative === 0 && num.negative !== 0) {\n\t      res = this.divmod(num.neg(), mode);\n\n\t      if (mode !== \'mod\') {\n\t        div = res.div.neg();\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: res.mod\n\t      };\n\t    }\n\n\t    if ((this.negative & num.negative) !== 0) {\n\t      res = this.neg().divmod(num.neg(), mode);\n\n\t      if (mode !== \'div\') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.isub(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: res.div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    // Both numbers are positive at this point\n\n\t    // Strip both numbers to approximate shift value\n\t    if (num.length > this.length || this.cmp(num) < 0) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: this\n\t      };\n\t    }\n\n\t    // Very short reduction\n\t    if (num.length === 1) {\n\t      if (mode === \'div\') {\n\t        return {\n\t          div: this.divn(num.words[0]),\n\t          mod: null\n\t        };\n\t      }\n\n\t      if (mode === \'mod\') {\n\t        return {\n\t          div: null,\n\t          mod: new BN(this.modn(num.words[0]))\n\t        };\n\t      }\n\n\t      return {\n\t        div: this.divn(num.words[0]),\n\t        mod: new BN(this.modn(num.words[0]))\n\t      };\n\t    }\n\n\t    return this._wordDiv(num, mode);\n\t  };\n\n\t  // Find `this` / `num`\n\t  BN.prototype.div = function div (num) {\n\t    return this.divmod(num, \'div\', false).div;\n\t  };\n\n\t  // Find `this` % `num`\n\t  BN.prototype.mod = function mod (num) {\n\t    return this.divmod(num, \'mod\', false).mod;\n\t  };\n\n\t  BN.prototype.umod = function umod (num) {\n\t    return this.divmod(num, \'mod\', true).mod;\n\t  };\n\n\t  // Find Round(`this` / `num`)\n\t  BN.prototype.divRound = function divRound (num) {\n\t    var dm = this.divmod(num);\n\n\t    // Fast case - exact division\n\t    if (dm.mod.isZero()) return dm.div;\n\n\t    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n\t    var half = num.ushrn(1);\n\t    var r2 = num.andln(1);\n\t    var cmp = mod.cmp(half);\n\n\t    // Round down\n\t    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n\t    // Round up\n\t    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n\t  };\n\n\t  BN.prototype.modn = function modn (num) {\n\t    assert(num <= 0x3ffffff);\n\t    var p = (1 << 26) % num;\n\n\t    var acc = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      acc = (p * acc + (this.words[i] | 0)) % num;\n\t    }\n\n\t    return acc;\n\t  };\n\n\t  // In-place division by number\n\t  BN.prototype.idivn = function idivn (num) {\n\t    assert(num <= 0x3ffffff);\n\n\t    var carry = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var w = (this.words[i] | 0) + carry * 0x4000000;\n\t      this.words[i] = (w / num) | 0;\n\t      carry = w % num;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.divn = function divn (num) {\n\t    return this.clone().idivn(num);\n\t  };\n\n\t  BN.prototype.egcd = function egcd (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var x = this;\n\t    var y = p.clone();\n\n\t    if (x.negative !== 0) {\n\t      x = x.umod(p);\n\t    } else {\n\t      x = x.clone();\n\t    }\n\n\t    // A * x + B * y = x\n\t    var A = new BN(1);\n\t    var B = new BN(0);\n\n\t    // C * x + D * y = y\n\t    var C = new BN(0);\n\t    var D = new BN(1);\n\n\t    var g = 0;\n\n\t    while (x.isEven() && y.isEven()) {\n\t      x.iushrn(1);\n\t      y.iushrn(1);\n\t      ++g;\n\t    }\n\n\t    var yp = y.clone();\n\t    var xp = x.clone();\n\n\t    while (!x.isZero()) {\n\t      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        x.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (A.isOdd() || B.isOdd()) {\n\t            A.iadd(yp);\n\t            B.isub(xp);\n\t          }\n\n\t          A.iushrn(1);\n\t          B.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        y.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (C.isOdd() || D.isOdd()) {\n\t            C.iadd(yp);\n\t            D.isub(xp);\n\t          }\n\n\t          C.iushrn(1);\n\t          D.iushrn(1);\n\t        }\n\t      }\n\n\t      if (x.cmp(y) >= 0) {\n\t        x.isub(y);\n\t        A.isub(C);\n\t        B.isub(D);\n\t      } else {\n\t        y.isub(x);\n\t        C.isub(A);\n\t        D.isub(B);\n\t      }\n\t    }\n\n\t    return {\n\t      a: C,\n\t      b: D,\n\t      gcd: y.iushln(g)\n\t    };\n\t  };\n\n\t  // This is reduced incarnation of the binary EEA\n\t  // above, designated to invert members of the\n\t  // _prime_ fields F(p) at a maximal speed\n\t  BN.prototype._invmp = function _invmp (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var a = this;\n\t    var b = p.clone();\n\n\t    if (a.negative !== 0) {\n\t      a = a.umod(p);\n\t    } else {\n\t      a = a.clone();\n\t    }\n\n\t    var x1 = new BN(1);\n\t    var x2 = new BN(0);\n\n\t    var delta = b.clone();\n\n\t    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n\t      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        a.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (x1.isOdd()) {\n\t            x1.iadd(delta);\n\t          }\n\n\t          x1.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        b.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (x2.isOdd()) {\n\t            x2.iadd(delta);\n\t          }\n\n\t          x2.iushrn(1);\n\t        }\n\t      }\n\n\t      if (a.cmp(b) >= 0) {\n\t        a.isub(b);\n\t        x1.isub(x2);\n\t      } else {\n\t        b.isub(a);\n\t        x2.isub(x1);\n\t      }\n\t    }\n\n\t    var res;\n\t    if (a.cmpn(1) === 0) {\n\t      res = x1;\n\t    } else {\n\t      res = x2;\n\t    }\n\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(p);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  BN.prototype.gcd = function gcd (num) {\n\t    if (this.isZero()) return num.abs();\n\t    if (num.isZero()) return this.abs();\n\n\t    var a = this.clone();\n\t    var b = num.clone();\n\t    a.negative = 0;\n\t    b.negative = 0;\n\n\t    // Remove common factor of two\n\t    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n\t      a.iushrn(1);\n\t      b.iushrn(1);\n\t    }\n\n\t    do {\n\t      while (a.isEven()) {\n\t        a.iushrn(1);\n\t      }\n\t      while (b.isEven()) {\n\t        b.iushrn(1);\n\t      }\n\n\t      var r = a.cmp(b);\n\t      if (r < 0) {\n\t        // Swap `a` and `b` to make `a` always bigger than `b`\n\t        var t = a;\n\t        a = b;\n\t        b = t;\n\t      } else if (r === 0 || b.cmpn(1) === 0) {\n\t        break;\n\t      }\n\n\t      a.isub(b);\n\t    } while (true);\n\n\t    return b.iushln(shift);\n\t  };\n\n\t  // Invert number in the field F(num)\n\t  BN.prototype.invm = function invm (num) {\n\t    return this.egcd(num).a.umod(num);\n\t  };\n\n\t  BN.prototype.isEven = function isEven () {\n\t    return (this.words[0] & 1) === 0;\n\t  };\n\n\t  BN.prototype.isOdd = function isOdd () {\n\t    return (this.words[0] & 1) === 1;\n\t  };\n\n\t  // And first word and num\n\t  BN.prototype.andln = function andln (num) {\n\t    return this.words[0] & num;\n\t  };\n\n\t  // Increment at the bit position in-line\n\t  BN.prototype.bincn = function bincn (bit) {\n\t    assert(typeof bit === \'number\');\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) {\n\t      this._expand(s + 1);\n\t      this.words[s] |= q;\n\t      return this;\n\t    }\n\n\t    // Add bit and propagate, if needed\n\t    var carry = q;\n\t    for (var i = s; carry !== 0 && i < this.length; i++) {\n\t      var w = this.words[i] | 0;\n\t      w += carry;\n\t      carry = w >>> 26;\n\t      w &= 0x3ffffff;\n\t      this.words[i] = w;\n\t    }\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.isZero = function isZero () {\n\t    return this.length === 1 && this.words[0] === 0;\n\t  };\n\n\t  BN.prototype.cmpn = function cmpn (num) {\n\t    var negative = num < 0;\n\n\t    if (this.negative !== 0 && !negative) return -1;\n\t    if (this.negative === 0 && negative) return 1;\n\n\t    this.strip();\n\n\t    var res;\n\t    if (this.length > 1) {\n\t      res = 1;\n\t    } else {\n\t      if (negative) {\n\t        num = -num;\n\t      }\n\n\t      assert(num <= 0x3ffffff, \'Number is too big\');\n\n\t      var w = this.words[0] | 0;\n\t      res = w === num ? 0 : w < num ? -1 : 1;\n\t    }\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Compare two numbers and return:\n\t  // 1 - if `this` > `num`\n\t  // 0 - if `this` == `num`\n\t  // -1 - if `this` < `num`\n\t  BN.prototype.cmp = function cmp (num) {\n\t    if (this.negative !== 0 && num.negative === 0) return -1;\n\t    if (this.negative === 0 && num.negative !== 0) return 1;\n\n\t    var res = this.ucmp(num);\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Unsigned comparison\n\t  BN.prototype.ucmp = function ucmp (num) {\n\t    // At this point both numbers have the same sign\n\t    if (this.length > num.length) return 1;\n\t    if (this.length < num.length) return -1;\n\n\t    var res = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var a = this.words[i] | 0;\n\t      var b = num.words[i] | 0;\n\n\t      if (a === b) continue;\n\t      if (a < b) {\n\t        res = -1;\n\t      } else if (a > b) {\n\t        res = 1;\n\t      }\n\t      break;\n\t    }\n\t    return res;\n\t  };\n\n\t  BN.prototype.gtn = function gtn (num) {\n\t    return this.cmpn(num) === 1;\n\t  };\n\n\t  BN.prototype.gt = function gt (num) {\n\t    return this.cmp(num) === 1;\n\t  };\n\n\t  BN.prototype.gten = function gten (num) {\n\t    return this.cmpn(num) >= 0;\n\t  };\n\n\t  BN.prototype.gte = function gte (num) {\n\t    return this.cmp(num) >= 0;\n\t  };\n\n\t  BN.prototype.ltn = function ltn (num) {\n\t    return this.cmpn(num) === -1;\n\t  };\n\n\t  BN.prototype.lt = function lt (num) {\n\t    return this.cmp(num) === -1;\n\t  };\n\n\t  BN.prototype.lten = function lten (num) {\n\t    return this.cmpn(num) <= 0;\n\t  };\n\n\t  BN.prototype.lte = function lte (num) {\n\t    return this.cmp(num) <= 0;\n\t  };\n\n\t  BN.prototype.eqn = function eqn (num) {\n\t    return this.cmpn(num) === 0;\n\t  };\n\n\t  BN.prototype.eq = function eq (num) {\n\t    return this.cmp(num) === 0;\n\t  };\n\n\t  //\n\t  // A reduce context, could be using montgomery or something better, depending\n\t  // on the `m` itself.\n\t  //\n\t  BN.red = function red (num) {\n\t    return new Red(num);\n\t  };\n\n\t  BN.prototype.toRed = function toRed (ctx) {\n\t    assert(!this.red, \'Already a number in reduction context\');\n\t    assert(this.negative === 0, \'red works only with positives\');\n\t    return ctx.convertTo(this)._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.fromRed = function fromRed () {\n\t    assert(this.red, \'fromRed works only with numbers in reduction context\');\n\t    return this.red.convertFrom(this);\n\t  };\n\n\t  BN.prototype._forceRed = function _forceRed (ctx) {\n\t    this.red = ctx;\n\t    return this;\n\t  };\n\n\t  BN.prototype.forceRed = function forceRed (ctx) {\n\t    assert(!this.red, \'Already a number in reduction context\');\n\t    return this._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.redAdd = function redAdd (num) {\n\t    assert(this.red, \'redAdd works only with red numbers\');\n\t    return this.red.add(this, num);\n\t  };\n\n\t  BN.prototype.redIAdd = function redIAdd (num) {\n\t    assert(this.red, \'redIAdd works only with red numbers\');\n\t    return this.red.iadd(this, num);\n\t  };\n\n\t  BN.prototype.redSub = function redSub (num) {\n\t    assert(this.red, \'redSub works only with red numbers\');\n\t    return this.red.sub(this, num);\n\t  };\n\n\t  BN.prototype.redISub = function redISub (num) {\n\t    assert(this.red, \'redISub works only with red numbers\');\n\t    return this.red.isub(this, num);\n\t  };\n\n\t  BN.prototype.redShl = function redShl (num) {\n\t    assert(this.red, \'redShl works only with red numbers\');\n\t    return this.red.shl(this, num);\n\t  };\n\n\t  BN.prototype.redMul = function redMul (num) {\n\t    assert(this.red, \'redMul works only with red numbers\');\n\t    this.red._verify2(this, num);\n\t    return this.red.mul(this, num);\n\t  };\n\n\t  BN.prototype.redIMul = function redIMul (num) {\n\t    assert(this.red, \'redMul works only with red numbers\');\n\t    this.red._verify2(this, num);\n\t    return this.red.imul(this, num);\n\t  };\n\n\t  BN.prototype.redSqr = function redSqr () {\n\t    assert(this.red, \'redSqr works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.sqr(this);\n\t  };\n\n\t  BN.prototype.redISqr = function redISqr () {\n\t    assert(this.red, \'redISqr works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.isqr(this);\n\t  };\n\n\t  // Square root over p\n\t  BN.prototype.redSqrt = function redSqrt () {\n\t    assert(this.red, \'redSqrt works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.sqrt(this);\n\t  };\n\n\t  BN.prototype.redInvm = function redInvm () {\n\t    assert(this.red, \'redInvm works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.invm(this);\n\t  };\n\n\t  // Return negative clone of `this` % `red modulo`\n\t  BN.prototype.redNeg = function redNeg () {\n\t    assert(this.red, \'redNeg works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.neg(this);\n\t  };\n\n\t  BN.prototype.redPow = function redPow (num) {\n\t    assert(this.red && !num.red, \'redPow(normalNum)\');\n\t    this.red._verify1(this);\n\t    return this.red.pow(this, num);\n\t  };\n\n\t  // Prime numbers with efficient reduction\n\t  var primes = {\n\t    k256: null,\n\t    p224: null,\n\t    p192: null,\n\t    p25519: null\n\t  };\n\n\t  // Pseudo-Mersenne prime\n\t  function MPrime (name, p) {\n\t    // P = 2 ^ N - K\n\t    this.name = name;\n\t    this.p = new BN(p, 16);\n\t    this.n = this.p.bitLength();\n\t    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n\t    this.tmp = this._tmp();\n\t  }\n\n\t  MPrime.prototype._tmp = function _tmp () {\n\t    var tmp = new BN(null);\n\t    tmp.words = new Array(Math.ceil(this.n / 13));\n\t    return tmp;\n\t  };\n\n\t  MPrime.prototype.ireduce = function ireduce (num) {\n\t    // Assumes that `num` is less than `P^2`\n\t    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n\t    var r = num;\n\t    var rlen;\n\n\t    do {\n\t      this.split(r, this.tmp);\n\t      r = this.imulK(r);\n\t      r = r.iadd(this.tmp);\n\t      rlen = r.bitLength();\n\t    } while (rlen > this.n);\n\n\t    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n\t    if (cmp === 0) {\n\t      r.words[0] = 0;\n\t      r.length = 1;\n\t    } else if (cmp > 0) {\n\t      r.isub(this.p);\n\t    } else {\n\t      if (r.strip !== undefined) {\n\t        // r is BN v4 instance\n\t        r.strip();\n\t      } else {\n\t        // r is BN v5 instance\n\t        r._strip();\n\t      }\n\t    }\n\n\t    return r;\n\t  };\n\n\t  MPrime.prototype.split = function split (input, out) {\n\t    input.iushrn(this.n, 0, out);\n\t  };\n\n\t  MPrime.prototype.imulK = function imulK (num) {\n\t    return num.imul(this.k);\n\t  };\n\n\t  function K256 () {\n\t    MPrime.call(\n\t      this,\n\t      \'k256\',\n\t      \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\');\n\t  }\n\t  inherits(K256, MPrime);\n\n\t  K256.prototype.split = function split (input, output) {\n\t    // 256 = 9 * 26 + 22\n\t    var mask = 0x3fffff;\n\n\t    var outLen = Math.min(input.length, 9);\n\t    for (var i = 0; i < outLen; i++) {\n\t      output.words[i] = input.words[i];\n\t    }\n\t    output.length = outLen;\n\n\t    if (input.length <= 9) {\n\t      input.words[0] = 0;\n\t      input.length = 1;\n\t      return;\n\t    }\n\n\t    // Shift by 9 limbs\n\t    var prev = input.words[9];\n\t    output.words[output.length++] = prev & mask;\n\n\t    for (i = 10; i < input.length; i++) {\n\t      var next = input.words[i] | 0;\n\t      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n\t      prev = next;\n\t    }\n\t    prev >>>= 22;\n\t    input.words[i - 10] = prev;\n\t    if (prev === 0 && input.length > 10) {\n\t      input.length -= 10;\n\t    } else {\n\t      input.length -= 9;\n\t    }\n\t  };\n\n\t  K256.prototype.imulK = function imulK (num) {\n\t    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n\t    num.words[num.length] = 0;\n\t    num.words[num.length + 1] = 0;\n\t    num.length += 2;\n\n\t    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\t    var lo = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var w = num.words[i] | 0;\n\t      lo += w * 0x3d1;\n\t      num.words[i] = lo & 0x3ffffff;\n\t      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n\t    }\n\n\t    // Fast length reduction\n\t    if (num.words[num.length - 1] === 0) {\n\t      num.length--;\n\t      if (num.words[num.length - 1] === 0) {\n\t        num.length--;\n\t      }\n\t    }\n\t    return num;\n\t  };\n\n\t  function P224 () {\n\t    MPrime.call(\n\t      this,\n\t      \'p224\',\n\t      \'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\');\n\t  }\n\t  inherits(P224, MPrime);\n\n\t  function P192 () {\n\t    MPrime.call(\n\t      this,\n\t      \'p192\',\n\t      \'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\');\n\t  }\n\t  inherits(P192, MPrime);\n\n\t  function P25519 () {\n\t    // 2 ^ 255 - 19\n\t    MPrime.call(\n\t      this,\n\t      \'25519\',\n\t      \'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\');\n\t  }\n\t  inherits(P25519, MPrime);\n\n\t  P25519.prototype.imulK = function imulK (num) {\n\t    // K = 0x13\n\t    var carry = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var hi = (num.words[i] | 0) * 0x13 + carry;\n\t      var lo = hi & 0x3ffffff;\n\t      hi >>>= 26;\n\n\t      num.words[i] = lo;\n\t      carry = hi;\n\t    }\n\t    if (carry !== 0) {\n\t      num.words[num.length++] = carry;\n\t    }\n\t    return num;\n\t  };\n\n\t  // Exported mostly for testing purposes, use plain name instead\n\t  BN._prime = function prime (name) {\n\t    // Cached version of prime\n\t    if (primes[name]) return primes[name];\n\n\t    var prime;\n\t    if (name === \'k256\') {\n\t      prime = new K256();\n\t    } else if (name === \'p224\') {\n\t      prime = new P224();\n\t    } else if (name === \'p192\') {\n\t      prime = new P192();\n\t    } else if (name === \'p25519\') {\n\t      prime = new P25519();\n\t    } else {\n\t      throw new Error(\'Unknown prime \' + name);\n\t    }\n\t    primes[name] = prime;\n\n\t    return prime;\n\t  };\n\n\t  //\n\t  // Base reduction engine\n\t  //\n\t  function Red (m) {\n\t    if (typeof m === \'string\') {\n\t      var prime = BN._prime(m);\n\t      this.m = prime.p;\n\t      this.prime = prime;\n\t    } else {\n\t      assert(m.gtn(1), \'modulus must be greater than 1\');\n\t      this.m = m;\n\t      this.prime = null;\n\t    }\n\t  }\n\n\t  Red.prototype._verify1 = function _verify1 (a) {\n\t    assert(a.negative === 0, \'red works only with positives\');\n\t    assert(a.red, \'red works only with red numbers\');\n\t  };\n\n\t  Red.prototype._verify2 = function _verify2 (a, b) {\n\t    assert((a.negative | b.negative) === 0, \'red works only with positives\');\n\t    assert(a.red && a.red === b.red,\n\t      \'red works only with red numbers\');\n\t  };\n\n\t  Red.prototype.imod = function imod (a) {\n\t    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\t    return a.umod(this.m)._forceRed(this);\n\t  };\n\n\t  Red.prototype.neg = function neg (a) {\n\t    if (a.isZero()) {\n\t      return a.clone();\n\t    }\n\n\t    return this.m.sub(a)._forceRed(this);\n\t  };\n\n\t  Red.prototype.add = function add (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.add(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.iadd = function iadd (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.iadd(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.sub = function sub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.sub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.isub = function isub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.isub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.shl = function shl (a, num) {\n\t    this._verify1(a);\n\t    return this.imod(a.ushln(num));\n\t  };\n\n\t  Red.prototype.imul = function imul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.imul(b));\n\t  };\n\n\t  Red.prototype.mul = function mul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.mul(b));\n\t  };\n\n\t  Red.prototype.isqr = function isqr (a) {\n\t    return this.imul(a, a.clone());\n\t  };\n\n\t  Red.prototype.sqr = function sqr (a) {\n\t    return this.mul(a, a);\n\t  };\n\n\t  Red.prototype.sqrt = function sqrt (a) {\n\t    if (a.isZero()) return a.clone();\n\n\t    var mod3 = this.m.andln(3);\n\t    assert(mod3 % 2 === 1);\n\n\t    // Fast case\n\t    if (mod3 === 3) {\n\t      var pow = this.m.add(new BN(1)).iushrn(2);\n\t      return this.pow(a, pow);\n\t    }\n\n\t    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n\t    //\n\t    // Find Q and S, that Q * 2 ^ S = (P - 1)\n\t    var q = this.m.subn(1);\n\t    var s = 0;\n\t    while (!q.isZero() && q.andln(1) === 0) {\n\t      s++;\n\t      q.iushrn(1);\n\t    }\n\t    assert(!q.isZero());\n\n\t    var one = new BN(1).toRed(this);\n\t    var nOne = one.redNeg();\n\n\t    // Find quadratic non-residue\n\t    // NOTE: Max is such because of generalized Riemann hypothesis.\n\t    var lpow = this.m.subn(1).iushrn(1);\n\t    var z = this.m.bitLength();\n\t    z = new BN(2 * z * z).toRed(this);\n\n\t    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n\t      z.redIAdd(nOne);\n\t    }\n\n\t    var c = this.pow(z, q);\n\t    var r = this.pow(a, q.addn(1).iushrn(1));\n\t    var t = this.pow(a, q);\n\t    var m = s;\n\t    while (t.cmp(one) !== 0) {\n\t      var tmp = t;\n\t      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n\t        tmp = tmp.redSqr();\n\t      }\n\t      assert(i < m);\n\t      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n\t      r = r.redMul(b);\n\t      c = b.redSqr();\n\t      t = t.redMul(c);\n\t      m = i;\n\t    }\n\n\t    return r;\n\t  };\n\n\t  Red.prototype.invm = function invm (a) {\n\t    var inv = a._invmp(this.m);\n\t    if (inv.negative !== 0) {\n\t      inv.negative = 0;\n\t      return this.imod(inv).redNeg();\n\t    } else {\n\t      return this.imod(inv);\n\t    }\n\t  };\n\n\t  Red.prototype.pow = function pow (a, num) {\n\t    if (num.isZero()) return new BN(1).toRed(this);\n\t    if (num.cmpn(1) === 0) return a.clone();\n\n\t    var windowSize = 4;\n\t    var wnd = new Array(1 << windowSize);\n\t    wnd[0] = new BN(1).toRed(this);\n\t    wnd[1] = a;\n\t    for (var i = 2; i < wnd.length; i++) {\n\t      wnd[i] = this.mul(wnd[i - 1], a);\n\t    }\n\n\t    var res = wnd[0];\n\t    var current = 0;\n\t    var currentLen = 0;\n\t    var start = num.bitLength() % 26;\n\t    if (start === 0) {\n\t      start = 26;\n\t    }\n\n\t    for (i = num.length - 1; i >= 0; i--) {\n\t      var word = num.words[i];\n\t      for (var j = start - 1; j >= 0; j--) {\n\t        var bit = (word >> j) & 1;\n\t        if (res !== wnd[0]) {\n\t          res = this.sqr(res);\n\t        }\n\n\t        if (bit === 0 && current === 0) {\n\t          currentLen = 0;\n\t          continue;\n\t        }\n\n\t        current <<= 1;\n\t        current |= bit;\n\t        currentLen++;\n\t        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n\t        res = this.mul(res, wnd[current]);\n\t        currentLen = 0;\n\t        current = 0;\n\t      }\n\t      start = 26;\n\t    }\n\n\t    return res;\n\t  };\n\n\t  Red.prototype.convertTo = function convertTo (num) {\n\t    var r = num.umod(this.m);\n\n\t    return r === num ? r.clone() : r;\n\t  };\n\n\t  Red.prototype.convertFrom = function convertFrom (num) {\n\t    var res = num.clone();\n\t    res.red = null;\n\t    return res;\n\t  };\n\n\t  //\n\t  // Montgomery method engine\n\t  //\n\n\t  BN.mont = function mont (num) {\n\t    return new Mont(num);\n\t  };\n\n\t  function Mont (m) {\n\t    Red.call(this, m);\n\n\t    this.shift = this.m.bitLength();\n\t    if (this.shift % 26 !== 0) {\n\t      this.shift += 26 - (this.shift % 26);\n\t    }\n\n\t    this.r = new BN(1).iushln(this.shift);\n\t    this.r2 = this.imod(this.r.sqr());\n\t    this.rinv = this.r._invmp(this.m);\n\n\t    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n\t    this.minv = this.minv.umod(this.r);\n\t    this.minv = this.r.sub(this.minv);\n\t  }\n\t  inherits(Mont, Red);\n\n\t  Mont.prototype.convertTo = function convertTo (num) {\n\t    return this.imod(num.ushln(this.shift));\n\t  };\n\n\t  Mont.prototype.convertFrom = function convertFrom (num) {\n\t    var r = this.imod(num.mul(this.rinv));\n\t    r.red = null;\n\t    return r;\n\t  };\n\n\t  Mont.prototype.imul = function imul (a, b) {\n\t    if (a.isZero() || b.isZero()) {\n\t      a.words[0] = 0;\n\t      a.length = 1;\n\t      return a;\n\t    }\n\n\t    var t = a.imul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.mul = function mul (a, b) {\n\t    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n\t    var t = a.mul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.invm = function invm (a) {\n\t    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n\t    var res = this.imod(a._invmp(this.m).mul(this.r2));\n\t    return res._forceRed(this);\n\t  };\n\t})( false || module, commonjsGlobal);\n\t});\n\tvar bn_1 = bn.BN;\n\n\tvar _version = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "logger/5.0.5";\n\n\t});\n\n\tvar _version$1 = unwrapExports(_version);\n\tvar _version_1 = _version.version;\n\n\tvar lib = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tvar _permanentCensorErrors = false;\n\tvar _censorErrors = false;\n\tvar LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };\n\tvar _logLevel = LogLevels["default"];\n\n\tvar _globalLogger = null;\n\tfunction _checkNormalize() {\n\t    try {\n\t        var missing_1 = [];\n\t        // Make sure all forms of normalization are supported\n\t        ["NFD", "NFC", "NFKD", "NFKC"].forEach(function (form) {\n\t            try {\n\t                if ("test".normalize(form) !== "test") {\n\t                    throw new Error("bad normalize");\n\t                }\n\t                ;\n\t            }\n\t            catch (error) {\n\t                missing_1.push(form);\n\t            }\n\t        });\n\t        if (missing_1.length) {\n\t            throw new Error("missing " + missing_1.join(", "));\n\t        }\n\t        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {\n\t            throw new Error("broken implementation");\n\t        }\n\t    }\n\t    catch (error) {\n\t        return error.message;\n\t    }\n\t    return null;\n\t}\n\tvar _normalizeError = _checkNormalize();\n\tvar LogLevel;\n\t(function (LogLevel) {\n\t    LogLevel["DEBUG"] = "DEBUG";\n\t    LogLevel["INFO"] = "INFO";\n\t    LogLevel["WARNING"] = "WARNING";\n\t    LogLevel["ERROR"] = "ERROR";\n\t    LogLevel["OFF"] = "OFF";\n\t})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));\n\tvar ErrorCode;\n\t(function (ErrorCode) {\n\t    ///////////////////\n\t    // Generic Errors\n\t    // Unknown Error\n\t    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";\n\t    // Not Implemented\n\t    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";\n\t    // Unsupported Operation\n\t    //   - operation\n\t    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";\n\t    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)\n\t    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)\n\t    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";\n\t    // Some sort of bad response from the server\n\t    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";\n\t    // Timeout\n\t    ErrorCode["TIMEOUT"] = "TIMEOUT";\n\t    ///////////////////\n\t    // Operational  Errors\n\t    // Buffer Overrun\n\t    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";\n\t    // Numeric Fault\n\t    //   - operation: the operation being executed\n\t    //   - fault: the reason this faulted\n\t    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";\n\t    ///////////////////\n\t    // Argument Errors\n\t    // Missing new operator to an object\n\t    //  - name: The name of the class\n\t    ErrorCode["MISSING_NEW"] = "MISSING_NEW";\n\t    // Invalid argument (e.g. value is incompatible with type) to a function:\n\t    //   - argument: The argument name that was invalid\n\t    //   - value: The value of the argument\n\t    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";\n\t    // Missing argument to a function:\n\t    //   - count: The number of arguments received\n\t    //   - expectedCount: The number of arguments expected\n\t    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";\n\t    // Too many arguments\n\t    //   - count: The number of arguments received\n\t    //   - expectedCount: The number of arguments expected\n\t    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";\n\t    ///////////////////\n\t    // Blockchain Errors\n\t    // Call exception\n\t    //  - transaction: the transaction\n\t    //  - address?: the contract address\n\t    //  - args?: The arguments passed into the function\n\t    //  - method?: The Solidity method signature\n\t    //  - errorSignature?: The EIP848 error signature\n\t    //  - errorArgs?: The EIP848 error parameters\n\t    //  - reason: The reason (only for EIP848 "Error(string)")\n\t    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";\n\t    // Insufficien funds (< value + gasLimit * gasPrice)\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";\n\t    // Nonce has already been used\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";\n\t    // The replacement fee for the transaction is too low\n\t    //   - transaction: the transaction attempted\n\t    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";\n\t    // The gas limit could not be estimated\n\t    //   - transaction: the transaction passed to estimateGas\n\t    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";\n\t})(ErrorCode = exports.ErrorCode || (exports.ErrorCode = {}));\n\t;\n\tvar Logger = /** @class */ (function () {\n\t    function Logger(version) {\n\t        Object.defineProperty(this, "version", {\n\t            enumerable: true,\n\t            value: version,\n\t            writable: false\n\t        });\n\t    }\n\t    Logger.prototype._log = function (logLevel, args) {\n\t        var level = logLevel.toLowerCase();\n\t        if (LogLevels[level] == null) {\n\t            this.throwArgumentError("invalid log level name", "logLevel", logLevel);\n\t        }\n\t        if (_logLevel > LogLevels[level]) {\n\t            return;\n\t        }\n\t        console.log.apply(console, args);\n\t    };\n\t    Logger.prototype.debug = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.DEBUG, args);\n\t    };\n\t    Logger.prototype.info = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.INFO, args);\n\t    };\n\t    Logger.prototype.warn = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        this._log(Logger.levels.WARNING, args);\n\t    };\n\t    Logger.prototype.makeError = function (message, code, params) {\n\t        // Errors are being censored\n\t        if (_censorErrors) {\n\t            return this.makeError("censored error", code, {});\n\t        }\n\t        if (!code) {\n\t            code = Logger.errors.UNKNOWN_ERROR;\n\t        }\n\t        if (!params) {\n\t            params = {};\n\t        }\n\t        var messageDetails = [];\n\t        Object.keys(params).forEach(function (key) {\n\t            try {\n\t                messageDetails.push(key + "=" + JSON.stringify(params[key]));\n\t            }\n\t            catch (error) {\n\t                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));\n\t            }\n\t        });\n\t        messageDetails.push("code=" + code);\n\t        messageDetails.push("version=" + this.version);\n\t        var reason = message;\n\t        if (messageDetails.length) {\n\t            message += " (" + messageDetails.join(", ") + ")";\n\t        }\n\t        // @TODO: Any??\n\t        var error = new Error(message);\n\t        error.reason = reason;\n\t        error.code = code;\n\t        Object.keys(params).forEach(function (key) {\n\t            error[key] = params[key];\n\t        });\n\t        return error;\n\t    };\n\t    Logger.prototype.throwError = function (message, code, params) {\n\t        throw this.makeError(message, code, params);\n\t    };\n\t    Logger.prototype.throwArgumentError = function (message, name, value) {\n\t        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {\n\t            argument: name,\n\t            value: value\n\t        });\n\t    };\n\t    Logger.prototype.assert = function (condition, message, code, params) {\n\t        if (!!condition) {\n\t            return;\n\t        }\n\t        this.throwError(message, code, params);\n\t    };\n\t    Logger.prototype.assertArgument = function (condition, message, name, value) {\n\t        if (!!condition) {\n\t            return;\n\t        }\n\t        this.throwArgumentError(message, name, value);\n\t    };\n\t    Logger.prototype.checkNormalize = function (message) {\n\t        if (message == null) {\n\t            message = "platform missing String.prototype.normalize";\n\t        }\n\t        if (_normalizeError) {\n\t            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "String.prototype.normalize", form: _normalizeError\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkSafeUint53 = function (value, message) {\n\t        if (typeof (value) !== "number") {\n\t            return;\n\t        }\n\t        if (message == null) {\n\t            message = "value not safe";\n\t        }\n\t        if (value < 0 || value >= 0x1fffffffffffff) {\n\t            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n\t                operation: "checkSafeInteger",\n\t                fault: "out-of-safe-range",\n\t                value: value\n\t            });\n\t        }\n\t        if (value % 1) {\n\t            this.throwError(message, Logger.errors.NUMERIC_FAULT, {\n\t                operation: "checkSafeInteger",\n\t                fault: "non-integer",\n\t                value: value\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkArgumentCount = function (count, expectedCount, message) {\n\t        if (message) {\n\t            message = ": " + message;\n\t        }\n\t        else {\n\t            message = "";\n\t        }\n\t        if (count < expectedCount) {\n\t            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {\n\t                count: count,\n\t                expectedCount: expectedCount\n\t            });\n\t        }\n\t        if (count > expectedCount) {\n\t            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {\n\t                count: count,\n\t                expectedCount: expectedCount\n\t            });\n\t        }\n\t    };\n\t    Logger.prototype.checkNew = function (target, kind) {\n\t        if (target === Object || target == null) {\n\t            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });\n\t        }\n\t    };\n\t    Logger.prototype.checkAbstract = function (target, kind) {\n\t        if (target === kind) {\n\t            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });\n\t        }\n\t        else if (target === Object || target == null) {\n\t            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });\n\t        }\n\t    };\n\t    Logger.globalLogger = function () {\n\t        if (!_globalLogger) {\n\t            _globalLogger = new Logger(_version.version);\n\t        }\n\t        return _globalLogger;\n\t    };\n\t    Logger.setCensorship = function (censorship, permanent) {\n\t        if (!censorship && permanent) {\n\t            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "setCensorship"\n\t            });\n\t        }\n\t        if (_permanentCensorErrors) {\n\t            if (!censorship) {\n\t                return;\n\t            }\n\t            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "setCensorship"\n\t            });\n\t        }\n\t        _censorErrors = !!censorship;\n\t        _permanentCensorErrors = !!permanent;\n\t    };\n\t    Logger.setLogLevel = function (logLevel) {\n\t        var level = LogLevels[logLevel.toLowerCase()];\n\t        if (level == null) {\n\t            Logger.globalLogger().warn("invalid log level - " + logLevel);\n\t            return;\n\t        }\n\t        _logLevel = level;\n\t    };\n\t    Logger.errors = ErrorCode;\n\t    Logger.levels = LogLevel;\n\t    return Logger;\n\t}());\n\texports.Logger = Logger;\n\n\t});\n\n\tvar index = unwrapExports(lib);\n\tvar lib_1 = lib.LogLevel;\n\tvar lib_2 = lib.ErrorCode;\n\tvar lib_3 = lib.Logger;\n\n\tvar _version$2 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "bytes/5.0.4";\n\n\t});\n\n\tvar _version$3 = unwrapExports(_version$2);\n\tvar _version_1$1 = _version$2.version;\n\n\tvar lib$1 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$2.version);\n\t///////////////////////////////\n\tfunction isHexable(value) {\n\t    return !!(value.toHexString);\n\t}\n\tfunction addSlice(array) {\n\t    if (array.slice) {\n\t        return array;\n\t    }\n\t    array.slice = function () {\n\t        var args = Array.prototype.slice.call(arguments);\n\t        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));\n\t    };\n\t    return array;\n\t}\n\tfunction isBytesLike(value) {\n\t    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));\n\t}\n\texports.isBytesLike = isBytesLike;\n\tfunction isBytes(value) {\n\t    if (value == null) {\n\t        return false;\n\t    }\n\t    if (value.constructor === Uint8Array) {\n\t        return true;\n\t    }\n\t    if (typeof (value) === "string") {\n\t        return false;\n\t    }\n\t    if (value.length == null) {\n\t        return false;\n\t    }\n\t    for (var i = 0; i < value.length; i++) {\n\t        var v = value[i];\n\t        if (v < 0 || v >= 256 || (v % 1)) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\texports.isBytes = isBytes;\n\tfunction arrayify(value, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    if (typeof (value) === "number") {\n\t        logger.checkSafeUint53(value, "invalid arrayify value");\n\t        var result = [];\n\t        while (value) {\n\t            result.unshift(value & 0xff);\n\t            value = parseInt(String(value / 256));\n\t        }\n\t        if (result.length === 0) {\n\t            result.push(0);\n\t        }\n\t        return addSlice(new Uint8Array(result));\n\t    }\n\t    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {\n\t        value = "0x" + value;\n\t    }\n\t    if (isHexable(value)) {\n\t        value = value.toHexString();\n\t    }\n\t    if (isHexString(value)) {\n\t        var hex = value.substring(2);\n\t        if (hex.length % 2) {\n\t            if (options.hexPad === "left") {\n\t                hex = "0x0" + hex.substring(2);\n\t            }\n\t            else if (options.hexPad === "right") {\n\t                hex += "0";\n\t            }\n\t            else {\n\t                logger.throwArgumentError("hex data is odd-length", "value", value);\n\t            }\n\t        }\n\t        var result = [];\n\t        for (var i = 0; i < hex.length; i += 2) {\n\t            result.push(parseInt(hex.substring(i, i + 2), 16));\n\t        }\n\t        return addSlice(new Uint8Array(result));\n\t    }\n\t    if (isBytes(value)) {\n\t        return addSlice(new Uint8Array(value));\n\t    }\n\t    return logger.throwArgumentError("invalid arrayify value", "value", value);\n\t}\n\texports.arrayify = arrayify;\n\tfunction concat(items) {\n\t    var objects = items.map(function (item) { return arrayify(item); });\n\t    var length = objects.reduce(function (accum, item) { return (accum + item.length); }, 0);\n\t    var result = new Uint8Array(length);\n\t    objects.reduce(function (offset, object) {\n\t        result.set(object, offset);\n\t        return offset + object.length;\n\t    }, 0);\n\t    return addSlice(result);\n\t}\n\texports.concat = concat;\n\tfunction stripZeros(value) {\n\t    var result = arrayify(value);\n\t    if (result.length === 0) {\n\t        return result;\n\t    }\n\t    // Find the first non-zero entry\n\t    var start = 0;\n\t    while (start < result.length && result[start] === 0) {\n\t        start++;\n\t    }\n\t    // If we started with zeros, strip them\n\t    if (start) {\n\t        result = result.slice(start);\n\t    }\n\t    return result;\n\t}\n\texports.stripZeros = stripZeros;\n\tfunction zeroPad(value, length) {\n\t    value = arrayify(value);\n\t    if (value.length > length) {\n\t        logger.throwArgumentError("value out of range", "value", arguments[0]);\n\t    }\n\t    var result = new Uint8Array(length);\n\t    result.set(value, length - value.length);\n\t    return addSlice(result);\n\t}\n\texports.zeroPad = zeroPad;\n\tfunction isHexString(value, length) {\n\t    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {\n\t        return false;\n\t    }\n\t    if (length && value.length !== 2 + 2 * length) {\n\t        return false;\n\t    }\n\t    return true;\n\t}\n\texports.isHexString = isHexString;\n\tvar HexCharacters = "0123456789abcdef";\n\tfunction hexlify(value, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    if (typeof (value) === "number") {\n\t        logger.checkSafeUint53(value, "invalid hexlify value");\n\t        var hex = "";\n\t        while (value) {\n\t            hex = HexCharacters[value & 0x0f] + hex;\n\t            value = Math.floor(value / 16);\n\t        }\n\t        if (hex.length) {\n\t            if (hex.length % 2) {\n\t                hex = "0" + hex;\n\t            }\n\t            return "0x" + hex;\n\t        }\n\t        return "0x00";\n\t    }\n\t    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {\n\t        value = "0x" + value;\n\t    }\n\t    if (isHexable(value)) {\n\t        return value.toHexString();\n\t    }\n\t    if (isHexString(value)) {\n\t        if (value.length % 2) {\n\t            if (options.hexPad === "left") {\n\t                value = "0x0" + value.substring(2);\n\t            }\n\t            else if (options.hexPad === "right") {\n\t                value += "0";\n\t            }\n\t            else {\n\t                logger.throwArgumentError("hex data is odd-length", "value", value);\n\t            }\n\t        }\n\t        return value.toLowerCase();\n\t    }\n\t    if (isBytes(value)) {\n\t        var result = "0x";\n\t        for (var i = 0; i < value.length; i++) {\n\t            var v = value[i];\n\t            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];\n\t        }\n\t        return result;\n\t    }\n\t    return logger.throwArgumentError("invalid hexlify value", "value", value);\n\t}\n\texports.hexlify = hexlify;\n\t/*\n\tfunction unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {\n\t    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {\n\t        return "0x0" + value.substring(2);\n\t    }\n\t    return value;\n\t}\n\t*/\n\tfunction hexDataLength(data) {\n\t    if (typeof (data) !== "string") {\n\t        data = hexlify(data);\n\t    }\n\t    else if (!isHexString(data) || (data.length % 2)) {\n\t        return null;\n\t    }\n\t    return (data.length - 2) / 2;\n\t}\n\texports.hexDataLength = hexDataLength;\n\tfunction hexDataSlice(data, offset, endOffset) {\n\t    if (typeof (data) !== "string") {\n\t        data = hexlify(data);\n\t    }\n\t    else if (!isHexString(data) || (data.length % 2)) {\n\t        logger.throwArgumentError("invalid hexData", "value", data);\n\t    }\n\t    offset = 2 + 2 * offset;\n\t    if (endOffset != null) {\n\t        return "0x" + data.substring(offset, 2 + 2 * endOffset);\n\t    }\n\t    return "0x" + data.substring(offset);\n\t}\n\texports.hexDataSlice = hexDataSlice;\n\tfunction hexConcat(items) {\n\t    var result = "0x";\n\t    items.forEach(function (item) {\n\t        result += hexlify(item).substring(2);\n\t    });\n\t    return result;\n\t}\n\texports.hexConcat = hexConcat;\n\tfunction hexValue(value) {\n\t    var trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));\n\t    if (trimmed === "0x") {\n\t        return "0x0";\n\t    }\n\t    return trimmed;\n\t}\n\texports.hexValue = hexValue;\n\tfunction hexStripZeros(value) {\n\t    if (typeof (value) !== "string") {\n\t        value = hexlify(value);\n\t    }\n\t    if (!isHexString(value)) {\n\t        logger.throwArgumentError("invalid hex string", "value", value);\n\t    }\n\t    value = value.substring(2);\n\t    var offset = 0;\n\t    while (offset < value.length && value[offset] === "0") {\n\t        offset++;\n\t    }\n\t    return "0x" + value.substring(offset);\n\t}\n\texports.hexStripZeros = hexStripZeros;\n\tfunction hexZeroPad(value, length) {\n\t    if (typeof (value) !== "string") {\n\t        value = hexlify(value);\n\t    }\n\t    else if (!isHexString(value)) {\n\t        logger.throwArgumentError("invalid hex string", "value", value);\n\t    }\n\t    if (value.length > 2 * length + 2) {\n\t        logger.throwArgumentError("value out of range", "value", arguments[1]);\n\t    }\n\t    while (value.length < 2 * length + 2) {\n\t        value = "0x0" + value.substring(2);\n\t    }\n\t    return value;\n\t}\n\texports.hexZeroPad = hexZeroPad;\n\tfunction splitSignature(signature) {\n\t    var result = {\n\t        r: "0x",\n\t        s: "0x",\n\t        _vs: "0x",\n\t        recoveryParam: 0,\n\t        v: 0\n\t    };\n\t    if (isBytesLike(signature)) {\n\t        var bytes = arrayify(signature);\n\t        if (bytes.length !== 65) {\n\t            logger.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature);\n\t        }\n\t        // Get the r, s and v\n\t        result.r = hexlify(bytes.slice(0, 32));\n\t        result.s = hexlify(bytes.slice(32, 64));\n\t        result.v = bytes[64];\n\t        // Allow a recid to be used as the v\n\t        if (result.v < 27) {\n\t            if (result.v === 0 || result.v === 1) {\n\t                result.v += 27;\n\t            }\n\t            else {\n\t                logger.throwArgumentError("signature invalid v byte", "signature", signature);\n\t            }\n\t        }\n\t        // Compute recoveryParam from v\n\t        result.recoveryParam = 1 - (result.v % 2);\n\t        // Compute _vs from recoveryParam and s\n\t        if (result.recoveryParam) {\n\t            bytes[32] |= 0x80;\n\t        }\n\t        result._vs = hexlify(bytes.slice(32, 64));\n\t    }\n\t    else {\n\t        result.r = signature.r;\n\t        result.s = signature.s;\n\t        result.v = signature.v;\n\t        result.recoveryParam = signature.recoveryParam;\n\t        result._vs = signature._vs;\n\t        // If the _vs is available, use it to populate missing s, v and recoveryParam\n\t        // and verify non-missing s, v and recoveryParam\n\t        if (result._vs != null) {\n\t            var vs_1 = zeroPad(arrayify(result._vs), 32);\n\t            result._vs = hexlify(vs_1);\n\t            // Set or check the recid\n\t            var recoveryParam = ((vs_1[0] >= 128) ? 1 : 0);\n\t            if (result.recoveryParam == null) {\n\t                result.recoveryParam = recoveryParam;\n\t            }\n\t            else if (result.recoveryParam !== recoveryParam) {\n\t                logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);\n\t            }\n\t            // Set or check the s\n\t            vs_1[0] &= 0x7f;\n\t            var s = hexlify(vs_1);\n\t            if (result.s == null) {\n\t                result.s = s;\n\t            }\n\t            else if (result.s !== s) {\n\t                logger.throwArgumentError("signature v mismatch _vs", "signature", signature);\n\t            }\n\t        }\n\t        // Use recid and v to populate each other\n\t        if (result.recoveryParam == null) {\n\t            if (result.v == null) {\n\t                logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);\n\t            }\n\t            else {\n\t                result.recoveryParam = 1 - (result.v % 2);\n\t            }\n\t        }\n\t        else {\n\t            if (result.v == null) {\n\t                result.v = 27 + result.recoveryParam;\n\t            }\n\t            else if (result.recoveryParam !== (1 - (result.v % 2))) {\n\t                logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);\n\t            }\n\t        }\n\t        if (result.r == null || !isHexString(result.r)) {\n\t            logger.throwArgumentError("signature missing or invalid r", "signature", signature);\n\t        }\n\t        else {\n\t            result.r = hexZeroPad(result.r, 32);\n\t        }\n\t        if (result.s == null || !isHexString(result.s)) {\n\t            logger.throwArgumentError("signature missing or invalid s", "signature", signature);\n\t        }\n\t        else {\n\t            result.s = hexZeroPad(result.s, 32);\n\t        }\n\t        var vs = arrayify(result.s);\n\t        if (vs[0] >= 128) {\n\t            logger.throwArgumentError("signature s out of range", "signature", signature);\n\t        }\n\t        if (result.recoveryParam) {\n\t            vs[0] |= 0x80;\n\t        }\n\t        var _vs = hexlify(vs);\n\t        if (result._vs) {\n\t            if (!isHexString(result._vs)) {\n\t                logger.throwArgumentError("signature invalid _vs", "signature", signature);\n\t            }\n\t            result._vs = hexZeroPad(result._vs, 32);\n\t        }\n\t        // Set or check the _vs\n\t        if (result._vs == null) {\n\t            result._vs = _vs;\n\t        }\n\t        else if (result._vs !== _vs) {\n\t            logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);\n\t        }\n\t    }\n\t    return result;\n\t}\n\texports.splitSignature = splitSignature;\n\tfunction joinSignature(signature) {\n\t    signature = splitSignature(signature);\n\t    return hexlify(concat([\n\t        signature.r,\n\t        signature.s,\n\t        (signature.recoveryParam ? "0x1c" : "0x1b")\n\t    ]));\n\t}\n\texports.joinSignature = joinSignature;\n\n\t});\n\n\tvar index$1 = unwrapExports(lib$1);\n\tvar lib_1$1 = lib$1.isBytesLike;\n\tvar lib_2$1 = lib$1.isBytes;\n\tvar lib_3$1 = lib$1.arrayify;\n\tvar lib_4 = lib$1.concat;\n\tvar lib_5 = lib$1.stripZeros;\n\tvar lib_6 = lib$1.zeroPad;\n\tvar lib_7 = lib$1.isHexString;\n\tvar lib_8 = lib$1.hexlify;\n\tvar lib_9 = lib$1.hexDataLength;\n\tvar lib_10 = lib$1.hexDataSlice;\n\tvar lib_11 = lib$1.hexConcat;\n\tvar lib_12 = lib$1.hexValue;\n\tvar lib_13 = lib$1.hexStripZeros;\n\tvar lib_14 = lib$1.hexZeroPad;\n\tvar lib_15 = lib$1.splitSignature;\n\tvar lib_16 = lib$1.joinSignature;\n\n\tvar _version$4 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "bignumber/5.0.7";\n\n\t});\n\n\tvar _version$5 = unwrapExports(_version$4);\n\tvar _version_1$2 = _version$4.version;\n\n\tvar bignumber = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\t/**\n\t *  BigNumber\n\t *\n\t *  A wrapper around the BN.js object. We use the BN.js library\n\t *  because it is used by elliptic, so it is required regardles.\n\t *\n\t */\n\n\n\n\n\tvar logger = new lib.Logger(_version$4.version);\n\tvar _constructorGuard = {};\n\tvar MAX_SAFE = 0x1fffffffffffff;\n\tfunction isBigNumberish(value) {\n\t    return (value != null) && (BigNumber.isBigNumber(value) ||\n\t        (typeof (value) === "number" && (value % 1) === 0) ||\n\t        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||\n\t        lib$1.isHexString(value) ||\n\t        (typeof (value) === "bigint") ||\n\t        lib$1.isBytes(value));\n\t}\n\texports.isBigNumberish = isBigNumberish;\n\tvar BigNumber = /** @class */ (function () {\n\t    function BigNumber(constructorGuard, hex) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, BigNumber);\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError("cannot call constructor directly; use BigNumber.from", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "new (BigNumber)"\n\t            });\n\t        }\n\t        this._hex = hex;\n\t        this._isBigNumber = true;\n\t        Object.freeze(this);\n\t    }\n\t    BigNumber.prototype.fromTwos = function (value) {\n\t        return toBigNumber(toBN(this).fromTwos(value));\n\t    };\n\t    BigNumber.prototype.toTwos = function (value) {\n\t        return toBigNumber(toBN(this).toTwos(value));\n\t    };\n\t    BigNumber.prototype.abs = function () {\n\t        if (this._hex[0] === "-") {\n\t            return BigNumber.from(this._hex.substring(1));\n\t        }\n\t        return this;\n\t    };\n\t    BigNumber.prototype.add = function (other) {\n\t        return toBigNumber(toBN(this).add(toBN(other)));\n\t    };\n\t    BigNumber.prototype.sub = function (other) {\n\t        return toBigNumber(toBN(this).sub(toBN(other)));\n\t    };\n\t    BigNumber.prototype.div = function (other) {\n\t        var o = BigNumber.from(other);\n\t        if (o.isZero()) {\n\t            throwFault("division by zero", "div");\n\t        }\n\t        return toBigNumber(toBN(this).div(toBN(other)));\n\t    };\n\t    BigNumber.prototype.mul = function (other) {\n\t        return toBigNumber(toBN(this).mul(toBN(other)));\n\t    };\n\t    BigNumber.prototype.mod = function (other) {\n\t        var value = toBN(other);\n\t        if (value.isNeg()) {\n\t            throwFault("cannot modulo negative values", "mod");\n\t        }\n\t        return toBigNumber(toBN(this).umod(value));\n\t    };\n\t    BigNumber.prototype.pow = function (other) {\n\t        var value = toBN(other);\n\t        if (value.isNeg()) {\n\t            throwFault("cannot raise to negative values", "pow");\n\t        }\n\t        return toBigNumber(toBN(this).pow(value));\n\t    };\n\t    BigNumber.prototype.and = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault("cannot \'and\' negative values", "and");\n\t        }\n\t        return toBigNumber(toBN(this).and(value));\n\t    };\n\t    BigNumber.prototype.or = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault("cannot \'or\' negative values", "or");\n\t        }\n\t        return toBigNumber(toBN(this).or(value));\n\t    };\n\t    BigNumber.prototype.xor = function (other) {\n\t        var value = toBN(other);\n\t        if (this.isNegative() || value.isNeg()) {\n\t            throwFault("cannot \'xor\' negative values", "xor");\n\t        }\n\t        return toBigNumber(toBN(this).xor(value));\n\t    };\n\t    BigNumber.prototype.mask = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault("cannot mask negative values", "mask");\n\t        }\n\t        return toBigNumber(toBN(this).maskn(value));\n\t    };\n\t    BigNumber.prototype.shl = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault("cannot shift negative values", "shl");\n\t        }\n\t        return toBigNumber(toBN(this).shln(value));\n\t    };\n\t    BigNumber.prototype.shr = function (value) {\n\t        if (this.isNegative() || value < 0) {\n\t            throwFault("cannot shift negative values", "shr");\n\t        }\n\t        return toBigNumber(toBN(this).shrn(value));\n\t    };\n\t    BigNumber.prototype.eq = function (other) {\n\t        return toBN(this).eq(toBN(other));\n\t    };\n\t    BigNumber.prototype.lt = function (other) {\n\t        return toBN(this).lt(toBN(other));\n\t    };\n\t    BigNumber.prototype.lte = function (other) {\n\t        return toBN(this).lte(toBN(other));\n\t    };\n\t    BigNumber.prototype.gt = function (other) {\n\t        return toBN(this).gt(toBN(other));\n\t    };\n\t    BigNumber.prototype.gte = function (other) {\n\t        return toBN(this).gte(toBN(other));\n\t    };\n\t    BigNumber.prototype.isNegative = function () {\n\t        return (this._hex[0] === "-");\n\t    };\n\t    BigNumber.prototype.isZero = function () {\n\t        return toBN(this).isZero();\n\t    };\n\t    BigNumber.prototype.toNumber = function () {\n\t        try {\n\t            return toBN(this).toNumber();\n\t        }\n\t        catch (error) {\n\t            throwFault("overflow", "toNumber", this.toString());\n\t        }\n\t        return null;\n\t    };\n\t    BigNumber.prototype.toString = function () {\n\t        // Lots of people expect this, which we do not support, so check\n\t        if (arguments.length !== 0) {\n\t            logger.throwError("bigNumber.toString does not accept parameters", lib.Logger.errors.UNEXPECTED_ARGUMENT, {});\n\t        }\n\t        return toBN(this).toString(10);\n\t    };\n\t    BigNumber.prototype.toHexString = function () {\n\t        return this._hex;\n\t    };\n\t    BigNumber.prototype.toJSON = function (key) {\n\t        return { type: "BigNumber", hex: this.toHexString() };\n\t    };\n\t    BigNumber.from = function (value) {\n\t        if (value instanceof BigNumber) {\n\t            return value;\n\t        }\n\t        if (typeof (value) === "string") {\n\t            if (value.match(/^-?0x[0-9a-f]+$/i)) {\n\t                return new BigNumber(_constructorGuard, toHex(value));\n\t            }\n\t            if (value.match(/^-?[0-9]+$/)) {\n\t                return new BigNumber(_constructorGuard, toHex(new bn.BN(value)));\n\t            }\n\t            return logger.throwArgumentError("invalid BigNumber string", "value", value);\n\t        }\n\t        if (typeof (value) === "number") {\n\t            if (value % 1) {\n\t                throwFault("underflow", "BigNumber.from", value);\n\t            }\n\t            if (value >= MAX_SAFE || value <= -MAX_SAFE) {\n\t                throwFault("overflow", "BigNumber.from", value);\n\t            }\n\t            return BigNumber.from(String(value));\n\t        }\n\t        var anyValue = value;\n\t        if (typeof (anyValue) === "bigint") {\n\t            return BigNumber.from(anyValue.toString());\n\t        }\n\t        if (lib$1.isBytes(anyValue)) {\n\t            return BigNumber.from(lib$1.hexlify(anyValue));\n\t        }\n\t        if (anyValue) {\n\t            // Hexable interface (takes piority)\n\t            if (anyValue.toHexString) {\n\t                var hex = anyValue.toHexString();\n\t                if (typeof (hex) === "string") {\n\t                    return BigNumber.from(hex);\n\t                }\n\t            }\n\t            else {\n\t                // For now, handle legacy JSON-ified values (goes away in v6)\n\t                var hex = anyValue._hex;\n\t                // New-form JSON\n\t                if (hex == null && anyValue.type === "BigNumber") {\n\t                    hex = anyValue.hex;\n\t                }\n\t                if (typeof (hex) === "string") {\n\t                    if (lib$1.isHexString(hex) || (hex[0] === "-" && lib$1.isHexString(hex.substring(1)))) {\n\t                        return BigNumber.from(hex);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        return logger.throwArgumentError("invalid BigNumber value", "value", value);\n\t    };\n\t    BigNumber.isBigNumber = function (value) {\n\t        return !!(value && value._isBigNumber);\n\t    };\n\t    return BigNumber;\n\t}());\n\texports.BigNumber = BigNumber;\n\t// Normalize the hex string\n\tfunction toHex(value) {\n\t    // For BN, call on the hex string\n\t    if (typeof (value) !== "string") {\n\t        return toHex(value.toString(16));\n\t    }\n\t    // If negative, prepend the negative sign to the normalized positive value\n\t    if (value[0] === "-") {\n\t        // Strip off the negative sign\n\t        value = value.substring(1);\n\t        // Cannot have mulitple negative signs (e.g. "--0x04")\n\t        if (value[0] === "-") {\n\t            logger.throwArgumentError("invalid hex", "value", value);\n\t        }\n\t        // Call toHex on the positive component\n\t        value = toHex(value);\n\t        // Do not allow "-0x00"\n\t        if (value === "0x00") {\n\t            return value;\n\t        }\n\t        // Negate the value\n\t        return "-" + value;\n\t    }\n\t    // Add a "0x" prefix if missing\n\t    if (value.substring(0, 2) !== "0x") {\n\t        value = "0x" + value;\n\t    }\n\t    // Normalize zero\n\t    if (value === "0x") {\n\t        return "0x00";\n\t    }\n\t    // Make the string even length\n\t    if (value.length % 2) {\n\t        value = "0x0" + value.substring(2);\n\t    }\n\t    // Trim to smallest even-length string\n\t    while (value.length > 4 && value.substring(0, 4) === "0x00") {\n\t        value = "0x" + value.substring(4);\n\t    }\n\t    return value;\n\t}\n\tfunction toBigNumber(value) {\n\t    return BigNumber.from(toHex(value));\n\t}\n\tfunction toBN(value) {\n\t    var hex = BigNumber.from(value).toHexString();\n\t    if (hex[0] === "-") {\n\t        return (new bn.BN("-" + hex.substring(3), 16));\n\t    }\n\t    return new bn.BN(hex.substring(2), 16);\n\t}\n\tfunction throwFault(fault, operation, value) {\n\t    var params = { fault: fault, operation: operation };\n\t    if (value != null) {\n\t        params.value = value;\n\t    }\n\t    return logger.throwError(fault, lib.Logger.errors.NUMERIC_FAULT, params);\n\t}\n\n\t});\n\n\tvar bignumber$1 = unwrapExports(bignumber);\n\tvar bignumber_1 = bignumber.isBigNumberish;\n\tvar bignumber_2 = bignumber.BigNumber;\n\n\tvar fixednumber = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$4.version);\n\n\tvar _constructorGuard = {};\n\tvar Zero = bignumber.BigNumber.from(0);\n\tvar NegativeOne = bignumber.BigNumber.from(-1);\n\tfunction throwFault(message, fault, operation, value) {\n\t    var params = { fault: fault, operation: operation };\n\t    if (value !== undefined) {\n\t        params.value = value;\n\t    }\n\t    return logger.throwError(message, lib.Logger.errors.NUMERIC_FAULT, params);\n\t}\n\t// Constant to pull zeros from for multipliers\n\tvar zeros = "0";\n\twhile (zeros.length < 256) {\n\t    zeros += zeros;\n\t}\n\t// Returns a string "1" followed by decimal "0"s\n\tfunction getMultiplier(decimals) {\n\t    if (typeof (decimals) !== "number") {\n\t        try {\n\t            decimals = bignumber.BigNumber.from(decimals).toNumber();\n\t        }\n\t        catch (e) { }\n\t    }\n\t    if (typeof (decimals) === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {\n\t        return ("1" + zeros.substring(0, decimals));\n\t    }\n\t    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);\n\t}\n\tfunction formatFixed(value, decimals) {\n\t    if (decimals == null) {\n\t        decimals = 0;\n\t    }\n\t    var multiplier = getMultiplier(decimals);\n\t    // Make sure wei is a big number (convert as necessary)\n\t    value = bignumber.BigNumber.from(value);\n\t    var negative = value.lt(Zero);\n\t    if (negative) {\n\t        value = value.mul(NegativeOne);\n\t    }\n\t    var fraction = value.mod(multiplier).toString();\n\t    while (fraction.length < multiplier.length - 1) {\n\t        fraction = "0" + fraction;\n\t    }\n\t    // Strip training 0\n\t    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];\n\t    var whole = value.div(multiplier).toString();\n\t    value = whole + "." + fraction;\n\t    if (negative) {\n\t        value = "-" + value;\n\t    }\n\t    return value;\n\t}\n\texports.formatFixed = formatFixed;\n\tfunction parseFixed(value, decimals) {\n\t    if (decimals == null) {\n\t        decimals = 0;\n\t    }\n\t    var multiplier = getMultiplier(decimals);\n\t    if (typeof (value) !== "string" || !value.match(/^-?[0-9.,]+$/)) {\n\t        logger.throwArgumentError("invalid decimal value", "value", value);\n\t    }\n\t    if (multiplier.length - 1 === 0) {\n\t        return bignumber.BigNumber.from(value);\n\t    }\n\t    // Is it negative?\n\t    var negative = (value.substring(0, 1) === "-");\n\t    if (negative) {\n\t        value = value.substring(1);\n\t    }\n\t    if (value === ".") {\n\t        logger.throwArgumentError("missing value", "value", value);\n\t    }\n\t    // Split it into a whole and fractional part\n\t    var comps = value.split(".");\n\t    if (comps.length > 2) {\n\t        logger.throwArgumentError("too many decimal points", "value", value);\n\t    }\n\t    var whole = comps[0], fraction = comps[1];\n\t    if (!whole) {\n\t        whole = "0";\n\t    }\n\t    if (!fraction) {\n\t        fraction = "0";\n\t    }\n\t    // Prevent underflow\n\t    if (fraction.length > multiplier.length - 1) {\n\t        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");\n\t    }\n\t    // Fully pad the string with zeros to get to wei\n\t    while (fraction.length < multiplier.length - 1) {\n\t        fraction += "0";\n\t    }\n\t    var wholeValue = bignumber.BigNumber.from(whole);\n\t    var fractionValue = bignumber.BigNumber.from(fraction);\n\t    var wei = (wholeValue.mul(multiplier)).add(fractionValue);\n\t    if (negative) {\n\t        wei = wei.mul(NegativeOne);\n\t    }\n\t    return wei;\n\t}\n\texports.parseFixed = parseFixed;\n\tvar FixedFormat = /** @class */ (function () {\n\t    function FixedFormat(constructorGuard, signed, width, decimals) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "new FixedFormat"\n\t            });\n\t        }\n\t        this.signed = signed;\n\t        this.width = width;\n\t        this.decimals = decimals;\n\t        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);\n\t        this._multiplier = getMultiplier(decimals);\n\t        Object.freeze(this);\n\t    }\n\t    FixedFormat.from = function (value) {\n\t        if (value instanceof FixedFormat) {\n\t            return value;\n\t        }\n\t        var signed = true;\n\t        var width = 128;\n\t        var decimals = 18;\n\t        if (typeof (value) === "string") {\n\t            if (value === "fixed") {\n\t                // defaults...\n\t            }\n\t            else if (value === "ufixed") {\n\t                signed = false;\n\t            }\n\t            else if (value != null) {\n\t                var match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);\n\t                if (!match) {\n\t                    logger.throwArgumentError("invalid fixed format", "format", value);\n\t                }\n\t                signed = (match[1] !== "u");\n\t                width = parseInt(match[2]);\n\t                decimals = parseInt(match[3]);\n\t            }\n\t        }\n\t        else if (value) {\n\t            var check = function (key, type, defaultValue) {\n\t                if (value[key] == null) {\n\t                    return defaultValue;\n\t                }\n\t                if (typeof (value[key]) !== type) {\n\t                    logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);\n\t                }\n\t                return value[key];\n\t            };\n\t            signed = check("signed", "boolean", signed);\n\t            width = check("width", "number", width);\n\t            decimals = check("decimals", "number", decimals);\n\t        }\n\t        if (width % 8) {\n\t            logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);\n\t        }\n\t        if (decimals > 80) {\n\t            logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);\n\t        }\n\t        return new FixedFormat(_constructorGuard, signed, width, decimals);\n\t    };\n\t    return FixedFormat;\n\t}());\n\texports.FixedFormat = FixedFormat;\n\tvar FixedNumber = /** @class */ (function () {\n\t    function FixedNumber(constructorGuard, hex, value, format) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, FixedNumber);\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "new FixedFormat"\n\t            });\n\t        }\n\t        this.format = format;\n\t        this._hex = hex;\n\t        this._value = value;\n\t        this._isFixedNumber = true;\n\t        Object.freeze(this);\n\t    }\n\t    FixedNumber.prototype._checkFormat = function (other) {\n\t        if (this.format.name !== other.format.name) {\n\t            logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);\n\t        }\n\t    };\n\t    FixedNumber.prototype.addUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.subUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.mulUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.divUnsafe = function (other) {\n\t        this._checkFormat(other);\n\t        var a = parseFixed(this._value, this.format.decimals);\n\t        var b = parseFixed(other._value, other.format.decimals);\n\t        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);\n\t    };\n\t    FixedNumber.prototype.floor = function () {\n\t        var comps = this.toString().split(".");\n\t        var result = FixedNumber.from(comps[0], this.format);\n\t        var hasFraction = !comps[1].match(/^(0*)$/);\n\t        if (this.isNegative() && hasFraction) {\n\t            result = result.subUnsafe(ONE);\n\t        }\n\t        return result;\n\t    };\n\t    FixedNumber.prototype.ceiling = function () {\n\t        var comps = this.toString().split(".");\n\t        var result = FixedNumber.from(comps[0], this.format);\n\t        var hasFraction = !comps[1].match(/^(0*)$/);\n\t        if (!this.isNegative() && hasFraction) {\n\t            result = result.addUnsafe(ONE);\n\t        }\n\t        return result;\n\t    };\n\t    // @TODO: Support other rounding algorithms\n\t    FixedNumber.prototype.round = function (decimals) {\n\t        if (decimals == null) {\n\t            decimals = 0;\n\t        }\n\t        // If we are already in range, we\'re done\n\t        var comps = this.toString().split(".");\n\t        if (decimals < 0 || decimals > 80 || (decimals % 1)) {\n\t            logger.throwArgumentError("invalid decimal count", "decimals", decimals);\n\t        }\n\t        if (comps[1].length <= decimals) {\n\t            return this;\n\t        }\n\t        var factor = FixedNumber.from("1" + zeros.substring(0, decimals));\n\t        return this.mulUnsafe(factor).addUnsafe(BUMP).floor().divUnsafe(factor);\n\t    };\n\t    FixedNumber.prototype.isZero = function () {\n\t        return (this._value === "0.0");\n\t    };\n\t    FixedNumber.prototype.isNegative = function () {\n\t        return (this._value[0] === "-");\n\t    };\n\t    FixedNumber.prototype.toString = function () { return this._value; };\n\t    FixedNumber.prototype.toHexString = function (width) {\n\t        if (width == null) {\n\t            return this._hex;\n\t        }\n\t        if (width % 8) {\n\t            logger.throwArgumentError("invalid byte width", "width", width);\n\t        }\n\t        var hex = bignumber.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();\n\t        return lib$1.hexZeroPad(hex, width / 8);\n\t    };\n\t    FixedNumber.prototype.toUnsafeFloat = function () { return parseFloat(this.toString()); };\n\t    FixedNumber.prototype.toFormat = function (format) {\n\t        return FixedNumber.fromString(this._value, format);\n\t    };\n\t    FixedNumber.fromValue = function (value, decimals, format) {\n\t        // If decimals looks more like a format, and there is no format, shift the parameters\n\t        if (format == null && decimals != null && !bignumber.isBigNumberish(decimals)) {\n\t            format = decimals;\n\t            decimals = null;\n\t        }\n\t        if (decimals == null) {\n\t            decimals = 0;\n\t        }\n\t        if (format == null) {\n\t            format = "fixed";\n\t        }\n\t        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));\n\t    };\n\t    FixedNumber.fromString = function (value, format) {\n\t        if (format == null) {\n\t            format = "fixed";\n\t        }\n\t        var fixedFormat = FixedFormat.from(format);\n\t        var numeric = parseFixed(value, fixedFormat.decimals);\n\t        if (!fixedFormat.signed && numeric.lt(Zero)) {\n\t            throwFault("unsigned value cannot be negative", "overflow", "value", value);\n\t        }\n\t        var hex = null;\n\t        if (fixedFormat.signed) {\n\t            hex = numeric.toTwos(fixedFormat.width).toHexString();\n\t        }\n\t        else {\n\t            hex = numeric.toHexString();\n\t            hex = lib$1.hexZeroPad(hex, fixedFormat.width / 8);\n\t        }\n\t        var decimal = formatFixed(numeric, fixedFormat.decimals);\n\t        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n\t    };\n\t    FixedNumber.fromBytes = function (value, format) {\n\t        if (format == null) {\n\t            format = "fixed";\n\t        }\n\t        var fixedFormat = FixedFormat.from(format);\n\t        if (lib$1.arrayify(value).length > fixedFormat.width / 8) {\n\t            throw new Error("overflow");\n\t        }\n\t        var numeric = bignumber.BigNumber.from(value);\n\t        if (fixedFormat.signed) {\n\t            numeric = numeric.fromTwos(fixedFormat.width);\n\t        }\n\t        var hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();\n\t        var decimal = formatFixed(numeric, fixedFormat.decimals);\n\t        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);\n\t    };\n\t    FixedNumber.from = function (value, format) {\n\t        if (typeof (value) === "string") {\n\t            return FixedNumber.fromString(value, format);\n\t        }\n\t        if (lib$1.isBytes(value)) {\n\t            return FixedNumber.fromBytes(value, format);\n\t        }\n\t        try {\n\t            return FixedNumber.fromValue(value, 0, format);\n\t        }\n\t        catch (error) {\n\t            // Allow NUMERIC_FAULT to bubble up\n\t            if (error.code !== lib.Logger.errors.INVALID_ARGUMENT) {\n\t                throw error;\n\t            }\n\t        }\n\t        return logger.throwArgumentError("invalid FixedNumber value", "value", value);\n\t    };\n\t    FixedNumber.isFixedNumber = function (value) {\n\t        return !!(value && value._isFixedNumber);\n\t    };\n\t    return FixedNumber;\n\t}());\n\texports.FixedNumber = FixedNumber;\n\tvar ONE = FixedNumber.from(1);\n\tvar BUMP = FixedNumber.from("0.5");\n\n\t});\n\n\tvar fixednumber$1 = unwrapExports(fixednumber);\n\tvar fixednumber_1 = fixednumber.formatFixed;\n\tvar fixednumber_2 = fixednumber.parseFixed;\n\tvar fixednumber_3 = fixednumber.FixedFormat;\n\tvar fixednumber_4 = fixednumber.FixedNumber;\n\n\tvar lib$2 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\texports.BigNumber = bignumber.BigNumber;\n\n\texports.formatFixed = fixednumber.formatFixed;\n\texports.FixedFormat = fixednumber.FixedFormat;\n\texports.FixedNumber = fixednumber.FixedNumber;\n\texports.parseFixed = fixednumber.parseFixed;\n\n\t});\n\n\tvar index$2 = unwrapExports(lib$2);\n\tvar lib_1$2 = lib$2.BigNumber;\n\tvar lib_2$2 = lib$2.formatFixed;\n\tvar lib_3$2 = lib$2.FixedFormat;\n\tvar lib_4$1 = lib$2.FixedNumber;\n\tvar lib_5$1 = lib$2.parseFixed;\n\n\tvar _version$6 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "properties/5.0.3";\n\n\t});\n\n\tvar _version$7 = unwrapExports(_version$6);\n\tvar _version_1$3 = _version$6.version;\n\n\tvar lib$3 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$6.version);\n\tfunction defineReadOnly(object, name, value) {\n\t    Object.defineProperty(object, name, {\n\t        enumerable: true,\n\t        value: value,\n\t        writable: false,\n\t    });\n\t}\n\texports.defineReadOnly = defineReadOnly;\n\t// Crawl up the constructor chain to find a static method\n\tfunction getStatic(ctor, key) {\n\t    for (var i = 0; i < 32; i++) {\n\t        if (ctor[key]) {\n\t            return ctor[key];\n\t        }\n\t        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {\n\t            break;\n\t        }\n\t        ctor = Object.getPrototypeOf(ctor.prototype).constructor;\n\t    }\n\t    return null;\n\t}\n\texports.getStatic = getStatic;\n\tfunction resolveProperties(object) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var promises, results;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    promises = Object.keys(object).map(function (key) {\n\t                        var value = object[key];\n\t                        return Promise.resolve(value).then(function (v) { return ({ key: key, value: v }); });\n\t                    });\n\t                    return [4 /*yield*/, Promise.all(promises)];\n\t                case 1:\n\t                    results = _a.sent();\n\t                    return [2 /*return*/, results.reduce(function (accum, result) {\n\t                            accum[(result.key)] = result.value;\n\t                            return accum;\n\t                        }, {})];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.resolveProperties = resolveProperties;\n\tfunction checkProperties(object, properties) {\n\t    if (!object || typeof (object) !== "object") {\n\t        logger.throwArgumentError("invalid object", "object", object);\n\t    }\n\t    Object.keys(object).forEach(function (key) {\n\t        if (!properties[key]) {\n\t            logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);\n\t        }\n\t    });\n\t}\n\texports.checkProperties = checkProperties;\n\tfunction shallowCopy(object) {\n\t    var result = {};\n\t    for (var key in object) {\n\t        result[key] = object[key];\n\t    }\n\t    return result;\n\t}\n\texports.shallowCopy = shallowCopy;\n\tvar opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };\n\tfunction _isFrozen(object) {\n\t    // Opaque objects are not mutable, so safe to copy by assignment\n\t    if (object === undefined || object === null || opaque[typeof (object)]) {\n\t        return true;\n\t    }\n\t    if (Array.isArray(object) || typeof (object) === "object") {\n\t        if (!Object.isFrozen(object)) {\n\t            return false;\n\t        }\n\t        var keys = Object.keys(object);\n\t        for (var i = 0; i < keys.length; i++) {\n\t            if (!_isFrozen(object[keys[i]])) {\n\t                return false;\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    return logger.throwArgumentError("Cannot deepCopy " + typeof (object), "object", object);\n\t}\n\t// Returns a new copy of object, such that no properties may be replaced.\n\t// New properties may be added only to objects.\n\tfunction _deepCopy(object) {\n\t    if (_isFrozen(object)) {\n\t        return object;\n\t    }\n\t    // Arrays are mutable, so we need to create a copy\n\t    if (Array.isArray(object)) {\n\t        return Object.freeze(object.map(function (item) { return deepCopy(item); }));\n\t    }\n\t    if (typeof (object) === "object") {\n\t        var result = {};\n\t        for (var key in object) {\n\t            var value = object[key];\n\t            if (value === undefined) {\n\t                continue;\n\t            }\n\t            defineReadOnly(result, key, deepCopy(value));\n\t        }\n\t        return result;\n\t    }\n\t    return logger.throwArgumentError("Cannot deepCopy " + typeof (object), "object", object);\n\t}\n\tfunction deepCopy(object) {\n\t    return _deepCopy(object);\n\t}\n\texports.deepCopy = deepCopy;\n\tvar Description = /** @class */ (function () {\n\t    function Description(info) {\n\t        for (var key in info) {\n\t            this[key] = deepCopy(info[key]);\n\t        }\n\t    }\n\t    return Description;\n\t}());\n\texports.Description = Description;\n\n\t});\n\n\tvar index$3 = unwrapExports(lib$3);\n\tvar lib_1$3 = lib$3.defineReadOnly;\n\tvar lib_2$3 = lib$3.getStatic;\n\tvar lib_3$3 = lib$3.resolveProperties;\n\tvar lib_4$2 = lib$3.checkProperties;\n\tvar lib_5$2 = lib$3.shallowCopy;\n\tvar lib_6$1 = lib$3.deepCopy;\n\tvar lib_7$1 = lib$3.Description;\n\n\tvar _version$8 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "abi/5.0.5";\n\n\t});\n\n\tvar _version$9 = unwrapExports(_version$8);\n\tvar _version_1$4 = _version$8.version;\n\n\tvar fragments = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\t;\n\tvar _constructorGuard = {};\n\tvar ModifiersBytes = { calldata: true, memory: true, storage: true };\n\tvar ModifiersNest = { calldata: true, memory: true };\n\tfunction checkModifier(type, name) {\n\t    if (type === "bytes" || type === "string") {\n\t        if (ModifiersBytes[name]) {\n\t            return true;\n\t        }\n\t    }\n\t    else if (type === "address") {\n\t        if (name === "payable") {\n\t            return true;\n\t        }\n\t    }\n\t    else if (type.indexOf("[") >= 0 || type === "tuple") {\n\t        if (ModifiersNest[name]) {\n\t            return true;\n\t        }\n\t    }\n\t    if (ModifiersBytes[name] || name === "payable") {\n\t        logger.throwArgumentError("invalid modifier", "name", name);\n\t    }\n\t    return false;\n\t}\n\t// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\n\tfunction parseParamType(param, allowIndexed) {\n\t    var originalParam = param;\n\t    function throwError(i) {\n\t        logger.throwArgumentError("unexpected character at position " + i, "param", param);\n\t    }\n\t    param = param.replace(/\\s/g, " ");\n\t    function newNode(parent) {\n\t        var node = { type: "", name: "", parent: parent, state: { allowType: true } };\n\t        if (allowIndexed) {\n\t            node.indexed = false;\n\t        }\n\t        return node;\n\t    }\n\t    var parent = { type: "", name: "", state: { allowType: true } };\n\t    var node = parent;\n\t    for (var i = 0; i < param.length; i++) {\n\t        var c = param[i];\n\t        switch (c) {\n\t            case "(":\n\t                if (node.state.allowType && node.type === "") {\n\t                    node.type = "tuple";\n\t                }\n\t                else if (!node.state.allowParams) {\n\t                    throwError(i);\n\t                }\n\t                node.state.allowType = false;\n\t                node.type = verifyType(node.type);\n\t                node.components = [newNode(node)];\n\t                node = node.components[0];\n\t                break;\n\t            case ")":\n\t                delete node.state;\n\t                if (node.name === "indexed") {\n\t                    if (!allowIndexed) {\n\t                        throwError(i);\n\t                    }\n\t                    node.indexed = true;\n\t                    node.name = "";\n\t                }\n\t                if (checkModifier(node.type, node.name)) {\n\t                    node.name = "";\n\t                }\n\t                node.type = verifyType(node.type);\n\t                var child = node;\n\t                node = node.parent;\n\t                if (!node) {\n\t                    throwError(i);\n\t                }\n\t                delete child.parent;\n\t                node.state.allowParams = false;\n\t                node.state.allowName = true;\n\t                node.state.allowArray = true;\n\t                break;\n\t            case ",":\n\t                delete node.state;\n\t                if (node.name === "indexed") {\n\t                    if (!allowIndexed) {\n\t                        throwError(i);\n\t                    }\n\t                    node.indexed = true;\n\t                    node.name = "";\n\t                }\n\t                if (checkModifier(node.type, node.name)) {\n\t                    node.name = "";\n\t                }\n\t                node.type = verifyType(node.type);\n\t                var sibling = newNode(node.parent);\n\t                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };\n\t                node.parent.components.push(sibling);\n\t                delete node.parent;\n\t                node = sibling;\n\t                break;\n\t            // Hit a space...\n\t            case " ":\n\t                // If reading type, the type is done and may read a param or name\n\t                if (node.state.allowType) {\n\t                    if (node.type !== "") {\n\t                        node.type = verifyType(node.type);\n\t                        delete node.state.allowType;\n\t                        node.state.allowName = true;\n\t                        node.state.allowParams = true;\n\t                    }\n\t                }\n\t                // If reading name, the name is done\n\t                if (node.state.allowName) {\n\t                    if (node.name !== "") {\n\t                        if (node.name === "indexed") {\n\t                            if (!allowIndexed) {\n\t                                throwError(i);\n\t                            }\n\t                            if (node.indexed) {\n\t                                throwError(i);\n\t                            }\n\t                            node.indexed = true;\n\t                            node.name = "";\n\t                        }\n\t                        else if (checkModifier(node.type, node.name)) {\n\t                            node.name = "";\n\t                        }\n\t                        else {\n\t                            node.state.allowName = false;\n\t                        }\n\t                    }\n\t                }\n\t                break;\n\t            case "[":\n\t                if (!node.state.allowArray) {\n\t                    throwError(i);\n\t                }\n\t                node.type += c;\n\t                node.state.allowArray = false;\n\t                node.state.allowName = false;\n\t                node.state.readArray = true;\n\t                break;\n\t            case "]":\n\t                if (!node.state.readArray) {\n\t                    throwError(i);\n\t                }\n\t                node.type += c;\n\t                node.state.readArray = false;\n\t                node.state.allowArray = true;\n\t                node.state.allowName = true;\n\t                break;\n\t            default:\n\t                if (node.state.allowType) {\n\t                    node.type += c;\n\t                    node.state.allowParams = true;\n\t                    node.state.allowArray = true;\n\t                }\n\t                else if (node.state.allowName) {\n\t                    node.name += c;\n\t                    delete node.state.allowArray;\n\t                }\n\t                else if (node.state.readArray) {\n\t                    node.type += c;\n\t                }\n\t                else {\n\t                    throwError(i);\n\t                }\n\t        }\n\t    }\n\t    if (node.parent) {\n\t        logger.throwArgumentError("unexpected eof", "param", param);\n\t    }\n\t    delete parent.state;\n\t    if (node.name === "indexed") {\n\t        if (!allowIndexed) {\n\t            throwError(originalParam.length - 7);\n\t        }\n\t        if (node.indexed) {\n\t            throwError(originalParam.length - 7);\n\t        }\n\t        node.indexed = true;\n\t        node.name = "";\n\t    }\n\t    else if (checkModifier(node.type, node.name)) {\n\t        node.name = "";\n\t    }\n\t    parent.type = verifyType(parent.type);\n\t    return parent;\n\t}\n\tfunction populate(object, params) {\n\t    for (var key in params) {\n\t        lib$3.defineReadOnly(object, key, params[key]);\n\t    }\n\t}\n\texports.FormatTypes = Object.freeze({\n\t    // Bare formatting, as is needed for computing a sighash of an event or function\n\t    sighash: "sighash",\n\t    // Human-Readable with Minimal spacing and without names (compact human-readable)\n\t    minimal: "minimal",\n\t    // Human-Readble with nice spacing, including all names\n\t    full: "full",\n\t    // JSON-format a la Solidity\n\t    json: "json"\n\t});\n\tvar paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\n\tvar ParamType = /** @class */ (function () {\n\t    function ParamType(constructorGuard, params) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError("use fromString", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "new ParamType()"\n\t            });\n\t        }\n\t        populate(this, params);\n\t        var match = this.type.match(paramTypeArray);\n\t        if (match) {\n\t            populate(this, {\n\t                arrayLength: parseInt(match[2] || "-1"),\n\t                arrayChildren: ParamType.fromObject({\n\t                    type: match[1],\n\t                    components: this.components\n\t                }),\n\t                baseType: "array"\n\t            });\n\t        }\n\t        else {\n\t            populate(this, {\n\t                arrayLength: null,\n\t                arrayChildren: null,\n\t                baseType: ((this.components != null) ? "tuple" : this.type)\n\t            });\n\t        }\n\t        this._isParamType = true;\n\t        Object.freeze(this);\n\t    }\n\t    // Format the parameter fragment\n\t    //   - sighash: "(uint256,address)"\n\t    //   - minimal: "tuple(uint256,address) indexed"\n\t    //   - full:    "tuple(uint256 foo, addres bar) indexed baz"\n\t    ParamType.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError("invalid format type", "format", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            var result_1 = {\n\t                type: ((this.baseType === "tuple") ? "tuple" : this.type),\n\t                name: (this.name || undefined)\n\t            };\n\t            if (typeof (this.indexed) === "boolean") {\n\t                result_1.indexed = this.indexed;\n\t            }\n\t            if (this.components) {\n\t                result_1.components = this.components.map(function (comp) { return JSON.parse(comp.format(format)); });\n\t            }\n\t            return JSON.stringify(result_1);\n\t        }\n\t        var result = "";\n\t        // Array\n\t        if (this.baseType === "array") {\n\t            result += this.arrayChildren.format(format);\n\t            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";\n\t        }\n\t        else {\n\t            if (this.baseType === "tuple") {\n\t                if (format !== exports.FormatTypes.sighash) {\n\t                    result += this.type;\n\t                }\n\t                result += "(" + this.components.map(function (comp) { return comp.format(format); }).join((format === exports.FormatTypes.full) ? ", " : ",") + ")";\n\t            }\n\t            else {\n\t                result += this.type;\n\t            }\n\t        }\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.indexed === true) {\n\t                result += " indexed";\n\t            }\n\t            if (format === exports.FormatTypes.full && this.name) {\n\t                result += " " + this.name;\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    ParamType.from = function (value, allowIndexed) {\n\t        if (typeof (value) === "string") {\n\t            return ParamType.fromString(value, allowIndexed);\n\t        }\n\t        return ParamType.fromObject(value);\n\t    };\n\t    ParamType.fromObject = function (value) {\n\t        if (ParamType.isParamType(value)) {\n\t            return value;\n\t        }\n\t        return new ParamType(_constructorGuard, {\n\t            name: (value.name || null),\n\t            type: verifyType(value.type),\n\t            indexed: ((value.indexed == null) ? null : !!value.indexed),\n\t            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n\t        });\n\t    };\n\t    ParamType.fromString = function (value, allowIndexed) {\n\t        function ParamTypify(node) {\n\t            return ParamType.fromObject({\n\t                name: node.name,\n\t                type: node.type,\n\t                indexed: node.indexed,\n\t                components: node.components\n\t            });\n\t        }\n\t        return ParamTypify(parseParamType(value, !!allowIndexed));\n\t    };\n\t    ParamType.isParamType = function (value) {\n\t        return !!(value != null && value._isParamType);\n\t    };\n\t    return ParamType;\n\t}());\n\texports.ParamType = ParamType;\n\t;\n\tfunction parseParams(value, allowIndex) {\n\t    return splitNesting(value).map(function (param) { return ParamType.fromString(param, allowIndex); });\n\t}\n\tvar Fragment = /** @class */ (function () {\n\t    function Fragment(constructorGuard, params) {\n\t        if (constructorGuard !== _constructorGuard) {\n\t            logger.throwError("use a static from method", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "new Fragment()"\n\t            });\n\t        }\n\t        populate(this, params);\n\t        this._isFragment = true;\n\t        Object.freeze(this);\n\t    }\n\t    Fragment.from = function (value) {\n\t        if (Fragment.isFragment(value)) {\n\t            return value;\n\t        }\n\t        if (typeof (value) === "string") {\n\t            return Fragment.fromString(value);\n\t        }\n\t        return Fragment.fromObject(value);\n\t    };\n\t    Fragment.fromObject = function (value) {\n\t        if (Fragment.isFragment(value)) {\n\t            return value;\n\t        }\n\t        switch (value.type) {\n\t            case "function":\n\t                return FunctionFragment.fromObject(value);\n\t            case "event":\n\t                return EventFragment.fromObject(value);\n\t            case "constructor":\n\t                return ConstructorFragment.fromObject(value);\n\t            case "fallback":\n\t            case "receive":\n\t                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n\t                return null;\n\t        }\n\t        return logger.throwArgumentError("invalid fragment object", "value", value);\n\t    };\n\t    Fragment.fromString = function (value) {\n\t        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space\n\t        value = value.replace(/\\s/g, " ");\n\t        value = value.replace(/\\(/g, " (").replace(/\\)/g, ") ").replace(/\\s+/g, " ");\n\t        value = value.trim();\n\t        if (value.split(" ")[0] === "event") {\n\t            return EventFragment.fromString(value.substring(5).trim());\n\t        }\n\t        else if (value.split(" ")[0] === "function") {\n\t            return FunctionFragment.fromString(value.substring(8).trim());\n\t        }\n\t        else if (value.split("(")[0].trim() === "constructor") {\n\t            return ConstructorFragment.fromString(value.trim());\n\t        }\n\t        return logger.throwArgumentError("unsupported fragment", "value", value);\n\t    };\n\t    Fragment.isFragment = function (value) {\n\t        return !!(value && value._isFragment);\n\t    };\n\t    return Fragment;\n\t}());\n\texports.Fragment = Fragment;\n\tvar EventFragment = /** @class */ (function (_super) {\n\t    __extends(EventFragment, _super);\n\t    function EventFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    EventFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError("invalid format type", "format", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: "event",\n\t                anonymous: this.anonymous,\n\t                name: this.name,\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n\t            });\n\t        }\n\t        var result = "";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            result += "event ";\n\t        }\n\t        result += this.name + "(" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? ", " : ",") + ") ";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.anonymous) {\n\t                result += "anonymous ";\n\t            }\n\t        }\n\t        return result.trim();\n\t    };\n\t    EventFragment.from = function (value) {\n\t        if (typeof (value) === "string") {\n\t            return EventFragment.fromString(value);\n\t        }\n\t        return EventFragment.fromObject(value);\n\t    };\n\t    EventFragment.fromObject = function (value) {\n\t        if (EventFragment.isEventFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== "event") {\n\t            logger.throwArgumentError("invalid event object", "value", value);\n\t        }\n\t        var params = {\n\t            name: verifyIdentifier(value.name),\n\t            anonymous: value.anonymous,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            type: "event"\n\t        };\n\t        return new EventFragment(_constructorGuard, params);\n\t    };\n\t    EventFragment.fromString = function (value) {\n\t        var match = value.match(regexParen);\n\t        if (!match) {\n\t            logger.throwArgumentError("invalid event string", "value", value);\n\t        }\n\t        var anonymous = false;\n\t        match[3].split(" ").forEach(function (modifier) {\n\t            switch (modifier.trim()) {\n\t                case "anonymous":\n\t                    anonymous = true;\n\t                    break;\n\t                case "":\n\t                    break;\n\t                default:\n\t                    logger.warn("unknown modifier: " + modifier);\n\t            }\n\t        });\n\t        return EventFragment.fromObject({\n\t            name: match[1].trim(),\n\t            anonymous: anonymous,\n\t            inputs: parseParams(match[2], true),\n\t            type: "event"\n\t        });\n\t    };\n\t    EventFragment.isEventFragment = function (value) {\n\t        return (value && value._isFragment && value.type === "event");\n\t    };\n\t    return EventFragment;\n\t}(Fragment));\n\texports.EventFragment = EventFragment;\n\tfunction parseGas(value, params) {\n\t    params.gas = null;\n\t    var comps = value.split("@");\n\t    if (comps.length !== 1) {\n\t        if (comps.length > 2) {\n\t            logger.throwArgumentError("invalid human-readable ABI signature", "value", value);\n\t        }\n\t        if (!comps[1].match(/^[0-9]+$/)) {\n\t            logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);\n\t        }\n\t        params.gas = lib$2.BigNumber.from(comps[1]);\n\t        return comps[0];\n\t    }\n\t    return value;\n\t}\n\tfunction parseModifiers(value, params) {\n\t    params.constant = false;\n\t    params.payable = false;\n\t    params.stateMutability = "nonpayable";\n\t    value.split(" ").forEach(function (modifier) {\n\t        switch (modifier.trim()) {\n\t            case "constant":\n\t                params.constant = true;\n\t                break;\n\t            case "payable":\n\t                params.payable = true;\n\t                params.stateMutability = "payable";\n\t                break;\n\t            case "nonpayable":\n\t                params.payable = false;\n\t                params.stateMutability = "nonpayable";\n\t                break;\n\t            case "pure":\n\t                params.constant = true;\n\t                params.stateMutability = "pure";\n\t                break;\n\t            case "view":\n\t                params.constant = true;\n\t                params.stateMutability = "view";\n\t                break;\n\t            case "external":\n\t            case "public":\n\t            case "":\n\t                break;\n\t            default:\n\t                console.log("unknown modifier: " + modifier);\n\t        }\n\t    });\n\t}\n\tfunction verifyState(value) {\n\t    var result = {\n\t        constant: false,\n\t        payable: true,\n\t        stateMutability: "payable"\n\t    };\n\t    if (value.stateMutability != null) {\n\t        result.stateMutability = value.stateMutability;\n\t        // Set (and check things are consistent) the constant property\n\t        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");\n\t        if (value.constant != null) {\n\t            if ((!!value.constant) !== result.constant) {\n\t                logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);\n\t            }\n\t        }\n\t        // Set (and check things are consistent) the payable property\n\t        result.payable = (result.stateMutability === "payable");\n\t        if (value.payable != null) {\n\t            if ((!!value.payable) !== result.payable) {\n\t                logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);\n\t            }\n\t        }\n\t    }\n\t    else if (value.payable != null) {\n\t        result.payable = !!value.payable;\n\t        // If payable we can assume non-constant; otherwise we can\'t assume\n\t        if (value.constant == null && !result.payable && value.type !== "constructor") {\n\t            logger.throwArgumentError("unable to determine stateMutability", "value", value);\n\t        }\n\t        result.constant = !!value.constant;\n\t        if (result.constant) {\n\t            result.stateMutability = "view";\n\t        }\n\t        else {\n\t            result.stateMutability = (result.payable ? "payable" : "nonpayable");\n\t        }\n\t        if (result.payable && result.constant) {\n\t            logger.throwArgumentError("cannot have constant payable function", "value", value);\n\t        }\n\t    }\n\t    else if (value.constant != null) {\n\t        result.constant = !!value.constant;\n\t        result.payable = !result.constant;\n\t        result.stateMutability = (result.constant ? "view" : "payable");\n\t    }\n\t    else if (value.type !== "constructor") {\n\t        logger.throwArgumentError("unable to determine stateMutability", "value", value);\n\t    }\n\t    return result;\n\t}\n\tvar ConstructorFragment = /** @class */ (function (_super) {\n\t    __extends(ConstructorFragment, _super);\n\t    function ConstructorFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    ConstructorFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError("invalid format type", "format", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: "constructor",\n\t                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),\n\t                payble: this.payable,\n\t                gas: (this.gas ? this.gas.toNumber() : undefined),\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); })\n\t            });\n\t        }\n\t        if (format === exports.FormatTypes.sighash) {\n\t            logger.throwError("cannot format a constructor for sighash", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "format(sighash)"\n\t            });\n\t        }\n\t        var result = "constructor(" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? ", " : ",") + ") ";\n\t        if (this.stateMutability && this.stateMutability !== "nonpayable") {\n\t            result += this.stateMutability + " ";\n\t        }\n\t        return result.trim();\n\t    };\n\t    ConstructorFragment.from = function (value) {\n\t        if (typeof (value) === "string") {\n\t            return ConstructorFragment.fromString(value);\n\t        }\n\t        return ConstructorFragment.fromObject(value);\n\t    };\n\t    ConstructorFragment.fromObject = function (value) {\n\t        if (ConstructorFragment.isConstructorFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== "constructor") {\n\t            logger.throwArgumentError("invalid constructor object", "value", value);\n\t        }\n\t        var state = verifyState(value);\n\t        if (state.constant) {\n\t            logger.throwArgumentError("constructor cannot be constant", "value", value);\n\t        }\n\t        var params = {\n\t            name: null,\n\t            type: value.type,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            payable: state.payable,\n\t            stateMutability: state.stateMutability,\n\t            gas: (value.gas ? lib$2.BigNumber.from(value.gas) : null)\n\t        };\n\t        return new ConstructorFragment(_constructorGuard, params);\n\t    };\n\t    ConstructorFragment.fromString = function (value) {\n\t        var params = { type: "constructor" };\n\t        value = parseGas(value, params);\n\t        var parens = value.match(regexParen);\n\t        if (!parens || parens[1].trim() !== "constructor") {\n\t            logger.throwArgumentError("invalid constructor string", "value", value);\n\t        }\n\t        params.inputs = parseParams(parens[2].trim(), false);\n\t        parseModifiers(parens[3].trim(), params);\n\t        return ConstructorFragment.fromObject(params);\n\t    };\n\t    ConstructorFragment.isConstructorFragment = function (value) {\n\t        return (value && value._isFragment && value.type === "constructor");\n\t    };\n\t    return ConstructorFragment;\n\t}(Fragment));\n\texports.ConstructorFragment = ConstructorFragment;\n\tvar FunctionFragment = /** @class */ (function (_super) {\n\t    __extends(FunctionFragment, _super);\n\t    function FunctionFragment() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    FunctionFragment.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = exports.FormatTypes.sighash;\n\t        }\n\t        if (!exports.FormatTypes[format]) {\n\t            logger.throwArgumentError("invalid format type", "format", format);\n\t        }\n\t        if (format === exports.FormatTypes.json) {\n\t            return JSON.stringify({\n\t                type: "function",\n\t                name: this.name,\n\t                constant: this.constant,\n\t                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),\n\t                payble: this.payable,\n\t                gas: (this.gas ? this.gas.toNumber() : undefined),\n\t                inputs: this.inputs.map(function (input) { return JSON.parse(input.format(format)); }),\n\t                ouputs: this.outputs.map(function (output) { return JSON.parse(output.format(format)); }),\n\t            });\n\t        }\n\t        var result = "";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            result += "function ";\n\t        }\n\t        result += this.name + "(" + this.inputs.map(function (input) { return input.format(format); }).join((format === exports.FormatTypes.full) ? ", " : ",") + ") ";\n\t        if (format !== exports.FormatTypes.sighash) {\n\t            if (this.stateMutability) {\n\t                if (this.stateMutability !== "nonpayable") {\n\t                    result += (this.stateMutability + " ");\n\t                }\n\t            }\n\t            else if (this.constant) {\n\t                result += "view ";\n\t            }\n\t            if (this.outputs && this.outputs.length) {\n\t                result += "returns (" + this.outputs.map(function (output) { return output.format(format); }).join(", ") + ") ";\n\t            }\n\t            if (this.gas != null) {\n\t                result += "@" + this.gas.toString() + " ";\n\t            }\n\t        }\n\t        return result.trim();\n\t    };\n\t    FunctionFragment.from = function (value) {\n\t        if (typeof (value) === "string") {\n\t            return FunctionFragment.fromString(value);\n\t        }\n\t        return FunctionFragment.fromObject(value);\n\t    };\n\t    FunctionFragment.fromObject = function (value) {\n\t        if (FunctionFragment.isFunctionFragment(value)) {\n\t            return value;\n\t        }\n\t        if (value.type !== "function") {\n\t            logger.throwArgumentError("invalid function object", "value", value);\n\t        }\n\t        var state = verifyState(value);\n\t        var params = {\n\t            type: value.type,\n\t            name: verifyIdentifier(value.name),\n\t            constant: state.constant,\n\t            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n\t            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n\t            payable: state.payable,\n\t            stateMutability: state.stateMutability,\n\t            gas: (value.gas ? lib$2.BigNumber.from(value.gas) : null)\n\t        };\n\t        return new FunctionFragment(_constructorGuard, params);\n\t    };\n\t    FunctionFragment.fromString = function (value) {\n\t        var params = { type: "function" };\n\t        value = parseGas(value, params);\n\t        var comps = value.split(" returns ");\n\t        if (comps.length > 2) {\n\t            logger.throwArgumentError("invalid function string", "value", value);\n\t        }\n\t        var parens = comps[0].match(regexParen);\n\t        if (!parens) {\n\t            logger.throwArgumentError("invalid function signature", "value", value);\n\t        }\n\t        params.name = parens[1].trim();\n\t        if (params.name) {\n\t            verifyIdentifier(params.name);\n\t        }\n\t        params.inputs = parseParams(parens[2], false);\n\t        parseModifiers(parens[3].trim(), params);\n\t        // We have outputs\n\t        if (comps.length > 1) {\n\t            var returns = comps[1].match(regexParen);\n\t            if (returns[1].trim() != "" || returns[3].trim() != "") {\n\t                logger.throwArgumentError("unexpected tokens", "value", value);\n\t            }\n\t            params.outputs = parseParams(returns[2], false);\n\t        }\n\t        else {\n\t            params.outputs = [];\n\t        }\n\t        return FunctionFragment.fromObject(params);\n\t    };\n\t    FunctionFragment.isFunctionFragment = function (value) {\n\t        return (value && value._isFragment && value.type === "function");\n\t    };\n\t    return FunctionFragment;\n\t}(ConstructorFragment));\n\texports.FunctionFragment = FunctionFragment;\n\t//export class ErrorFragment extends Fragment {\n\t//}\n\t//export class StructFragment extends Fragment {\n\t//}\n\tfunction verifyType(type) {\n\t    // These need to be transformed to their full description\n\t    if (type.match(/^uint($|[^1-9])/)) {\n\t        type = "uint256" + type.substring(4);\n\t    }\n\t    else if (type.match(/^int($|[^1-9])/)) {\n\t        type = "int256" + type.substring(3);\n\t    }\n\t    // @TODO: more verification\n\t    return type;\n\t}\n\tvar regexIdentifier = new RegExp("^[A-Za-z_][A-Za-z0-9_]*$");\n\tfunction verifyIdentifier(value) {\n\t    if (!value || !value.match(regexIdentifier)) {\n\t        logger.throwArgumentError("invalid identifier \\"" + value + "\\"", "value", value);\n\t    }\n\t    return value;\n\t}\n\tvar regexParen = new RegExp("^([^)(]*)\\\\((.*)\\\\)([^)(]*)$");\n\tfunction splitNesting(value) {\n\t    value = value.trim();\n\t    var result = [];\n\t    var accum = "";\n\t    var depth = 0;\n\t    for (var offset = 0; offset < value.length; offset++) {\n\t        var c = value[offset];\n\t        if (c === "," && depth === 0) {\n\t            result.push(accum);\n\t            accum = "";\n\t        }\n\t        else {\n\t            accum += c;\n\t            if (c === "(") {\n\t                depth++;\n\t            }\n\t            else if (c === ")") {\n\t                depth--;\n\t                if (depth === -1) {\n\t                    logger.throwArgumentError("unbalanced parenthesis", "value", value);\n\t                }\n\t            }\n\t        }\n\t    }\n\t    if (accum) {\n\t        result.push(accum);\n\t    }\n\t    return result;\n\t}\n\n\t});\n\n\tvar fragments$1 = unwrapExports(fragments);\n\tvar fragments_1 = fragments.FormatTypes;\n\tvar fragments_2 = fragments.ParamType;\n\tvar fragments_3 = fragments.Fragment;\n\tvar fragments_4 = fragments.EventFragment;\n\tvar fragments_5 = fragments.ConstructorFragment;\n\tvar fragments_6 = fragments.FunctionFragment;\n\n\tvar abstractCoder = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\tfunction checkResultErrors(result) {\n\t    // Find the first error (if any)\n\t    var errors = [];\n\t    var checkErrors = function (path, object) {\n\t        if (!Array.isArray(object)) {\n\t            return;\n\t        }\n\t        for (var key in object) {\n\t            var childPath = path.slice();\n\t            childPath.push(key);\n\t            try {\n\t                checkErrors(childPath, object[key]);\n\t            }\n\t            catch (error) {\n\t                errors.push({ path: childPath, error: error });\n\t            }\n\t        }\n\t    };\n\t    checkErrors([], result);\n\t    return errors;\n\t}\n\texports.checkResultErrors = checkResultErrors;\n\tvar Coder = /** @class */ (function () {\n\t    function Coder(name, type, localName, dynamic) {\n\t        // @TODO: defineReadOnly these\n\t        this.name = name;\n\t        this.type = type;\n\t        this.localName = localName;\n\t        this.dynamic = dynamic;\n\t    }\n\t    Coder.prototype._throwError = function (message, value) {\n\t        logger.throwArgumentError(message, this.localName, value);\n\t    };\n\t    return Coder;\n\t}());\n\texports.Coder = Coder;\n\tvar Writer = /** @class */ (function () {\n\t    function Writer(wordSize) {\n\t        lib$3.defineReadOnly(this, "wordSize", wordSize || 32);\n\t        this._data = lib$1.arrayify([]);\n\t        this._padding = new Uint8Array(wordSize);\n\t    }\n\t    Object.defineProperty(Writer.prototype, "data", {\n\t        get: function () { return lib$1.hexlify(this._data); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Writer.prototype, "length", {\n\t        get: function () { return this._data.length; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Writer.prototype._writeData = function (data) {\n\t        this._data = lib$1.concat([this._data, data]);\n\t        return data.length;\n\t    };\n\t    // Arrayish items; padded on the right to wordSize\n\t    Writer.prototype.writeBytes = function (value) {\n\t        var bytes = lib$1.arrayify(value);\n\t        if (bytes.length % this.wordSize) {\n\t            bytes = lib$1.concat([bytes, this._padding.slice(bytes.length % this.wordSize)]);\n\t        }\n\t        return this._writeData(bytes);\n\t    };\n\t    Writer.prototype._getValue = function (value) {\n\t        var bytes = lib$1.arrayify(lib$2.BigNumber.from(value));\n\t        if (bytes.length > this.wordSize) {\n\t            logger.throwError("value out-of-bounds", lib.Logger.errors.BUFFER_OVERRUN, {\n\t                length: this.wordSize,\n\t                offset: bytes.length\n\t            });\n\t        }\n\t        if (bytes.length % this.wordSize) {\n\t            bytes = lib$1.concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n\t        }\n\t        return bytes;\n\t    };\n\t    // BigNumberish items; padded on the left to wordSize\n\t    Writer.prototype.writeValue = function (value) {\n\t        return this._writeData(this._getValue(value));\n\t    };\n\t    Writer.prototype.writeUpdatableValue = function () {\n\t        var _this = this;\n\t        var offset = this.length;\n\t        this.writeValue(0);\n\t        return function (value) {\n\t            _this._data.set(_this._getValue(value), offset);\n\t        };\n\t    };\n\t    return Writer;\n\t}());\n\texports.Writer = Writer;\n\tvar Reader = /** @class */ (function () {\n\t    function Reader(data, wordSize, coerceFunc, allowLoose) {\n\t        lib$3.defineReadOnly(this, "_data", lib$1.arrayify(data));\n\t        lib$3.defineReadOnly(this, "wordSize", wordSize || 32);\n\t        lib$3.defineReadOnly(this, "_coerceFunc", coerceFunc);\n\t        lib$3.defineReadOnly(this, "allowLoose", allowLoose);\n\t        this._offset = 0;\n\t    }\n\t    Object.defineProperty(Reader.prototype, "data", {\n\t        get: function () { return lib$1.hexlify(this._data); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Reader.prototype, "consumed", {\n\t        get: function () { return this._offset; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    // The default Coerce function\n\t    Reader.coerce = function (name, value) {\n\t        var match = name.match("^u?int([0-9]+)$");\n\t        if (match && parseInt(match[1]) <= 48) {\n\t            value = value.toNumber();\n\t        }\n\t        return value;\n\t    };\n\t    Reader.prototype.coerce = function (name, value) {\n\t        if (this._coerceFunc) {\n\t            return this._coerceFunc(name, value);\n\t        }\n\t        return Reader.coerce(name, value);\n\t    };\n\t    Reader.prototype._peekBytes = function (offset, length, loose) {\n\t        var alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n\t        if (this._offset + alignedLength > this._data.length) {\n\t            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n\t                alignedLength = length;\n\t            }\n\t            else {\n\t                logger.throwError("data out-of-bounds", lib.Logger.errors.BUFFER_OVERRUN, {\n\t                    length: this._data.length,\n\t                    offset: this._offset + alignedLength\n\t                });\n\t            }\n\t        }\n\t        return this._data.slice(this._offset, this._offset + alignedLength);\n\t    };\n\t    Reader.prototype.subReader = function (offset) {\n\t        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n\t    };\n\t    Reader.prototype.readBytes = function (length, loose) {\n\t        var bytes = this._peekBytes(0, length, !!loose);\n\t        this._offset += bytes.length;\n\t        // @TODO: Make sure the length..end bytes are all 0?\n\t        return bytes.slice(0, length);\n\t    };\n\t    Reader.prototype.readValue = function () {\n\t        return lib$2.BigNumber.from(this.readBytes(this.wordSize));\n\t    };\n\t    return Reader;\n\t}());\n\texports.Reader = Reader;\n\n\t});\n\n\tvar abstractCoder$1 = unwrapExports(abstractCoder);\n\tvar abstractCoder_1 = abstractCoder.checkResultErrors;\n\tvar abstractCoder_2 = abstractCoder.Coder;\n\tvar abstractCoder_3 = abstractCoder.Writer;\n\tvar abstractCoder_4 = abstractCoder.Reader;\n\n\tvar sha3 = createCommonjsModule(function (module) {\n\t/**\r\n\t * [js-sha3]{@link https://github.com/emn178/js-sha3}\r\n\t *\r\n\t * @version 0.5.7\r\n\t * @author Chen, Yi-Cyuan [emn178@gmail.com]\r\n\t * @copyright Chen, Yi-Cyuan 2015-2016\r\n\t * @license MIT\r\n\t */\r\n\t/*jslint bitwise: true */\r\n\t(function () {\r\n\t  \'use strict\';\r\n\r\n\t  var root = typeof window === \'object\' ? window : {};\r\n\t  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === \'object\' && process.versions && process.versions.node;\r\n\t  if (NODE_JS) {\r\n\t    root = commonjsGlobal;\r\n\t  }\r\n\t  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && \'object\' === \'object\' && module.exports;\r\n\t  var HEX_CHARS = \'0123456789abcdef\'.split(\'\');\r\n\t  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];\r\n\t  var KECCAK_PADDING = [1, 256, 65536, 16777216];\r\n\t  var PADDING = [6, 1536, 393216, 100663296];\r\n\t  var SHIFT = [0, 8, 16, 24];\r\n\t  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,\r\n\t            0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,\r\n\t            2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,\r\n\t            2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,\r\n\t            2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];\r\n\t  var BITS = [224, 256, 384, 512];\r\n\t  var SHAKE_BITS = [128, 256];\r\n\t  var OUTPUT_TYPES = [\'hex\', \'buffer\', \'arrayBuffer\', \'array\'];\r\n\r\n\t  var createOutputMethod = function (bits, padding, outputType) {\r\n\t    return function (message) {\r\n\t      return new Keccak(bits, padding, bits).update(message)[outputType]();\r\n\t    };\r\n\t  };\r\n\r\n\t  var createShakeOutputMethod = function (bits, padding, outputType) {\r\n\t    return function (message, outputBits) {\r\n\t      return new Keccak(bits, padding, outputBits).update(message)[outputType]();\r\n\t    };\r\n\t  };\r\n\r\n\t  var createMethod = function (bits, padding) {\r\n\t    var method = createOutputMethod(bits, padding, \'hex\');\r\n\t    method.create = function () {\r\n\t      return new Keccak(bits, padding, bits);\r\n\t    };\r\n\t    method.update = function (message) {\r\n\t      return method.create().update(message);\r\n\t    };\r\n\t    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\r\n\t      var type = OUTPUT_TYPES[i];\r\n\t      method[type] = createOutputMethod(bits, padding, type);\r\n\t    }\r\n\t    return method;\r\n\t  };\r\n\r\n\t  var createShakeMethod = function (bits, padding) {\r\n\t    var method = createShakeOutputMethod(bits, padding, \'hex\');\r\n\t    method.create = function (outputBits) {\r\n\t      return new Keccak(bits, padding, outputBits);\r\n\t    };\r\n\t    method.update = function (message, outputBits) {\r\n\t      return method.create(outputBits).update(message);\r\n\t    };\r\n\t    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {\r\n\t      var type = OUTPUT_TYPES[i];\r\n\t      method[type] = createShakeOutputMethod(bits, padding, type);\r\n\t    }\r\n\t    return method;\r\n\t  };\r\n\r\n\t  var algorithms = [\r\n\t    {name: \'keccak\', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod},\r\n\t    {name: \'sha3\', padding: PADDING, bits: BITS, createMethod: createMethod},\r\n\t    {name: \'shake\', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod}\r\n\t  ];\r\n\r\n\t  var methods = {}, methodNames = [];\r\n\r\n\t  for (var i = 0; i < algorithms.length; ++i) {\r\n\t    var algorithm = algorithms[i];\r\n\t    var bits  = algorithm.bits;\r\n\t    for (var j = 0; j < bits.length; ++j) {\r\n\t      var methodName = algorithm.name +\'_\' + bits[j];\r\n\t      methodNames.push(methodName);\r\n\t      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);\r\n\t    }\r\n\t  }\r\n\r\n\t  function Keccak(bits, padding, outputBits) {\r\n\t    this.blocks = [];\r\n\t    this.s = [];\r\n\t    this.padding = padding;\r\n\t    this.outputBits = outputBits;\r\n\t    this.reset = true;\r\n\t    this.block = 0;\r\n\t    this.start = 0;\r\n\t    this.blockCount = (1600 - (bits << 1)) >> 5;\r\n\t    this.byteCount = this.blockCount << 2;\r\n\t    this.outputBlocks = outputBits >> 5;\r\n\t    this.extraBytes = (outputBits & 31) >> 3;\r\n\r\n\t    for (var i = 0; i < 50; ++i) {\r\n\t      this.s[i] = 0;\r\n\t    }\r\n\t  }\r\n\r\n\t  Keccak.prototype.update = function (message) {\r\n\t    var notString = typeof message !== \'string\';\r\n\t    if (notString && message.constructor === ArrayBuffer) {\r\n\t      message = new Uint8Array(message);\r\n\t    }\r\n\t    var length = message.length, blocks = this.blocks, byteCount = this.byteCount,\r\n\t      blockCount = this.blockCount, index = 0, s = this.s, i, code;\r\n\r\n\t    while (index < length) {\r\n\t      if (this.reset) {\r\n\t        this.reset = false;\r\n\t        blocks[0] = this.block;\r\n\t        for (i = 1; i < blockCount + 1; ++i) {\r\n\t          blocks[i] = 0;\r\n\t        }\r\n\t      }\r\n\t      if (notString) {\r\n\t        for (i = this.start; index < length && i < byteCount; ++index) {\r\n\t          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];\r\n\t        }\r\n\t      } else {\r\n\t        for (i = this.start; index < length && i < byteCount; ++index) {\r\n\t          code = message.charCodeAt(index);\r\n\t          if (code < 0x80) {\r\n\t            blocks[i >> 2] |= code << SHIFT[i++ & 3];\r\n\t          } else if (code < 0x800) {\r\n\t            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\r\n\t          } else if (code < 0xd800 || code >= 0xe000) {\r\n\t            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\r\n\t          } else {\r\n\t            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));\r\n\t            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];\r\n\t            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];\r\n\t          }\r\n\t        }\r\n\t      }\r\n\t      this.lastByteIndex = i;\r\n\t      if (i >= byteCount) {\r\n\t        this.start = i - byteCount;\r\n\t        this.block = blocks[blockCount];\r\n\t        for (i = 0; i < blockCount; ++i) {\r\n\t          s[i] ^= blocks[i];\r\n\t        }\r\n\t        f(s);\r\n\t        this.reset = true;\r\n\t      } else {\r\n\t        this.start = i;\r\n\t      }\r\n\t    }\r\n\t    return this;\r\n\t  };\r\n\r\n\t  Keccak.prototype.finalize = function () {\r\n\t    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;\r\n\t    blocks[i >> 2] |= this.padding[i & 3];\r\n\t    if (this.lastByteIndex === this.byteCount) {\r\n\t      blocks[0] = blocks[blockCount];\r\n\t      for (i = 1; i < blockCount + 1; ++i) {\r\n\t        blocks[i] = 0;\r\n\t      }\r\n\t    }\r\n\t    blocks[blockCount - 1] |= 0x80000000;\r\n\t    for (i = 0; i < blockCount; ++i) {\r\n\t      s[i] ^= blocks[i];\r\n\t    }\r\n\t    f(s);\r\n\t  };\r\n\r\n\t  Keccak.prototype.toString = Keccak.prototype.hex = function () {\r\n\t    this.finalize();\r\n\r\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\r\n\t        extraBytes = this.extraBytes, i = 0, j = 0;\r\n\t    var hex = \'\', block;\r\n\t    while (j < outputBlocks) {\r\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\r\n\t        block = s[i];\r\n\t        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +\r\n\t               HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +\r\n\t               HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +\r\n\t               HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];\r\n\t      }\r\n\t      if (j % blockCount === 0) {\r\n\t        f(s);\r\n\t        i = 0;\r\n\t      }\r\n\t    }\r\n\t    if (extraBytes) {\r\n\t      block = s[i];\r\n\t      if (extraBytes > 0) {\r\n\t        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];\r\n\t      }\r\n\t      if (extraBytes > 1) {\r\n\t        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];\r\n\t      }\r\n\t      if (extraBytes > 2) {\r\n\t        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];\r\n\t      }\r\n\t    }\r\n\t    return hex;\r\n\t  };\r\n\r\n\t  Keccak.prototype.arrayBuffer = function () {\r\n\t    this.finalize();\r\n\r\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\r\n\t        extraBytes = this.extraBytes, i = 0, j = 0;\r\n\t    var bytes = this.outputBits >> 3;\r\n\t    var buffer;\r\n\t    if (extraBytes) {\r\n\t      buffer = new ArrayBuffer((outputBlocks + 1) << 2);\r\n\t    } else {\r\n\t      buffer = new ArrayBuffer(bytes);\r\n\t    }\r\n\t    var array = new Uint32Array(buffer);\r\n\t    while (j < outputBlocks) {\r\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\r\n\t        array[j] = s[i];\r\n\t      }\r\n\t      if (j % blockCount === 0) {\r\n\t        f(s);\r\n\t      }\r\n\t    }\r\n\t    if (extraBytes) {\r\n\t      array[i] = s[i];\r\n\t      buffer = buffer.slice(0, bytes);\r\n\t    }\r\n\t    return buffer;\r\n\t  };\r\n\r\n\t  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;\r\n\r\n\t  Keccak.prototype.digest = Keccak.prototype.array = function () {\r\n\t    this.finalize();\r\n\r\n\t    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,\r\n\t        extraBytes = this.extraBytes, i = 0, j = 0;\r\n\t    var array = [], offset, block;\r\n\t    while (j < outputBlocks) {\r\n\t      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {\r\n\t        offset = j << 2;\r\n\t        block = s[i];\r\n\t        array[offset] = block & 0xFF;\r\n\t        array[offset + 1] = (block >> 8) & 0xFF;\r\n\t        array[offset + 2] = (block >> 16) & 0xFF;\r\n\t        array[offset + 3] = (block >> 24) & 0xFF;\r\n\t      }\r\n\t      if (j % blockCount === 0) {\r\n\t        f(s);\r\n\t      }\r\n\t    }\r\n\t    if (extraBytes) {\r\n\t      offset = j << 2;\r\n\t      block = s[i];\r\n\t      if (extraBytes > 0) {\r\n\t        array[offset] = block & 0xFF;\r\n\t      }\r\n\t      if (extraBytes > 1) {\r\n\t        array[offset + 1] = (block >> 8) & 0xFF;\r\n\t      }\r\n\t      if (extraBytes > 2) {\r\n\t        array[offset + 2] = (block >> 16) & 0xFF;\r\n\t      }\r\n\t    }\r\n\t    return array;\r\n\t  };\r\n\r\n\t  var f = function (s) {\r\n\t    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,\r\n\t        b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,\r\n\t        b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,\r\n\t        b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;\r\n\t    for (n = 0; n < 48; n += 2) {\r\n\t      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];\r\n\t      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];\r\n\t      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];\r\n\t      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];\r\n\t      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];\r\n\t      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];\r\n\t      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];\r\n\t      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];\r\n\t      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];\r\n\t      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];\r\n\r\n\t      h = c8 ^ ((c2 << 1) | (c3 >>> 31));\r\n\t      l = c9 ^ ((c3 << 1) | (c2 >>> 31));\r\n\t      s[0] ^= h;\r\n\t      s[1] ^= l;\r\n\t      s[10] ^= h;\r\n\t      s[11] ^= l;\r\n\t      s[20] ^= h;\r\n\t      s[21] ^= l;\r\n\t      s[30] ^= h;\r\n\t      s[31] ^= l;\r\n\t      s[40] ^= h;\r\n\t      s[41] ^= l;\r\n\t      h = c0 ^ ((c4 << 1) | (c5 >>> 31));\r\n\t      l = c1 ^ ((c5 << 1) | (c4 >>> 31));\r\n\t      s[2] ^= h;\r\n\t      s[3] ^= l;\r\n\t      s[12] ^= h;\r\n\t      s[13] ^= l;\r\n\t      s[22] ^= h;\r\n\t      s[23] ^= l;\r\n\t      s[32] ^= h;\r\n\t      s[33] ^= l;\r\n\t      s[42] ^= h;\r\n\t      s[43] ^= l;\r\n\t      h = c2 ^ ((c6 << 1) | (c7 >>> 31));\r\n\t      l = c3 ^ ((c7 << 1) | (c6 >>> 31));\r\n\t      s[4] ^= h;\r\n\t      s[5] ^= l;\r\n\t      s[14] ^= h;\r\n\t      s[15] ^= l;\r\n\t      s[24] ^= h;\r\n\t      s[25] ^= l;\r\n\t      s[34] ^= h;\r\n\t      s[35] ^= l;\r\n\t      s[44] ^= h;\r\n\t      s[45] ^= l;\r\n\t      h = c4 ^ ((c8 << 1) | (c9 >>> 31));\r\n\t      l = c5 ^ ((c9 << 1) | (c8 >>> 31));\r\n\t      s[6] ^= h;\r\n\t      s[7] ^= l;\r\n\t      s[16] ^= h;\r\n\t      s[17] ^= l;\r\n\t      s[26] ^= h;\r\n\t      s[27] ^= l;\r\n\t      s[36] ^= h;\r\n\t      s[37] ^= l;\r\n\t      s[46] ^= h;\r\n\t      s[47] ^= l;\r\n\t      h = c6 ^ ((c0 << 1) | (c1 >>> 31));\r\n\t      l = c7 ^ ((c1 << 1) | (c0 >>> 31));\r\n\t      s[8] ^= h;\r\n\t      s[9] ^= l;\r\n\t      s[18] ^= h;\r\n\t      s[19] ^= l;\r\n\t      s[28] ^= h;\r\n\t      s[29] ^= l;\r\n\t      s[38] ^= h;\r\n\t      s[39] ^= l;\r\n\t      s[48] ^= h;\r\n\t      s[49] ^= l;\r\n\r\n\t      b0 = s[0];\r\n\t      b1 = s[1];\r\n\t      b32 = (s[11] << 4) | (s[10] >>> 28);\r\n\t      b33 = (s[10] << 4) | (s[11] >>> 28);\r\n\t      b14 = (s[20] << 3) | (s[21] >>> 29);\r\n\t      b15 = (s[21] << 3) | (s[20] >>> 29);\r\n\t      b46 = (s[31] << 9) | (s[30] >>> 23);\r\n\t      b47 = (s[30] << 9) | (s[31] >>> 23);\r\n\t      b28 = (s[40] << 18) | (s[41] >>> 14);\r\n\t      b29 = (s[41] << 18) | (s[40] >>> 14);\r\n\t      b20 = (s[2] << 1) | (s[3] >>> 31);\r\n\t      b21 = (s[3] << 1) | (s[2] >>> 31);\r\n\t      b2 = (s[13] << 12) | (s[12] >>> 20);\r\n\t      b3 = (s[12] << 12) | (s[13] >>> 20);\r\n\t      b34 = (s[22] << 10) | (s[23] >>> 22);\r\n\t      b35 = (s[23] << 10) | (s[22] >>> 22);\r\n\t      b16 = (s[33] << 13) | (s[32] >>> 19);\r\n\t      b17 = (s[32] << 13) | (s[33] >>> 19);\r\n\t      b48 = (s[42] << 2) | (s[43] >>> 30);\r\n\t      b49 = (s[43] << 2) | (s[42] >>> 30);\r\n\t      b40 = (s[5] << 30) | (s[4] >>> 2);\r\n\t      b41 = (s[4] << 30) | (s[5] >>> 2);\r\n\t      b22 = (s[14] << 6) | (s[15] >>> 26);\r\n\t      b23 = (s[15] << 6) | (s[14] >>> 26);\r\n\t      b4 = (s[25] << 11) | (s[24] >>> 21);\r\n\t      b5 = (s[24] << 11) | (s[25] >>> 21);\r\n\t      b36 = (s[34] << 15) | (s[35] >>> 17);\r\n\t      b37 = (s[35] << 15) | (s[34] >>> 17);\r\n\t      b18 = (s[45] << 29) | (s[44] >>> 3);\r\n\t      b19 = (s[44] << 29) | (s[45] >>> 3);\r\n\t      b10 = (s[6] << 28) | (s[7] >>> 4);\r\n\t      b11 = (s[7] << 28) | (s[6] >>> 4);\r\n\t      b42 = (s[17] << 23) | (s[16] >>> 9);\r\n\t      b43 = (s[16] << 23) | (s[17] >>> 9);\r\n\t      b24 = (s[26] << 25) | (s[27] >>> 7);\r\n\t      b25 = (s[27] << 25) | (s[26] >>> 7);\r\n\t      b6 = (s[36] << 21) | (s[37] >>> 11);\r\n\t      b7 = (s[37] << 21) | (s[36] >>> 11);\r\n\t      b38 = (s[47] << 24) | (s[46] >>> 8);\r\n\t      b39 = (s[46] << 24) | (s[47] >>> 8);\r\n\t      b30 = (s[8] << 27) | (s[9] >>> 5);\r\n\t      b31 = (s[9] << 27) | (s[8] >>> 5);\r\n\t      b12 = (s[18] << 20) | (s[19] >>> 12);\r\n\t      b13 = (s[19] << 20) | (s[18] >>> 12);\r\n\t      b44 = (s[29] << 7) | (s[28] >>> 25);\r\n\t      b45 = (s[28] << 7) | (s[29] >>> 25);\r\n\t      b26 = (s[38] << 8) | (s[39] >>> 24);\r\n\t      b27 = (s[39] << 8) | (s[38] >>> 24);\r\n\t      b8 = (s[48] << 14) | (s[49] >>> 18);\r\n\t      b9 = (s[49] << 14) | (s[48] >>> 18);\r\n\r\n\t      s[0] = b0 ^ (~b2 & b4);\r\n\t      s[1] = b1 ^ (~b3 & b5);\r\n\t      s[10] = b10 ^ (~b12 & b14);\r\n\t      s[11] = b11 ^ (~b13 & b15);\r\n\t      s[20] = b20 ^ (~b22 & b24);\r\n\t      s[21] = b21 ^ (~b23 & b25);\r\n\t      s[30] = b30 ^ (~b32 & b34);\r\n\t      s[31] = b31 ^ (~b33 & b35);\r\n\t      s[40] = b40 ^ (~b42 & b44);\r\n\t      s[41] = b41 ^ (~b43 & b45);\r\n\t      s[2] = b2 ^ (~b4 & b6);\r\n\t      s[3] = b3 ^ (~b5 & b7);\r\n\t      s[12] = b12 ^ (~b14 & b16);\r\n\t      s[13] = b13 ^ (~b15 & b17);\r\n\t      s[22] = b22 ^ (~b24 & b26);\r\n\t      s[23] = b23 ^ (~b25 & b27);\r\n\t      s[32] = b32 ^ (~b34 & b36);\r\n\t      s[33] = b33 ^ (~b35 & b37);\r\n\t      s[42] = b42 ^ (~b44 & b46);\r\n\t      s[43] = b43 ^ (~b45 & b47);\r\n\t      s[4] = b4 ^ (~b6 & b8);\r\n\t      s[5] = b5 ^ (~b7 & b9);\r\n\t      s[14] = b14 ^ (~b16 & b18);\r\n\t      s[15] = b15 ^ (~b17 & b19);\r\n\t      s[24] = b24 ^ (~b26 & b28);\r\n\t      s[25] = b25 ^ (~b27 & b29);\r\n\t      s[34] = b34 ^ (~b36 & b38);\r\n\t      s[35] = b35 ^ (~b37 & b39);\r\n\t      s[44] = b44 ^ (~b46 & b48);\r\n\t      s[45] = b45 ^ (~b47 & b49);\r\n\t      s[6] = b6 ^ (~b8 & b0);\r\n\t      s[7] = b7 ^ (~b9 & b1);\r\n\t      s[16] = b16 ^ (~b18 & b10);\r\n\t      s[17] = b17 ^ (~b19 & b11);\r\n\t      s[26] = b26 ^ (~b28 & b20);\r\n\t      s[27] = b27 ^ (~b29 & b21);\r\n\t      s[36] = b36 ^ (~b38 & b30);\r\n\t      s[37] = b37 ^ (~b39 & b31);\r\n\t      s[46] = b46 ^ (~b48 & b40);\r\n\t      s[47] = b47 ^ (~b49 & b41);\r\n\t      s[8] = b8 ^ (~b0 & b2);\r\n\t      s[9] = b9 ^ (~b1 & b3);\r\n\t      s[18] = b18 ^ (~b10 & b12);\r\n\t      s[19] = b19 ^ (~b11 & b13);\r\n\t      s[28] = b28 ^ (~b20 & b22);\r\n\t      s[29] = b29 ^ (~b21 & b23);\r\n\t      s[38] = b38 ^ (~b30 & b32);\r\n\t      s[39] = b39 ^ (~b31 & b33);\r\n\t      s[48] = b48 ^ (~b40 & b42);\r\n\t      s[49] = b49 ^ (~b41 & b43);\r\n\r\n\t      s[0] ^= RC[n];\r\n\t      s[1] ^= RC[n + 1];\r\n\t    }\r\n\t  };\r\n\r\n\t  if (COMMON_JS) {\r\n\t    module.exports = methods;\r\n\t  } else {\r\n\t    for (var i = 0; i < methodNames.length; ++i) {\r\n\t      root[methodNames[i]] = methods[methodNames[i]];\r\n\t    }\r\n\t  }\r\n\t})();\n\t});\n\n\tvar lib$4 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { "default": mod };\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tvar js_sha3_1 = __importDefault(sha3);\n\n\tfunction keccak256(data) {\n\t    return \'0x\' + js_sha3_1.default.keccak_256(lib$1.arrayify(data));\n\t}\n\texports.keccak256 = keccak256;\n\n\t});\n\n\tvar index$4 = unwrapExports(lib$4);\n\tvar lib_1$4 = lib$4.keccak256;\n\n\tvar _version$a = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "rlp/5.0.3";\n\n\t});\n\n\tvar _version$b = unwrapExports(_version$a);\n\tvar _version_1$5 = _version$a.version;\n\n\tvar lib$5 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\t//See: https://github.com/ethereum/wiki/wiki/RLP\n\n\n\n\tvar logger = new lib.Logger(_version$a.version);\n\tfunction arrayifyInteger(value) {\n\t    var result = [];\n\t    while (value) {\n\t        result.unshift(value & 0xff);\n\t        value >>= 8;\n\t    }\n\t    return result;\n\t}\n\tfunction unarrayifyInteger(data, offset, length) {\n\t    var result = 0;\n\t    for (var i = 0; i < length; i++) {\n\t        result = (result * 256) + data[offset + i];\n\t    }\n\t    return result;\n\t}\n\tfunction _encode(object) {\n\t    if (Array.isArray(object)) {\n\t        var payload_1 = [];\n\t        object.forEach(function (child) {\n\t            payload_1 = payload_1.concat(_encode(child));\n\t        });\n\t        if (payload_1.length <= 55) {\n\t            payload_1.unshift(0xc0 + payload_1.length);\n\t            return payload_1;\n\t        }\n\t        var length_1 = arrayifyInteger(payload_1.length);\n\t        length_1.unshift(0xf7 + length_1.length);\n\t        return length_1.concat(payload_1);\n\t    }\n\t    if (!lib$1.isBytesLike(object)) {\n\t        logger.throwArgumentError("RLP object must be BytesLike", "object", object);\n\t    }\n\t    var data = Array.prototype.slice.call(lib$1.arrayify(object));\n\t    if (data.length === 1 && data[0] <= 0x7f) {\n\t        return data;\n\t    }\n\t    else if (data.length <= 55) {\n\t        data.unshift(0x80 + data.length);\n\t        return data;\n\t    }\n\t    var length = arrayifyInteger(data.length);\n\t    length.unshift(0xb7 + length.length);\n\t    return length.concat(data);\n\t}\n\tfunction encode(object) {\n\t    return lib$1.hexlify(_encode(object));\n\t}\n\texports.encode = encode;\n\tfunction _decodeChildren(data, offset, childOffset, length) {\n\t    var result = [];\n\t    while (childOffset < offset + 1 + length) {\n\t        var decoded = _decode(data, childOffset);\n\t        result.push(decoded.result);\n\t        childOffset += decoded.consumed;\n\t        if (childOffset > offset + 1 + length) {\n\t            logger.throwError("child data too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t    }\n\t    return { consumed: (1 + length), result: result };\n\t}\n\t// returns { consumed: number, result: Object }\n\tfunction _decode(data, offset) {\n\t    if (data.length === 0) {\n\t        logger.throwError("data too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t    }\n\t    // Array with extra length prefix\n\t    if (data[offset] >= 0xf8) {\n\t        var lengthLength = data[offset] - 0xf7;\n\t        if (offset + 1 + lengthLength > data.length) {\n\t            logger.throwError("data short segment too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var length_2 = unarrayifyInteger(data, offset + 1, lengthLength);\n\t        if (offset + 1 + lengthLength + length_2 > data.length) {\n\t            logger.throwError("data long segment too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length_2);\n\t    }\n\t    else if (data[offset] >= 0xc0) {\n\t        var length_3 = data[offset] - 0xc0;\n\t        if (offset + 1 + length_3 > data.length) {\n\t            logger.throwError("data array too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        return _decodeChildren(data, offset, offset + 1, length_3);\n\t    }\n\t    else if (data[offset] >= 0xb8) {\n\t        var lengthLength = data[offset] - 0xb7;\n\t        if (offset + 1 + lengthLength > data.length) {\n\t            logger.throwError("data array too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var length_4 = unarrayifyInteger(data, offset + 1, lengthLength);\n\t        if (offset + 1 + lengthLength + length_4 > data.length) {\n\t            logger.throwError("data array too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var result = lib$1.hexlify(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length_4));\n\t        return { consumed: (1 + lengthLength + length_4), result: result };\n\t    }\n\t    else if (data[offset] >= 0x80) {\n\t        var length_5 = data[offset] - 0x80;\n\t        if (offset + 1 + length_5 > data.length) {\n\t            logger.throwError("data too short", lib.Logger.errors.BUFFER_OVERRUN, {});\n\t        }\n\t        var result = lib$1.hexlify(data.slice(offset + 1, offset + 1 + length_5));\n\t        return { consumed: (1 + length_5), result: result };\n\t    }\n\t    return { consumed: 1, result: lib$1.hexlify(data[offset]) };\n\t}\n\tfunction decode(data) {\n\t    var bytes = lib$1.arrayify(data);\n\t    var decoded = _decode(bytes, 0);\n\t    if (decoded.consumed !== bytes.length) {\n\t        logger.throwArgumentError("invalid rlp data", "data", data);\n\t    }\n\t    return decoded.result;\n\t}\n\texports.decode = decode;\n\n\t});\n\n\tvar index$5 = unwrapExports(lib$5);\n\tvar lib_1$5 = lib$5.encode;\n\tvar lib_2$4 = lib$5.decode;\n\n\tvar _version$c = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "address/5.0.4";\n\n\t});\n\n\tvar _version$d = unwrapExports(_version$c);\n\tvar _version_1$6 = _version$c.version;\n\n\tvar lib$6 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\t// We use this for base 36 maths\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$c.version);\n\tfunction getChecksumAddress(address) {\n\t    if (!lib$1.isHexString(address, 20)) {\n\t        logger.throwArgumentError("invalid address", "address", address);\n\t    }\n\t    address = address.toLowerCase();\n\t    var chars = address.substring(2).split("");\n\t    var expanded = new Uint8Array(40);\n\t    for (var i = 0; i < 40; i++) {\n\t        expanded[i] = chars[i].charCodeAt(0);\n\t    }\n\t    var hashed = lib$1.arrayify(lib$4.keccak256(expanded));\n\t    for (var i = 0; i < 40; i += 2) {\n\t        if ((hashed[i >> 1] >> 4) >= 8) {\n\t            chars[i] = chars[i].toUpperCase();\n\t        }\n\t        if ((hashed[i >> 1] & 0x0f) >= 8) {\n\t            chars[i + 1] = chars[i + 1].toUpperCase();\n\t        }\n\t    }\n\t    return "0x" + chars.join("");\n\t}\n\t// Shims for environments that are missing some required constants and functions\n\tvar MAX_SAFE_INTEGER = 0x1fffffffffffff;\n\tfunction log10(x) {\n\t    if (Math.log10) {\n\t        return Math.log10(x);\n\t    }\n\t    return Math.log(x) / Math.LN10;\n\t}\n\t// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number\n\t// Create lookup table\n\tvar ibanLookup = {};\n\tfor (var i = 0; i < 10; i++) {\n\t    ibanLookup[String(i)] = String(i);\n\t}\n\tfor (var i = 0; i < 26; i++) {\n\t    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);\n\t}\n\t// How many decimal digits can we process? (for 64-bit float, this is 15)\n\tvar safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));\n\tfunction ibanChecksum(address) {\n\t    address = address.toUpperCase();\n\t    address = address.substring(4) + address.substring(0, 2) + "00";\n\t    var expanded = address.split("").map(function (c) { return ibanLookup[c]; }).join("");\n\t    // Javascript can handle integers safely up to 15 (decimal) digits\n\t    while (expanded.length >= safeDigits) {\n\t        var block = expanded.substring(0, safeDigits);\n\t        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);\n\t    }\n\t    var checksum = String(98 - (parseInt(expanded, 10) % 97));\n\t    while (checksum.length < 2) {\n\t        checksum = "0" + checksum;\n\t    }\n\t    return checksum;\n\t}\n\t;\n\tfunction getAddress(address) {\n\t    var result = null;\n\t    if (typeof (address) !== "string") {\n\t        logger.throwArgumentError("invalid address", "address", address);\n\t    }\n\t    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {\n\t        // Missing the 0x prefix\n\t        if (address.substring(0, 2) !== "0x") {\n\t            address = "0x" + address;\n\t        }\n\t        result = getChecksumAddress(address);\n\t        // It is a checksummed address with a bad checksum\n\t        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {\n\t            logger.throwArgumentError("bad address checksum", "address", address);\n\t        }\n\t        // Maybe ICAP? (we only support direct mode)\n\t    }\n\t    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {\n\t        // It is an ICAP address with a bad checksum\n\t        if (address.substring(2, 4) !== ibanChecksum(address)) {\n\t            logger.throwArgumentError("bad icap checksum", "address", address);\n\t        }\n\t        result = (new bn.BN(address.substring(4), 36)).toString(16);\n\t        while (result.length < 40) {\n\t            result = "0" + result;\n\t        }\n\t        result = getChecksumAddress("0x" + result);\n\t    }\n\t    else {\n\t        logger.throwArgumentError("invalid address", "address", address);\n\t    }\n\t    return result;\n\t}\n\texports.getAddress = getAddress;\n\tfunction isAddress(address) {\n\t    try {\n\t        getAddress(address);\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isAddress = isAddress;\n\tfunction getIcapAddress(address) {\n\t    var base36 = (new bn.BN(getAddress(address).substring(2), 16)).toString(36).toUpperCase();\n\t    while (base36.length < 30) {\n\t        base36 = "0" + base36;\n\t    }\n\t    return "XE" + ibanChecksum("XE00" + base36) + base36;\n\t}\n\texports.getIcapAddress = getIcapAddress;\n\t// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed\n\tfunction getContractAddress(transaction) {\n\t    var from = null;\n\t    try {\n\t        from = getAddress(transaction.from);\n\t    }\n\t    catch (error) {\n\t        logger.throwArgumentError("missing from address", "transaction", transaction);\n\t    }\n\t    var nonce = lib$1.stripZeros(lib$1.arrayify(lib$2.BigNumber.from(transaction.nonce).toHexString()));\n\t    return getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$5.encode([from, nonce])), 12));\n\t}\n\texports.getContractAddress = getContractAddress;\n\tfunction getCreate2Address(from, salt, initCodeHash) {\n\t    if (lib$1.hexDataLength(salt) !== 32) {\n\t        logger.throwArgumentError("salt must be 32 bytes", "salt", salt);\n\t    }\n\t    if (lib$1.hexDataLength(initCodeHash) !== 32) {\n\t        logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);\n\t    }\n\t    return getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$1.concat(["0xff", getAddress(from), salt, initCodeHash])), 12));\n\t}\n\texports.getCreate2Address = getCreate2Address;\n\n\t});\n\n\tvar index$6 = unwrapExports(lib$6);\n\tvar lib_1$6 = lib$6.getAddress;\n\tvar lib_2$5 = lib$6.isAddress;\n\tvar lib_3$4 = lib$6.getIcapAddress;\n\tvar lib_4$3 = lib$6.getContractAddress;\n\tvar lib_5$3 = lib$6.getCreate2Address;\n\n\tvar address = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar AddressCoder = /** @class */ (function (_super) {\n\t    __extends(AddressCoder, _super);\n\t    function AddressCoder(localName) {\n\t        return _super.call(this, "address", "address", localName, false) || this;\n\t    }\n\t    AddressCoder.prototype.encode = function (writer, value) {\n\t        try {\n\t            lib$6.getAddress(value);\n\t        }\n\t        catch (error) {\n\t            this._throwError(error.message, value);\n\t        }\n\t        return writer.writeValue(value);\n\t    };\n\t    AddressCoder.prototype.decode = function (reader) {\n\t        return lib$6.getAddress(lib$1.hexZeroPad(reader.readValue().toHexString(), 20));\n\t    };\n\t    return AddressCoder;\n\t}(abstractCoder.Coder));\n\texports.AddressCoder = AddressCoder;\n\n\t});\n\n\tvar address$1 = unwrapExports(address);\n\tvar address_2 = address.AddressCoder;\n\n\tvar anonymous = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\t// Clones the functionality of an existing Coder, but without a localName\n\tvar AnonymousCoder = /** @class */ (function (_super) {\n\t    __extends(AnonymousCoder, _super);\n\t    function AnonymousCoder(coder) {\n\t        var _this = _super.call(this, coder.name, coder.type, undefined, coder.dynamic) || this;\n\t        _this.coder = coder;\n\t        return _this;\n\t    }\n\t    AnonymousCoder.prototype.encode = function (writer, value) {\n\t        return this.coder.encode(writer, value);\n\t    };\n\t    AnonymousCoder.prototype.decode = function (reader) {\n\t        return this.coder.decode(reader);\n\t    };\n\t    return AnonymousCoder;\n\t}(abstractCoder.Coder));\n\texports.AnonymousCoder = AnonymousCoder;\n\n\t});\n\n\tvar anonymous$1 = unwrapExports(anonymous);\n\tvar anonymous_1 = anonymous.AnonymousCoder;\n\n\tvar array = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\n\n\tfunction pack(writer, coders, values) {\n\t    var arrayValues = null;\n\t    if (Array.isArray(values)) {\n\t        arrayValues = values;\n\t    }\n\t    else if (values && typeof (values) === "object") {\n\t        var unique_1 = {};\n\t        arrayValues = coders.map(function (coder) {\n\t            var name = coder.localName;\n\t            if (!name) {\n\t                logger.throwError("cannot encode object for signature with missing names", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: "values",\n\t                    coder: coder,\n\t                    value: values\n\t                });\n\t            }\n\t            if (unique_1[name]) {\n\t                logger.throwError("cannot encode object for signature with duplicate names", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: "values",\n\t                    coder: coder,\n\t                    value: values\n\t                });\n\t            }\n\t            unique_1[name] = true;\n\t            return values[name];\n\t        });\n\t    }\n\t    else {\n\t        logger.throwArgumentError("invalid tuple value", "tuple", values);\n\t    }\n\t    if (coders.length !== arrayValues.length) {\n\t        logger.throwArgumentError("types/value length mismatch", "tuple", values);\n\t    }\n\t    var staticWriter = new abstractCoder.Writer(writer.wordSize);\n\t    var dynamicWriter = new abstractCoder.Writer(writer.wordSize);\n\t    var updateFuncs = [];\n\t    coders.forEach(function (coder, index) {\n\t        var value = arrayValues[index];\n\t        if (coder.dynamic) {\n\t            // Get current dynamic offset (for the future pointer)\n\t            var dynamicOffset_1 = dynamicWriter.length;\n\t            // Encode the dynamic value into the dynamicWriter\n\t            coder.encode(dynamicWriter, value);\n\t            // Prepare to populate the correct offset once we are done\n\t            var updateFunc_1 = staticWriter.writeUpdatableValue();\n\t            updateFuncs.push(function (baseOffset) {\n\t                updateFunc_1(baseOffset + dynamicOffset_1);\n\t            });\n\t        }\n\t        else {\n\t            coder.encode(staticWriter, value);\n\t        }\n\t    });\n\t    // Backfill all the dynamic offsets, now that we know the static length\n\t    updateFuncs.forEach(function (func) { func(staticWriter.length); });\n\t    var length = writer.writeBytes(staticWriter.data);\n\t    length += writer.writeBytes(dynamicWriter.data);\n\t    return length;\n\t}\n\texports.pack = pack;\n\tfunction unpack(reader, coders) {\n\t    var values = [];\n\t    // A reader anchored to this base\n\t    var baseReader = reader.subReader(0);\n\t    coders.forEach(function (coder) {\n\t        var value = null;\n\t        if (coder.dynamic) {\n\t            var offset = reader.readValue();\n\t            var offsetReader = baseReader.subReader(offset.toNumber());\n\t            try {\n\t                value = coder.decode(offsetReader);\n\t            }\n\t            catch (error) {\n\t                // Cannot recover from this\n\t                if (error.code === lib.Logger.errors.BUFFER_OVERRUN) {\n\t                    throw error;\n\t                }\n\t                value = error;\n\t                value.baseType = coder.name;\n\t                value.name = coder.localName;\n\t                value.type = coder.type;\n\t            }\n\t        }\n\t        else {\n\t            try {\n\t                value = coder.decode(reader);\n\t            }\n\t            catch (error) {\n\t                // Cannot recover from this\n\t                if (error.code === lib.Logger.errors.BUFFER_OVERRUN) {\n\t                    throw error;\n\t                }\n\t                value = error;\n\t                value.baseType = coder.name;\n\t                value.name = coder.localName;\n\t                value.type = coder.type;\n\t            }\n\t        }\n\t        if (value != undefined) {\n\t            values.push(value);\n\t        }\n\t    });\n\t    // We only output named properties for uniquely named coders\n\t    var uniqueNames = coders.reduce(function (accum, coder) {\n\t        var name = coder.localName;\n\t        if (name) {\n\t            if (!accum[name]) {\n\t                accum[name] = 0;\n\t            }\n\t            accum[name]++;\n\t        }\n\t        return accum;\n\t    }, {});\n\t    // Add any named parameters (i.e. tuples)\n\t    coders.forEach(function (coder, index) {\n\t        var name = coder.localName;\n\t        if (!name || uniqueNames[name] !== 1) {\n\t            return;\n\t        }\n\t        if (name === "length") {\n\t            name = "_length";\n\t        }\n\t        if (values[name] != null) {\n\t            return;\n\t        }\n\t        var value = values[index];\n\t        if (value instanceof Error) {\n\t            Object.defineProperty(values, name, {\n\t                get: function () { throw value; }\n\t            });\n\t        }\n\t        else {\n\t            values[name] = value;\n\t        }\n\t    });\n\t    var _loop_1 = function (i) {\n\t        var value = values[i];\n\t        if (value instanceof Error) {\n\t            Object.defineProperty(values, i, {\n\t                get: function () { throw value; }\n\t            });\n\t        }\n\t    };\n\t    for (var i = 0; i < values.length; i++) {\n\t        _loop_1(i);\n\t    }\n\t    return Object.freeze(values);\n\t}\n\texports.unpack = unpack;\n\tvar ArrayCoder = /** @class */ (function (_super) {\n\t    __extends(ArrayCoder, _super);\n\t    function ArrayCoder(coder, length, localName) {\n\t        var _this = this;\n\t        var type = (coder.type + "[" + (length >= 0 ? length : "") + "]");\n\t        var dynamic = (length === -1 || coder.dynamic);\n\t        _this = _super.call(this, "array", type, localName, dynamic) || this;\n\t        _this.coder = coder;\n\t        _this.length = length;\n\t        return _this;\n\t    }\n\t    ArrayCoder.prototype.encode = function (writer, value) {\n\t        if (!Array.isArray(value)) {\n\t            this._throwError("expected array value", value);\n\t        }\n\t        var count = this.length;\n\t        if (count === -1) {\n\t            count = value.length;\n\t            writer.writeValue(value.length);\n\t        }\n\t        logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));\n\t        var coders = [];\n\t        for (var i = 0; i < value.length; i++) {\n\t            coders.push(this.coder);\n\t        }\n\t        return pack(writer, coders, value);\n\t    };\n\t    ArrayCoder.prototype.decode = function (reader) {\n\t        var count = this.length;\n\t        if (count === -1) {\n\t            count = reader.readValue().toNumber();\n\t        }\n\t        var coders = [];\n\t        for (var i = 0; i < count; i++) {\n\t            coders.push(new anonymous.AnonymousCoder(this.coder));\n\t        }\n\t        return reader.coerce(this.name, unpack(reader, coders));\n\t    };\n\t    return ArrayCoder;\n\t}(abstractCoder.Coder));\n\texports.ArrayCoder = ArrayCoder;\n\n\t});\n\n\tvar array$1 = unwrapExports(array);\n\tvar array_1 = array.pack;\n\tvar array_2 = array.unpack;\n\tvar array_3 = array.ArrayCoder;\n\n\tvar boolean_1 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tvar BooleanCoder = /** @class */ (function (_super) {\n\t    __extends(BooleanCoder, _super);\n\t    function BooleanCoder(localName) {\n\t        return _super.call(this, "bool", "bool", localName, false) || this;\n\t    }\n\t    BooleanCoder.prototype.encode = function (writer, value) {\n\t        return writer.writeValue(value ? 1 : 0);\n\t    };\n\t    BooleanCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.type, !reader.readValue().isZero());\n\t    };\n\t    return BooleanCoder;\n\t}(abstractCoder.Coder));\n\texports.BooleanCoder = BooleanCoder;\n\n\t});\n\n\tvar boolean = unwrapExports(boolean_1);\n\tvar boolean_2 = boolean_1.BooleanCoder;\n\n\tvar bytes = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar DynamicBytesCoder = /** @class */ (function (_super) {\n\t    __extends(DynamicBytesCoder, _super);\n\t    function DynamicBytesCoder(type, localName) {\n\t        return _super.call(this, type, type, localName, true) || this;\n\t    }\n\t    DynamicBytesCoder.prototype.encode = function (writer, value) {\n\t        value = lib$1.arrayify(value);\n\t        var length = writer.writeValue(value.length);\n\t        length += writer.writeBytes(value);\n\t        return length;\n\t    };\n\t    DynamicBytesCoder.prototype.decode = function (reader) {\n\t        return reader.readBytes(reader.readValue().toNumber(), true);\n\t    };\n\t    return DynamicBytesCoder;\n\t}(abstractCoder.Coder));\n\texports.DynamicBytesCoder = DynamicBytesCoder;\n\tvar BytesCoder = /** @class */ (function (_super) {\n\t    __extends(BytesCoder, _super);\n\t    function BytesCoder(localName) {\n\t        return _super.call(this, "bytes", localName) || this;\n\t    }\n\t    BytesCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, lib$1.hexlify(_super.prototype.decode.call(this, reader)));\n\t    };\n\t    return BytesCoder;\n\t}(DynamicBytesCoder));\n\texports.BytesCoder = BytesCoder;\n\n\t});\n\n\tvar bytes$1 = unwrapExports(bytes);\n\tvar bytes_2 = bytes.DynamicBytesCoder;\n\tvar bytes_3 = bytes.BytesCoder;\n\n\tvar fixedBytes = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\t// @TODO: Merge this with bytes\n\tvar FixedBytesCoder = /** @class */ (function (_super) {\n\t    __extends(FixedBytesCoder, _super);\n\t    function FixedBytesCoder(size, localName) {\n\t        var _this = this;\n\t        var name = "bytes" + String(size);\n\t        _this = _super.call(this, name, name, localName, false) || this;\n\t        _this.size = size;\n\t        return _this;\n\t    }\n\t    FixedBytesCoder.prototype.encode = function (writer, value) {\n\t        var data = lib$1.arrayify(value);\n\t        if (data.length !== this.size) {\n\t            this._throwError("incorrect data length", value);\n\t        }\n\t        return writer.writeBytes(data);\n\t    };\n\t    FixedBytesCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, lib$1.hexlify(reader.readBytes(this.size)));\n\t    };\n\t    return FixedBytesCoder;\n\t}(abstractCoder.Coder));\n\texports.FixedBytesCoder = FixedBytesCoder;\n\n\t});\n\n\tvar fixedBytes$1 = unwrapExports(fixedBytes);\n\tvar fixedBytes_1 = fixedBytes.FixedBytesCoder;\n\n\tvar _null = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tvar NullCoder = /** @class */ (function (_super) {\n\t    __extends(NullCoder, _super);\n\t    function NullCoder(localName) {\n\t        return _super.call(this, "null", "", localName, false) || this;\n\t    }\n\t    NullCoder.prototype.encode = function (writer, value) {\n\t        if (value != null) {\n\t            this._throwError("not null", value);\n\t        }\n\t        return writer.writeBytes([]);\n\t    };\n\t    NullCoder.prototype.decode = function (reader) {\n\t        reader.readBytes(0);\n\t        return reader.coerce(this.name, null);\n\t    };\n\t    return NullCoder;\n\t}(abstractCoder.Coder));\n\texports.NullCoder = NullCoder;\n\n\t});\n\n\tvar _null$1 = unwrapExports(_null);\n\tvar _null_1 = _null.NullCoder;\n\n\tvar lib$7 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tvar AddressZero = "0x0000000000000000000000000000000000000000";\n\texports.AddressZero = AddressZero;\n\tvar HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";\n\texports.HashZero = HashZero;\n\t// NFKC (composed)             // (decomposed)\n\tvar EtherSymbol = "\\u039e"; // "\\uD835\\uDF63";\n\texports.EtherSymbol = EtherSymbol;\n\tvar NegativeOne = lib$2.BigNumber.from(-1);\n\texports.NegativeOne = NegativeOne;\n\tvar Zero = lib$2.BigNumber.from(0);\n\texports.Zero = Zero;\n\tvar One = lib$2.BigNumber.from(1);\n\texports.One = One;\n\tvar Two = lib$2.BigNumber.from(2);\n\texports.Two = Two;\n\tvar WeiPerEther = lib$2.BigNumber.from("1000000000000000000");\n\texports.WeiPerEther = WeiPerEther;\n\tvar MaxUint256 = lib$2.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");\n\texports.MaxUint256 = MaxUint256;\n\n\t});\n\n\tvar index$7 = unwrapExports(lib$7);\n\tvar lib_1$7 = lib$7.AddressZero;\n\tvar lib_2$6 = lib$7.HashZero;\n\tvar lib_3$5 = lib$7.EtherSymbol;\n\tvar lib_4$4 = lib$7.NegativeOne;\n\tvar lib_5$4 = lib$7.Zero;\n\tvar lib_6$2 = lib$7.One;\n\tvar lib_7$2 = lib$7.Two;\n\tvar lib_8$1 = lib$7.WeiPerEther;\n\tvar lib_9$1 = lib$7.MaxUint256;\n\n\tvar number = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar NumberCoder = /** @class */ (function (_super) {\n\t    __extends(NumberCoder, _super);\n\t    function NumberCoder(size, signed, localName) {\n\t        var _this = this;\n\t        var name = ((signed ? "int" : "uint") + (size * 8));\n\t        _this = _super.call(this, name, name, localName, false) || this;\n\t        _this.size = size;\n\t        _this.signed = signed;\n\t        return _this;\n\t    }\n\t    NumberCoder.prototype.encode = function (writer, value) {\n\t        var v = lib$2.BigNumber.from(value);\n\t        // Check bounds are safe for encoding\n\t        var maxUintValue = lib$7.MaxUint256.mask(writer.wordSize * 8);\n\t        if (this.signed) {\n\t            var bounds = maxUintValue.mask(this.size * 8 - 1);\n\t            if (v.gt(bounds) || v.lt(bounds.add(lib$7.One).mul(lib$7.NegativeOne))) {\n\t                this._throwError("value out-of-bounds", value);\n\t            }\n\t        }\n\t        else if (v.lt(lib$7.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n\t            this._throwError("value out-of-bounds", value);\n\t        }\n\t        v = v.toTwos(this.size * 8).mask(this.size * 8);\n\t        if (this.signed) {\n\t            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n\t        }\n\t        return writer.writeValue(v);\n\t    };\n\t    NumberCoder.prototype.decode = function (reader) {\n\t        var value = reader.readValue().mask(this.size * 8);\n\t        if (this.signed) {\n\t            value = value.fromTwos(this.size * 8);\n\t        }\n\t        return reader.coerce(this.name, value);\n\t    };\n\t    return NumberCoder;\n\t}(abstractCoder.Coder));\n\texports.NumberCoder = NumberCoder;\n\n\t});\n\n\tvar number$1 = unwrapExports(number);\n\tvar number_1 = number.NumberCoder;\n\n\tvar _version$e = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "strings/5.0.4";\n\n\t});\n\n\tvar _version$f = unwrapExports(_version$e);\n\tvar _version_1$7 = _version$e.version;\n\n\tvar utf8 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$e.version);\n\t///////////////////////////////\n\tvar UnicodeNormalizationForm;\n\t(function (UnicodeNormalizationForm) {\n\t    UnicodeNormalizationForm["current"] = "";\n\t    UnicodeNormalizationForm["NFC"] = "NFC";\n\t    UnicodeNormalizationForm["NFD"] = "NFD";\n\t    UnicodeNormalizationForm["NFKC"] = "NFKC";\n\t    UnicodeNormalizationForm["NFKD"] = "NFKD";\n\t})(UnicodeNormalizationForm = exports.UnicodeNormalizationForm || (exports.UnicodeNormalizationForm = {}));\n\t;\n\tvar Utf8ErrorReason;\n\t(function (Utf8ErrorReason) {\n\t    // A continuation byte was present where there was nothing to continue\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";\n\t    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";\n\t    // The string is too short to process the expected codepoint\n\t    // - offset = the index the codepoint began in\n\t    Utf8ErrorReason["OVERRUN"] = "string overrun";\n\t    // A missing continuation byte was expected but not found\n\t    // - offset = the index the continuation byte was expected at\n\t    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";\n\t    // The computed code point is outside the range for UTF-8\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n\t    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";\n\t    // UTF-8 strings may not contain UTF-16 surrogate pairs\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n\t    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";\n\t    // The string is an overlong reperesentation\n\t    // - offset       = start of this codepoint\n\t    // - badCodepoint = the computed codepoint; already bounds checked\n\t    Utf8ErrorReason["OVERLONG"] = "overlong representation";\n\t})(Utf8ErrorReason = exports.Utf8ErrorReason || (exports.Utf8ErrorReason = {}));\n\t;\n\tfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n\t    return logger.throwArgumentError("invalid codepoint at offset " + offset + "; " + reason, "bytes", bytes);\n\t}\n\tfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n\t    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n\t    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n\t        var i = 0;\n\t        for (var o = offset + 1; o < bytes.length; o++) {\n\t            if (bytes[o] >> 6 !== 0x02) {\n\t                break;\n\t            }\n\t            i++;\n\t        }\n\t        return i;\n\t    }\n\t    // This byte runs us past the end of the string, so just jump to the end\n\t    // (but the first byte was read already read and therefore skipped)\n\t    if (reason === Utf8ErrorReason.OVERRUN) {\n\t        return bytes.length - offset - 1;\n\t    }\n\t    // Nothing to skip\n\t    return 0;\n\t}\n\tfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n\t    // Overlong representations are otherwise "valid" code points; just non-deistingtished\n\t    if (reason === Utf8ErrorReason.OVERLONG) {\n\t        output.push(badCodepoint);\n\t        return 0;\n\t    }\n\t    // Put the replacement character into the output\n\t    output.push(0xfffd);\n\t    // Otherwise, process as if ignoring errors\n\t    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n\t}\n\t// Common error handing strategies\n\texports.Utf8ErrorFuncs = Object.freeze({\n\t    error: errorFunc,\n\t    ignore: ignoreFunc,\n\t    replace: replaceFunc\n\t});\n\t// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\n\tfunction getUtf8CodePoints(bytes, onError) {\n\t    if (onError == null) {\n\t        onError = exports.Utf8ErrorFuncs.error;\n\t    }\n\t    bytes = lib$1.arrayify(bytes);\n\t    var result = [];\n\t    var i = 0;\n\t    // Invalid bytes are ignored\n\t    while (i < bytes.length) {\n\t        var c = bytes[i++];\n\t        // 0xxx xxxx\n\t        if (c >> 7 === 0) {\n\t            result.push(c);\n\t            continue;\n\t        }\n\t        // Multibyte; how many bytes left for this character?\n\t        var extraLength = null;\n\t        var overlongMask = null;\n\t        // 110x xxxx 10xx xxxx\n\t        if ((c & 0xe0) === 0xc0) {\n\t            extraLength = 1;\n\t            overlongMask = 0x7f;\n\t            // 1110 xxxx 10xx xxxx 10xx xxxx\n\t        }\n\t        else if ((c & 0xf0) === 0xe0) {\n\t            extraLength = 2;\n\t            overlongMask = 0x7ff;\n\t            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n\t        }\n\t        else if ((c & 0xf8) === 0xf0) {\n\t            extraLength = 3;\n\t            overlongMask = 0xffff;\n\t        }\n\t        else {\n\t            if ((c & 0xc0) === 0x80) {\n\t                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n\t            }\n\t            else {\n\t                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n\t            }\n\t            continue;\n\t        }\n\t        // Do we have enough bytes in our data?\n\t        if (i - 1 + extraLength >= bytes.length) {\n\t            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n\t            continue;\n\t        }\n\t        // Remove the length prefix from the char\n\t        var res = c & ((1 << (8 - extraLength - 1)) - 1);\n\t        for (var j = 0; j < extraLength; j++) {\n\t            var nextChar = bytes[i];\n\t            // Invalid continuation byte\n\t            if ((nextChar & 0xc0) != 0x80) {\n\t                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n\t                res = null;\n\t                break;\n\t            }\n\t            ;\n\t            res = (res << 6) | (nextChar & 0x3f);\n\t            i++;\n\t        }\n\t        // See above loop for invalid contimuation byte\n\t        if (res === null) {\n\t            continue;\n\t        }\n\t        // Maximum code point\n\t        if (res > 0x10ffff) {\n\t            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        // Reserved for UTF-16 surrogate halves\n\t        if (res >= 0xd800 && res <= 0xdfff) {\n\t            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        // Check for overlong sequences (more bytes than needed)\n\t        if (res <= overlongMask) {\n\t            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n\t            continue;\n\t        }\n\t        result.push(res);\n\t    }\n\t    return result;\n\t}\n\t// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\n\tfunction toUtf8Bytes(str, form) {\n\t    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n\t    if (form != UnicodeNormalizationForm.current) {\n\t        logger.checkNormalize();\n\t        str = str.normalize(form);\n\t    }\n\t    var result = [];\n\t    for (var i = 0; i < str.length; i++) {\n\t        var c = str.charCodeAt(i);\n\t        if (c < 0x80) {\n\t            result.push(c);\n\t        }\n\t        else if (c < 0x800) {\n\t            result.push((c >> 6) | 0xc0);\n\t            result.push((c & 0x3f) | 0x80);\n\t        }\n\t        else if ((c & 0xfc00) == 0xd800) {\n\t            i++;\n\t            var c2 = str.charCodeAt(i);\n\t            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n\t                throw new Error("invalid utf-8 string");\n\t            }\n\t            // Surrogate Pair\n\t            var pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n\t            result.push((pair >> 18) | 0xf0);\n\t            result.push(((pair >> 12) & 0x3f) | 0x80);\n\t            result.push(((pair >> 6) & 0x3f) | 0x80);\n\t            result.push((pair & 0x3f) | 0x80);\n\t        }\n\t        else {\n\t            result.push((c >> 12) | 0xe0);\n\t            result.push(((c >> 6) & 0x3f) | 0x80);\n\t            result.push((c & 0x3f) | 0x80);\n\t        }\n\t    }\n\t    return lib$1.arrayify(result);\n\t}\n\texports.toUtf8Bytes = toUtf8Bytes;\n\t;\n\tfunction escapeChar(value) {\n\t    var hex = ("0000" + value.toString(16));\n\t    return "\\\\u" + hex.substring(hex.length - 4);\n\t}\n\tfunction _toEscapedUtf8String(bytes, onError) {\n\t    return \'"\' + getUtf8CodePoints(bytes, onError).map(function (codePoint) {\n\t        if (codePoint < 256) {\n\t            switch (codePoint) {\n\t                case 8: return "\\\\b";\n\t                case 9: return "\\\\t";\n\t                case 10: return "\\\\n";\n\t                case 13: return "\\\\r";\n\t                case 34: return "\\\\\\"";\n\t                case 92: return "\\\\\\\\";\n\t            }\n\t            if (codePoint >= 32 && codePoint < 127) {\n\t                return String.fromCharCode(codePoint);\n\t            }\n\t        }\n\t        if (codePoint <= 0xffff) {\n\t            return escapeChar(codePoint);\n\t        }\n\t        codePoint -= 0x10000;\n\t        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n\t    }).join("") + \'"\';\n\t}\n\texports._toEscapedUtf8String = _toEscapedUtf8String;\n\tfunction _toUtf8String(codePoints) {\n\t    return codePoints.map(function (codePoint) {\n\t        if (codePoint <= 0xffff) {\n\t            return String.fromCharCode(codePoint);\n\t        }\n\t        codePoint -= 0x10000;\n\t        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n\t    }).join("");\n\t}\n\texports._toUtf8String = _toUtf8String;\n\tfunction toUtf8String(bytes, onError) {\n\t    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n\t}\n\texports.toUtf8String = toUtf8String;\n\tfunction toUtf8CodePoints(str, form) {\n\t    if (form === void 0) { form = UnicodeNormalizationForm.current; }\n\t    return getUtf8CodePoints(toUtf8Bytes(str, form));\n\t}\n\texports.toUtf8CodePoints = toUtf8CodePoints;\n\n\t});\n\n\tvar utf8$1 = unwrapExports(utf8);\n\tvar utf8_1 = utf8.UnicodeNormalizationForm;\n\tvar utf8_2 = utf8.Utf8ErrorReason;\n\tvar utf8_3 = utf8.Utf8ErrorFuncs;\n\tvar utf8_4 = utf8.toUtf8Bytes;\n\tvar utf8_5 = utf8._toEscapedUtf8String;\n\tvar utf8_6 = utf8._toUtf8String;\n\tvar utf8_7 = utf8.toUtf8String;\n\tvar utf8_8 = utf8.toUtf8CodePoints;\n\n\tvar bytes32 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tfunction formatBytes32String(text) {\n\t    // Get the bytes\n\t    var bytes = utf8.toUtf8Bytes(text);\n\t    // Check we have room for null-termination\n\t    if (bytes.length > 31) {\n\t        throw new Error("bytes32 string must be less than 32 bytes");\n\t    }\n\t    // Zero-pad (implicitly null-terminates)\n\t    return lib$1.hexlify(lib$1.concat([bytes, lib$7.HashZero]).slice(0, 32));\n\t}\n\texports.formatBytes32String = formatBytes32String;\n\tfunction parseBytes32String(bytes) {\n\t    var data = lib$1.arrayify(bytes);\n\t    // Must be 32 bytes with a null-termination\n\t    if (data.length !== 32) {\n\t        throw new Error("invalid bytes32 - not 32 bytes long");\n\t    }\n\t    if (data[31] !== 0) {\n\t        throw new Error("invalid bytes32 string - no null terminator");\n\t    }\n\t    // Find the null termination\n\t    var length = 31;\n\t    while (data[length - 1] === 0) {\n\t        length--;\n\t    }\n\t    // Determine the string value\n\t    return utf8.toUtf8String(data.slice(0, length));\n\t}\n\texports.parseBytes32String = parseBytes32String;\n\n\t});\n\n\tvar bytes32$1 = unwrapExports(bytes32);\n\tvar bytes32_1 = bytes32.formatBytes32String;\n\tvar bytes32_2 = bytes32.parseBytes32String;\n\n\tvar idna = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tfunction bytes2(data) {\n\t    if ((data.length % 4) !== 0) {\n\t        throw new Error("bad data");\n\t    }\n\t    var result = [];\n\t    for (var i = 0; i < data.length; i += 4) {\n\t        result.push(parseInt(data.substring(i, i + 4), 16));\n\t    }\n\t    return result;\n\t}\n\tfunction createTable(data, func) {\n\t    if (!func) {\n\t        func = function (value) { return [parseInt(value, 16)]; };\n\t    }\n\t    var lo = 0;\n\t    var result = {};\n\t    data.split(",").forEach(function (pair) {\n\t        var comps = pair.split(":");\n\t        lo += parseInt(comps[0], 16);\n\t        result[lo] = func(comps[1]);\n\t    });\n\t    return result;\n\t}\n\tfunction createRangeTable(data) {\n\t    var hi = 0;\n\t    return data.split(",").map(function (v) {\n\t        var comps = v.split("-");\n\t        if (comps.length === 1) {\n\t            comps[1] = "0";\n\t        }\n\t        else if (comps[1] === "") {\n\t            comps[1] = "1";\n\t        }\n\t        var lo = hi + parseInt(comps[0], 16);\n\t        hi = parseInt(comps[1], 16);\n\t        return { l: lo, h: hi };\n\t    });\n\t}\n\tfunction matchMap(value, ranges) {\n\t    var lo = 0;\n\t    for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        lo += range.l;\n\t        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {\n\t            if (range.e && range.e.indexOf(value - lo) !== -1) {\n\t                continue;\n\t            }\n\t            return range;\n\t        }\n\t    }\n\t    return null;\n\t}\n\tvar Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");\n\t// @TODO: Make this relative...\n\tvar Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(function (v) { return parseInt(v, 16); });\n\tvar Table_B_2_ranges = [\n\t    { h: 25, s: 32, l: 65 },\n\t    { h: 30, s: 32, e: [23], l: 127 },\n\t    { h: 54, s: 1, e: [48], l: 64, d: 2 },\n\t    { h: 14, s: 1, l: 57, d: 2 },\n\t    { h: 44, s: 1, l: 17, d: 2 },\n\t    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },\n\t    { h: 16, s: 1, l: 68, d: 2 },\n\t    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },\n\t    { h: 26, s: 32, e: [17], l: 435 },\n\t    { h: 22, s: 1, l: 71, d: 2 },\n\t    { h: 15, s: 80, l: 40 },\n\t    { h: 31, s: 32, l: 16 },\n\t    { h: 32, s: 1, l: 80, d: 2 },\n\t    { h: 52, s: 1, l: 42, d: 2 },\n\t    { h: 12, s: 1, l: 55, d: 2 },\n\t    { h: 40, s: 1, e: [38], l: 15, d: 2 },\n\t    { h: 14, s: 1, l: 48, d: 2 },\n\t    { h: 37, s: 48, l: 49 },\n\t    { h: 148, s: 1, l: 6351, d: 2 },\n\t    { h: 88, s: 1, l: 160, d: 2 },\n\t    { h: 15, s: 16, l: 704 },\n\t    { h: 25, s: 26, l: 854 },\n\t    { h: 25, s: 32, l: 55915 },\n\t    { h: 37, s: 40, l: 1247 },\n\t    { h: 25, s: -119711, l: 53248 },\n\t    { h: 25, s: -119763, l: 52 },\n\t    { h: 25, s: -119815, l: 52 },\n\t    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },\n\t    { h: 25, s: -119919, l: 52 },\n\t    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },\n\t    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },\n\t    { h: 25, s: -120075, l: 52 },\n\t    { h: 25, s: -120127, l: 52 },\n\t    { h: 25, s: -120179, l: 52 },\n\t    { h: 25, s: -120231, l: 52 },\n\t    { h: 25, s: -120283, l: 52 },\n\t    { h: 25, s: -120335, l: 52 },\n\t    { h: 24, s: -119543, e: [17], l: 56 },\n\t    { h: 24, s: -119601, e: [17], l: 58 },\n\t    { h: 24, s: -119659, e: [17], l: 58 },\n\t    { h: 24, s: -119717, e: [17], l: 58 },\n\t    { h: 24, s: -119775, e: [17], l: 58 }\n\t];\n\tvar Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");\n\tvar Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");\n\tvar Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);\n\tvar Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");\n\tfunction flatten(values) {\n\t    return values.reduce(function (accum, value) {\n\t        value.forEach(function (value) { accum.push(value); });\n\t        return accum;\n\t    }, []);\n\t}\n\tfunction _nameprepTableA1(codepoint) {\n\t    return !!matchMap(codepoint, Table_A_1_ranges);\n\t}\n\texports._nameprepTableA1 = _nameprepTableA1;\n\tfunction _nameprepTableB2(codepoint) {\n\t    var range = matchMap(codepoint, Table_B_2_ranges);\n\t    if (range) {\n\t        return [codepoint + range.s];\n\t    }\n\t    var codes = Table_B_2_lut_abs[codepoint];\n\t    if (codes) {\n\t        return codes;\n\t    }\n\t    var shift = Table_B_2_lut_rel[codepoint];\n\t    if (shift) {\n\t        return [codepoint + shift[0]];\n\t    }\n\t    var complex = Table_B_2_complex[codepoint];\n\t    if (complex) {\n\t        return complex;\n\t    }\n\t    return null;\n\t}\n\texports._nameprepTableB2 = _nameprepTableB2;\n\tfunction _nameprepTableC(codepoint) {\n\t    return !!matchMap(codepoint, Table_C_ranges);\n\t}\n\texports._nameprepTableC = _nameprepTableC;\n\tfunction nameprep(value) {\n\t    // This allows platforms with incomplete normalize to bypass\n\t    // it for very basic names which the built-in toLowerCase\n\t    // will certainly handle correctly\n\t    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {\n\t        return value.toLowerCase();\n\t    }\n\t    // Get the code points (keeping the current normalization)\n\t    var codes = utf8.toUtf8CodePoints(value);\n\t    codes = flatten(codes.map(function (code) {\n\t        // Substitute Table B.1 (Maps to Nothing)\n\t        if (Table_B_1_flags.indexOf(code) >= 0) {\n\t            return [];\n\t        }\n\t        if (code >= 0xfe00 && code <= 0xfe0f) {\n\t            return [];\n\t        }\n\t        // Substitute Table B.2 (Case Folding)\n\t        var codesTableB2 = _nameprepTableB2(code);\n\t        if (codesTableB2) {\n\t            return codesTableB2;\n\t        }\n\t        // No Substitution\n\t        return [code];\n\t    }));\n\t    // Normalize using form KC\n\t    codes = utf8.toUtf8CodePoints(utf8._toUtf8String(codes), utf8.UnicodeNormalizationForm.NFKC);\n\t    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9\n\t    codes.forEach(function (code) {\n\t        if (_nameprepTableC(code)) {\n\t            throw new Error("STRINGPREP_CONTAINS_PROHIBITED");\n\t        }\n\t    });\n\t    // Prohibit Unassigned Code Points (Table A.1)\n\t    codes.forEach(function (code) {\n\t        if (_nameprepTableA1(code)) {\n\t            throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");\n\t        }\n\t    });\n\t    // IDNA extras\n\t    var name = utf8._toUtf8String(codes);\n\t    // IDNA: 4.2.3.1\n\t    if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {\n\t        throw new Error("invalid hyphen");\n\t    }\n\t    // IDNA: 4.2.4\n\t    if (name.length > 63) {\n\t        throw new Error("too long");\n\t    }\n\t    return name;\n\t}\n\texports.nameprep = nameprep;\n\n\t});\n\n\tvar idna$1 = unwrapExports(idna);\n\tvar idna_1 = idna._nameprepTableA1;\n\tvar idna_2 = idna._nameprepTableB2;\n\tvar idna_3 = idna._nameprepTableC;\n\tvar idna_4 = idna.nameprep;\n\n\tvar lib$8 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\texports.formatBytes32String = bytes32.formatBytes32String;\n\texports.parseBytes32String = bytes32.parseBytes32String;\n\n\texports.nameprep = idna.nameprep;\n\n\texports._toEscapedUtf8String = utf8._toEscapedUtf8String;\n\texports.toUtf8Bytes = utf8.toUtf8Bytes;\n\texports.toUtf8CodePoints = utf8.toUtf8CodePoints;\n\texports.toUtf8String = utf8.toUtf8String;\n\texports.UnicodeNormalizationForm = utf8.UnicodeNormalizationForm;\n\texports.Utf8ErrorFuncs = utf8.Utf8ErrorFuncs;\n\texports.Utf8ErrorReason = utf8.Utf8ErrorReason;\n\n\t});\n\n\tvar index$8 = unwrapExports(lib$8);\n\tvar lib_1$8 = lib$8.formatBytes32String;\n\tvar lib_2$7 = lib$8.parseBytes32String;\n\tvar lib_3$6 = lib$8.nameprep;\n\tvar lib_4$5 = lib$8._toEscapedUtf8String;\n\tvar lib_5$5 = lib$8.toUtf8Bytes;\n\tvar lib_6$3 = lib$8.toUtf8CodePoints;\n\tvar lib_7$3 = lib$8.toUtf8String;\n\tvar lib_8$2 = lib$8.UnicodeNormalizationForm;\n\tvar lib_9$2 = lib$8.Utf8ErrorFuncs;\n\tvar lib_10$1 = lib$8.Utf8ErrorReason;\n\n\tvar string = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar StringCoder = /** @class */ (function (_super) {\n\t    __extends(StringCoder, _super);\n\t    function StringCoder(localName) {\n\t        return _super.call(this, "string", localName) || this;\n\t    }\n\t    StringCoder.prototype.encode = function (writer, value) {\n\t        return _super.prototype.encode.call(this, writer, lib$8.toUtf8Bytes(value));\n\t    };\n\t    StringCoder.prototype.decode = function (reader) {\n\t        return lib$8.toUtf8String(_super.prototype.decode.call(this, reader));\n\t    };\n\t    return StringCoder;\n\t}(bytes.DynamicBytesCoder));\n\texports.StringCoder = StringCoder;\n\n\t});\n\n\tvar string$1 = unwrapExports(string);\n\tvar string_1 = string.StringCoder;\n\n\tvar tuple = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar TupleCoder = /** @class */ (function (_super) {\n\t    __extends(TupleCoder, _super);\n\t    function TupleCoder(coders, localName) {\n\t        var _this = this;\n\t        var dynamic = false;\n\t        var types = [];\n\t        coders.forEach(function (coder) {\n\t            if (coder.dynamic) {\n\t                dynamic = true;\n\t            }\n\t            types.push(coder.type);\n\t        });\n\t        var type = ("tuple(" + types.join(",") + ")");\n\t        _this = _super.call(this, "tuple", type, localName, dynamic) || this;\n\t        _this.coders = coders;\n\t        return _this;\n\t    }\n\t    TupleCoder.prototype.encode = function (writer, value) {\n\t        return array.pack(writer, this.coders, value);\n\t    };\n\t    TupleCoder.prototype.decode = function (reader) {\n\t        return reader.coerce(this.name, array.unpack(reader, this.coders));\n\t    };\n\t    return TupleCoder;\n\t}(abstractCoder.Coder));\n\texports.TupleCoder = TupleCoder;\n\n\t});\n\n\tvar tuple$1 = unwrapExports(tuple);\n\tvar tuple_1 = tuple.TupleCoder;\n\n\tvar abiCoder = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\t// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\n\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\n\n\n\n\n\n\n\n\n\n\n\tvar paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\n\tvar paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\n\tvar AbiCoder = /** @class */ (function () {\n\t    function AbiCoder(coerceFunc) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, AbiCoder);\n\t        lib$3.defineReadOnly(this, "coerceFunc", coerceFunc || null);\n\t    }\n\t    AbiCoder.prototype._getCoder = function (param) {\n\t        var _this = this;\n\t        switch (param.baseType) {\n\t            case "address":\n\t                return new address.AddressCoder(param.name);\n\t            case "bool":\n\t                return new boolean_1.BooleanCoder(param.name);\n\t            case "string":\n\t                return new string.StringCoder(param.name);\n\t            case "bytes":\n\t                return new bytes.BytesCoder(param.name);\n\t            case "array":\n\t                return new array.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n\t            case "tuple":\n\t                return new tuple.TupleCoder((param.components || []).map(function (component) {\n\t                    return _this._getCoder(component);\n\t                }), param.name);\n\t            case "":\n\t                return new _null.NullCoder(param.name);\n\t        }\n\t        // u?int[0-9]*\n\t        var match = param.type.match(paramTypeNumber);\n\t        if (match) {\n\t            var size = parseInt(match[2] || "256");\n\t            if (size === 0 || size > 256 || (size % 8) !== 0) {\n\t                logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);\n\t            }\n\t            return new number.NumberCoder(size / 8, (match[1] === "int"), param.name);\n\t        }\n\t        // bytes[0-9]+\n\t        match = param.type.match(paramTypeBytes);\n\t        if (match) {\n\t            var size = parseInt(match[1]);\n\t            if (size === 0 || size > 32) {\n\t                logger.throwArgumentError("invalid bytes length", "param", param);\n\t            }\n\t            return new fixedBytes.FixedBytesCoder(size, param.name);\n\t        }\n\t        return logger.throwArgumentError("invalid type", "type", param.type);\n\t    };\n\t    AbiCoder.prototype._getWordSize = function () { return 32; };\n\t    AbiCoder.prototype._getReader = function (data, allowLoose) {\n\t        return new abstractCoder.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n\t    };\n\t    AbiCoder.prototype._getWriter = function () {\n\t        return new abstractCoder.Writer(this._getWordSize());\n\t    };\n\t    AbiCoder.prototype.encode = function (types, values) {\n\t        var _this = this;\n\t        if (types.length !== values.length) {\n\t            logger.throwError("types/values length mismatch", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                count: { types: types.length, values: values.length },\n\t                value: { types: types, values: values }\n\t            });\n\t        }\n\t        var coders = types.map(function (type) { return _this._getCoder(fragments.ParamType.from(type)); });\n\t        var coder = (new tuple.TupleCoder(coders, "_"));\n\t        var writer = this._getWriter();\n\t        coder.encode(writer, values);\n\t        return writer.data;\n\t    };\n\t    AbiCoder.prototype.decode = function (types, data, loose) {\n\t        var _this = this;\n\t        var coders = types.map(function (type) { return _this._getCoder(fragments.ParamType.from(type)); });\n\t        var coder = new tuple.TupleCoder(coders, "_");\n\t        return coder.decode(this._getReader(lib$1.arrayify(data), loose));\n\t    };\n\t    return AbiCoder;\n\t}());\n\texports.AbiCoder = AbiCoder;\n\texports.defaultAbiCoder = new AbiCoder();\n\n\t});\n\n\tvar abiCoder$1 = unwrapExports(abiCoder);\n\tvar abiCoder_1 = abiCoder.AbiCoder;\n\tvar abiCoder_2 = abiCoder.defaultAbiCoder;\n\n\tvar _version$g = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "hash/5.0.4";\n\n\t});\n\n\tvar _version$h = unwrapExports(_version$g);\n\tvar _version_1$8 = _version$g.version;\n\n\tvar lib$9 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$g.version);\n\t///////////////////////////////\n\tvar Zeros = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n\tvar Partition = new RegExp("^((.*)\\\\.)?([^.]+)$");\n\tfunction isValidName(name) {\n\t    try {\n\t        var comps = name.split(".");\n\t        for (var i = 0; i < comps.length; i++) {\n\t            if (lib$8.nameprep(comps[i]).length === 0) {\n\t                throw new Error("empty");\n\t            }\n\t        }\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isValidName = isValidName;\n\tfunction namehash(name) {\n\t    /* istanbul ignore if */\n\t    if (typeof (name) !== "string") {\n\t        logger.throwArgumentError("invalid address - " + String(name), "name", name);\n\t    }\n\t    var result = Zeros;\n\t    while (name.length) {\n\t        var partition = name.match(Partition);\n\t        var label = lib$8.toUtf8Bytes(lib$8.nameprep(partition[3]));\n\t        result = lib$4.keccak256(lib$1.concat([result, lib$4.keccak256(label)]));\n\t        name = partition[2] || "";\n\t    }\n\t    return lib$1.hexlify(result);\n\t}\n\texports.namehash = namehash;\n\tfunction id(text) {\n\t    return lib$4.keccak256(lib$8.toUtf8Bytes(text));\n\t}\n\texports.id = id;\n\texports.messagePrefix = "\\x19Ethereum Signed Message:\\n";\n\tfunction hashMessage(message) {\n\t    if (typeof (message) === "string") {\n\t        message = lib$8.toUtf8Bytes(message);\n\t    }\n\t    return lib$4.keccak256(lib$1.concat([\n\t        lib$8.toUtf8Bytes(exports.messagePrefix),\n\t        lib$8.toUtf8Bytes(String(message.length)),\n\t        message\n\t    ]));\n\t}\n\texports.hashMessage = hashMessage;\n\n\t});\n\n\tvar index$9 = unwrapExports(lib$9);\n\tvar lib_1$9 = lib$9.isValidName;\n\tvar lib_2$8 = lib$9.namehash;\n\tvar lib_3$7 = lib$9.id;\n\tvar lib_4$6 = lib$9.messagePrefix;\n\tvar lib_5$6 = lib$9.hashMessage;\n\n\tvar _interface = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\n\n\texports.checkResultErrors = abstractCoder.checkResultErrors;\n\n\n\n\tvar logger = new lib.Logger(_version$8.version);\n\tvar LogDescription = /** @class */ (function (_super) {\n\t    __extends(LogDescription, _super);\n\t    function LogDescription() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return LogDescription;\n\t}(lib$3.Description));\n\texports.LogDescription = LogDescription;\n\tvar TransactionDescription = /** @class */ (function (_super) {\n\t    __extends(TransactionDescription, _super);\n\t    function TransactionDescription() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    return TransactionDescription;\n\t}(lib$3.Description));\n\texports.TransactionDescription = TransactionDescription;\n\tvar Indexed = /** @class */ (function (_super) {\n\t    __extends(Indexed, _super);\n\t    function Indexed() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    Indexed.isIndexed = function (value) {\n\t        return !!(value && value._isIndexed);\n\t    };\n\t    return Indexed;\n\t}(lib$3.Description));\n\texports.Indexed = Indexed;\n\tfunction wrapAccessError(property, error) {\n\t    var wrap = new Error("deferred error during ABI decoding triggered accessing " + property);\n\t    wrap.error = error;\n\t    return wrap;\n\t}\n\t/*\n\tfunction checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {\n\t    params.reduce((accum, param) => {\n\t        if (param.name) {\n\t            if (accum[param.name]) {\n\t                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);\n\t            }\n\t            accum[param.name] = true;\n\t        }\n\t        return accum;\n\t    }, <{ [ name: string ]: boolean }>{ });\n\t}\n\t*/\n\tvar Interface = /** @class */ (function () {\n\t    function Interface(fragments$1) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Interface);\n\t        var abi = [];\n\t        if (typeof (fragments$1) === "string") {\n\t            abi = JSON.parse(fragments$1);\n\t        }\n\t        else {\n\t            abi = fragments$1;\n\t        }\n\t        lib$3.defineReadOnly(this, "fragments", abi.map(function (fragment) {\n\t            return fragments.Fragment.from(fragment);\n\t        }).filter(function (fragment) { return (fragment != null); }));\n\t        lib$3.defineReadOnly(this, "_abiCoder", lib$3.getStatic((_newTarget), "getAbiCoder")());\n\t        lib$3.defineReadOnly(this, "functions", {});\n\t        lib$3.defineReadOnly(this, "errors", {});\n\t        lib$3.defineReadOnly(this, "events", {});\n\t        lib$3.defineReadOnly(this, "structs", {});\n\t        // Add all fragments by their signature\n\t        this.fragments.forEach(function (fragment) {\n\t            var bucket = null;\n\t            switch (fragment.type) {\n\t                case "constructor":\n\t                    if (_this.deploy) {\n\t                        logger.warn("duplicate definition - constructor");\n\t                        return;\n\t                    }\n\t                    //checkNames(fragment, "input", fragment.inputs);\n\t                    lib$3.defineReadOnly(_this, "deploy", fragment);\n\t                    return;\n\t                case "function":\n\t                    //checkNames(fragment, "input", fragment.inputs);\n\t                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);\n\t                    bucket = _this.functions;\n\t                    break;\n\t                case "event":\n\t                    //checkNames(fragment, "input", fragment.inputs);\n\t                    bucket = _this.events;\n\t                    break;\n\t                default:\n\t                    return;\n\t            }\n\t            var signature = fragment.format();\n\t            if (bucket[signature]) {\n\t                logger.warn("duplicate definition - " + signature);\n\t                return;\n\t            }\n\t            bucket[signature] = fragment;\n\t        });\n\t        // If we do not have a constructor add a default\n\t        if (!this.deploy) {\n\t            lib$3.defineReadOnly(this, "deploy", fragments.ConstructorFragment.from({\n\t                payable: false,\n\t                type: "constructor"\n\t            }));\n\t        }\n\t        lib$3.defineReadOnly(this, "_isInterface", true);\n\t    }\n\t    Interface.prototype.format = function (format) {\n\t        if (!format) {\n\t            format = fragments.FormatTypes.full;\n\t        }\n\t        if (format === fragments.FormatTypes.sighash) {\n\t            logger.throwArgumentError("interface does not support formatting sighash", "format", format);\n\t        }\n\t        var abi = this.fragments.map(function (fragment) { return fragment.format(format); });\n\t        // We need to re-bundle the JSON fragments a bit\n\t        if (format === fragments.FormatTypes.json) {\n\t            return JSON.stringify(abi.map(function (j) { return JSON.parse(j); }));\n\t        }\n\t        return abi;\n\t    };\n\t    // Sub-classes can override these to handle other blockchains\n\t    Interface.getAbiCoder = function () {\n\t        return abiCoder.defaultAbiCoder;\n\t    };\n\t    Interface.getAddress = function (address) {\n\t        return lib$6.getAddress(address);\n\t    };\n\t    Interface.getSighash = function (functionFragment) {\n\t        return lib$1.hexDataSlice(lib$9.id(functionFragment.format()), 0, 4);\n\t    };\n\t    Interface.getEventTopic = function (eventFragment) {\n\t        return lib$9.id(eventFragment.format());\n\t    };\n\t    // Find a function definition by any means necessary (unless it is ambiguous)\n\t    Interface.prototype.getFunction = function (nameOrSignatureOrSighash) {\n\t        if (lib$1.isHexString(nameOrSignatureOrSighash)) {\n\t            for (var name_1 in this.functions) {\n\t                if (nameOrSignatureOrSighash === this.getSighash(name_1)) {\n\t                    return this.functions[name_1];\n\t                }\n\t            }\n\t            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);\n\t        }\n\t        // It is a bare name, look up the function (will return null if ambiguous)\n\t        if (nameOrSignatureOrSighash.indexOf("(") === -1) {\n\t            var name_2 = nameOrSignatureOrSighash.trim();\n\t            var matching = Object.keys(this.functions).filter(function (f) { return (f.split("(" /* fix:) */)[0] === name_2); });\n\t            if (matching.length === 0) {\n\t                logger.throwArgumentError("no matching function", "name", name_2);\n\t            }\n\t            else if (matching.length > 1) {\n\t                logger.throwArgumentError("multiple matching functions", "name", name_2);\n\t            }\n\t            return this.functions[matching[0]];\n\t        }\n\t        // Normlize the signature and lookup the function\n\t        var result = this.functions[fragments.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n\t        if (!result) {\n\t            logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);\n\t        }\n\t        return result;\n\t    };\n\t    // Find an event definition by any means necessary (unless it is ambiguous)\n\t    Interface.prototype.getEvent = function (nameOrSignatureOrTopic) {\n\t        if (lib$1.isHexString(nameOrSignatureOrTopic)) {\n\t            var topichash = nameOrSignatureOrTopic.toLowerCase();\n\t            for (var name_3 in this.events) {\n\t                if (topichash === this.getEventTopic(name_3)) {\n\t                    return this.events[name_3];\n\t                }\n\t            }\n\t            logger.throwArgumentError("no matching event", "topichash", topichash);\n\t        }\n\t        // It is a bare name, look up the function (will return null if ambiguous)\n\t        if (nameOrSignatureOrTopic.indexOf("(") === -1) {\n\t            var name_4 = nameOrSignatureOrTopic.trim();\n\t            var matching = Object.keys(this.events).filter(function (f) { return (f.split("(" /* fix:) */)[0] === name_4); });\n\t            if (matching.length === 0) {\n\t                logger.throwArgumentError("no matching event", "name", name_4);\n\t            }\n\t            else if (matching.length > 1) {\n\t                logger.throwArgumentError("multiple matching events", "name", name_4);\n\t            }\n\t            return this.events[matching[0]];\n\t        }\n\t        // Normlize the signature and lookup the function\n\t        var result = this.events[fragments.EventFragment.fromString(nameOrSignatureOrTopic).format()];\n\t        if (!result) {\n\t            logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);\n\t        }\n\t        return result;\n\t    };\n\t    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n\t    Interface.prototype.getSighash = function (functionFragment) {\n\t        if (typeof (functionFragment) === "string") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return lib$3.getStatic(this.constructor, "getSighash")(functionFragment);\n\t    };\n\t    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n\t    Interface.prototype.getEventTopic = function (eventFragment) {\n\t        if (typeof (eventFragment) === "string") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        return lib$3.getStatic(this.constructor, "getEventTopic")(eventFragment);\n\t    };\n\t    Interface.prototype._decodeParams = function (params, data) {\n\t        return this._abiCoder.decode(params, data);\n\t    };\n\t    Interface.prototype._encodeParams = function (params, values) {\n\t        return this._abiCoder.encode(params, values);\n\t    };\n\t    Interface.prototype.encodeDeploy = function (values) {\n\t        return this._encodeParams(this.deploy.inputs, values || []);\n\t    };\n\t    // Decode the data for a function call (e.g. tx.data)\n\t    Interface.prototype.decodeFunctionData = function (functionFragment, data) {\n\t        if (typeof (functionFragment) === "string") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        var bytes = lib$1.arrayify(data);\n\t        if (lib$1.hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n\t            logger.throwArgumentError("data signature does not match function " + functionFragment.name + ".", "data", lib$1.hexlify(bytes));\n\t        }\n\t        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n\t    };\n\t    // Encode the data for a function call (e.g. tx.data)\n\t    Interface.prototype.encodeFunctionData = function (functionFragment, values) {\n\t        if (typeof (functionFragment) === "string") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return lib$1.hexlify(lib$1.concat([\n\t            this.getSighash(functionFragment),\n\t            this._encodeParams(functionFragment.inputs, values || [])\n\t        ]));\n\t    };\n\t    // Decode the result from a function call (e.g. from eth_call)\n\t    Interface.prototype.decodeFunctionResult = function (functionFragment, data) {\n\t        if (typeof (functionFragment) === "string") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        var bytes = lib$1.arrayify(data);\n\t        var reason = null;\n\t        var errorSignature = null;\n\t        switch (bytes.length % this._abiCoder._getWordSize()) {\n\t            case 0:\n\t                try {\n\t                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n\t                }\n\t                catch (error) { }\n\t                break;\n\t            case 4:\n\t                if (lib$1.hexlify(bytes.slice(0, 4)) === "0x08c379a0") {\n\t                    errorSignature = "Error(string)";\n\t                    reason = this._abiCoder.decode(["string"], bytes.slice(4))[0];\n\t                }\n\t                break;\n\t        }\n\t        return logger.throwError("call revert exception", lib.Logger.errors.CALL_EXCEPTION, {\n\t            method: functionFragment.format(),\n\t            errorSignature: errorSignature,\n\t            errorArgs: [reason],\n\t            reason: reason\n\t        });\n\t    };\n\t    // Encode the result for a function call (e.g. for eth_call)\n\t    Interface.prototype.encodeFunctionResult = function (functionFragment, values) {\n\t        if (typeof (functionFragment) === "string") {\n\t            functionFragment = this.getFunction(functionFragment);\n\t        }\n\t        return lib$1.hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));\n\t    };\n\t    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n\t    Interface.prototype.encodeFilterTopics = function (eventFragment, values) {\n\t        var _this = this;\n\t        if (typeof (eventFragment) === "string") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        if (values.length > eventFragment.inputs.length) {\n\t            logger.throwError("too many arguments for " + eventFragment.format(), lib.Logger.errors.UNEXPECTED_ARGUMENT, {\n\t                argument: "values",\n\t                value: values\n\t            });\n\t        }\n\t        var topics = [];\n\t        if (!eventFragment.anonymous) {\n\t            topics.push(this.getEventTopic(eventFragment));\n\t        }\n\t        var encodeTopic = function (param, value) {\n\t            if (param.type === "string") {\n\t                return lib$9.id(value);\n\t            }\n\t            else if (param.type === "bytes") {\n\t                return lib$4.keccak256(lib$1.hexlify(value));\n\t            }\n\t            // Check addresses are valid\n\t            if (param.type === "address") {\n\t                _this._abiCoder.encode(["address"], [value]);\n\t            }\n\t            return lib$1.hexZeroPad(lib$1.hexlify(value), 32);\n\t        };\n\t        values.forEach(function (value, index) {\n\t            var param = eventFragment.inputs[index];\n\t            if (!param.indexed) {\n\t                if (value != null) {\n\t                    logger.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);\n\t                }\n\t                return;\n\t            }\n\t            if (value == null) {\n\t                topics.push(null);\n\t            }\n\t            else if (param.baseType === "array" || param.baseType === "tuple") {\n\t                logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);\n\t            }\n\t            else if (Array.isArray(value)) {\n\t                topics.push(value.map(function (value) { return encodeTopic(param, value); }));\n\t            }\n\t            else {\n\t                topics.push(encodeTopic(param, value));\n\t            }\n\t        });\n\t        // Trim off trailing nulls\n\t        while (topics.length && topics[topics.length - 1] === null) {\n\t            topics.pop();\n\t        }\n\t        return topics;\n\t    };\n\t    Interface.prototype.encodeEventLog = function (eventFragment, values) {\n\t        var _this = this;\n\t        if (typeof (eventFragment) === "string") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        var topics = [];\n\t        var dataTypes = [];\n\t        var dataValues = [];\n\t        if (!eventFragment.anonymous) {\n\t            topics.push(this.getEventTopic(eventFragment));\n\t        }\n\t        if (values.length !== eventFragment.inputs.length) {\n\t            logger.throwArgumentError("event arguments/values mismatch", "values", values);\n\t        }\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            var value = values[index];\n\t            if (param.indexed) {\n\t                if (param.type === "string") {\n\t                    topics.push(lib$9.id(value));\n\t                }\n\t                else if (param.type === "bytes") {\n\t                    topics.push(lib$4.keccak256(value));\n\t                }\n\t                else if (param.baseType === "tuple" || param.baseType === "array") {\n\t                    // @TOOD\n\t                    throw new Error("not implemented");\n\t                }\n\t                else {\n\t                    topics.push(_this._abiCoder.encode([param.type], [value]));\n\t                }\n\t            }\n\t            else {\n\t                dataTypes.push(param);\n\t                dataValues.push(value);\n\t            }\n\t        });\n\t        return {\n\t            data: this._abiCoder.encode(dataTypes, dataValues),\n\t            topics: topics\n\t        };\n\t    };\n\t    // Decode a filter for the event and the search criteria\n\t    Interface.prototype.decodeEventLog = function (eventFragment, data, topics) {\n\t        if (typeof (eventFragment) === "string") {\n\t            eventFragment = this.getEvent(eventFragment);\n\t        }\n\t        if (topics != null && !eventFragment.anonymous) {\n\t            var topicHash = this.getEventTopic(eventFragment);\n\t            if (!lib$1.isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n\t                logger.throwError("fragment/topic mismatch", lib.Logger.errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });\n\t            }\n\t            topics = topics.slice(1);\n\t        }\n\t        var indexed = [];\n\t        var nonIndexed = [];\n\t        var dynamic = [];\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            if (param.indexed) {\n\t                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {\n\t                    indexed.push(fragments.ParamType.fromObject({ type: "bytes32", name: param.name }));\n\t                    dynamic.push(true);\n\t                }\n\t                else {\n\t                    indexed.push(param);\n\t                    dynamic.push(false);\n\t                }\n\t            }\n\t            else {\n\t                nonIndexed.push(param);\n\t                dynamic.push(false);\n\t            }\n\t        });\n\t        var resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, lib$1.concat(topics)) : null;\n\t        var resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n\t        var result = [];\n\t        var nonIndexedIndex = 0, indexedIndex = 0;\n\t        eventFragment.inputs.forEach(function (param, index) {\n\t            if (param.indexed) {\n\t                if (resultIndexed == null) {\n\t                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n\t                }\n\t                else if (dynamic[index]) {\n\t                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n\t                }\n\t                else {\n\t                    try {\n\t                        result[index] = resultIndexed[indexedIndex++];\n\t                    }\n\t                    catch (error) {\n\t                        result[index] = error;\n\t                    }\n\t                }\n\t            }\n\t            else {\n\t                try {\n\t                    result[index] = resultNonIndexed[nonIndexedIndex++];\n\t                }\n\t                catch (error) {\n\t                    result[index] = error;\n\t                }\n\t            }\n\t            // Add the keyword argument if named and safe\n\t            if (param.name && result[param.name] == null) {\n\t                var value_1 = result[index];\n\t                // Make error named values throw on access\n\t                if (value_1 instanceof Error) {\n\t                    Object.defineProperty(result, param.name, {\n\t                        get: function () { throw wrapAccessError("property " + JSON.stringify(param.name), value_1); }\n\t                    });\n\t                }\n\t                else {\n\t                    result[param.name] = value_1;\n\t                }\n\t            }\n\t        });\n\t        var _loop_1 = function (i) {\n\t            var value = result[i];\n\t            if (value instanceof Error) {\n\t                Object.defineProperty(result, i, {\n\t                    get: function () { throw wrapAccessError("index " + i, value); }\n\t                });\n\t            }\n\t        };\n\t        // Make all error indexed values throw on access\n\t        for (var i = 0; i < result.length; i++) {\n\t            _loop_1(i);\n\t        }\n\t        return Object.freeze(result);\n\t    };\n\t    // Given a transaction, find the matching function fragment (if any) and\n\t    // determine all its properties and call parameters\n\t    Interface.prototype.parseTransaction = function (tx) {\n\t        var fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n\t        if (!fragment) {\n\t            return null;\n\t        }\n\t        return new TransactionDescription({\n\t            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),\n\t            functionFragment: fragment,\n\t            name: fragment.name,\n\t            signature: fragment.format(),\n\t            sighash: this.getSighash(fragment),\n\t            value: lib$2.BigNumber.from(tx.value || "0"),\n\t        });\n\t    };\n\t    // Given an event log, find the matching event fragment (if any) and\n\t    // determine all its properties and values\n\t    Interface.prototype.parseLog = function (log) {\n\t        var fragment = this.getEvent(log.topics[0]);\n\t        if (!fragment || fragment.anonymous) {\n\t            return null;\n\t        }\n\t        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n\t        //        Probably not, because just because it is the only event in the ABI does\n\t        //        not mean we have the full ABI; maybe jsut a fragment?\n\t        return new LogDescription({\n\t            eventFragment: fragment,\n\t            name: fragment.name,\n\t            signature: fragment.format(),\n\t            topic: this.getEventTopic(fragment),\n\t            args: this.decodeEventLog(fragment, log.data, log.topics)\n\t        });\n\t    };\n\t    /*\n\t    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n\t        if (Interface.isInterface(value)) {\n\t            return value;\n\t        }\n\t        if (typeof(value) === "string") {\n\t            return new Interface(JSON.parse(value));\n\t        }\n\t        return new Interface(value);\n\t    }\n\t    */\n\t    Interface.isInterface = function (value) {\n\t        return !!(value && value._isInterface);\n\t    };\n\t    return Interface;\n\t}());\n\texports.Interface = Interface;\n\n\t});\n\n\tvar _interface$1 = unwrapExports(_interface);\n\tvar _interface_1 = _interface.checkResultErrors;\n\tvar _interface_2 = _interface.LogDescription;\n\tvar _interface_3 = _interface.TransactionDescription;\n\tvar _interface_4 = _interface.Indexed;\n\tvar _interface_5 = _interface.Interface;\n\n\tvar lib$a = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\texports.ConstructorFragment = fragments.ConstructorFragment;\n\texports.EventFragment = fragments.EventFragment;\n\texports.FormatTypes = fragments.FormatTypes;\n\texports.Fragment = fragments.Fragment;\n\texports.FunctionFragment = fragments.FunctionFragment;\n\texports.ParamType = fragments.ParamType;\n\n\texports.AbiCoder = abiCoder.AbiCoder;\n\texports.defaultAbiCoder = abiCoder.defaultAbiCoder;\n\n\texports.checkResultErrors = _interface.checkResultErrors;\n\texports.Indexed = _interface.Indexed;\n\texports.Interface = _interface.Interface;\n\texports.LogDescription = _interface.LogDescription;\n\texports.TransactionDescription = _interface.TransactionDescription;\n\n\t});\n\n\tvar index$a = unwrapExports(lib$a);\n\tvar lib_1$a = lib$a.ConstructorFragment;\n\tvar lib_2$9 = lib$a.EventFragment;\n\tvar lib_3$8 = lib$a.FormatTypes;\n\tvar lib_4$7 = lib$a.Fragment;\n\tvar lib_5$7 = lib$a.FunctionFragment;\n\tvar lib_6$4 = lib$a.ParamType;\n\tvar lib_7$4 = lib$a.AbiCoder;\n\tvar lib_8$3 = lib$a.defaultAbiCoder;\n\tvar lib_9$3 = lib$a.checkResultErrors;\n\tvar lib_10$2 = lib$a.Indexed;\n\tvar lib_11$1 = lib$a.Interface;\n\tvar lib_12$1 = lib$a.LogDescription;\n\tvar lib_13$1 = lib$a.TransactionDescription;\n\n\tvar _version$i = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "abstract-provider/5.0.4";\n\n\t});\n\n\tvar _version$j = unwrapExports(_version$i);\n\tvar _version_1$9 = _version$i.version;\n\n\tvar lib$b = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\tvar logger = new lib.Logger(_version$i.version);\n\t;\n\t;\n\t//export type CallTransactionable = {\n\t//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n\t//};\n\tvar ForkEvent = /** @class */ (function (_super) {\n\t    __extends(ForkEvent, _super);\n\t    function ForkEvent() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    ForkEvent.isForkEvent = function (value) {\n\t        return !!(value && value._isForkEvent);\n\t    };\n\t    return ForkEvent;\n\t}(lib$3.Description));\n\texports.ForkEvent = ForkEvent;\n\tvar BlockForkEvent = /** @class */ (function (_super) {\n\t    __extends(BlockForkEvent, _super);\n\t    function BlockForkEvent(blockHash, expiry) {\n\t        var _this = this;\n\t        if (!lib$1.isHexString(blockHash, 32)) {\n\t            logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isBlockForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            blockHash: blockHash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return BlockForkEvent;\n\t}(ForkEvent));\n\texports.BlockForkEvent = BlockForkEvent;\n\tvar TransactionForkEvent = /** @class */ (function (_super) {\n\t    __extends(TransactionForkEvent, _super);\n\t    function TransactionForkEvent(hash, expiry) {\n\t        var _this = this;\n\t        if (!lib$1.isHexString(hash, 32)) {\n\t            logger.throwArgumentError("invalid transaction hash", "hash", hash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isTransactionForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            hash: hash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return TransactionForkEvent;\n\t}(ForkEvent));\n\texports.TransactionForkEvent = TransactionForkEvent;\n\tvar TransactionOrderForkEvent = /** @class */ (function (_super) {\n\t    __extends(TransactionOrderForkEvent, _super);\n\t    function TransactionOrderForkEvent(beforeHash, afterHash, expiry) {\n\t        var _this = this;\n\t        if (!lib$1.isHexString(beforeHash, 32)) {\n\t            logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);\n\t        }\n\t        if (!lib$1.isHexString(afterHash, 32)) {\n\t            logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);\n\t        }\n\t        _this = _super.call(this, {\n\t            _isForkEvent: true,\n\t            _isTransactionOrderForkEvent: true,\n\t            expiry: (expiry || 0),\n\t            beforeHash: beforeHash,\n\t            afterHash: afterHash\n\t        }) || this;\n\t        return _this;\n\t    }\n\t    return TransactionOrderForkEvent;\n\t}(ForkEvent));\n\texports.TransactionOrderForkEvent = TransactionOrderForkEvent;\n\t///////////////////////////////\n\t// Exported Abstracts\n\tvar Provider = /** @class */ (function () {\n\t    function Provider() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkAbstract(_newTarget, Provider);\n\t        lib$3.defineReadOnly(this, "_isProvider", true);\n\t    }\n\t    // Alias for "on"\n\t    Provider.prototype.addListener = function (eventName, listener) {\n\t        return this.on(eventName, listener);\n\t    };\n\t    // Alias for "off"\n\t    Provider.prototype.removeListener = function (eventName, listener) {\n\t        return this.off(eventName, listener);\n\t    };\n\t    Provider.isProvider = function (value) {\n\t        return !!(value && value._isProvider);\n\t    };\n\t    return Provider;\n\t}());\n\texports.Provider = Provider;\n\n\t});\n\n\tvar index$b = unwrapExports(lib$b);\n\tvar lib_1$b = lib$b.ForkEvent;\n\tvar lib_2$a = lib$b.BlockForkEvent;\n\tvar lib_3$9 = lib$b.TransactionForkEvent;\n\tvar lib_4$8 = lib$b.TransactionOrderForkEvent;\n\tvar lib_5$8 = lib$b.Provider;\n\n\tvar _version$k = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "abstract-signer/5.0.5";\n\n\t});\n\n\tvar _version$l = unwrapExports(_version$k);\n\tvar _version_1$a = _version$k.version;\n\n\tvar lib$c = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$k.version);\n\tvar allowedTransactionKeys = [\n\t    "chainId", "data", "from", "gasLimit", "gasPrice", "nonce", "to", "value"\n\t];\n\tvar forwardErrors = [\n\t    lib.Logger.errors.INSUFFICIENT_FUNDS,\n\t    lib.Logger.errors.NONCE_EXPIRED,\n\t    lib.Logger.errors.REPLACEMENT_UNDERPRICED,\n\t];\n\t// Sub-Class Notes:\n\t//  - A Signer MUST always make sure, that if present, the "from" field\n\t//    matches the Signer, before sending or signing a transaction\n\t//  - A Signer SHOULD always wrap private information (such as a private\n\t//    key or mnemonic) in a function, so that console.log does not leak\n\t//    the data\n\tvar Signer = /** @class */ (function () {\n\t    ///////////////////\n\t    // Sub-classes MUST call super\n\t    function Signer() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkAbstract(_newTarget, Signer);\n\t        lib$3.defineReadOnly(this, "_isSigner", true);\n\t    }\n\t    ///////////////////\n\t    // Sub-classes MAY override these\n\t    Signer.prototype.getBalance = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider("getBalance");\n\t                        return [4 /*yield*/, this.provider.getBalance(this.getAddress(), blockTag)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getTransactionCount = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider("getTransactionCount");\n\t                        return [4 /*yield*/, this.provider.getTransactionCount(this.getAddress(), blockTag)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates "from" if unspecified, and estimates the gas for the transation\n\t    Signer.prototype.estimateGas = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider("estimateGas");\n\t                        return [4 /*yield*/, lib$3.resolveProperties(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, this.provider.estimateGas(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates "from" if unspecified, and calls with the transation\n\t    Signer.prototype.call = function (transaction, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider("call");\n\t                        return [4 /*yield*/, lib$3.resolveProperties(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, this.provider.call(tx, blockTag)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Populates all fields in a transaction, signs it and sends it to the network\n\t    Signer.prototype.sendTransaction = function (transaction) {\n\t        var _this = this;\n\t        this._checkProvider("sendTransaction");\n\t        return this.populateTransaction(transaction).then(function (tx) {\n\t            return _this.signTransaction(tx).then(function (signedTx) {\n\t                return _this.provider.sendTransaction(signedTx);\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getChainId = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider("getChainId");\n\t                        return [4 /*yield*/, this.provider.getNetwork()];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        return [2 /*return*/, network.chainId];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.getGasPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider("getGasPrice");\n\t                        return [4 /*yield*/, this.provider.getGasPrice()];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Signer.prototype.resolveName = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        this._checkProvider("resolveName");\n\t                        return [4 /*yield*/, this.provider.resolveName(name)];\n\t                    case 1: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Checks a transaction does not contain invalid keys and if\n\t    // no "from" is provided, populates it.\n\t    // - does NOT require a provider\n\t    // - adds "from" is not present\n\t    // - returns a COPY (safe to mutate the result)\n\t    // By default called from: (overriding these prevents it)\n\t    //   - call\n\t    //   - estimateGas\n\t    //   - populateTransaction (and therefor sendTransaction)\n\t    Signer.prototype.checkTransaction = function (transaction) {\n\t        for (var key in transaction) {\n\t            if (allowedTransactionKeys.indexOf(key) === -1) {\n\t                logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);\n\t            }\n\t        }\n\t        var tx = lib$3.shallowCopy(transaction);\n\t        if (tx.from == null) {\n\t            tx.from = this.getAddress();\n\t        }\n\t        else {\n\t            // Make sure any provided address matches this signer\n\t            tx.from = Promise.all([\n\t                Promise.resolve(tx.from),\n\t                this.getAddress()\n\t            ]).then(function (result) {\n\t                if (result[0] !== result[1]) {\n\t                    logger.throwArgumentError("from address mismatch", "transaction", transaction);\n\t                }\n\t                return result[0];\n\t            });\n\t        }\n\t        return tx;\n\t    };\n\t    // Populates ALL keys for a transaction and checks that "from" matches\n\t    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n\t    // By default called from: (overriding these prevents it)\n\t    //   - sendTransaction\n\t    Signer.prototype.populateTransaction = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, lib$3.resolveProperties(this.checkTransaction(transaction))];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        if (tx.to != null) {\n\t                            tx.to = Promise.resolve(tx.to).then(function (to) { return _this.resolveName(to); });\n\t                        }\n\t                        if (tx.gasPrice == null) {\n\t                            tx.gasPrice = this.getGasPrice();\n\t                        }\n\t                        if (tx.nonce == null) {\n\t                            tx.nonce = this.getTransactionCount("pending");\n\t                        }\n\t                        if (tx.gasLimit == null) {\n\t                            tx.gasLimit = this.estimateGas(tx).catch(function (error) {\n\t                                if (forwardErrors.indexOf(error.code) >= 0) {\n\t                                    throw error;\n\t                                }\n\t                                return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n\t                                    error: error,\n\t                                    tx: tx\n\t                                });\n\t                            });\n\t                        }\n\t                        if (tx.chainId == null) {\n\t                            tx.chainId = this.getChainId();\n\t                        }\n\t                        else {\n\t                            tx.chainId = Promise.all([\n\t                                Promise.resolve(tx.chainId),\n\t                                this.getChainId()\n\t                            ]).then(function (results) {\n\t                                if (results[1] !== 0 && results[0] !== results[1]) {\n\t                                    logger.throwArgumentError("chainId address mismatch", "transaction", transaction);\n\t                                }\n\t                                return results[0];\n\t                            });\n\t                        }\n\t                        return [4 /*yield*/, lib$3.resolveProperties(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    ///////////////////\n\t    // Sub-classes SHOULD leave these alone\n\t    Signer.prototype._checkProvider = function (operation) {\n\t        if (!this.provider) {\n\t            logger.throwError("missing provider", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: (operation || "_checkProvider")\n\t            });\n\t        }\n\t    };\n\t    Signer.isSigner = function (value) {\n\t        return !!(value && value._isSigner);\n\t    };\n\t    return Signer;\n\t}());\n\texports.Signer = Signer;\n\tvar VoidSigner = /** @class */ (function (_super) {\n\t    __extends(VoidSigner, _super);\n\t    function VoidSigner(address, provider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, VoidSigner);\n\t        _this = _super.call(this) || this;\n\t        lib$3.defineReadOnly(_this, "address", address);\n\t        lib$3.defineReadOnly(_this, "provider", provider || null);\n\t        return _this;\n\t    }\n\t    VoidSigner.prototype.getAddress = function () {\n\t        return Promise.resolve(this.address);\n\t    };\n\t    VoidSigner.prototype._fail = function (message, operation) {\n\t        return Promise.resolve().then(function () {\n\t            logger.throwError(message, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n\t        });\n\t    };\n\t    VoidSigner.prototype.signMessage = function (message) {\n\t        return this._fail("VoidSigner cannot sign messages", "signMessage");\n\t    };\n\t    VoidSigner.prototype.signTransaction = function (transaction) {\n\t        return this._fail("VoidSigner cannot sign transactions", "signTransaction");\n\t    };\n\t    VoidSigner.prototype.connect = function (provider) {\n\t        return new VoidSigner(this.address, provider);\n\t    };\n\t    return VoidSigner;\n\t}(Signer));\n\texports.VoidSigner = VoidSigner;\n\n\t});\n\n\tvar index$c = unwrapExports(lib$c);\n\tvar lib_1$c = lib$c.Signer;\n\tvar lib_2$b = lib$c.VoidSigner;\n\n\tvar _version$m = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "contracts/5.0.4";\n\n\t});\n\n\tvar _version$n = unwrapExports(_version$m);\n\tvar _version_1$b = _version$m.version;\n\n\tvar lib$d = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __spreadArrays = (commonjsGlobal && commonjsGlobal.__spreadArrays) || function () {\n\t    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\t    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n\t        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n\t            r[k] = a[j];\n\t    return r;\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\t//import { AddressZero } from "@ethersproject/constants";\n\n\t// @TOOD remove dependences transactions\n\n\n\tvar logger = new lib.Logger(_version$m.version);\n\t;\n\t;\n\t///////////////////////////////\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n\t};\n\tfunction resolveName(resolver, nameOrPromise) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var name;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0: return [4 /*yield*/, nameOrPromise];\n\t                case 1:\n\t                    name = _a.sent();\n\t                    // If it is already an address, just use it (after adding checksum)\n\t                    try {\n\t                        return [2 /*return*/, lib$6.getAddress(name)];\n\t                    }\n\t                    catch (error) { }\n\t                    if (!resolver) {\n\t                        logger.throwError("a provider or signer is needed to resolve ENS names", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            operation: "resolveName"\n\t                        });\n\t                    }\n\t                    return [4 /*yield*/, resolver.resolveName(name)];\n\t                case 2: return [2 /*return*/, _a.sent()];\n\t            }\n\t        });\n\t    });\n\t}\n\t// Recursively replaces ENS names with promises to resolve the name and resolves all properties\n\tfunction resolveAddresses(resolver, value, paramType) {\n\t    if (Array.isArray(paramType)) {\n\t        return Promise.all(paramType.map(function (paramType, index) {\n\t            return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n\t        }));\n\t    }\n\t    if (paramType.type === "address") {\n\t        return resolveName(resolver, value);\n\t    }\n\t    if (paramType.type === "tuple") {\n\t        return resolveAddresses(resolver, value, paramType.components);\n\t    }\n\t    if (paramType.baseType === "array") {\n\t        if (!Array.isArray(value)) {\n\t            throw new Error("invalid value for array");\n\t        }\n\t        return Promise.all(value.map(function (v) { return resolveAddresses(resolver, v, paramType.arrayChildren); }));\n\t    }\n\t    return Promise.resolve(value);\n\t}\n\tfunction populateTransaction(contract, fragment, args) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var overrides, resolved, tx, ro, roValue, leftovers;\n\t        var _this = this;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    overrides = {};\n\t                    if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {\n\t                        overrides = lib$3.shallowCopy(args.pop());\n\t                    }\n\t                    // Make sure the parameter count matches\n\t                    logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");\n\t                    // Populate "from" override (allow promises)\n\t                    if (contract.signer) {\n\t                        if (overrides.from) {\n\t                            // Contracts with a Signer are from the Signer\'s frame-of-reference;\n\t                            // but we allow overriding "from" if it matches the signer\n\t                            overrides.from = lib$3.resolveProperties({\n\t                                override: resolveName(contract.signer, overrides.from),\n\t                                signer: contract.signer.getAddress()\n\t                            }).then(function (check) { return __awaiter(_this, void 0, void 0, function () {\n\t                                return __generator(this, function (_a) {\n\t                                    if (lib$6.getAddress(check.signer) !== check.override) {\n\t                                        logger.throwError("Contract with a Signer cannot override from", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                            operation: "overrides.from"\n\t                                        });\n\t                                    }\n\t                                    return [2 /*return*/, check.override];\n\t                                });\n\t                            }); });\n\t                        }\n\t                        else {\n\t                            overrides.from = contract.signer.getAddress();\n\t                        }\n\t                    }\n\t                    else if (overrides.from) {\n\t                        overrides.from = resolveName(contract.provider, overrides.from);\n\t                        //} else {\n\t                        // Contracts without a signer can override "from", and if\n\t                        // unspecified the zero address is used\n\t                        //overrides.from = AddressZero;\n\t                    }\n\t                    return [4 /*yield*/, lib$3.resolveProperties({\n\t                            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n\t                            address: contract.resolvedAddress,\n\t                            overrides: (lib$3.resolveProperties(overrides) || {})\n\t                        })];\n\t                case 1:\n\t                    resolved = _a.sent();\n\t                    tx = {\n\t                        data: contract.interface.encodeFunctionData(fragment, resolved.args),\n\t                        to: resolved.address\n\t                    };\n\t                    ro = resolved.overrides;\n\t                    // Populate simple overrides\n\t                    if (ro.nonce != null) {\n\t                        tx.nonce = lib$2.BigNumber.from(ro.nonce).toNumber();\n\t                    }\n\t                    if (ro.gasLimit != null) {\n\t                        tx.gasLimit = lib$2.BigNumber.from(ro.gasLimit);\n\t                    }\n\t                    if (ro.gasPrice != null) {\n\t                        tx.gasPrice = lib$2.BigNumber.from(ro.gasPrice);\n\t                    }\n\t                    if (ro.from != null) {\n\t                        tx.from = ro.from;\n\t                    }\n\t                    // If there was no "gasLimit" override, but the ABI specifies a default, use it\n\t                    if (tx.gasLimit == null && fragment.gas != null) {\n\t                        tx.gasLimit = lib$2.BigNumber.from(fragment.gas).add(21000);\n\t                    }\n\t                    // Populate "value" override\n\t                    if (ro.value) {\n\t                        roValue = lib$2.BigNumber.from(ro.value);\n\t                        if (!roValue.isZero() && !fragment.payable) {\n\t                            logger.throwError("non-payable method cannot override value", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: "overrides.value",\n\t                                value: overrides.value\n\t                            });\n\t                        }\n\t                        tx.value = roValue;\n\t                    }\n\t                    // Remvoe the overrides\n\t                    delete overrides.nonce;\n\t                    delete overrides.gasLimit;\n\t                    delete overrides.gasPrice;\n\t                    delete overrides.from;\n\t                    delete overrides.value;\n\t                    leftovers = Object.keys(overrides).filter(function (key) { return (overrides[key] != null); });\n\t                    if (leftovers.length) {\n\t                        logger.throwError("cannot override " + leftovers.map(function (l) { return JSON.stringify(l); }).join(","), lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            operation: "overrides",\n\t                            overrides: leftovers\n\t                        });\n\t                    }\n\t                    return [2 /*return*/, tx];\n\t            }\n\t        });\n\t    });\n\t}\n\tfunction buildPopulate(contract, fragment) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, populateTransaction(contract, fragment, args)];\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildEstimate(contract, fragment) {\n\t    var signerOrProvider = (contract.signer || contract.provider);\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var tx;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!signerOrProvider) {\n\t                            logger.throwError("estimate require a provider or signer", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: "estimateGas"\n\t                            });\n\t                        }\n\t                        return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 1:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, signerOrProvider.estimateGas(tx)];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildCall(contract, fragment, collapseSimple) {\n\t    var signerOrProvider = (contract.signer || contract.provider);\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockTag, overrides, tx, result, value;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        blockTag = undefined;\n\t                        if (!(args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object")) return [3 /*break*/, 3];\n\t                        overrides = lib$3.shallowCopy(args.pop());\n\t                        if (!(overrides.blockTag != null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, overrides.blockTag];\n\t                    case 1:\n\t                        blockTag = _a.sent();\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        delete overrides.blockTag;\n\t                        args.push(overrides);\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        if (!(contract.deployTransaction != null)) return [3 /*break*/, 5];\n\t                        return [4 /*yield*/, contract._deployed(blockTag)];\n\t                    case 4:\n\t                        _a.sent();\n\t                        _a.label = 5;\n\t                    case 5: return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 6:\n\t                        tx = _a.sent();\n\t                        return [4 /*yield*/, signerOrProvider.call(tx, blockTag)];\n\t                    case 7:\n\t                        result = _a.sent();\n\t                        try {\n\t                            value = contract.interface.decodeFunctionResult(fragment, result);\n\t                            if (collapseSimple && fragment.outputs.length === 1) {\n\t                                value = value[0];\n\t                            }\n\t                            return [2 /*return*/, value];\n\t                        }\n\t                        catch (error) {\n\t                            if (error.code === lib.Logger.errors.CALL_EXCEPTION) {\n\t                                error.address = contract.address;\n\t                                error.args = args;\n\t                                error.transaction = tx;\n\t                            }\n\t                            throw error;\n\t                        }\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildSend(contract, fragment) {\n\t    return function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var txRequest, tx, wait;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!contract.signer) {\n\t                            logger.throwError("sending a transaction requires a signer", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: "sendTransaction"\n\t                            });\n\t                        }\n\t                        if (!(contract.deployTransaction != null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, contract._deployed()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        _a.label = 2;\n\t                    case 2: return [4 /*yield*/, populateTransaction(contract, fragment, args)];\n\t                    case 3:\n\t                        txRequest = _a.sent();\n\t                        return [4 /*yield*/, contract.signer.sendTransaction(txRequest)];\n\t                    case 4:\n\t                        tx = _a.sent();\n\t                        wait = tx.wait.bind(tx);\n\t                        tx.wait = function (confirmations) {\n\t                            return wait(confirmations).then(function (receipt) {\n\t                                receipt.events = receipt.logs.map(function (log) {\n\t                                    var event = lib$3.deepCopy(log);\n\t                                    var parsed = null;\n\t                                    try {\n\t                                        parsed = contract.interface.parseLog(log);\n\t                                    }\n\t                                    catch (e) { }\n\t                                    // Successfully parsed the event log; include it\n\t                                    if (parsed) {\n\t                                        event.args = parsed.args;\n\t                                        event.decode = function (data, topics) {\n\t                                            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n\t                                        };\n\t                                        event.event = parsed.name;\n\t                                        event.eventSignature = parsed.signature;\n\t                                    }\n\t                                    // Useful operations\n\t                                    event.removeListener = function () { return contract.provider; };\n\t                                    event.getBlock = function () {\n\t                                        return contract.provider.getBlock(receipt.blockHash);\n\t                                    };\n\t                                    event.getTransaction = function () {\n\t                                        return contract.provider.getTransaction(receipt.transactionHash);\n\t                                    };\n\t                                    event.getTransactionReceipt = function () {\n\t                                        return Promise.resolve(receipt);\n\t                                    };\n\t                                    return event;\n\t                                });\n\t                                return receipt;\n\t                            });\n\t                        };\n\t                        return [2 /*return*/, tx];\n\t                }\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildDefault(contract, fragment, collapseSimple) {\n\t    if (fragment.constant) {\n\t        return buildCall(contract, fragment, collapseSimple);\n\t    }\n\t    return buildSend(contract, fragment);\n\t}\n\tfunction getEventTag(filter) {\n\t    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n\t        return "*";\n\t    }\n\t    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map(function (topic) {\n\t        if (Array.isArray(topic)) {\n\t            return topic.join("|");\n\t        }\n\t        return topic;\n\t    }).join(":") : "");\n\t}\n\tvar RunningEvent = /** @class */ (function () {\n\t    function RunningEvent(tag, filter) {\n\t        lib$3.defineReadOnly(this, "tag", tag);\n\t        lib$3.defineReadOnly(this, "filter", filter);\n\t        this._listeners = [];\n\t    }\n\t    RunningEvent.prototype.addListener = function (listener, once) {\n\t        this._listeners.push({ listener: listener, once: once });\n\t    };\n\t    RunningEvent.prototype.removeListener = function (listener) {\n\t        var done = false;\n\t        this._listeners = this._listeners.filter(function (item) {\n\t            if (done || item.listener !== listener) {\n\t                return true;\n\t            }\n\t            done = true;\n\t            return false;\n\t        });\n\t    };\n\t    RunningEvent.prototype.removeAllListeners = function () {\n\t        this._listeners = [];\n\t    };\n\t    RunningEvent.prototype.listeners = function () {\n\t        return this._listeners.map(function (i) { return i.listener; });\n\t    };\n\t    RunningEvent.prototype.listenerCount = function () {\n\t        return this._listeners.length;\n\t    };\n\t    RunningEvent.prototype.run = function (args) {\n\t        var _this = this;\n\t        var listenerCount = this.listenerCount();\n\t        this._listeners = this._listeners.filter(function (item) {\n\t            var argsCopy = args.slice();\n\t            // Call the callback in the next event loop\n\t            setTimeout(function () {\n\t                item.listener.apply(_this, argsCopy);\n\t            }, 0);\n\t            // Reschedule it if it not "once"\n\t            return !(item.once);\n\t        });\n\t        return listenerCount;\n\t    };\n\t    RunningEvent.prototype.prepareEvent = function (event) {\n\t    };\n\t    // Returns the array that will be applied to an emit\n\t    RunningEvent.prototype.getEmit = function (event) {\n\t        return [event];\n\t    };\n\t    return RunningEvent;\n\t}());\n\tvar ErrorRunningEvent = /** @class */ (function (_super) {\n\t    __extends(ErrorRunningEvent, _super);\n\t    function ErrorRunningEvent() {\n\t        return _super.call(this, "error", null) || this;\n\t    }\n\t    return ErrorRunningEvent;\n\t}(RunningEvent));\n\t// @TODO Fragment should inherit Wildcard? and just override getEmit?\n\t//       or have a common abstract super class, with enough constructor\n\t//       options to configure both.\n\t// A Fragment Event will populate all the properties that Wildcard\n\t// will, and additioanlly dereference the arguments when emitting\n\tvar FragmentRunningEvent = /** @class */ (function (_super) {\n\t    __extends(FragmentRunningEvent, _super);\n\t    function FragmentRunningEvent(address, contractInterface, fragment, topics) {\n\t        var _this = this;\n\t        var filter = {\n\t            address: address\n\t        };\n\t        var topic = contractInterface.getEventTopic(fragment);\n\t        if (topics) {\n\t            if (topic !== topics[0]) {\n\t                logger.throwArgumentError("topic mismatch", "topics", topics);\n\t            }\n\t            filter.topics = topics.slice();\n\t        }\n\t        else {\n\t            filter.topics = [topic];\n\t        }\n\t        _this = _super.call(this, getEventTag(filter), filter) || this;\n\t        lib$3.defineReadOnly(_this, "address", address);\n\t        lib$3.defineReadOnly(_this, "interface", contractInterface);\n\t        lib$3.defineReadOnly(_this, "fragment", fragment);\n\t        return _this;\n\t    }\n\t    FragmentRunningEvent.prototype.prepareEvent = function (event) {\n\t        var _this = this;\n\t        _super.prototype.prepareEvent.call(this, event);\n\t        event.event = this.fragment.name;\n\t        event.eventSignature = this.fragment.format();\n\t        event.decode = function (data, topics) {\n\t            return _this.interface.decodeEventLog(_this.fragment, data, topics);\n\t        };\n\t        try {\n\t            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n\t        }\n\t        catch (error) {\n\t            event.args = null;\n\t            event.decodeError = error;\n\t        }\n\t    };\n\t    FragmentRunningEvent.prototype.getEmit = function (event) {\n\t        var errors = lib$a.checkResultErrors(event.args);\n\t        if (errors.length) {\n\t            throw errors[0].error;\n\t        }\n\t        var args = (event.args || []).slice();\n\t        args.push(event);\n\t        return args;\n\t    };\n\t    return FragmentRunningEvent;\n\t}(RunningEvent));\n\t// A Wildard Event will attempt to populate:\n\t//  - event            The name of the event name\n\t//  - eventSignature   The full signature of the event\n\t//  - decode           A function to decode data and topics\n\t//  - args             The decoded data and topics\n\tvar WildcardRunningEvent = /** @class */ (function (_super) {\n\t    __extends(WildcardRunningEvent, _super);\n\t    function WildcardRunningEvent(address, contractInterface) {\n\t        var _this = _super.call(this, "*", { address: address }) || this;\n\t        lib$3.defineReadOnly(_this, "address", address);\n\t        lib$3.defineReadOnly(_this, "interface", contractInterface);\n\t        return _this;\n\t    }\n\t    WildcardRunningEvent.prototype.prepareEvent = function (event) {\n\t        var _this = this;\n\t        _super.prototype.prepareEvent.call(this, event);\n\t        try {\n\t            var parsed_1 = this.interface.parseLog(event);\n\t            event.event = parsed_1.name;\n\t            event.eventSignature = parsed_1.signature;\n\t            event.decode = function (data, topics) {\n\t                return _this.interface.decodeEventLog(parsed_1.eventFragment, data, topics);\n\t            };\n\t            event.args = parsed_1.args;\n\t        }\n\t        catch (error) {\n\t            // No matching event\n\t        }\n\t    };\n\t    return WildcardRunningEvent;\n\t}(RunningEvent));\n\tvar Contract = /** @class */ (function () {\n\t    function Contract(addressOrName, contractInterface, signerOrProvider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Contract);\n\t        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n\t        //address = getAddress(address);\n\t        lib$3.defineReadOnly(this, "interface", lib$3.getStatic((_newTarget), "getInterface")(contractInterface));\n\t        if (signerOrProvider == null) {\n\t            lib$3.defineReadOnly(this, "provider", null);\n\t            lib$3.defineReadOnly(this, "signer", null);\n\t        }\n\t        else if (lib$c.Signer.isSigner(signerOrProvider)) {\n\t            lib$3.defineReadOnly(this, "provider", signerOrProvider.provider || null);\n\t            lib$3.defineReadOnly(this, "signer", signerOrProvider);\n\t        }\n\t        else if (lib$b.Provider.isProvider(signerOrProvider)) {\n\t            lib$3.defineReadOnly(this, "provider", signerOrProvider);\n\t            lib$3.defineReadOnly(this, "signer", null);\n\t        }\n\t        else {\n\t            logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);\n\t        }\n\t        lib$3.defineReadOnly(this, "callStatic", {});\n\t        lib$3.defineReadOnly(this, "estimateGas", {});\n\t        lib$3.defineReadOnly(this, "functions", {});\n\t        lib$3.defineReadOnly(this, "populateTransaction", {});\n\t        lib$3.defineReadOnly(this, "filters", {});\n\t        {\n\t            var uniqueFilters_1 = {};\n\t            Object.keys(this.interface.events).forEach(function (eventSignature) {\n\t                var event = _this.interface.events[eventSignature];\n\t                lib$3.defineReadOnly(_this.filters, eventSignature, function () {\n\t                    var args = [];\n\t                    for (var _i = 0; _i < arguments.length; _i++) {\n\t                        args[_i] = arguments[_i];\n\t                    }\n\t                    return {\n\t                        address: _this.address,\n\t                        topics: _this.interface.encodeFilterTopics(event, args)\n\t                    };\n\t                });\n\t                if (!uniqueFilters_1[event.name]) {\n\t                    uniqueFilters_1[event.name] = [];\n\t                }\n\t                uniqueFilters_1[event.name].push(eventSignature);\n\t            });\n\t            Object.keys(uniqueFilters_1).forEach(function (name) {\n\t                var filters = uniqueFilters_1[name];\n\t                if (filters.length === 1) {\n\t                    lib$3.defineReadOnly(_this.filters, name, _this.filters[filters[0]]);\n\t                }\n\t                else {\n\t                    logger.warn("Duplicate definition of " + name + " (" + filters.join(", ") + ")");\n\t                }\n\t            });\n\t        }\n\t        lib$3.defineReadOnly(this, "_runningEvents", {});\n\t        lib$3.defineReadOnly(this, "_wrappedEmits", {});\n\t        lib$3.defineReadOnly(this, "address", addressOrName);\n\t        if (this.provider) {\n\t            lib$3.defineReadOnly(this, "resolvedAddress", this.provider.resolveName(addressOrName).then(function (address) {\n\t                if (address == null) {\n\t                    throw new Error("name not found");\n\t                }\n\t                return address;\n\t            }).catch(function (error) {\n\t                console.log("ERROR: Cannot find Contract - " + addressOrName);\n\t                throw error;\n\t            }));\n\t        }\n\t        else {\n\t            try {\n\t                lib$3.defineReadOnly(this, "resolvedAddress", Promise.resolve(lib$6.getAddress(addressOrName)));\n\t            }\n\t            catch (error) {\n\t                // Without a provider, we cannot use ENS names\n\t                logger.throwError("provider is required to use ENS name as contract address", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                    operation: "new Contract"\n\t                });\n\t            }\n\t        }\n\t        var uniqueNames = {};\n\t        var uniqueSignatures = {};\n\t        Object.keys(this.interface.functions).forEach(function (signature) {\n\t            var fragment = _this.interface.functions[signature];\n\t            // Check that the signature is unique; if not the ABI generation has\n\t            // not been cleaned or may be incorrectly generated\n\t            if (uniqueSignatures[signature]) {\n\t                logger.warn("Duplicate ABI entry for " + JSON.stringify(name));\n\t                return;\n\t            }\n\t            uniqueSignatures[signature] = true;\n\t            // Track unique names; we only expose bare named functions if they\n\t            // are ambiguous\n\t            {\n\t                var name_1 = fragment.name;\n\t                if (!uniqueNames[name_1]) {\n\t                    uniqueNames[name_1] = [];\n\t                }\n\t                uniqueNames[name_1].push(signature);\n\t            }\n\t            if (_this[signature] == null) {\n\t                lib$3.defineReadOnly(_this, signature, buildDefault(_this, fragment, true));\n\t            }\n\t            // We do not collapse simple calls on this bucket, which allows\n\t            // frameworks to safely use this without introspection as well as\n\t            // allows decoding error recovery.\n\t            if (_this.functions[signature] == null) {\n\t                lib$3.defineReadOnly(_this.functions, signature, buildDefault(_this, fragment, false));\n\t            }\n\t            if (_this.callStatic[signature] == null) {\n\t                lib$3.defineReadOnly(_this.callStatic, signature, buildCall(_this, fragment, true));\n\t            }\n\t            if (_this.populateTransaction[signature] == null) {\n\t                lib$3.defineReadOnly(_this.populateTransaction, signature, buildPopulate(_this, fragment));\n\t            }\n\t            if (_this.estimateGas[signature] == null) {\n\t                lib$3.defineReadOnly(_this.estimateGas, signature, buildEstimate(_this, fragment));\n\t            }\n\t        });\n\t        Object.keys(uniqueNames).forEach(function (name) {\n\t            // Ambiguous names to not get attached as bare names\n\t            var signatures = uniqueNames[name];\n\t            if (signatures.length > 1) {\n\t                return;\n\t            }\n\t            var signature = signatures[0];\n\t            if (_this[name] == null) {\n\t                lib$3.defineReadOnly(_this, name, _this[signature]);\n\t            }\n\t            if (_this.functions[name] == null) {\n\t                lib$3.defineReadOnly(_this.functions, name, _this.functions[signature]);\n\t            }\n\t            if (_this.callStatic[name] == null) {\n\t                lib$3.defineReadOnly(_this.callStatic, name, _this.callStatic[signature]);\n\t            }\n\t            if (_this.populateTransaction[name] == null) {\n\t                lib$3.defineReadOnly(_this.populateTransaction, name, _this.populateTransaction[signature]);\n\t            }\n\t            if (_this.estimateGas[name] == null) {\n\t                lib$3.defineReadOnly(_this.estimateGas, name, _this.estimateGas[signature]);\n\t            }\n\t        });\n\t    }\n\t    Contract.getContractAddress = function (transaction) {\n\t        return lib$6.getContractAddress(transaction);\n\t    };\n\t    Contract.getInterface = function (contractInterface) {\n\t        if (lib$a.Interface.isInterface(contractInterface)) {\n\t            return contractInterface;\n\t        }\n\t        return new lib$a.Interface(contractInterface);\n\t    };\n\t    // @TODO: Allow timeout?\n\t    Contract.prototype.deployed = function () {\n\t        return this._deployed();\n\t    };\n\t    Contract.prototype._deployed = function (blockTag) {\n\t        var _this = this;\n\t        if (!this._deployedPromise) {\n\t            // If we were just deployed, we know the transaction we should occur in\n\t            if (this.deployTransaction) {\n\t                this._deployedPromise = this.deployTransaction.wait().then(function () {\n\t                    return _this;\n\t                });\n\t            }\n\t            else {\n\t                // @TODO: Once we allow a timeout to be passed in, we will wait\n\t                // up to that many blocks for getCode\n\t                // Otherwise, poll for our code to be deployed\n\t                this._deployedPromise = this.provider.getCode(this.address, blockTag).then(function (code) {\n\t                    if (code === "0x") {\n\t                        logger.throwError("contract not deployed", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                            contractAddress: _this.address,\n\t                            operation: "getDeployed"\n\t                        });\n\t                    }\n\t                    return _this;\n\t                });\n\t            }\n\t        }\n\t        return this._deployedPromise;\n\t    };\n\t    // @TODO:\n\t    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n\t    // @TODO:\n\t    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n\t    Contract.prototype.fallback = function (overrides) {\n\t        var _this = this;\n\t        if (!this.signer) {\n\t            logger.throwError("sending a transactions require a signer", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });\n\t        }\n\t        var tx = lib$3.shallowCopy(overrides || {});\n\t        ["from", "to"].forEach(function (key) {\n\t            if (tx[key] == null) {\n\t                return;\n\t            }\n\t            logger.throwError("cannot override " + key, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n\t        });\n\t        tx.to = this.resolvedAddress;\n\t        return this.deployed().then(function () {\n\t            return _this.signer.sendTransaction(tx);\n\t        });\n\t    };\n\t    // Reconnect to a different signer or provider\n\t    Contract.prototype.connect = function (signerOrProvider) {\n\t        if (typeof (signerOrProvider) === "string") {\n\t            signerOrProvider = new lib$c.VoidSigner(signerOrProvider, this.provider);\n\t        }\n\t        var contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n\t        if (this.deployTransaction) {\n\t            lib$3.defineReadOnly(contract, "deployTransaction", this.deployTransaction);\n\t        }\n\t        return contract;\n\t    };\n\t    // Re-attach to a different on-chain instance of this contract\n\t    Contract.prototype.attach = function (addressOrName) {\n\t        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n\t    };\n\t    Contract.isIndexed = function (value) {\n\t        return lib$a.Indexed.isIndexed(value);\n\t    };\n\t    Contract.prototype._normalizeRunningEvent = function (runningEvent) {\n\t        // Already have an instance of this event running; we can re-use it\n\t        if (this._runningEvents[runningEvent.tag]) {\n\t            return this._runningEvents[runningEvent.tag];\n\t        }\n\t        return runningEvent;\n\t    };\n\t    Contract.prototype._getRunningEvent = function (eventName) {\n\t        if (typeof (eventName) === "string") {\n\t            // Listen for "error" events (if your contract has an error event, include\n\t            // the full signature to bypass this special event keyword)\n\t            if (eventName === "error") {\n\t                return this._normalizeRunningEvent(new ErrorRunningEvent());\n\t            }\n\t            // Listen for any event that is registered\n\t            if (eventName === "event") {\n\t                return this._normalizeRunningEvent(new RunningEvent("event", null));\n\t            }\n\t            // Listen for any event\n\t            if (eventName === "*") {\n\t                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n\t            }\n\t            // Get the event Fragment (throws if ambiguous/unknown event)\n\t            var fragment = this.interface.getEvent(eventName);\n\t            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n\t        }\n\t        // We have topics to filter by...\n\t        if (eventName.topics && eventName.topics.length > 0) {\n\t            // Is it a known topichash? (throws if no matching topichash)\n\t            try {\n\t                var topic = eventName.topics[0];\n\t                if (typeof (topic) !== "string") {\n\t                    throw new Error("invalid topic"); // @TODO: May happen for anonymous events\n\t                }\n\t                var fragment = this.interface.getEvent(topic);\n\t                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n\t            }\n\t            catch (error) { }\n\t            // Filter by the unknown topichash\n\t            var filter = {\n\t                address: this.address,\n\t                topics: eventName.topics\n\t            };\n\t            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n\t        }\n\t        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n\t    };\n\t    Contract.prototype._checkRunningEvents = function (runningEvent) {\n\t        if (runningEvent.listenerCount() === 0) {\n\t            delete this._runningEvents[runningEvent.tag];\n\t            // If we have a poller for this, remove it\n\t            var emit = this._wrappedEmits[runningEvent.tag];\n\t            if (emit) {\n\t                this.provider.off(runningEvent.filter, emit);\n\t                delete this._wrappedEmits[runningEvent.tag];\n\t            }\n\t        }\n\t    };\n\t    // Subclasses can override this to gracefully recover\n\t    // from parse errors if they wish\n\t    Contract.prototype._wrapEvent = function (runningEvent, log, listener) {\n\t        var _this = this;\n\t        var event = lib$3.deepCopy(log);\n\t        event.removeListener = function () {\n\t            if (!listener) {\n\t                return;\n\t            }\n\t            runningEvent.removeListener(listener);\n\t            _this._checkRunningEvents(runningEvent);\n\t        };\n\t        event.getBlock = function () { return _this.provider.getBlock(log.blockHash); };\n\t        event.getTransaction = function () { return _this.provider.getTransaction(log.transactionHash); };\n\t        event.getTransactionReceipt = function () { return _this.provider.getTransactionReceipt(log.transactionHash); };\n\t        // This may throw if the topics and data mismatch the signature\n\t        runningEvent.prepareEvent(event);\n\t        return event;\n\t    };\n\t    Contract.prototype._addEventListener = function (runningEvent, listener, once) {\n\t        var _this = this;\n\t        if (!this.provider) {\n\t            logger.throwError("events require a provider or a signer with a provider", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: "once" });\n\t        }\n\t        runningEvent.addListener(listener, once);\n\t        // Track this running event and its listeners (may already be there; but no hard in updating)\n\t        this._runningEvents[runningEvent.tag] = runningEvent;\n\t        // If we are not polling the provider, start polling\n\t        if (!this._wrappedEmits[runningEvent.tag]) {\n\t            var wrappedEmit = function (log) {\n\t                var event = _this._wrapEvent(runningEvent, log, listener);\n\t                // Try to emit the result for the parameterized event...\n\t                if (event.decodeError == null) {\n\t                    try {\n\t                        var args = runningEvent.getEmit(event);\n\t                        _this.emit.apply(_this, __spreadArrays([runningEvent.filter], args));\n\t                    }\n\t                    catch (error) {\n\t                        event.decodeError = error.error;\n\t                    }\n\t                }\n\t                // Always emit "event" for fragment-base events\n\t                if (runningEvent.filter != null) {\n\t                    _this.emit("event", event);\n\t                }\n\t                // Emit "error" if there was an error\n\t                if (event.decodeError != null) {\n\t                    _this.emit("error", event.decodeError, event);\n\t                }\n\t            };\n\t            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n\t            // Special events, like "error" do not have a filter\n\t            if (runningEvent.filter != null) {\n\t                this.provider.on(runningEvent.filter, wrappedEmit);\n\t            }\n\t        }\n\t    };\n\t    Contract.prototype.queryFilter = function (event, fromBlockOrBlockhash, toBlock) {\n\t        var _this = this;\n\t        var runningEvent = this._getRunningEvent(event);\n\t        var filter = lib$3.shallowCopy(runningEvent.filter);\n\t        if (typeof (fromBlockOrBlockhash) === "string" && lib$1.isHexString(fromBlockOrBlockhash, 32)) {\n\t            if (toBlock != null) {\n\t                logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);\n\t            }\n\t            filter.blockHash = fromBlockOrBlockhash;\n\t        }\n\t        else {\n\t            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n\t            filter.toBlock = ((toBlock != null) ? toBlock : "latest");\n\t        }\n\t        return this.provider.getLogs(filter).then(function (logs) {\n\t            return logs.map(function (log) { return _this._wrapEvent(runningEvent, log, null); });\n\t        });\n\t    };\n\t    Contract.prototype.on = function (event, listener) {\n\t        this._addEventListener(this._getRunningEvent(event), listener, false);\n\t        return this;\n\t    };\n\t    Contract.prototype.once = function (event, listener) {\n\t        this._addEventListener(this._getRunningEvent(event), listener, true);\n\t        return this;\n\t    };\n\t    Contract.prototype.emit = function (eventName) {\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        if (!this.provider) {\n\t            return false;\n\t        }\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        var result = (runningEvent.run(args) > 0);\n\t        // May have drained all the "once" events; check for living events\n\t        this._checkRunningEvents(runningEvent);\n\t        return result;\n\t    };\n\t    Contract.prototype.listenerCount = function (eventName) {\n\t        if (!this.provider) {\n\t            return 0;\n\t        }\n\t        return this._getRunningEvent(eventName).listenerCount();\n\t    };\n\t    Contract.prototype.listeners = function (eventName) {\n\t        if (!this.provider) {\n\t            return [];\n\t        }\n\t        if (eventName == null) {\n\t            var result_1 = [];\n\t            for (var tag in this._runningEvents) {\n\t                this._runningEvents[tag].listeners().forEach(function (listener) {\n\t                    result_1.push(listener);\n\t                });\n\t            }\n\t            return result_1;\n\t        }\n\t        return this._getRunningEvent(eventName).listeners();\n\t    };\n\t    Contract.prototype.removeAllListeners = function (eventName) {\n\t        if (!this.provider) {\n\t            return this;\n\t        }\n\t        if (eventName == null) {\n\t            for (var tag in this._runningEvents) {\n\t                var runningEvent_1 = this._runningEvents[tag];\n\t                runningEvent_1.removeAllListeners();\n\t                this._checkRunningEvents(runningEvent_1);\n\t            }\n\t            return this;\n\t        }\n\t        // Delete any listeners\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        runningEvent.removeAllListeners();\n\t        this._checkRunningEvents(runningEvent);\n\t        return this;\n\t    };\n\t    Contract.prototype.off = function (eventName, listener) {\n\t        if (!this.provider) {\n\t            return this;\n\t        }\n\t        var runningEvent = this._getRunningEvent(eventName);\n\t        runningEvent.removeListener(listener);\n\t        this._checkRunningEvents(runningEvent);\n\t        return this;\n\t    };\n\t    Contract.prototype.removeListener = function (eventName, listener) {\n\t        return this.off(eventName, listener);\n\t    };\n\t    return Contract;\n\t}());\n\texports.Contract = Contract;\n\tvar ContractFactory = /** @class */ (function () {\n\t    function ContractFactory(contractInterface, bytecode, signer) {\n\t        var _newTarget = this.constructor;\n\t        var bytecodeHex = null;\n\t        if (typeof (bytecode) === "string") {\n\t            bytecodeHex = bytecode;\n\t        }\n\t        else if (lib$1.isBytes(bytecode)) {\n\t            bytecodeHex = lib$1.hexlify(bytecode);\n\t        }\n\t        else if (bytecode && typeof (bytecode.object) === "string") {\n\t            // Allow the bytecode object from the Solidity compiler\n\t            bytecodeHex = bytecode.object;\n\t        }\n\t        else {\n\t            // Crash in the next verification step\n\t            bytecodeHex = "!";\n\t        }\n\t        // Make sure it is 0x prefixed\n\t        if (bytecodeHex.substring(0, 2) !== "0x") {\n\t            bytecodeHex = "0x" + bytecodeHex;\n\t        }\n\t        // Make sure the final result is valid bytecode\n\t        if (!lib$1.isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n\t            logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);\n\t        }\n\t        // If we have a signer, make sure it is valid\n\t        if (signer && !lib$c.Signer.isSigner(signer)) {\n\t            logger.throwArgumentError("invalid signer", "signer", signer);\n\t        }\n\t        lib$3.defineReadOnly(this, "bytecode", bytecodeHex);\n\t        lib$3.defineReadOnly(this, "interface", lib$3.getStatic((_newTarget), "getInterface")(contractInterface));\n\t        lib$3.defineReadOnly(this, "signer", signer || null);\n\t    }\n\t    // @TODO: Future; rename to populteTransaction?\n\t    ContractFactory.prototype.getDeployTransaction = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        var tx = {};\n\t        // If we have 1 additional argument, we allow transaction overrides\n\t        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {\n\t            tx = lib$3.shallowCopy(args.pop());\n\t            for (var key in tx) {\n\t                if (!allowedTransactionKeys[key]) {\n\t                    throw new Error("unknown transaction override " + key);\n\t                }\n\t            }\n\t        }\n\t        // Do not allow these to be overridden in a deployment transaction\n\t        ["data", "from", "to"].forEach(function (key) {\n\t            if (tx[key] == null) {\n\t                return;\n\t            }\n\t            logger.throwError("cannot override " + key, lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n\t        });\n\t        // Make sure the call matches the constructor signature\n\t        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");\n\t        // Set the data to the bytecode + the encoded constructor arguments\n\t        tx.data = lib$1.hexlify(lib$1.concat([\n\t            this.bytecode,\n\t            this.interface.encodeDeploy(args)\n\t        ]));\n\t        return tx;\n\t    };\n\t    ContractFactory.prototype.deploy = function () {\n\t        var args = [];\n\t        for (var _i = 0; _i < arguments.length; _i++) {\n\t            args[_i] = arguments[_i];\n\t        }\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var overrides, params, unsignedTx, tx, address, contract;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        overrides = {};\n\t                        // If 1 extra parameter was passed in, it contains overrides\n\t                        if (args.length === this.interface.deploy.inputs.length + 1) {\n\t                            overrides = args.pop();\n\t                        }\n\t                        // Make sure the call matches the constructor signature\n\t                        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");\n\t                        return [4 /*yield*/, resolveAddresses(this.signer, args, this.interface.deploy.inputs)];\n\t                    case 1:\n\t                        params = _a.sent();\n\t                        params.push(overrides);\n\t                        unsignedTx = this.getDeployTransaction.apply(this, params);\n\t                        return [4 /*yield*/, this.signer.sendTransaction(unsignedTx)];\n\t                    case 2:\n\t                        tx = _a.sent();\n\t                        address = lib$3.getStatic(this.constructor, "getContractAddress")(tx);\n\t                        contract = lib$3.getStatic(this.constructor, "getContract")(address, this.interface, this.signer);\n\t                        lib$3.defineReadOnly(contract, "deployTransaction", tx);\n\t                        return [2 /*return*/, contract];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    ContractFactory.prototype.attach = function (address) {\n\t        return (this.constructor).getContract(address, this.interface, this.signer);\n\t    };\n\t    ContractFactory.prototype.connect = function (signer) {\n\t        return new (this.constructor)(this.interface, this.bytecode, signer);\n\t    };\n\t    ContractFactory.fromSolidity = function (compilerOutput, signer) {\n\t        if (compilerOutput == null) {\n\t            logger.throwError("missing compiler output", lib.Logger.errors.MISSING_ARGUMENT, { argument: "compilerOutput" });\n\t        }\n\t        if (typeof (compilerOutput) === "string") {\n\t            compilerOutput = JSON.parse(compilerOutput);\n\t        }\n\t        var abi = compilerOutput.abi;\n\t        var bytecode = null;\n\t        if (compilerOutput.bytecode) {\n\t            bytecode = compilerOutput.bytecode;\n\t        }\n\t        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n\t            bytecode = compilerOutput.evm.bytecode;\n\t        }\n\t        return new this(abi, bytecode, signer);\n\t    };\n\t    ContractFactory.getInterface = function (contractInterface) {\n\t        return Contract.getInterface(contractInterface);\n\t    };\n\t    ContractFactory.getContractAddress = function (tx) {\n\t        return lib$6.getContractAddress(tx);\n\t    };\n\t    ContractFactory.getContract = function (address, contractInterface, signer) {\n\t        return new Contract(address, contractInterface, signer);\n\t    };\n\t    return ContractFactory;\n\t}());\n\texports.ContractFactory = ContractFactory;\n\n\t});\n\n\tvar index$d = unwrapExports(lib$d);\n\tvar lib_1$d = lib$d.Contract;\n\tvar lib_2$c = lib$d.ContractFactory;\n\n\tvar lib$e = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\t/**\n\t * var basex = require("base-x");\n\t *\n\t * This implementation is heavily based on base-x. The main reason to\n\t * deviate was to prevent the dependency of Buffer.\n\t *\n\t * Contributors:\n\t *\n\t * base-x encoding\n\t * Forked from https://github.com/cryptocoinjs/bs58\n\t * Originally written by Mike Hearn for BitcoinJ\n\t * Copyright (c) 2011 Google Inc\n\t * Ported to JavaScript by Stefan Thomas\n\t * Merged Buffer refactorings from base58-native by Stephen Pair\n\t * Copyright (c) 2013 BitPay Inc\n\t *\n\t * The MIT License (MIT)\n\t *\n\t * Copyright base-x contributors (c) 2016\n\t *\n\t * Permission is hereby granted, free of charge, to any person obtaining a\n\t * copy of this software and associated documentation files (the "Software"),\n\t * to deal in the Software without restriction, including without limitation\n\t * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n\t * and/or sell copies of the Software, and to permit persons to whom the\n\t * Software is furnished to do so, subject to the following conditions:\n\t *\n\t * The above copyright notice and this permission notice shall be included in\n\t * all copies or substantial portions of the Software.\n\n\t * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\t * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\t * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\t * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\t * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n\t * IN THE SOFTWARE.\n\t *\n\t */\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar BaseX = /** @class */ (function () {\n\t    function BaseX(alphabet) {\n\t        lib$3.defineReadOnly(this, "alphabet", alphabet);\n\t        lib$3.defineReadOnly(this, "base", alphabet.length);\n\t        lib$3.defineReadOnly(this, "_alphabetMap", {});\n\t        lib$3.defineReadOnly(this, "_leader", alphabet.charAt(0));\n\t        // pre-compute lookup table\n\t        for (var i = 0; i < alphabet.length; i++) {\n\t            this._alphabetMap[alphabet.charAt(i)] = i;\n\t        }\n\t    }\n\t    BaseX.prototype.encode = function (value) {\n\t        var source = lib$1.arrayify(value);\n\t        if (source.length === 0) {\n\t            return "";\n\t        }\n\t        var digits = [0];\n\t        for (var i = 0; i < source.length; ++i) {\n\t            var carry = source[i];\n\t            for (var j = 0; j < digits.length; ++j) {\n\t                carry += digits[j] << 8;\n\t                digits[j] = carry % this.base;\n\t                carry = (carry / this.base) | 0;\n\t            }\n\t            while (carry > 0) {\n\t                digits.push(carry % this.base);\n\t                carry = (carry / this.base) | 0;\n\t            }\n\t        }\n\t        var string = "";\n\t        // deal with leading zeros\n\t        for (var k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n\t            string += this._leader;\n\t        }\n\t        // convert digits to a string\n\t        for (var q = digits.length - 1; q >= 0; --q) {\n\t            string += this.alphabet[digits[q]];\n\t        }\n\t        return string;\n\t    };\n\t    BaseX.prototype.decode = function (value) {\n\t        if (typeof (value) !== "string") {\n\t            throw new TypeError("Expected String");\n\t        }\n\t        var bytes = [];\n\t        if (value.length === 0) {\n\t            return new Uint8Array(bytes);\n\t        }\n\t        bytes.push(0);\n\t        for (var i = 0; i < value.length; i++) {\n\t            var byte = this._alphabetMap[value[i]];\n\t            if (byte === undefined) {\n\t                throw new Error("Non-base" + this.base + " character");\n\t            }\n\t            var carry = byte;\n\t            for (var j = 0; j < bytes.length; ++j) {\n\t                carry += bytes[j] * this.base;\n\t                bytes[j] = carry & 0xff;\n\t                carry >>= 8;\n\t            }\n\t            while (carry > 0) {\n\t                bytes.push(carry & 0xff);\n\t                carry >>= 8;\n\t            }\n\t        }\n\t        // deal with leading zeros\n\t        for (var k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n\t            bytes.push(0);\n\t        }\n\t        return lib$1.arrayify(new Uint8Array(bytes.reverse()));\n\t    };\n\t    return BaseX;\n\t}());\n\texports.BaseX = BaseX;\n\tvar Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");\n\texports.Base32 = Base32;\n\tvar Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");\n\texports.Base58 = Base58;\n\t//console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))\n\t//console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))\n\n\t});\n\n\tvar index$e = unwrapExports(lib$e);\n\tvar lib_1$e = lib$e.BaseX;\n\tvar lib_2$d = lib$e.Base32;\n\tvar lib_3$a = lib$e.Base58;\n\n\tvar minimalisticAssert = assert;\n\n\tfunction assert(val, msg) {\n\t  if (!val)\n\t    throw new Error(msg || \'Assertion failed\');\n\t}\n\n\tassert.equal = function assertEqual(l, r, msg) {\n\t  if (l != r)\n\t    throw new Error(msg || (\'Assertion failed: \' + l + \' != \' + r));\n\t};\n\n\tvar inherits_browser = createCommonjsModule(function (module) {\n\tif (typeof Object.create === \'function\') {\n\t  // implementation from standard node.js \'util\' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    if (superCtor) {\n\t      ctor.super_ = superCtor;\n\t      ctor.prototype = Object.create(superCtor.prototype, {\n\t        constructor: {\n\t          value: ctor,\n\t          enumerable: false,\n\t          writable: true,\n\t          configurable: true\n\t        }\n\t      });\n\t    }\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    if (superCtor) {\n\t      ctor.super_ = superCtor;\n\t      var TempCtor = function () {};\n\t      TempCtor.prototype = superCtor.prototype;\n\t      ctor.prototype = new TempCtor();\n\t      ctor.prototype.constructor = ctor;\n\t    }\n\t  };\n\t}\n\t});\n\n\t\'use strict\';\n\n\n\n\n\tvar inherits_1 = inherits_browser;\n\n\tfunction toArray(msg, enc) {\n\t  if (Array.isArray(msg))\n\t    return msg.slice();\n\t  if (!msg)\n\t    return [];\n\t  var res = [];\n\t  if (typeof msg === \'string\') {\n\t    if (!enc) {\n\t      for (var i = 0; i < msg.length; i++) {\n\t        var c = msg.charCodeAt(i);\n\t        var hi = c >> 8;\n\t        var lo = c & 0xff;\n\t        if (hi)\n\t          res.push(hi, lo);\n\t        else\n\t          res.push(lo);\n\t      }\n\t    } else if (enc === \'hex\') {\n\t      msg = msg.replace(/[^a-z0-9]+/ig, \'\');\n\t      if (msg.length % 2 !== 0)\n\t        msg = \'0\' + msg;\n\t      for (i = 0; i < msg.length; i += 2)\n\t        res.push(parseInt(msg[i] + msg[i + 1], 16));\n\t    }\n\t  } else {\n\t    for (i = 0; i < msg.length; i++)\n\t      res[i] = msg[i] | 0;\n\t  }\n\t  return res;\n\t}\n\tvar toArray_1 = toArray;\n\n\tfunction toHex(msg) {\n\t  var res = \'\';\n\t  for (var i = 0; i < msg.length; i++)\n\t    res += zero2(msg[i].toString(16));\n\t  return res;\n\t}\n\tvar toHex_1 = toHex;\n\n\tfunction htonl(w) {\n\t  var res = (w >>> 24) |\n\t            ((w >>> 8) & 0xff00) |\n\t            ((w << 8) & 0xff0000) |\n\t            ((w & 0xff) << 24);\n\t  return res >>> 0;\n\t}\n\tvar htonl_1 = htonl;\n\n\tfunction toHex32(msg, endian) {\n\t  var res = \'\';\n\t  for (var i = 0; i < msg.length; i++) {\n\t    var w = msg[i];\n\t    if (endian === \'little\')\n\t      w = htonl(w);\n\t    res += zero8(w.toString(16));\n\t  }\n\t  return res;\n\t}\n\tvar toHex32_1 = toHex32;\n\n\tfunction zero2(word) {\n\t  if (word.length === 1)\n\t    return \'0\' + word;\n\t  else\n\t    return word;\n\t}\n\tvar zero2_1 = zero2;\n\n\tfunction zero8(word) {\n\t  if (word.length === 7)\n\t    return \'0\' + word;\n\t  else if (word.length === 6)\n\t    return \'00\' + word;\n\t  else if (word.length === 5)\n\t    return \'000\' + word;\n\t  else if (word.length === 4)\n\t    return \'0000\' + word;\n\t  else if (word.length === 3)\n\t    return \'00000\' + word;\n\t  else if (word.length === 2)\n\t    return \'000000\' + word;\n\t  else if (word.length === 1)\n\t    return \'0000000\' + word;\n\t  else\n\t    return word;\n\t}\n\tvar zero8_1 = zero8;\n\n\tfunction join32(msg, start, end, endian) {\n\t  var len = end - start;\n\t  minimalisticAssert(len % 4 === 0);\n\t  var res = new Array(len / 4);\n\t  for (var i = 0, k = start; i < res.length; i++, k += 4) {\n\t    var w;\n\t    if (endian === \'big\')\n\t      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];\n\t    else\n\t      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];\n\t    res[i] = w >>> 0;\n\t  }\n\t  return res;\n\t}\n\tvar join32_1 = join32;\n\n\tfunction split32(msg, endian) {\n\t  var res = new Array(msg.length * 4);\n\t  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {\n\t    var m = msg[i];\n\t    if (endian === \'big\') {\n\t      res[k] = m >>> 24;\n\t      res[k + 1] = (m >>> 16) & 0xff;\n\t      res[k + 2] = (m >>> 8) & 0xff;\n\t      res[k + 3] = m & 0xff;\n\t    } else {\n\t      res[k + 3] = m >>> 24;\n\t      res[k + 2] = (m >>> 16) & 0xff;\n\t      res[k + 1] = (m >>> 8) & 0xff;\n\t      res[k] = m & 0xff;\n\t    }\n\t  }\n\t  return res;\n\t}\n\tvar split32_1 = split32;\n\n\tfunction rotr32(w, b) {\n\t  return (w >>> b) | (w << (32 - b));\n\t}\n\tvar rotr32_1 = rotr32;\n\n\tfunction rotl32(w, b) {\n\t  return (w << b) | (w >>> (32 - b));\n\t}\n\tvar rotl32_1 = rotl32;\n\n\tfunction sum32(a, b) {\n\t  return (a + b) >>> 0;\n\t}\n\tvar sum32_1 = sum32;\n\n\tfunction sum32_3(a, b, c) {\n\t  return (a + b + c) >>> 0;\n\t}\n\tvar sum32_3_1 = sum32_3;\n\n\tfunction sum32_4(a, b, c, d) {\n\t  return (a + b + c + d) >>> 0;\n\t}\n\tvar sum32_4_1 = sum32_4;\n\n\tfunction sum32_5(a, b, c, d, e) {\n\t  return (a + b + c + d + e) >>> 0;\n\t}\n\tvar sum32_5_1 = sum32_5;\n\n\tfunction sum64(buf, pos, ah, al) {\n\t  var bh = buf[pos];\n\t  var bl = buf[pos + 1];\n\n\t  var lo = (al + bl) >>> 0;\n\t  var hi = (lo < al ? 1 : 0) + ah + bh;\n\t  buf[pos] = hi >>> 0;\n\t  buf[pos + 1] = lo;\n\t}\n\tvar sum64_1 = sum64;\n\n\tfunction sum64_hi(ah, al, bh, bl) {\n\t  var lo = (al + bl) >>> 0;\n\t  var hi = (lo < al ? 1 : 0) + ah + bh;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_hi_1 = sum64_hi;\n\n\tfunction sum64_lo(ah, al, bh, bl) {\n\t  var lo = al + bl;\n\t  return lo >>> 0;\n\t}\n\tvar sum64_lo_1 = sum64_lo;\n\n\tfunction sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {\n\t  var carry = 0;\n\t  var lo = al;\n\t  lo = (lo + bl) >>> 0;\n\t  carry += lo < al ? 1 : 0;\n\t  lo = (lo + cl) >>> 0;\n\t  carry += lo < cl ? 1 : 0;\n\t  lo = (lo + dl) >>> 0;\n\t  carry += lo < dl ? 1 : 0;\n\n\t  var hi = ah + bh + ch + dh + carry;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_4_hi_1 = sum64_4_hi;\n\n\tfunction sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {\n\t  var lo = al + bl + cl + dl;\n\t  return lo >>> 0;\n\t}\n\tvar sum64_4_lo_1 = sum64_4_lo;\n\n\tfunction sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n\t  var carry = 0;\n\t  var lo = al;\n\t  lo = (lo + bl) >>> 0;\n\t  carry += lo < al ? 1 : 0;\n\t  lo = (lo + cl) >>> 0;\n\t  carry += lo < cl ? 1 : 0;\n\t  lo = (lo + dl) >>> 0;\n\t  carry += lo < dl ? 1 : 0;\n\t  lo = (lo + el) >>> 0;\n\t  carry += lo < el ? 1 : 0;\n\n\t  var hi = ah + bh + ch + dh + eh + carry;\n\t  return hi >>> 0;\n\t}\n\tvar sum64_5_hi_1 = sum64_5_hi;\n\n\tfunction sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {\n\t  var lo = al + bl + cl + dl + el;\n\n\t  return lo >>> 0;\n\t}\n\tvar sum64_5_lo_1 = sum64_5_lo;\n\n\tfunction rotr64_hi(ah, al, num) {\n\t  var r = (al << (32 - num)) | (ah >>> num);\n\t  return r >>> 0;\n\t}\n\tvar rotr64_hi_1 = rotr64_hi;\n\n\tfunction rotr64_lo(ah, al, num) {\n\t  var r = (ah << (32 - num)) | (al >>> num);\n\t  return r >>> 0;\n\t}\n\tvar rotr64_lo_1 = rotr64_lo;\n\n\tfunction shr64_hi(ah, al, num) {\n\t  return ah >>> num;\n\t}\n\tvar shr64_hi_1 = shr64_hi;\n\n\tfunction shr64_lo(ah, al, num) {\n\t  var r = (ah << (32 - num)) | (al >>> num);\n\t  return r >>> 0;\n\t}\n\tvar shr64_lo_1 = shr64_lo;\n\n\tvar utils = {\n\t\tinherits: inherits_1,\n\t\ttoArray: toArray_1,\n\t\ttoHex: toHex_1,\n\t\thtonl: htonl_1,\n\t\ttoHex32: toHex32_1,\n\t\tzero2: zero2_1,\n\t\tzero8: zero8_1,\n\t\tjoin32: join32_1,\n\t\tsplit32: split32_1,\n\t\trotr32: rotr32_1,\n\t\trotl32: rotl32_1,\n\t\tsum32: sum32_1,\n\t\tsum32_3: sum32_3_1,\n\t\tsum32_4: sum32_4_1,\n\t\tsum32_5: sum32_5_1,\n\t\tsum64: sum64_1,\n\t\tsum64_hi: sum64_hi_1,\n\t\tsum64_lo: sum64_lo_1,\n\t\tsum64_4_hi: sum64_4_hi_1,\n\t\tsum64_4_lo: sum64_4_lo_1,\n\t\tsum64_5_hi: sum64_5_hi_1,\n\t\tsum64_5_lo: sum64_5_lo_1,\n\t\trotr64_hi: rotr64_hi_1,\n\t\trotr64_lo: rotr64_lo_1,\n\t\tshr64_hi: shr64_hi_1,\n\t\tshr64_lo: shr64_lo_1\n\t};\n\n\t\'use strict\';\n\n\n\n\n\tfunction BlockHash() {\n\t  this.pending = null;\n\t  this.pendingTotal = 0;\n\t  this.blockSize = this.constructor.blockSize;\n\t  this.outSize = this.constructor.outSize;\n\t  this.hmacStrength = this.constructor.hmacStrength;\n\t  this.padLength = this.constructor.padLength / 8;\n\t  this.endian = \'big\';\n\n\t  this._delta8 = this.blockSize / 8;\n\t  this._delta32 = this.blockSize / 32;\n\t}\n\tvar BlockHash_1 = BlockHash;\n\n\tBlockHash.prototype.update = function update(msg, enc) {\n\t  // Convert message to array, pad it, and join into 32bit blocks\n\t  msg = utils.toArray(msg, enc);\n\t  if (!this.pending)\n\t    this.pending = msg;\n\t  else\n\t    this.pending = this.pending.concat(msg);\n\t  this.pendingTotal += msg.length;\n\n\t  // Enough data, try updating\n\t  if (this.pending.length >= this._delta8) {\n\t    msg = this.pending;\n\n\t    // Process pending data in blocks\n\t    var r = msg.length % this._delta8;\n\t    this.pending = msg.slice(msg.length - r, msg.length);\n\t    if (this.pending.length === 0)\n\t      this.pending = null;\n\n\t    msg = utils.join32(msg, 0, msg.length - r, this.endian);\n\t    for (var i = 0; i < msg.length; i += this._delta32)\n\t      this._update(msg, i, i + this._delta32);\n\t  }\n\n\t  return this;\n\t};\n\n\tBlockHash.prototype.digest = function digest(enc) {\n\t  this.update(this._pad());\n\t  minimalisticAssert(this.pending === null);\n\n\t  return this._digest(enc);\n\t};\n\n\tBlockHash.prototype._pad = function pad() {\n\t  var len = this.pendingTotal;\n\t  var bytes = this._delta8;\n\t  var k = bytes - ((len + this.padLength) % bytes);\n\t  var res = new Array(k + this.padLength);\n\t  res[0] = 0x80;\n\t  for (var i = 1; i < k; i++)\n\t    res[i] = 0;\n\n\t  // Append length\n\t  len <<= 3;\n\t  if (this.endian === \'big\') {\n\t    for (var t = 8; t < this.padLength; t++)\n\t      res[i++] = 0;\n\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = (len >>> 24) & 0xff;\n\t    res[i++] = (len >>> 16) & 0xff;\n\t    res[i++] = (len >>> 8) & 0xff;\n\t    res[i++] = len & 0xff;\n\t  } else {\n\t    res[i++] = len & 0xff;\n\t    res[i++] = (len >>> 8) & 0xff;\n\t    res[i++] = (len >>> 16) & 0xff;\n\t    res[i++] = (len >>> 24) & 0xff;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\t    res[i++] = 0;\n\n\t    for (t = 8; t < this.padLength; t++)\n\t      res[i++] = 0;\n\t  }\n\n\t  return res;\n\t};\n\n\tvar common = {\n\t\tBlockHash: BlockHash_1\n\t};\n\n\tvar _1 = {};\n\n\tvar _224 = {};\n\n\t\'use strict\';\n\n\n\tvar rotr32$1 = utils.rotr32;\n\n\tfunction ft_1(s, x, y, z) {\n\t  if (s === 0)\n\t    return ch32(x, y, z);\n\t  if (s === 1 || s === 3)\n\t    return p32(x, y, z);\n\t  if (s === 2)\n\t    return maj32(x, y, z);\n\t}\n\tvar ft_1_1 = ft_1;\n\n\tfunction ch32(x, y, z) {\n\t  return (x & y) ^ ((~x) & z);\n\t}\n\tvar ch32_1 = ch32;\n\n\tfunction maj32(x, y, z) {\n\t  return (x & y) ^ (x & z) ^ (y & z);\n\t}\n\tvar maj32_1 = maj32;\n\n\tfunction p32(x, y, z) {\n\t  return x ^ y ^ z;\n\t}\n\tvar p32_1 = p32;\n\n\tfunction s0_256(x) {\n\t  return rotr32$1(x, 2) ^ rotr32$1(x, 13) ^ rotr32$1(x, 22);\n\t}\n\tvar s0_256_1 = s0_256;\n\n\tfunction s1_256(x) {\n\t  return rotr32$1(x, 6) ^ rotr32$1(x, 11) ^ rotr32$1(x, 25);\n\t}\n\tvar s1_256_1 = s1_256;\n\n\tfunction g0_256(x) {\n\t  return rotr32$1(x, 7) ^ rotr32$1(x, 18) ^ (x >>> 3);\n\t}\n\tvar g0_256_1 = g0_256;\n\n\tfunction g1_256(x) {\n\t  return rotr32$1(x, 17) ^ rotr32$1(x, 19) ^ (x >>> 10);\n\t}\n\tvar g1_256_1 = g1_256;\n\n\tvar common$1 = {\n\t\tft_1: ft_1_1,\n\t\tch32: ch32_1,\n\t\tmaj32: maj32_1,\n\t\tp32: p32_1,\n\t\ts0_256: s0_256_1,\n\t\ts1_256: s1_256_1,\n\t\tg0_256: g0_256_1,\n\t\tg1_256: g1_256_1\n\t};\n\n\t\'use strict\';\n\n\n\n\n\n\n\tvar sum32$1 = utils.sum32;\n\tvar sum32_4$1 = utils.sum32_4;\n\tvar sum32_5$1 = utils.sum32_5;\n\tvar ch32$1 = common$1.ch32;\n\tvar maj32$1 = common$1.maj32;\n\tvar s0_256$1 = common$1.s0_256;\n\tvar s1_256$1 = common$1.s1_256;\n\tvar g0_256$1 = common$1.g0_256;\n\tvar g1_256$1 = common$1.g1_256;\n\n\tvar BlockHash$1 = common.BlockHash;\n\n\tvar sha256_K = [\n\t  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n\t  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n\t  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n\t  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n\t  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n\t  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n\t  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n\t  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n\t  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n\t  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n\t  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n\t  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n\t  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\t];\n\n\tfunction SHA256() {\n\t  if (!(this instanceof SHA256))\n\t    return new SHA256();\n\n\t  BlockHash$1.call(this);\n\t  this.h = [\n\t    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n\t    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n\t  ];\n\t  this.k = sha256_K;\n\t  this.W = new Array(64);\n\t}\n\tutils.inherits(SHA256, BlockHash$1);\n\tvar _256 = SHA256;\n\n\tSHA256.blockSize = 512;\n\tSHA256.outSize = 256;\n\tSHA256.hmacStrength = 192;\n\tSHA256.padLength = 64;\n\n\tSHA256.prototype._update = function _update(msg, start) {\n\t  var W = this.W;\n\n\t  for (var i = 0; i < 16; i++)\n\t    W[i] = msg[start + i];\n\t  for (; i < W.length; i++)\n\t    W[i] = sum32_4$1(g1_256$1(W[i - 2]), W[i - 7], g0_256$1(W[i - 15]), W[i - 16]);\n\n\t  var a = this.h[0];\n\t  var b = this.h[1];\n\t  var c = this.h[2];\n\t  var d = this.h[3];\n\t  var e = this.h[4];\n\t  var f = this.h[5];\n\t  var g = this.h[6];\n\t  var h = this.h[7];\n\n\t  minimalisticAssert(this.k.length === W.length);\n\t  for (i = 0; i < W.length; i++) {\n\t    var T1 = sum32_5$1(h, s1_256$1(e), ch32$1(e, f, g), this.k[i], W[i]);\n\t    var T2 = sum32$1(s0_256$1(a), maj32$1(a, b, c));\n\t    h = g;\n\t    g = f;\n\t    f = e;\n\t    e = sum32$1(d, T1);\n\t    d = c;\n\t    c = b;\n\t    b = a;\n\t    a = sum32$1(T1, T2);\n\t  }\n\n\t  this.h[0] = sum32$1(this.h[0], a);\n\t  this.h[1] = sum32$1(this.h[1], b);\n\t  this.h[2] = sum32$1(this.h[2], c);\n\t  this.h[3] = sum32$1(this.h[3], d);\n\t  this.h[4] = sum32$1(this.h[4], e);\n\t  this.h[5] = sum32$1(this.h[5], f);\n\t  this.h[6] = sum32$1(this.h[6], g);\n\t  this.h[7] = sum32$1(this.h[7], h);\n\t};\n\n\tSHA256.prototype._digest = function digest(enc) {\n\t  if (enc === \'hex\')\n\t    return utils.toHex32(this.h, \'big\');\n\t  else\n\t    return utils.split32(this.h, \'big\');\n\t};\n\n\tvar _384 = {};\n\n\t\'use strict\';\n\n\n\n\n\n\tvar rotr64_hi$1 = utils.rotr64_hi;\n\tvar rotr64_lo$1 = utils.rotr64_lo;\n\tvar shr64_hi$1 = utils.shr64_hi;\n\tvar shr64_lo$1 = utils.shr64_lo;\n\tvar sum64$1 = utils.sum64;\n\tvar sum64_hi$1 = utils.sum64_hi;\n\tvar sum64_lo$1 = utils.sum64_lo;\n\tvar sum64_4_hi$1 = utils.sum64_4_hi;\n\tvar sum64_4_lo$1 = utils.sum64_4_lo;\n\tvar sum64_5_hi$1 = utils.sum64_5_hi;\n\tvar sum64_5_lo$1 = utils.sum64_5_lo;\n\n\tvar BlockHash$2 = common.BlockHash;\n\n\tvar sha512_K = [\n\t  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,\n\t  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,\n\t  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n\t  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,\n\t  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,\n\t  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n\t  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,\n\t  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,\n\t  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n\t  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,\n\t  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,\n\t  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n\t  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,\n\t  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,\n\t  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n\t  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,\n\t  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,\n\t  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n\t  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,\n\t  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,\n\t  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n\t  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,\n\t  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,\n\t  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n\t  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,\n\t  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,\n\t  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n\t  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,\n\t  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,\n\t  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n\t  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,\n\t  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,\n\t  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n\t  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,\n\t  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,\n\t  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n\t  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,\n\t  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,\n\t  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n\t  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817\n\t];\n\n\tfunction SHA512() {\n\t  if (!(this instanceof SHA512))\n\t    return new SHA512();\n\n\t  BlockHash$2.call(this);\n\t  this.h = [\n\t    0x6a09e667, 0xf3bcc908,\n\t    0xbb67ae85, 0x84caa73b,\n\t    0x3c6ef372, 0xfe94f82b,\n\t    0xa54ff53a, 0x5f1d36f1,\n\t    0x510e527f, 0xade682d1,\n\t    0x9b05688c, 0x2b3e6c1f,\n\t    0x1f83d9ab, 0xfb41bd6b,\n\t    0x5be0cd19, 0x137e2179 ];\n\t  this.k = sha512_K;\n\t  this.W = new Array(160);\n\t}\n\tutils.inherits(SHA512, BlockHash$2);\n\tvar _512 = SHA512;\n\n\tSHA512.blockSize = 1024;\n\tSHA512.outSize = 512;\n\tSHA512.hmacStrength = 192;\n\tSHA512.padLength = 128;\n\n\tSHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {\n\t  var W = this.W;\n\n\t  // 32 x 32bit words\n\t  for (var i = 0; i < 32; i++)\n\t    W[i] = msg[start + i];\n\t  for (; i < W.length; i += 2) {\n\t    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2\n\t    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);\n\t    var c1_hi = W[i - 14];  // i - 7\n\t    var c1_lo = W[i - 13];\n\t    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15\n\t    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);\n\t    var c3_hi = W[i - 32];  // i - 16\n\t    var c3_lo = W[i - 31];\n\n\t    W[i] = sum64_4_hi$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo);\n\t    W[i + 1] = sum64_4_lo$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo);\n\t  }\n\t};\n\n\tSHA512.prototype._update = function _update(msg, start) {\n\t  this._prepareBlock(msg, start);\n\n\t  var W = this.W;\n\n\t  var ah = this.h[0];\n\t  var al = this.h[1];\n\t  var bh = this.h[2];\n\t  var bl = this.h[3];\n\t  var ch = this.h[4];\n\t  var cl = this.h[5];\n\t  var dh = this.h[6];\n\t  var dl = this.h[7];\n\t  var eh = this.h[8];\n\t  var el = this.h[9];\n\t  var fh = this.h[10];\n\t  var fl = this.h[11];\n\t  var gh = this.h[12];\n\t  var gl = this.h[13];\n\t  var hh = this.h[14];\n\t  var hl = this.h[15];\n\n\t  minimalisticAssert(this.k.length === W.length);\n\t  for (var i = 0; i < W.length; i += 2) {\n\t    var c0_hi = hh;\n\t    var c0_lo = hl;\n\t    var c1_hi = s1_512_hi(eh, el);\n\t    var c1_lo = s1_512_lo(eh, el);\n\t    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);\n\t    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);\n\t    var c3_hi = this.k[i];\n\t    var c3_lo = this.k[i + 1];\n\t    var c4_hi = W[i];\n\t    var c4_lo = W[i + 1];\n\n\t    var T1_hi = sum64_5_hi$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo,\n\t      c4_hi, c4_lo);\n\t    var T1_lo = sum64_5_lo$1(\n\t      c0_hi, c0_lo,\n\t      c1_hi, c1_lo,\n\t      c2_hi, c2_lo,\n\t      c3_hi, c3_lo,\n\t      c4_hi, c4_lo);\n\n\t    c0_hi = s0_512_hi(ah, al);\n\t    c0_lo = s0_512_lo(ah, al);\n\t    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);\n\t    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);\n\n\t    var T2_hi = sum64_hi$1(c0_hi, c0_lo, c1_hi, c1_lo);\n\t    var T2_lo = sum64_lo$1(c0_hi, c0_lo, c1_hi, c1_lo);\n\n\t    hh = gh;\n\t    hl = gl;\n\n\t    gh = fh;\n\t    gl = fl;\n\n\t    fh = eh;\n\t    fl = el;\n\n\t    eh = sum64_hi$1(dh, dl, T1_hi, T1_lo);\n\t    el = sum64_lo$1(dl, dl, T1_hi, T1_lo);\n\n\t    dh = ch;\n\t    dl = cl;\n\n\t    ch = bh;\n\t    cl = bl;\n\n\t    bh = ah;\n\t    bl = al;\n\n\t    ah = sum64_hi$1(T1_hi, T1_lo, T2_hi, T2_lo);\n\t    al = sum64_lo$1(T1_hi, T1_lo, T2_hi, T2_lo);\n\t  }\n\n\t  sum64$1(this.h, 0, ah, al);\n\t  sum64$1(this.h, 2, bh, bl);\n\t  sum64$1(this.h, 4, ch, cl);\n\t  sum64$1(this.h, 6, dh, dl);\n\t  sum64$1(this.h, 8, eh, el);\n\t  sum64$1(this.h, 10, fh, fl);\n\t  sum64$1(this.h, 12, gh, gl);\n\t  sum64$1(this.h, 14, hh, hl);\n\t};\n\n\tSHA512.prototype._digest = function digest(enc) {\n\t  if (enc === \'hex\')\n\t    return utils.toHex32(this.h, \'big\');\n\t  else\n\t    return utils.split32(this.h, \'big\');\n\t};\n\n\tfunction ch64_hi(xh, xl, yh, yl, zh) {\n\t  var r = (xh & yh) ^ ((~xh) & zh);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction ch64_lo(xh, xl, yh, yl, zh, zl) {\n\t  var r = (xl & yl) ^ ((~xl) & zl);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction maj64_hi(xh, xl, yh, yl, zh) {\n\t  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction maj64_lo(xh, xl, yh, yl, zh, zl) {\n\t  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s0_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 28);\n\t  var c1_hi = rotr64_hi$1(xl, xh, 2);  // 34\n\t  var c2_hi = rotr64_hi$1(xl, xh, 7);  // 39\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s0_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 28);\n\t  var c1_lo = rotr64_lo$1(xl, xh, 2);  // 34\n\t  var c2_lo = rotr64_lo$1(xl, xh, 7);  // 39\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s1_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 14);\n\t  var c1_hi = rotr64_hi$1(xh, xl, 18);\n\t  var c2_hi = rotr64_hi$1(xl, xh, 9);  // 41\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction s1_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 14);\n\t  var c1_lo = rotr64_lo$1(xh, xl, 18);\n\t  var c2_lo = rotr64_lo$1(xl, xh, 9);  // 41\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g0_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 1);\n\t  var c1_hi = rotr64_hi$1(xh, xl, 8);\n\t  var c2_hi = shr64_hi$1(xh, xl, 7);\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g0_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 1);\n\t  var c1_lo = rotr64_lo$1(xh, xl, 8);\n\t  var c2_lo = shr64_lo$1(xh, xl, 7);\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g1_512_hi(xh, xl) {\n\t  var c0_hi = rotr64_hi$1(xh, xl, 19);\n\t  var c1_hi = rotr64_hi$1(xl, xh, 29);  // 61\n\t  var c2_hi = shr64_hi$1(xh, xl, 6);\n\n\t  var r = c0_hi ^ c1_hi ^ c2_hi;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\tfunction g1_512_lo(xh, xl) {\n\t  var c0_lo = rotr64_lo$1(xh, xl, 19);\n\t  var c1_lo = rotr64_lo$1(xl, xh, 29);  // 61\n\t  var c2_lo = shr64_lo$1(xh, xl, 6);\n\n\t  var r = c0_lo ^ c1_lo ^ c2_lo;\n\t  if (r < 0)\n\t    r += 0x100000000;\n\t  return r;\n\t}\n\n\t\'use strict\';\n\n\tvar sha1 = _1;\n\tvar sha224 = _224;\n\tvar sha256 = _256;\n\tvar sha384 = _384;\n\tvar sha512 = _512;\n\n\tvar sha = {\n\t\tsha1: sha1,\n\t\tsha224: sha224,\n\t\tsha256: sha256,\n\t\tsha384: sha384,\n\t\tsha512: sha512\n\t};\n\n\t\'use strict\';\n\n\n\n\n\tvar rotl32$1 = utils.rotl32;\n\tvar sum32$2 = utils.sum32;\n\tvar sum32_3$1 = utils.sum32_3;\n\tvar sum32_4$2 = utils.sum32_4;\n\tvar BlockHash$3 = common.BlockHash;\n\n\tfunction RIPEMD160() {\n\t  if (!(this instanceof RIPEMD160))\n\t    return new RIPEMD160();\n\n\t  BlockHash$3.call(this);\n\n\t  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];\n\t  this.endian = \'little\';\n\t}\n\tutils.inherits(RIPEMD160, BlockHash$3);\n\tvar ripemd160 = RIPEMD160;\n\n\tRIPEMD160.blockSize = 512;\n\tRIPEMD160.outSize = 160;\n\tRIPEMD160.hmacStrength = 192;\n\tRIPEMD160.padLength = 64;\n\n\tRIPEMD160.prototype._update = function update(msg, start) {\n\t  var A = this.h[0];\n\t  var B = this.h[1];\n\t  var C = this.h[2];\n\t  var D = this.h[3];\n\t  var E = this.h[4];\n\t  var Ah = A;\n\t  var Bh = B;\n\t  var Ch = C;\n\t  var Dh = D;\n\t  var Eh = E;\n\t  for (var j = 0; j < 80; j++) {\n\t    var T = sum32$2(\n\t      rotl32$1(\n\t        sum32_4$2(A, f(j, B, C, D), msg[r[j] + start], K(j)),\n\t        s[j]),\n\t      E);\n\t    A = E;\n\t    E = D;\n\t    D = rotl32$1(C, 10);\n\t    C = B;\n\t    B = T;\n\t    T = sum32$2(\n\t      rotl32$1(\n\t        sum32_4$2(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),\n\t        sh[j]),\n\t      Eh);\n\t    Ah = Eh;\n\t    Eh = Dh;\n\t    Dh = rotl32$1(Ch, 10);\n\t    Ch = Bh;\n\t    Bh = T;\n\t  }\n\t  T = sum32_3$1(this.h[1], C, Dh);\n\t  this.h[1] = sum32_3$1(this.h[2], D, Eh);\n\t  this.h[2] = sum32_3$1(this.h[3], E, Ah);\n\t  this.h[3] = sum32_3$1(this.h[4], A, Bh);\n\t  this.h[4] = sum32_3$1(this.h[0], B, Ch);\n\t  this.h[0] = T;\n\t};\n\n\tRIPEMD160.prototype._digest = function digest(enc) {\n\t  if (enc === \'hex\')\n\t    return utils.toHex32(this.h, \'little\');\n\t  else\n\t    return utils.split32(this.h, \'little\');\n\t};\n\n\tfunction f(j, x, y, z) {\n\t  if (j <= 15)\n\t    return x ^ y ^ z;\n\t  else if (j <= 31)\n\t    return (x & y) | ((~x) & z);\n\t  else if (j <= 47)\n\t    return (x | (~y)) ^ z;\n\t  else if (j <= 63)\n\t    return (x & z) | (y & (~z));\n\t  else\n\t    return x ^ (y | (~z));\n\t}\n\n\tfunction K(j) {\n\t  if (j <= 15)\n\t    return 0x00000000;\n\t  else if (j <= 31)\n\t    return 0x5a827999;\n\t  else if (j <= 47)\n\t    return 0x6ed9eba1;\n\t  else if (j <= 63)\n\t    return 0x8f1bbcdc;\n\t  else\n\t    return 0xa953fd4e;\n\t}\n\n\tfunction Kh(j) {\n\t  if (j <= 15)\n\t    return 0x50a28be6;\n\t  else if (j <= 31)\n\t    return 0x5c4dd124;\n\t  else if (j <= 47)\n\t    return 0x6d703ef3;\n\t  else if (j <= 63)\n\t    return 0x7a6d76e9;\n\t  else\n\t    return 0x00000000;\n\t}\n\n\tvar r = [\n\t  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n\t  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n\t  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n\t  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n\t  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13\n\t];\n\n\tvar rh = [\n\t  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n\t  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n\t  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n\t  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n\t  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11\n\t];\n\n\tvar s = [\n\t  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n\t  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n\t  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n\t  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n\t  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6\n\t];\n\n\tvar sh = [\n\t  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n\t  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n\t  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n\t  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n\t  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11\n\t];\n\n\tvar ripemd = {\n\t\tripemd160: ripemd160\n\t};\n\n\t\'use strict\';\n\n\n\n\n\tfunction Hmac(hash, key, enc) {\n\t  if (!(this instanceof Hmac))\n\t    return new Hmac(hash, key, enc);\n\t  this.Hash = hash;\n\t  this.blockSize = hash.blockSize / 8;\n\t  this.outSize = hash.outSize / 8;\n\t  this.inner = null;\n\t  this.outer = null;\n\n\t  this._init(utils.toArray(key, enc));\n\t}\n\tvar hmac = Hmac;\n\n\tHmac.prototype._init = function init(key) {\n\t  // Shorten key, if needed\n\t  if (key.length > this.blockSize)\n\t    key = new this.Hash().update(key).digest();\n\t  minimalisticAssert(key.length <= this.blockSize);\n\n\t  // Add padding to key\n\t  for (var i = key.length; i < this.blockSize; i++)\n\t    key.push(0);\n\n\t  for (i = 0; i < key.length; i++)\n\t    key[i] ^= 0x36;\n\t  this.inner = new this.Hash().update(key);\n\n\t  // 0x36 ^ 0x5c = 0x6a\n\t  for (i = 0; i < key.length; i++)\n\t    key[i] ^= 0x6a;\n\t  this.outer = new this.Hash().update(key);\n\t};\n\n\tHmac.prototype.update = function update(msg, enc) {\n\t  this.inner.update(msg, enc);\n\t  return this;\n\t};\n\n\tHmac.prototype.digest = function digest(enc) {\n\t  this.outer.update(this.inner.digest());\n\t  return this.outer.digest(enc);\n\t};\n\n\tvar hash_1 = createCommonjsModule(function (module, exports) {\n\tvar hash = exports;\n\n\thash.utils = utils;\n\thash.common = common;\n\thash.sha = sha;\n\thash.ripemd = ripemd;\n\thash.hmac = hmac;\n\n\t// Proxy hash functions to the main object\n\thash.sha1 = hash.sha.sha1;\n\thash.sha256 = hash.sha.sha256;\n\thash.sha224 = hash.sha.sha224;\n\thash.sha384 = hash.sha.sha384;\n\thash.sha512 = hash.sha.sha512;\n\thash.ripemd160 = hash.ripemd.ripemd160;\n\t});\n\tvar hash_2 = hash_1.hmac;\n\tvar hash_3 = hash_1.ripemd160;\n\tvar hash_4 = hash_1.sha256;\n\tvar hash_5 = hash_1.sha512;\n\n\tvar _version$o = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "sha2/5.0.3";\n\n\t});\n\n\tvar _version$p = unwrapExports(_version$o);\n\tvar _version_1$c = _version$o.version;\n\n\tvar browser = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result["default"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tvar hash = __importStar(hash_1);\n\n\n\n\tvar logger = new lib.Logger(_version$o.version);\n\tvar SupportedAlgorithm;\n\t(function (SupportedAlgorithm) {\n\t    SupportedAlgorithm["sha256"] = "sha256";\n\t    SupportedAlgorithm["sha512"] = "sha512";\n\t})(SupportedAlgorithm = exports.SupportedAlgorithm || (exports.SupportedAlgorithm = {}));\n\t;\n\tfunction ripemd160(data) {\n\t    return "0x" + (hash.ripemd160().update(lib$1.arrayify(data)).digest("hex"));\n\t}\n\texports.ripemd160 = ripemd160;\n\tfunction sha256(data) {\n\t    return "0x" + (hash.sha256().update(lib$1.arrayify(data)).digest("hex"));\n\t}\n\texports.sha256 = sha256;\n\tfunction sha512(data) {\n\t    return "0x" + (hash.sha512().update(lib$1.arrayify(data)).digest("hex"));\n\t}\n\texports.sha512 = sha512;\n\tfunction computeHmac(algorithm, key, data) {\n\t    if (!SupportedAlgorithm[algorithm]) {\n\t        logger.throwError("unsupported algorithm " + algorithm, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: "hmac",\n\t            algorithm: algorithm\n\t        });\n\t    }\n\t    return "0x" + hash.hmac(hash[algorithm], lib$1.arrayify(key)).update(lib$1.arrayify(data)).digest("hex");\n\t}\n\texports.computeHmac = computeHmac;\n\n\t});\n\n\tvar browser$1 = unwrapExports(browser);\n\tvar browser_1 = browser.SupportedAlgorithm;\n\tvar browser_2 = browser.ripemd160;\n\tvar browser_3 = browser.sha256;\n\tvar browser_4 = browser.sha512;\n\tvar browser_5 = browser.computeHmac;\n\n\tvar browser$2 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tfunction pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {\n\t    password = lib$1.arrayify(password);\n\t    salt = lib$1.arrayify(salt);\n\t    var hLen;\n\t    var l = 1;\n\t    var DK = new Uint8Array(keylen);\n\t    var block1 = new Uint8Array(salt.length + 4);\n\t    block1.set(salt);\n\t    //salt.copy(block1, 0, 0, salt.length)\n\t    var r;\n\t    var T;\n\t    for (var i = 1; i <= l; i++) {\n\t        //block1.writeUInt32BE(i, salt.length)\n\t        block1[salt.length] = (i >> 24) & 0xff;\n\t        block1[salt.length + 1] = (i >> 16) & 0xff;\n\t        block1[salt.length + 2] = (i >> 8) & 0xff;\n\t        block1[salt.length + 3] = i & 0xff;\n\t        //let U = createHmac(password).update(block1).digest();\n\t        var U = lib$1.arrayify(browser.computeHmac(hashAlgorithm, password, block1));\n\t        if (!hLen) {\n\t            hLen = U.length;\n\t            T = new Uint8Array(hLen);\n\t            l = Math.ceil(keylen / hLen);\n\t            r = keylen - (l - 1) * hLen;\n\t        }\n\t        //U.copy(T, 0, 0, hLen)\n\t        T.set(U);\n\t        for (var j = 1; j < iterations; j++) {\n\t            //U = createHmac(password).update(U).digest();\n\t            U = lib$1.arrayify(browser.computeHmac(hashAlgorithm, password, U));\n\t            for (var k = 0; k < hLen; k++)\n\t                T[k] ^= U[k];\n\t        }\n\t        var destPos = (i - 1) * hLen;\n\t        var len = (i === l ? r : hLen);\n\t        //T.copy(DK, destPos, 0, len)\n\t        DK.set(lib$1.arrayify(T).slice(0, len), destPos);\n\t    }\n\t    return lib$1.hexlify(DK);\n\t}\n\texports.pbkdf2 = pbkdf2;\n\n\t});\n\n\tvar browser$3 = unwrapExports(browser$2);\n\tvar browser_1$1 = browser$2.pbkdf2;\n\n\tvar version = "6.5.3";\n\tvar _package = {\n\t\tversion: version\n\t};\n\n\tvar _package$1 = /*#__PURE__*/Object.freeze({\n\t\tversion: version,\n\t\t\'default\': _package\n\t});\n\n\tvar bn$1 = createCommonjsModule(function (module) {\n\t(function (module, exports) {\n\t  \'use strict\';\n\n\t  // Utils\n\t  function assert (val, msg) {\n\t    if (!val) throw new Error(msg || \'Assertion failed\');\n\t  }\n\n\t  // Could use `inherits` module, but don\'t want to move from single file\n\t  // architecture yet.\n\t  function inherits (ctor, superCtor) {\n\t    ctor.super_ = superCtor;\n\t    var TempCtor = function () {};\n\t    TempCtor.prototype = superCtor.prototype;\n\t    ctor.prototype = new TempCtor();\n\t    ctor.prototype.constructor = ctor;\n\t  }\n\n\t  // BN\n\n\t  function BN (number, base, endian) {\n\t    if (BN.isBN(number)) {\n\t      return number;\n\t    }\n\n\t    this.negative = 0;\n\t    this.words = null;\n\t    this.length = 0;\n\n\t    // Reduction context\n\t    this.red = null;\n\n\t    if (number !== null) {\n\t      if (base === \'le\' || base === \'be\') {\n\t        endian = base;\n\t        base = 10;\n\t      }\n\n\t      this._init(number || 0, base || 10, endian || \'be\');\n\t    }\n\t  }\n\t  if (typeof module === \'object\') {\n\t    module.exports = BN;\n\t  } else {\n\t    exports.BN = BN;\n\t  }\n\n\t  BN.BN = BN;\n\t  BN.wordSize = 26;\n\n\t  var Buffer;\n\t  try {\n\t    Buffer = require$$0.Buffer;\n\t  } catch (e) {\n\t  }\n\n\t  BN.isBN = function isBN (num) {\n\t    if (num instanceof BN) {\n\t      return true;\n\t    }\n\n\t    return num !== null && typeof num === \'object\' &&\n\t      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n\t  };\n\n\t  BN.max = function max (left, right) {\n\t    if (left.cmp(right) > 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.min = function min (left, right) {\n\t    if (left.cmp(right) < 0) return left;\n\t    return right;\n\t  };\n\n\t  BN.prototype._init = function init (number, base, endian) {\n\t    if (typeof number === \'number\') {\n\t      return this._initNumber(number, base, endian);\n\t    }\n\n\t    if (typeof number === \'object\') {\n\t      return this._initArray(number, base, endian);\n\t    }\n\n\t    if (base === \'hex\') {\n\t      base = 16;\n\t    }\n\t    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n\t    number = number.toString().replace(/\\s+/g, \'\');\n\t    var start = 0;\n\t    if (number[0] === \'-\') {\n\t      start++;\n\t    }\n\n\t    if (base === 16) {\n\t      this._parseHex(number, start);\n\t    } else {\n\t      this._parseBase(number, base, start);\n\t    }\n\n\t    if (number[0] === \'-\') {\n\t      this.negative = 1;\n\t    }\n\n\t    this.strip();\n\n\t    if (endian !== \'le\') return;\n\n\t    this._initArray(this.toArray(), base, endian);\n\t  };\n\n\t  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n\t    if (number < 0) {\n\t      this.negative = 1;\n\t      number = -number;\n\t    }\n\t    if (number < 0x4000000) {\n\t      this.words = [ number & 0x3ffffff ];\n\t      this.length = 1;\n\t    } else if (number < 0x10000000000000) {\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff\n\t      ];\n\t      this.length = 2;\n\t    } else {\n\t      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n\t      this.words = [\n\t        number & 0x3ffffff,\n\t        (number / 0x4000000) & 0x3ffffff,\n\t        1\n\t      ];\n\t      this.length = 3;\n\t    }\n\n\t    if (endian !== \'le\') return;\n\n\t    // Reverse the bytes\n\t    this._initArray(this.toArray(), base, endian);\n\t  };\n\n\t  BN.prototype._initArray = function _initArray (number, base, endian) {\n\t    // Perhaps a Uint8Array\n\t    assert(typeof number.length === \'number\');\n\t    if (number.length <= 0) {\n\t      this.words = [ 0 ];\n\t      this.length = 1;\n\t      return this;\n\t    }\n\n\t    this.length = Math.ceil(number.length / 3);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    var j, w;\n\t    var off = 0;\n\t    if (endian === \'be\') {\n\t      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n\t        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    } else if (endian === \'le\') {\n\t      for (i = 0, j = 0; i < number.length; i += 3) {\n\t        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n\t        this.words[j] |= (w << off) & 0x3ffffff;\n\t        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n\t        off += 24;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          j++;\n\t        }\n\t      }\n\t    }\n\t    return this.strip();\n\t  };\n\n\t  function parseHex (str, start, end) {\n\t    var r = 0;\n\t    var len = Math.min(str.length, end);\n\t    for (var i = start; i < len; i++) {\n\t      var c = str.charCodeAt(i) - 48;\n\n\t      r <<= 4;\n\n\t      // \'a\' - \'f\'\n\t      if (c >= 49 && c <= 54) {\n\t        r |= c - 49 + 0xa;\n\n\t      // \'A\' - \'F\'\n\t      } else if (c >= 17 && c <= 22) {\n\t        r |= c - 17 + 0xa;\n\n\t      // \'0\' - \'9\'\n\t      } else {\n\t        r |= c & 0xf;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseHex = function _parseHex (number, start) {\n\t    // Create possibly bigger array to ensure that it fits the number\n\t    this.length = Math.ceil((number.length - start) / 6);\n\t    this.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      this.words[i] = 0;\n\t    }\n\n\t    var j, w;\n\t    // Scan 24-bit chunks and add them to the number\n\t    var off = 0;\n\t    for (i = number.length - 6, j = 0; i >= start; i -= 6) {\n\t      w = parseHex(number, i, i + 6);\n\t      this.words[j] |= (w << off) & 0x3ffffff;\n\t      // NOTE: `0x3fffff` is intentional here, 26bits max shift + 24bit hex limb\n\t      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n\t      off += 24;\n\t      if (off >= 26) {\n\t        off -= 26;\n\t        j++;\n\t      }\n\t    }\n\t    if (i + 6 !== start) {\n\t      w = parseHex(number, start, i + 6);\n\t      this.words[j] |= (w << off) & 0x3ffffff;\n\t      this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;\n\t    }\n\t    this.strip();\n\t  };\n\n\t  function parseBase (str, start, end, mul) {\n\t    var r = 0;\n\t    var len = Math.min(str.length, end);\n\t    for (var i = start; i < len; i++) {\n\t      var c = str.charCodeAt(i) - 48;\n\n\t      r *= mul;\n\n\t      // \'a\'\n\t      if (c >= 49) {\n\t        r += c - 49 + 0xa;\n\n\t      // \'A\'\n\t      } else if (c >= 17) {\n\t        r += c - 17 + 0xa;\n\n\t      // \'0\' - \'9\'\n\t      } else {\n\t        r += c;\n\t      }\n\t    }\n\t    return r;\n\t  }\n\n\t  BN.prototype._parseBase = function _parseBase (number, base, start) {\n\t    // Initialize as zero\n\t    this.words = [ 0 ];\n\t    this.length = 1;\n\n\t    // Find length of limb in base\n\t    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n\t      limbLen++;\n\t    }\n\t    limbLen--;\n\t    limbPow = (limbPow / base) | 0;\n\n\t    var total = number.length - start;\n\t    var mod = total % limbLen;\n\t    var end = Math.min(total, total - mod) + start;\n\n\t    var word = 0;\n\t    for (var i = start; i < end; i += limbLen) {\n\t      word = parseBase(number, i, i + limbLen, base);\n\n\t      this.imuln(limbPow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\n\t    if (mod !== 0) {\n\t      var pow = 1;\n\t      word = parseBase(number, i, number.length, base);\n\n\t      for (i = 0; i < mod; i++) {\n\t        pow *= base;\n\t      }\n\n\t      this.imuln(pow);\n\t      if (this.words[0] + word < 0x4000000) {\n\t        this.words[0] += word;\n\t      } else {\n\t        this._iaddn(word);\n\t      }\n\t    }\n\t  };\n\n\t  BN.prototype.copy = function copy (dest) {\n\t    dest.words = new Array(this.length);\n\t    for (var i = 0; i < this.length; i++) {\n\t      dest.words[i] = this.words[i];\n\t    }\n\t    dest.length = this.length;\n\t    dest.negative = this.negative;\n\t    dest.red = this.red;\n\t  };\n\n\t  BN.prototype.clone = function clone () {\n\t    var r = new BN(null);\n\t    this.copy(r);\n\t    return r;\n\t  };\n\n\t  BN.prototype._expand = function _expand (size) {\n\t    while (this.length < size) {\n\t      this.words[this.length++] = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  // Remove leading `0` from `this`\n\t  BN.prototype.strip = function strip () {\n\t    while (this.length > 1 && this.words[this.length - 1] === 0) {\n\t      this.length--;\n\t    }\n\t    return this._normSign();\n\t  };\n\n\t  BN.prototype._normSign = function _normSign () {\n\t    // -0 = 0\n\t    if (this.length === 1 && this.words[0] === 0) {\n\t      this.negative = 0;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.inspect = function inspect () {\n\t    return (this.red ? \'<BN-R: \' : \'<BN: \') + this.toString(16) + \'>\';\n\t  };\n\n\t  /*\n\n\t  var zeros = [];\n\t  var groupSizes = [];\n\t  var groupBases = [];\n\n\t  var s = \'\';\n\t  var i = -1;\n\t  while (++i < BN.wordSize) {\n\t    zeros[i] = s;\n\t    s += \'0\';\n\t  }\n\t  groupSizes[0] = 0;\n\t  groupSizes[1] = 0;\n\t  groupBases[0] = 0;\n\t  groupBases[1] = 0;\n\t  var base = 2 - 1;\n\t  while (++base < 36 + 1) {\n\t    var groupSize = 0;\n\t    var groupBase = 1;\n\t    while (groupBase < (1 << BN.wordSize) / base) {\n\t      groupBase *= base;\n\t      groupSize += 1;\n\t    }\n\t    groupSizes[base] = groupSize;\n\t    groupBases[base] = groupBase;\n\t  }\n\n\t  */\n\n\t  var zeros = [\n\t    \'\',\n\t    \'0\',\n\t    \'00\',\n\t    \'000\',\n\t    \'0000\',\n\t    \'00000\',\n\t    \'000000\',\n\t    \'0000000\',\n\t    \'00000000\',\n\t    \'000000000\',\n\t    \'0000000000\',\n\t    \'00000000000\',\n\t    \'000000000000\',\n\t    \'0000000000000\',\n\t    \'00000000000000\',\n\t    \'000000000000000\',\n\t    \'0000000000000000\',\n\t    \'00000000000000000\',\n\t    \'000000000000000000\',\n\t    \'0000000000000000000\',\n\t    \'00000000000000000000\',\n\t    \'000000000000000000000\',\n\t    \'0000000000000000000000\',\n\t    \'00000000000000000000000\',\n\t    \'000000000000000000000000\',\n\t    \'0000000000000000000000000\'\n\t  ];\n\n\t  var groupSizes = [\n\t    0, 0,\n\t    25, 16, 12, 11, 10, 9, 8,\n\t    8, 7, 7, 7, 7, 6, 6,\n\t    6, 6, 6, 6, 6, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5,\n\t    5, 5, 5, 5, 5, 5, 5\n\t  ];\n\n\t  var groupBases = [\n\t    0, 0,\n\t    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n\t    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n\t    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n\t    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n\t    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n\t  ];\n\n\t  BN.prototype.toString = function toString (base, padding) {\n\t    base = base || 10;\n\t    padding = padding | 0 || 1;\n\n\t    var out;\n\t    if (base === 16 || base === \'hex\') {\n\t      out = \'\';\n\t      var off = 0;\n\t      var carry = 0;\n\t      for (var i = 0; i < this.length; i++) {\n\t        var w = this.words[i];\n\t        var word = (((w << off) | carry) & 0xffffff).toString(16);\n\t        carry = (w >>> (24 - off)) & 0xffffff;\n\t        if (carry !== 0 || i !== this.length - 1) {\n\t          out = zeros[6 - word.length] + word + out;\n\t        } else {\n\t          out = word + out;\n\t        }\n\t        off += 2;\n\t        if (off >= 26) {\n\t          off -= 26;\n\t          i--;\n\t        }\n\t      }\n\t      if (carry !== 0) {\n\t        out = carry.toString(16) + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = \'0\' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = \'-\' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    if (base === (base | 0) && base >= 2 && base <= 36) {\n\t      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n\t      var groupSize = groupSizes[base];\n\t      // var groupBase = Math.pow(base, groupSize);\n\t      var groupBase = groupBases[base];\n\t      out = \'\';\n\t      var c = this.clone();\n\t      c.negative = 0;\n\t      while (!c.isZero()) {\n\t        var r = c.modn(groupBase).toString(base);\n\t        c = c.idivn(groupBase);\n\n\t        if (!c.isZero()) {\n\t          out = zeros[groupSize - r.length] + r + out;\n\t        } else {\n\t          out = r + out;\n\t        }\n\t      }\n\t      if (this.isZero()) {\n\t        out = \'0\' + out;\n\t      }\n\t      while (out.length % padding !== 0) {\n\t        out = \'0\' + out;\n\t      }\n\t      if (this.negative !== 0) {\n\t        out = \'-\' + out;\n\t      }\n\t      return out;\n\t    }\n\n\t    assert(false, \'Base should be between 2 and 36\');\n\t  };\n\n\t  BN.prototype.toNumber = function toNumber () {\n\t    var ret = this.words[0];\n\t    if (this.length === 2) {\n\t      ret += this.words[1] * 0x4000000;\n\t    } else if (this.length === 3 && this.words[2] === 0x01) {\n\t      // NOTE: at this stage it is known that the top bit is set\n\t      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n\t    } else if (this.length > 2) {\n\t      assert(false, \'Number can only safely store up to 53 bits\');\n\t    }\n\t    return (this.negative !== 0) ? -ret : ret;\n\t  };\n\n\t  BN.prototype.toJSON = function toJSON () {\n\t    return this.toString(16);\n\t  };\n\n\t  BN.prototype.toBuffer = function toBuffer (endian, length) {\n\t    assert(typeof Buffer !== \'undefined\');\n\t    return this.toArrayLike(Buffer, endian, length);\n\t  };\n\n\t  BN.prototype.toArray = function toArray (endian, length) {\n\t    return this.toArrayLike(Array, endian, length);\n\t  };\n\n\t  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n\t    var byteLength = this.byteLength();\n\t    var reqLength = length || Math.max(1, byteLength);\n\t    assert(byteLength <= reqLength, \'byte array longer than desired length\');\n\t    assert(reqLength > 0, \'Requested array length <= 0\');\n\n\t    this.strip();\n\t    var littleEndian = endian === \'le\';\n\t    var res = new ArrayType(reqLength);\n\n\t    var b, i;\n\t    var q = this.clone();\n\t    if (!littleEndian) {\n\t      // Assume big-endian\n\t      for (i = 0; i < reqLength - byteLength; i++) {\n\t        res[i] = 0;\n\t      }\n\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[reqLength - i - 1] = b;\n\t      }\n\t    } else {\n\t      for (i = 0; !q.isZero(); i++) {\n\t        b = q.andln(0xff);\n\t        q.iushrn(8);\n\n\t        res[i] = b;\n\t      }\n\n\t      for (; i < reqLength; i++) {\n\t        res[i] = 0;\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  if (Math.clz32) {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      return 32 - Math.clz32(w);\n\t    };\n\t  } else {\n\t    BN.prototype._countBits = function _countBits (w) {\n\t      var t = w;\n\t      var r = 0;\n\t      if (t >= 0x1000) {\n\t        r += 13;\n\t        t >>>= 13;\n\t      }\n\t      if (t >= 0x40) {\n\t        r += 7;\n\t        t >>>= 7;\n\t      }\n\t      if (t >= 0x8) {\n\t        r += 4;\n\t        t >>>= 4;\n\t      }\n\t      if (t >= 0x02) {\n\t        r += 2;\n\t        t >>>= 2;\n\t      }\n\t      return r + t;\n\t    };\n\t  }\n\n\t  BN.prototype._zeroBits = function _zeroBits (w) {\n\t    // Short-cut\n\t    if (w === 0) return 26;\n\n\t    var t = w;\n\t    var r = 0;\n\t    if ((t & 0x1fff) === 0) {\n\t      r += 13;\n\t      t >>>= 13;\n\t    }\n\t    if ((t & 0x7f) === 0) {\n\t      r += 7;\n\t      t >>>= 7;\n\t    }\n\t    if ((t & 0xf) === 0) {\n\t      r += 4;\n\t      t >>>= 4;\n\t    }\n\t    if ((t & 0x3) === 0) {\n\t      r += 2;\n\t      t >>>= 2;\n\t    }\n\t    if ((t & 0x1) === 0) {\n\t      r++;\n\t    }\n\t    return r;\n\t  };\n\n\t  // Return number of used bits in a BN\n\t  BN.prototype.bitLength = function bitLength () {\n\t    var w = this.words[this.length - 1];\n\t    var hi = this._countBits(w);\n\t    return (this.length - 1) * 26 + hi;\n\t  };\n\n\t  function toBitArray (num) {\n\t    var w = new Array(num.bitLength());\n\n\t    for (var bit = 0; bit < w.length; bit++) {\n\t      var off = (bit / 26) | 0;\n\t      var wbit = bit % 26;\n\n\t      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;\n\t    }\n\n\t    return w;\n\t  }\n\n\t  // Number of trailing zero bits\n\t  BN.prototype.zeroBits = function zeroBits () {\n\t    if (this.isZero()) return 0;\n\n\t    var r = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var b = this._zeroBits(this.words[i]);\n\t      r += b;\n\t      if (b !== 26) break;\n\t    }\n\t    return r;\n\t  };\n\n\t  BN.prototype.byteLength = function byteLength () {\n\t    return Math.ceil(this.bitLength() / 8);\n\t  };\n\n\t  BN.prototype.toTwos = function toTwos (width) {\n\t    if (this.negative !== 0) {\n\t      return this.abs().inotn(width).iaddn(1);\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.fromTwos = function fromTwos (width) {\n\t    if (this.testn(width - 1)) {\n\t      return this.notn(width).iaddn(1).ineg();\n\t    }\n\t    return this.clone();\n\t  };\n\n\t  BN.prototype.isNeg = function isNeg () {\n\t    return this.negative !== 0;\n\t  };\n\n\t  // Return negative clone of `this`\n\t  BN.prototype.neg = function neg () {\n\t    return this.clone().ineg();\n\t  };\n\n\t  BN.prototype.ineg = function ineg () {\n\t    if (!this.isZero()) {\n\t      this.negative ^= 1;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Or `num` with `this` in-place\n\t  BN.prototype.iuor = function iuor (num) {\n\t    while (this.length < num.length) {\n\t      this.words[this.length++] = 0;\n\t    }\n\n\t    for (var i = 0; i < num.length; i++) {\n\t      this.words[i] = this.words[i] | num.words[i];\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ior = function ior (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuor(num);\n\t  };\n\n\t  // Or `num` with `this`\n\t  BN.prototype.or = function or (num) {\n\t    if (this.length > num.length) return this.clone().ior(num);\n\t    return num.clone().ior(this);\n\t  };\n\n\t  BN.prototype.uor = function uor (num) {\n\t    if (this.length > num.length) return this.clone().iuor(num);\n\t    return num.clone().iuor(this);\n\t  };\n\n\t  // And `num` with `this` in-place\n\t  BN.prototype.iuand = function iuand (num) {\n\t    // b = min-length(num, this)\n\t    var b;\n\t    if (this.length > num.length) {\n\t      b = num;\n\t    } else {\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = this.words[i] & num.words[i];\n\t    }\n\n\t    this.length = b.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.iand = function iand (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuand(num);\n\t  };\n\n\t  // And `num` with `this`\n\t  BN.prototype.and = function and (num) {\n\t    if (this.length > num.length) return this.clone().iand(num);\n\t    return num.clone().iand(this);\n\t  };\n\n\t  BN.prototype.uand = function uand (num) {\n\t    if (this.length > num.length) return this.clone().iuand(num);\n\t    return num.clone().iuand(this);\n\t  };\n\n\t  // Xor `num` with `this` in-place\n\t  BN.prototype.iuxor = function iuxor (num) {\n\t    // a.length > b.length\n\t    var a;\n\t    var b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    for (var i = 0; i < b.length; i++) {\n\t      this.words[i] = a.words[i] ^ b.words[i];\n\t    }\n\n\t    if (this !== a) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = a.length;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ixor = function ixor (num) {\n\t    assert((this.negative | num.negative) === 0);\n\t    return this.iuxor(num);\n\t  };\n\n\t  // Xor `num` with `this`\n\t  BN.prototype.xor = function xor (num) {\n\t    if (this.length > num.length) return this.clone().ixor(num);\n\t    return num.clone().ixor(this);\n\t  };\n\n\t  BN.prototype.uxor = function uxor (num) {\n\t    if (this.length > num.length) return this.clone().iuxor(num);\n\t    return num.clone().iuxor(this);\n\t  };\n\n\t  // Not ``this`` with ``width`` bitwidth\n\t  BN.prototype.inotn = function inotn (width) {\n\t    assert(typeof width === \'number\' && width >= 0);\n\n\t    var bytesNeeded = Math.ceil(width / 26) | 0;\n\t    var bitsLeft = width % 26;\n\n\t    // Extend the buffer with leading zeroes\n\t    this._expand(bytesNeeded);\n\n\t    if (bitsLeft > 0) {\n\t      bytesNeeded--;\n\t    }\n\n\t    // Handle complete words\n\t    for (var i = 0; i < bytesNeeded; i++) {\n\t      this.words[i] = ~this.words[i] & 0x3ffffff;\n\t    }\n\n\t    // Handle the residue\n\t    if (bitsLeft > 0) {\n\t      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n\t    }\n\n\t    // And remove leading zeroes\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.notn = function notn (width) {\n\t    return this.clone().inotn(width);\n\t  };\n\n\t  // Set `bit` of `this`\n\t  BN.prototype.setn = function setn (bit, val) {\n\t    assert(typeof bit === \'number\' && bit >= 0);\n\n\t    var off = (bit / 26) | 0;\n\t    var wbit = bit % 26;\n\n\t    this._expand(off + 1);\n\n\t    if (val) {\n\t      this.words[off] = this.words[off] | (1 << wbit);\n\t    } else {\n\t      this.words[off] = this.words[off] & ~(1 << wbit);\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Add `num` to `this` in-place\n\t  BN.prototype.iadd = function iadd (num) {\n\t    var r;\n\n\t    // negative + positive\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      this.negative = 0;\n\t      r = this.isub(num);\n\t      this.negative ^= 1;\n\t      return this._normSign();\n\n\t    // positive + negative\n\t    } else if (this.negative === 0 && num.negative !== 0) {\n\t      num.negative = 0;\n\t      r = this.isub(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\t    }\n\n\t    // a.length > b.length\n\t    var a, b;\n\t    if (this.length > num.length) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      this.words[i] = r & 0x3ffffff;\n\t      carry = r >>> 26;\n\t    }\n\n\t    this.length = a.length;\n\t    if (carry !== 0) {\n\t      this.words[this.length] = carry;\n\t      this.length++;\n\t    // Copy the rest of the words\n\t    } else if (a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    return this;\n\t  };\n\n\t  // Add `num` to `this`\n\t  BN.prototype.add = function add (num) {\n\t    var res;\n\t    if (num.negative !== 0 && this.negative === 0) {\n\t      num.negative = 0;\n\t      res = this.sub(num);\n\t      num.negative ^= 1;\n\t      return res;\n\t    } else if (num.negative === 0 && this.negative !== 0) {\n\t      this.negative = 0;\n\t      res = num.sub(this);\n\t      this.negative = 1;\n\t      return res;\n\t    }\n\n\t    if (this.length > num.length) return this.clone().iadd(num);\n\n\t    return num.clone().iadd(this);\n\t  };\n\n\t  // Subtract `num` from `this` in-place\n\t  BN.prototype.isub = function isub (num) {\n\t    // this - (-num) = this + num\n\t    if (num.negative !== 0) {\n\t      num.negative = 0;\n\t      var r = this.iadd(num);\n\t      num.negative = 1;\n\t      return r._normSign();\n\n\t    // -this - num = -(this + num)\n\t    } else if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iadd(num);\n\t      this.negative = 1;\n\t      return this._normSign();\n\t    }\n\n\t    // At this point both numbers are positive\n\t    var cmp = this.cmp(num);\n\n\t    // Optimization - zeroify\n\t    if (cmp === 0) {\n\t      this.negative = 0;\n\t      this.length = 1;\n\t      this.words[0] = 0;\n\t      return this;\n\t    }\n\n\t    // a > b\n\t    var a, b;\n\t    if (cmp > 0) {\n\t      a = this;\n\t      b = num;\n\t    } else {\n\t      a = num;\n\t      b = this;\n\t    }\n\n\t    var carry = 0;\n\t    for (var i = 0; i < b.length; i++) {\n\t      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\t    for (; carry !== 0 && i < a.length; i++) {\n\t      r = (a.words[i] | 0) + carry;\n\t      carry = r >> 26;\n\t      this.words[i] = r & 0x3ffffff;\n\t    }\n\n\t    // Copy rest of the words\n\t    if (carry === 0 && i < a.length && a !== this) {\n\t      for (; i < a.length; i++) {\n\t        this.words[i] = a.words[i];\n\t      }\n\t    }\n\n\t    this.length = Math.max(this.length, i);\n\n\t    if (a !== this) {\n\t      this.negative = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Subtract `num` from `this`\n\t  BN.prototype.sub = function sub (num) {\n\t    return this.clone().isub(num);\n\t  };\n\n\t  function smallMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    var len = (self.length + num.length) | 0;\n\t    out.length = len;\n\t    len = (len - 1) | 0;\n\n\t    // Peel one iteration (compiler can\'t do it, because of code complexity)\n\t    var a = self.words[0] | 0;\n\t    var b = num.words[0] | 0;\n\t    var r = a * b;\n\n\t    var lo = r & 0x3ffffff;\n\t    var carry = (r / 0x4000000) | 0;\n\t    out.words[0] = lo;\n\n\t    for (var k = 1; k < len; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = carry >>> 26;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = (k - j) | 0;\n\t        a = self.words[i] | 0;\n\t        b = num.words[j] | 0;\n\t        r = a * b + rword;\n\t        ncarry += (r / 0x4000000) | 0;\n\t        rword = r & 0x3ffffff;\n\t      }\n\t      out.words[k] = rword | 0;\n\t      carry = ncarry | 0;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry | 0;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  // TODO(indutny): it may be reasonable to omit it for users who don\'t need\n\t  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n\t  // multiplication (like elliptic secp256k1).\n\t  var comb10MulTo = function comb10MulTo (self, num, out) {\n\t    var a = self.words;\n\t    var b = num.words;\n\t    var o = out.words;\n\t    var c = 0;\n\t    var lo;\n\t    var mid;\n\t    var hi;\n\t    var a0 = a[0] | 0;\n\t    var al0 = a0 & 0x1fff;\n\t    var ah0 = a0 >>> 13;\n\t    var a1 = a[1] | 0;\n\t    var al1 = a1 & 0x1fff;\n\t    var ah1 = a1 >>> 13;\n\t    var a2 = a[2] | 0;\n\t    var al2 = a2 & 0x1fff;\n\t    var ah2 = a2 >>> 13;\n\t    var a3 = a[3] | 0;\n\t    var al3 = a3 & 0x1fff;\n\t    var ah3 = a3 >>> 13;\n\t    var a4 = a[4] | 0;\n\t    var al4 = a4 & 0x1fff;\n\t    var ah4 = a4 >>> 13;\n\t    var a5 = a[5] | 0;\n\t    var al5 = a5 & 0x1fff;\n\t    var ah5 = a5 >>> 13;\n\t    var a6 = a[6] | 0;\n\t    var al6 = a6 & 0x1fff;\n\t    var ah6 = a6 >>> 13;\n\t    var a7 = a[7] | 0;\n\t    var al7 = a7 & 0x1fff;\n\t    var ah7 = a7 >>> 13;\n\t    var a8 = a[8] | 0;\n\t    var al8 = a8 & 0x1fff;\n\t    var ah8 = a8 >>> 13;\n\t    var a9 = a[9] | 0;\n\t    var al9 = a9 & 0x1fff;\n\t    var ah9 = a9 >>> 13;\n\t    var b0 = b[0] | 0;\n\t    var bl0 = b0 & 0x1fff;\n\t    var bh0 = b0 >>> 13;\n\t    var b1 = b[1] | 0;\n\t    var bl1 = b1 & 0x1fff;\n\t    var bh1 = b1 >>> 13;\n\t    var b2 = b[2] | 0;\n\t    var bl2 = b2 & 0x1fff;\n\t    var bh2 = b2 >>> 13;\n\t    var b3 = b[3] | 0;\n\t    var bl3 = b3 & 0x1fff;\n\t    var bh3 = b3 >>> 13;\n\t    var b4 = b[4] | 0;\n\t    var bl4 = b4 & 0x1fff;\n\t    var bh4 = b4 >>> 13;\n\t    var b5 = b[5] | 0;\n\t    var bl5 = b5 & 0x1fff;\n\t    var bh5 = b5 >>> 13;\n\t    var b6 = b[6] | 0;\n\t    var bl6 = b6 & 0x1fff;\n\t    var bh6 = b6 >>> 13;\n\t    var b7 = b[7] | 0;\n\t    var bl7 = b7 & 0x1fff;\n\t    var bh7 = b7 >>> 13;\n\t    var b8 = b[8] | 0;\n\t    var bl8 = b8 & 0x1fff;\n\t    var bh8 = b8 >>> 13;\n\t    var b9 = b[9] | 0;\n\t    var bl9 = b9 & 0x1fff;\n\t    var bh9 = b9 >>> 13;\n\n\t    out.negative = self.negative ^ num.negative;\n\t    out.length = 19;\n\t    /* k = 0 */\n\t    lo = Math.imul(al0, bl0);\n\t    mid = Math.imul(al0, bh0);\n\t    mid = (mid + Math.imul(ah0, bl0)) | 0;\n\t    hi = Math.imul(ah0, bh0);\n\t    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n\t    w0 &= 0x3ffffff;\n\t    /* k = 1 */\n\t    lo = Math.imul(al1, bl0);\n\t    mid = Math.imul(al1, bh0);\n\t    mid = (mid + Math.imul(ah1, bl0)) | 0;\n\t    hi = Math.imul(ah1, bh0);\n\t    lo = (lo + Math.imul(al0, bl1)) | 0;\n\t    mid = (mid + Math.imul(al0, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh1)) | 0;\n\t    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n\t    w1 &= 0x3ffffff;\n\t    /* k = 2 */\n\t    lo = Math.imul(al2, bl0);\n\t    mid = Math.imul(al2, bh0);\n\t    mid = (mid + Math.imul(ah2, bl0)) | 0;\n\t    hi = Math.imul(ah2, bh0);\n\t    lo = (lo + Math.imul(al1, bl1)) | 0;\n\t    mid = (mid + Math.imul(al1, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh1)) | 0;\n\t    lo = (lo + Math.imul(al0, bl2)) | 0;\n\t    mid = (mid + Math.imul(al0, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh2)) | 0;\n\t    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n\t    w2 &= 0x3ffffff;\n\t    /* k = 3 */\n\t    lo = Math.imul(al3, bl0);\n\t    mid = Math.imul(al3, bh0);\n\t    mid = (mid + Math.imul(ah3, bl0)) | 0;\n\t    hi = Math.imul(ah3, bh0);\n\t    lo = (lo + Math.imul(al2, bl1)) | 0;\n\t    mid = (mid + Math.imul(al2, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh1)) | 0;\n\t    lo = (lo + Math.imul(al1, bl2)) | 0;\n\t    mid = (mid + Math.imul(al1, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh2)) | 0;\n\t    lo = (lo + Math.imul(al0, bl3)) | 0;\n\t    mid = (mid + Math.imul(al0, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh3)) | 0;\n\t    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n\t    w3 &= 0x3ffffff;\n\t    /* k = 4 */\n\t    lo = Math.imul(al4, bl0);\n\t    mid = Math.imul(al4, bh0);\n\t    mid = (mid + Math.imul(ah4, bl0)) | 0;\n\t    hi = Math.imul(ah4, bh0);\n\t    lo = (lo + Math.imul(al3, bl1)) | 0;\n\t    mid = (mid + Math.imul(al3, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh1)) | 0;\n\t    lo = (lo + Math.imul(al2, bl2)) | 0;\n\t    mid = (mid + Math.imul(al2, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh2)) | 0;\n\t    lo = (lo + Math.imul(al1, bl3)) | 0;\n\t    mid = (mid + Math.imul(al1, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh3)) | 0;\n\t    lo = (lo + Math.imul(al0, bl4)) | 0;\n\t    mid = (mid + Math.imul(al0, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh4)) | 0;\n\t    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n\t    w4 &= 0x3ffffff;\n\t    /* k = 5 */\n\t    lo = Math.imul(al5, bl0);\n\t    mid = Math.imul(al5, bh0);\n\t    mid = (mid + Math.imul(ah5, bl0)) | 0;\n\t    hi = Math.imul(ah5, bh0);\n\t    lo = (lo + Math.imul(al4, bl1)) | 0;\n\t    mid = (mid + Math.imul(al4, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh1)) | 0;\n\t    lo = (lo + Math.imul(al3, bl2)) | 0;\n\t    mid = (mid + Math.imul(al3, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh2)) | 0;\n\t    lo = (lo + Math.imul(al2, bl3)) | 0;\n\t    mid = (mid + Math.imul(al2, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh3)) | 0;\n\t    lo = (lo + Math.imul(al1, bl4)) | 0;\n\t    mid = (mid + Math.imul(al1, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh4)) | 0;\n\t    lo = (lo + Math.imul(al0, bl5)) | 0;\n\t    mid = (mid + Math.imul(al0, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh5)) | 0;\n\t    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n\t    w5 &= 0x3ffffff;\n\t    /* k = 6 */\n\t    lo = Math.imul(al6, bl0);\n\t    mid = Math.imul(al6, bh0);\n\t    mid = (mid + Math.imul(ah6, bl0)) | 0;\n\t    hi = Math.imul(ah6, bh0);\n\t    lo = (lo + Math.imul(al5, bl1)) | 0;\n\t    mid = (mid + Math.imul(al5, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh1)) | 0;\n\t    lo = (lo + Math.imul(al4, bl2)) | 0;\n\t    mid = (mid + Math.imul(al4, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh2)) | 0;\n\t    lo = (lo + Math.imul(al3, bl3)) | 0;\n\t    mid = (mid + Math.imul(al3, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh3)) | 0;\n\t    lo = (lo + Math.imul(al2, bl4)) | 0;\n\t    mid = (mid + Math.imul(al2, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh4)) | 0;\n\t    lo = (lo + Math.imul(al1, bl5)) | 0;\n\t    mid = (mid + Math.imul(al1, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh5)) | 0;\n\t    lo = (lo + Math.imul(al0, bl6)) | 0;\n\t    mid = (mid + Math.imul(al0, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh6)) | 0;\n\t    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n\t    w6 &= 0x3ffffff;\n\t    /* k = 7 */\n\t    lo = Math.imul(al7, bl0);\n\t    mid = Math.imul(al7, bh0);\n\t    mid = (mid + Math.imul(ah7, bl0)) | 0;\n\t    hi = Math.imul(ah7, bh0);\n\t    lo = (lo + Math.imul(al6, bl1)) | 0;\n\t    mid = (mid + Math.imul(al6, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh1)) | 0;\n\t    lo = (lo + Math.imul(al5, bl2)) | 0;\n\t    mid = (mid + Math.imul(al5, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh2)) | 0;\n\t    lo = (lo + Math.imul(al4, bl3)) | 0;\n\t    mid = (mid + Math.imul(al4, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh3)) | 0;\n\t    lo = (lo + Math.imul(al3, bl4)) | 0;\n\t    mid = (mid + Math.imul(al3, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh4)) | 0;\n\t    lo = (lo + Math.imul(al2, bl5)) | 0;\n\t    mid = (mid + Math.imul(al2, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh5)) | 0;\n\t    lo = (lo + Math.imul(al1, bl6)) | 0;\n\t    mid = (mid + Math.imul(al1, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh6)) | 0;\n\t    lo = (lo + Math.imul(al0, bl7)) | 0;\n\t    mid = (mid + Math.imul(al0, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh7)) | 0;\n\t    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n\t    w7 &= 0x3ffffff;\n\t    /* k = 8 */\n\t    lo = Math.imul(al8, bl0);\n\t    mid = Math.imul(al8, bh0);\n\t    mid = (mid + Math.imul(ah8, bl0)) | 0;\n\t    hi = Math.imul(ah8, bh0);\n\t    lo = (lo + Math.imul(al7, bl1)) | 0;\n\t    mid = (mid + Math.imul(al7, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh1)) | 0;\n\t    lo = (lo + Math.imul(al6, bl2)) | 0;\n\t    mid = (mid + Math.imul(al6, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh2)) | 0;\n\t    lo = (lo + Math.imul(al5, bl3)) | 0;\n\t    mid = (mid + Math.imul(al5, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh3)) | 0;\n\t    lo = (lo + Math.imul(al4, bl4)) | 0;\n\t    mid = (mid + Math.imul(al4, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh4)) | 0;\n\t    lo = (lo + Math.imul(al3, bl5)) | 0;\n\t    mid = (mid + Math.imul(al3, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh5)) | 0;\n\t    lo = (lo + Math.imul(al2, bl6)) | 0;\n\t    mid = (mid + Math.imul(al2, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh6)) | 0;\n\t    lo = (lo + Math.imul(al1, bl7)) | 0;\n\t    mid = (mid + Math.imul(al1, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh7)) | 0;\n\t    lo = (lo + Math.imul(al0, bl8)) | 0;\n\t    mid = (mid + Math.imul(al0, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh8)) | 0;\n\t    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n\t    w8 &= 0x3ffffff;\n\t    /* k = 9 */\n\t    lo = Math.imul(al9, bl0);\n\t    mid = Math.imul(al9, bh0);\n\t    mid = (mid + Math.imul(ah9, bl0)) | 0;\n\t    hi = Math.imul(ah9, bh0);\n\t    lo = (lo + Math.imul(al8, bl1)) | 0;\n\t    mid = (mid + Math.imul(al8, bh1)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl1)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh1)) | 0;\n\t    lo = (lo + Math.imul(al7, bl2)) | 0;\n\t    mid = (mid + Math.imul(al7, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh2)) | 0;\n\t    lo = (lo + Math.imul(al6, bl3)) | 0;\n\t    mid = (mid + Math.imul(al6, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh3)) | 0;\n\t    lo = (lo + Math.imul(al5, bl4)) | 0;\n\t    mid = (mid + Math.imul(al5, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh4)) | 0;\n\t    lo = (lo + Math.imul(al4, bl5)) | 0;\n\t    mid = (mid + Math.imul(al4, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh5)) | 0;\n\t    lo = (lo + Math.imul(al3, bl6)) | 0;\n\t    mid = (mid + Math.imul(al3, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh6)) | 0;\n\t    lo = (lo + Math.imul(al2, bl7)) | 0;\n\t    mid = (mid + Math.imul(al2, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh7)) | 0;\n\t    lo = (lo + Math.imul(al1, bl8)) | 0;\n\t    mid = (mid + Math.imul(al1, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh8)) | 0;\n\t    lo = (lo + Math.imul(al0, bl9)) | 0;\n\t    mid = (mid + Math.imul(al0, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah0, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah0, bh9)) | 0;\n\t    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n\t    w9 &= 0x3ffffff;\n\t    /* k = 10 */\n\t    lo = Math.imul(al9, bl1);\n\t    mid = Math.imul(al9, bh1);\n\t    mid = (mid + Math.imul(ah9, bl1)) | 0;\n\t    hi = Math.imul(ah9, bh1);\n\t    lo = (lo + Math.imul(al8, bl2)) | 0;\n\t    mid = (mid + Math.imul(al8, bh2)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl2)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh2)) | 0;\n\t    lo = (lo + Math.imul(al7, bl3)) | 0;\n\t    mid = (mid + Math.imul(al7, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh3)) | 0;\n\t    lo = (lo + Math.imul(al6, bl4)) | 0;\n\t    mid = (mid + Math.imul(al6, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh4)) | 0;\n\t    lo = (lo + Math.imul(al5, bl5)) | 0;\n\t    mid = (mid + Math.imul(al5, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh5)) | 0;\n\t    lo = (lo + Math.imul(al4, bl6)) | 0;\n\t    mid = (mid + Math.imul(al4, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh6)) | 0;\n\t    lo = (lo + Math.imul(al3, bl7)) | 0;\n\t    mid = (mid + Math.imul(al3, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh7)) | 0;\n\t    lo = (lo + Math.imul(al2, bl8)) | 0;\n\t    mid = (mid + Math.imul(al2, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh8)) | 0;\n\t    lo = (lo + Math.imul(al1, bl9)) | 0;\n\t    mid = (mid + Math.imul(al1, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah1, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah1, bh9)) | 0;\n\t    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n\t    w10 &= 0x3ffffff;\n\t    /* k = 11 */\n\t    lo = Math.imul(al9, bl2);\n\t    mid = Math.imul(al9, bh2);\n\t    mid = (mid + Math.imul(ah9, bl2)) | 0;\n\t    hi = Math.imul(ah9, bh2);\n\t    lo = (lo + Math.imul(al8, bl3)) | 0;\n\t    mid = (mid + Math.imul(al8, bh3)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl3)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh3)) | 0;\n\t    lo = (lo + Math.imul(al7, bl4)) | 0;\n\t    mid = (mid + Math.imul(al7, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh4)) | 0;\n\t    lo = (lo + Math.imul(al6, bl5)) | 0;\n\t    mid = (mid + Math.imul(al6, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh5)) | 0;\n\t    lo = (lo + Math.imul(al5, bl6)) | 0;\n\t    mid = (mid + Math.imul(al5, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh6)) | 0;\n\t    lo = (lo + Math.imul(al4, bl7)) | 0;\n\t    mid = (mid + Math.imul(al4, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh7)) | 0;\n\t    lo = (lo + Math.imul(al3, bl8)) | 0;\n\t    mid = (mid + Math.imul(al3, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh8)) | 0;\n\t    lo = (lo + Math.imul(al2, bl9)) | 0;\n\t    mid = (mid + Math.imul(al2, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah2, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah2, bh9)) | 0;\n\t    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n\t    w11 &= 0x3ffffff;\n\t    /* k = 12 */\n\t    lo = Math.imul(al9, bl3);\n\t    mid = Math.imul(al9, bh3);\n\t    mid = (mid + Math.imul(ah9, bl3)) | 0;\n\t    hi = Math.imul(ah9, bh3);\n\t    lo = (lo + Math.imul(al8, bl4)) | 0;\n\t    mid = (mid + Math.imul(al8, bh4)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl4)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh4)) | 0;\n\t    lo = (lo + Math.imul(al7, bl5)) | 0;\n\t    mid = (mid + Math.imul(al7, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh5)) | 0;\n\t    lo = (lo + Math.imul(al6, bl6)) | 0;\n\t    mid = (mid + Math.imul(al6, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh6)) | 0;\n\t    lo = (lo + Math.imul(al5, bl7)) | 0;\n\t    mid = (mid + Math.imul(al5, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh7)) | 0;\n\t    lo = (lo + Math.imul(al4, bl8)) | 0;\n\t    mid = (mid + Math.imul(al4, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh8)) | 0;\n\t    lo = (lo + Math.imul(al3, bl9)) | 0;\n\t    mid = (mid + Math.imul(al3, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah3, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah3, bh9)) | 0;\n\t    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n\t    w12 &= 0x3ffffff;\n\t    /* k = 13 */\n\t    lo = Math.imul(al9, bl4);\n\t    mid = Math.imul(al9, bh4);\n\t    mid = (mid + Math.imul(ah9, bl4)) | 0;\n\t    hi = Math.imul(ah9, bh4);\n\t    lo = (lo + Math.imul(al8, bl5)) | 0;\n\t    mid = (mid + Math.imul(al8, bh5)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl5)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh5)) | 0;\n\t    lo = (lo + Math.imul(al7, bl6)) | 0;\n\t    mid = (mid + Math.imul(al7, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh6)) | 0;\n\t    lo = (lo + Math.imul(al6, bl7)) | 0;\n\t    mid = (mid + Math.imul(al6, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh7)) | 0;\n\t    lo = (lo + Math.imul(al5, bl8)) | 0;\n\t    mid = (mid + Math.imul(al5, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh8)) | 0;\n\t    lo = (lo + Math.imul(al4, bl9)) | 0;\n\t    mid = (mid + Math.imul(al4, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah4, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah4, bh9)) | 0;\n\t    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n\t    w13 &= 0x3ffffff;\n\t    /* k = 14 */\n\t    lo = Math.imul(al9, bl5);\n\t    mid = Math.imul(al9, bh5);\n\t    mid = (mid + Math.imul(ah9, bl5)) | 0;\n\t    hi = Math.imul(ah9, bh5);\n\t    lo = (lo + Math.imul(al8, bl6)) | 0;\n\t    mid = (mid + Math.imul(al8, bh6)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl6)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh6)) | 0;\n\t    lo = (lo + Math.imul(al7, bl7)) | 0;\n\t    mid = (mid + Math.imul(al7, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh7)) | 0;\n\t    lo = (lo + Math.imul(al6, bl8)) | 0;\n\t    mid = (mid + Math.imul(al6, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh8)) | 0;\n\t    lo = (lo + Math.imul(al5, bl9)) | 0;\n\t    mid = (mid + Math.imul(al5, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah5, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah5, bh9)) | 0;\n\t    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n\t    w14 &= 0x3ffffff;\n\t    /* k = 15 */\n\t    lo = Math.imul(al9, bl6);\n\t    mid = Math.imul(al9, bh6);\n\t    mid = (mid + Math.imul(ah9, bl6)) | 0;\n\t    hi = Math.imul(ah9, bh6);\n\t    lo = (lo + Math.imul(al8, bl7)) | 0;\n\t    mid = (mid + Math.imul(al8, bh7)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl7)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh7)) | 0;\n\t    lo = (lo + Math.imul(al7, bl8)) | 0;\n\t    mid = (mid + Math.imul(al7, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh8)) | 0;\n\t    lo = (lo + Math.imul(al6, bl9)) | 0;\n\t    mid = (mid + Math.imul(al6, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah6, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah6, bh9)) | 0;\n\t    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n\t    w15 &= 0x3ffffff;\n\t    /* k = 16 */\n\t    lo = Math.imul(al9, bl7);\n\t    mid = Math.imul(al9, bh7);\n\t    mid = (mid + Math.imul(ah9, bl7)) | 0;\n\t    hi = Math.imul(ah9, bh7);\n\t    lo = (lo + Math.imul(al8, bl8)) | 0;\n\t    mid = (mid + Math.imul(al8, bh8)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl8)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh8)) | 0;\n\t    lo = (lo + Math.imul(al7, bl9)) | 0;\n\t    mid = (mid + Math.imul(al7, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah7, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah7, bh9)) | 0;\n\t    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n\t    w16 &= 0x3ffffff;\n\t    /* k = 17 */\n\t    lo = Math.imul(al9, bl8);\n\t    mid = Math.imul(al9, bh8);\n\t    mid = (mid + Math.imul(ah9, bl8)) | 0;\n\t    hi = Math.imul(ah9, bh8);\n\t    lo = (lo + Math.imul(al8, bl9)) | 0;\n\t    mid = (mid + Math.imul(al8, bh9)) | 0;\n\t    mid = (mid + Math.imul(ah8, bl9)) | 0;\n\t    hi = (hi + Math.imul(ah8, bh9)) | 0;\n\t    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n\t    w17 &= 0x3ffffff;\n\t    /* k = 18 */\n\t    lo = Math.imul(al9, bl9);\n\t    mid = Math.imul(al9, bh9);\n\t    mid = (mid + Math.imul(ah9, bl9)) | 0;\n\t    hi = Math.imul(ah9, bh9);\n\t    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n\t    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n\t    w18 &= 0x3ffffff;\n\t    o[0] = w0;\n\t    o[1] = w1;\n\t    o[2] = w2;\n\t    o[3] = w3;\n\t    o[4] = w4;\n\t    o[5] = w5;\n\t    o[6] = w6;\n\t    o[7] = w7;\n\t    o[8] = w8;\n\t    o[9] = w9;\n\t    o[10] = w10;\n\t    o[11] = w11;\n\t    o[12] = w12;\n\t    o[13] = w13;\n\t    o[14] = w14;\n\t    o[15] = w15;\n\t    o[16] = w16;\n\t    o[17] = w17;\n\t    o[18] = w18;\n\t    if (c !== 0) {\n\t      o[19] = c;\n\t      out.length++;\n\t    }\n\t    return out;\n\t  };\n\n\t  // Polyfill comb\n\t  if (!Math.imul) {\n\t    comb10MulTo = smallMulTo;\n\t  }\n\n\t  function bigMulTo (self, num, out) {\n\t    out.negative = num.negative ^ self.negative;\n\t    out.length = self.length + num.length;\n\n\t    var carry = 0;\n\t    var hncarry = 0;\n\t    for (var k = 0; k < out.length - 1; k++) {\n\t      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n\t      // note that ncarry could be >= 0x3ffffff\n\t      var ncarry = hncarry;\n\t      hncarry = 0;\n\t      var rword = carry & 0x3ffffff;\n\t      var maxJ = Math.min(k, num.length - 1);\n\t      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n\t        var i = k - j;\n\t        var a = self.words[i] | 0;\n\t        var b = num.words[j] | 0;\n\t        var r = a * b;\n\n\t        var lo = r & 0x3ffffff;\n\t        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n\t        lo = (lo + rword) | 0;\n\t        rword = lo & 0x3ffffff;\n\t        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n\t        hncarry += ncarry >>> 26;\n\t        ncarry &= 0x3ffffff;\n\t      }\n\t      out.words[k] = rword;\n\t      carry = ncarry;\n\t      ncarry = hncarry;\n\t    }\n\t    if (carry !== 0) {\n\t      out.words[k] = carry;\n\t    } else {\n\t      out.length--;\n\t    }\n\n\t    return out.strip();\n\t  }\n\n\t  function jumboMulTo (self, num, out) {\n\t    var fftm = new FFTM();\n\t    return fftm.mulp(self, num, out);\n\t  }\n\n\t  BN.prototype.mulTo = function mulTo (num, out) {\n\t    var res;\n\t    var len = this.length + num.length;\n\t    if (this.length === 10 && num.length === 10) {\n\t      res = comb10MulTo(this, num, out);\n\t    } else if (len < 63) {\n\t      res = smallMulTo(this, num, out);\n\t    } else if (len < 1024) {\n\t      res = bigMulTo(this, num, out);\n\t    } else {\n\t      res = jumboMulTo(this, num, out);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Cooley-Tukey algorithm for FFT\n\t  // slightly revisited to rely on looping instead of recursion\n\n\t  function FFTM (x, y) {\n\t    this.x = x;\n\t    this.y = y;\n\t  }\n\n\t  FFTM.prototype.makeRBT = function makeRBT (N) {\n\t    var t = new Array(N);\n\t    var l = BN.prototype._countBits(N) - 1;\n\t    for (var i = 0; i < N; i++) {\n\t      t[i] = this.revBin(i, l, N);\n\t    }\n\n\t    return t;\n\t  };\n\n\t  // Returns binary-reversed representation of `x`\n\t  FFTM.prototype.revBin = function revBin (x, l, N) {\n\t    if (x === 0 || x === N - 1) return x;\n\n\t    var rb = 0;\n\t    for (var i = 0; i < l; i++) {\n\t      rb |= (x & 1) << (l - i - 1);\n\t      x >>= 1;\n\t    }\n\n\t    return rb;\n\t  };\n\n\t  // Performs "tweedling" phase, therefore \'emulating\'\n\t  // behaviour of the recursive algorithm\n\t  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n\t    for (var i = 0; i < N; i++) {\n\t      rtws[i] = rws[rbt[i]];\n\t      itws[i] = iws[rbt[i]];\n\t    }\n\t  };\n\n\t  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n\t    this.permute(rbt, rws, iws, rtws, itws, N);\n\n\t    for (var s = 1; s < N; s <<= 1) {\n\t      var l = s << 1;\n\n\t      var rtwdf = Math.cos(2 * Math.PI / l);\n\t      var itwdf = Math.sin(2 * Math.PI / l);\n\n\t      for (var p = 0; p < N; p += l) {\n\t        var rtwdf_ = rtwdf;\n\t        var itwdf_ = itwdf;\n\n\t        for (var j = 0; j < s; j++) {\n\t          var re = rtws[p + j];\n\t          var ie = itws[p + j];\n\n\t          var ro = rtws[p + j + s];\n\t          var io = itws[p + j + s];\n\n\t          var rx = rtwdf_ * ro - itwdf_ * io;\n\n\t          io = rtwdf_ * io + itwdf_ * ro;\n\t          ro = rx;\n\n\t          rtws[p + j] = re + ro;\n\t          itws[p + j] = ie + io;\n\n\t          rtws[p + j + s] = re - ro;\n\t          itws[p + j + s] = ie - io;\n\n\t          /* jshint maxdepth : false */\n\t          if (j !== l) {\n\t            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n\t            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n\t            rtwdf_ = rx;\n\t          }\n\t        }\n\t      }\n\t    }\n\t  };\n\n\t  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n\t    var N = Math.max(m, n) | 1;\n\t    var odd = N & 1;\n\t    var i = 0;\n\t    for (N = N / 2 | 0; N; N = N >>> 1) {\n\t      i++;\n\t    }\n\n\t    return 1 << i + 1 + odd;\n\t  };\n\n\t  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n\t    if (N <= 1) return;\n\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var t = rws[i];\n\n\t      rws[i] = rws[N - i - 1];\n\t      rws[N - i - 1] = t;\n\n\t      t = iws[i];\n\n\t      iws[i] = -iws[N - i - 1];\n\t      iws[N - i - 1] = -t;\n\t    }\n\t  };\n\n\t  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < N / 2; i++) {\n\t      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n\t        Math.round(ws[2 * i] / N) +\n\t        carry;\n\n\t      ws[i] = w & 0x3ffffff;\n\n\t      if (w < 0x4000000) {\n\t        carry = 0;\n\t      } else {\n\t        carry = w / 0x4000000 | 0;\n\t      }\n\t    }\n\n\t    return ws;\n\t  };\n\n\t  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n\t    var carry = 0;\n\t    for (var i = 0; i < len; i++) {\n\t      carry = carry + (ws[i] | 0);\n\n\t      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n\t      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n\t    }\n\n\t    // Pad with zeroes\n\t    for (i = 2 * len; i < N; ++i) {\n\t      rws[i] = 0;\n\t    }\n\n\t    assert(carry === 0);\n\t    assert((carry & ~0x1fff) === 0);\n\t  };\n\n\t  FFTM.prototype.stub = function stub (N) {\n\t    var ph = new Array(N);\n\t    for (var i = 0; i < N; i++) {\n\t      ph[i] = 0;\n\t    }\n\n\t    return ph;\n\t  };\n\n\t  FFTM.prototype.mulp = function mulp (x, y, out) {\n\t    var N = 2 * this.guessLen13b(x.length, y.length);\n\n\t    var rbt = this.makeRBT(N);\n\n\t    var _ = this.stub(N);\n\n\t    var rws = new Array(N);\n\t    var rwst = new Array(N);\n\t    var iwst = new Array(N);\n\n\t    var nrws = new Array(N);\n\t    var nrwst = new Array(N);\n\t    var niwst = new Array(N);\n\n\t    var rmws = out.words;\n\t    rmws.length = N;\n\n\t    this.convert13b(x.words, x.length, rws, N);\n\t    this.convert13b(y.words, y.length, nrws, N);\n\n\t    this.transform(rws, _, rwst, iwst, N, rbt);\n\t    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n\t    for (var i = 0; i < N; i++) {\n\t      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n\t      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n\t      rwst[i] = rx;\n\t    }\n\n\t    this.conjugate(rwst, iwst, N);\n\t    this.transform(rwst, iwst, rmws, _, N, rbt);\n\t    this.conjugate(rmws, _, N);\n\t    this.normalize13b(rmws, N);\n\n\t    out.negative = x.negative ^ y.negative;\n\t    out.length = x.length + y.length;\n\t    return out.strip();\n\t  };\n\n\t  // Multiply `this` by `num`\n\t  BN.prototype.mul = function mul (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return this.mulTo(num, out);\n\t  };\n\n\t  // Multiply employing FFT\n\t  BN.prototype.mulf = function mulf (num) {\n\t    var out = new BN(null);\n\t    out.words = new Array(this.length + num.length);\n\t    return jumboMulTo(this, num, out);\n\t  };\n\n\t  // In-place Multiplication\n\t  BN.prototype.imul = function imul (num) {\n\t    return this.clone().mulTo(num, this);\n\t  };\n\n\t  BN.prototype.imuln = function imuln (num) {\n\t    assert(typeof num === \'number\');\n\t    assert(num < 0x4000000);\n\n\t    // Carry\n\t    var carry = 0;\n\t    for (var i = 0; i < this.length; i++) {\n\t      var w = (this.words[i] | 0) * num;\n\t      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n\t      carry >>= 26;\n\t      carry += (w / 0x4000000) | 0;\n\t      // NOTE: lo is 27bit maximum\n\t      carry += lo >>> 26;\n\t      this.words[i] = lo & 0x3ffffff;\n\t    }\n\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.muln = function muln (num) {\n\t    return this.clone().imuln(num);\n\t  };\n\n\t  // `this` * `this`\n\t  BN.prototype.sqr = function sqr () {\n\t    return this.mul(this);\n\t  };\n\n\t  // `this` * `this` in-place\n\t  BN.prototype.isqr = function isqr () {\n\t    return this.imul(this.clone());\n\t  };\n\n\t  // Math.pow(`this`, `num`)\n\t  BN.prototype.pow = function pow (num) {\n\t    var w = toBitArray(num);\n\t    if (w.length === 0) return new BN(1);\n\n\t    // Skip leading zeroes\n\t    var res = this;\n\t    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n\t      if (w[i] !== 0) break;\n\t    }\n\n\t    if (++i < w.length) {\n\t      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n\t        if (w[i] === 0) continue;\n\n\t        res = res.mul(q);\n\t      }\n\t    }\n\n\t    return res;\n\t  };\n\n\t  // Shift-left in-place\n\t  BN.prototype.iushln = function iushln (bits) {\n\t    assert(typeof bits === \'number\' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\t    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n\t    var i;\n\n\t    if (r !== 0) {\n\t      var carry = 0;\n\n\t      for (i = 0; i < this.length; i++) {\n\t        var newCarry = this.words[i] & carryMask;\n\t        var c = ((this.words[i] | 0) - newCarry) << r;\n\t        this.words[i] = c | carry;\n\t        carry = newCarry >>> (26 - r);\n\t      }\n\n\t      if (carry) {\n\t        this.words[i] = carry;\n\t        this.length++;\n\t      }\n\t    }\n\n\t    if (s !== 0) {\n\t      for (i = this.length - 1; i >= 0; i--) {\n\t        this.words[i + s] = this.words[i];\n\t      }\n\n\t      for (i = 0; i < s; i++) {\n\t        this.words[i] = 0;\n\t      }\n\n\t      this.length += s;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishln = function ishln (bits) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushln(bits);\n\t  };\n\n\t  // Shift-right in-place\n\t  // NOTE: `hint` is a lowest bit before trailing zeroes\n\t  // NOTE: if `extended` is present - it will be filled with destroyed bits\n\t  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n\t    assert(typeof bits === \'number\' && bits >= 0);\n\t    var h;\n\t    if (hint) {\n\t      h = (hint - (hint % 26)) / 26;\n\t    } else {\n\t      h = 0;\n\t    }\n\n\t    var r = bits % 26;\n\t    var s = Math.min((bits - r) / 26, this.length);\n\t    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t    var maskedWords = extended;\n\n\t    h -= s;\n\t    h = Math.max(0, h);\n\n\t    // Extended mode, copy masked part\n\t    if (maskedWords) {\n\t      for (var i = 0; i < s; i++) {\n\t        maskedWords.words[i] = this.words[i];\n\t      }\n\t      maskedWords.length = s;\n\t    }\n\n\t    if (s === 0) {\n\t      // No-op, we should not move anything at all\n\t    } else if (this.length > s) {\n\t      this.length -= s;\n\t      for (i = 0; i < this.length; i++) {\n\t        this.words[i] = this.words[i + s];\n\t      }\n\t    } else {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    var carry = 0;\n\t    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n\t      var word = this.words[i] | 0;\n\t      this.words[i] = (carry << (26 - r)) | (word >>> r);\n\t      carry = word & mask;\n\t    }\n\n\t    // Push carried bits as a mask\n\t    if (maskedWords && carry !== 0) {\n\t      maskedWords.words[maskedWords.length++] = carry;\n\t    }\n\n\t    if (this.length === 0) {\n\t      this.words[0] = 0;\n\t      this.length = 1;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n\t    // TODO(indutny): implement me\n\t    assert(this.negative === 0);\n\t    return this.iushrn(bits, hint, extended);\n\t  };\n\n\t  // Shift-left\n\t  BN.prototype.shln = function shln (bits) {\n\t    return this.clone().ishln(bits);\n\t  };\n\n\t  BN.prototype.ushln = function ushln (bits) {\n\t    return this.clone().iushln(bits);\n\t  };\n\n\t  // Shift-right\n\t  BN.prototype.shrn = function shrn (bits) {\n\t    return this.clone().ishrn(bits);\n\t  };\n\n\t  BN.prototype.ushrn = function ushrn (bits) {\n\t    return this.clone().iushrn(bits);\n\t  };\n\n\t  // Test if n bit is set\n\t  BN.prototype.testn = function testn (bit) {\n\t    assert(typeof bit === \'number\' && bit >= 0);\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) return false;\n\n\t    // Check bit and return\n\t    var w = this.words[s];\n\n\t    return !!(w & q);\n\t  };\n\n\t  // Return only lowers bits of number (in-place)\n\t  BN.prototype.imaskn = function imaskn (bits) {\n\t    assert(typeof bits === \'number\' && bits >= 0);\n\t    var r = bits % 26;\n\t    var s = (bits - r) / 26;\n\n\t    assert(this.negative === 0, \'imaskn works only with positive numbers\');\n\n\t    if (this.length <= s) {\n\t      return this;\n\t    }\n\n\t    if (r !== 0) {\n\t      s++;\n\t    }\n\t    this.length = Math.min(s, this.length);\n\n\t    if (r !== 0) {\n\t      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n\t      this.words[this.length - 1] &= mask;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  // Return only lowers bits of number\n\t  BN.prototype.maskn = function maskn (bits) {\n\t    return this.clone().imaskn(bits);\n\t  };\n\n\t  // Add plain number `num` to `this`\n\t  BN.prototype.iaddn = function iaddn (num) {\n\t    assert(typeof num === \'number\');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.isubn(-num);\n\n\t    // Possible sign change\n\t    if (this.negative !== 0) {\n\t      if (this.length === 1 && (this.words[0] | 0) < num) {\n\t        this.words[0] = num - (this.words[0] | 0);\n\t        this.negative = 0;\n\t        return this;\n\t      }\n\n\t      this.negative = 0;\n\t      this.isubn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    // Add without checks\n\t    return this._iaddn(num);\n\t  };\n\n\t  BN.prototype._iaddn = function _iaddn (num) {\n\t    this.words[0] += num;\n\n\t    // Carry\n\t    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n\t      this.words[i] -= 0x4000000;\n\t      if (i === this.length - 1) {\n\t        this.words[i + 1] = 1;\n\t      } else {\n\t        this.words[i + 1]++;\n\t      }\n\t    }\n\t    this.length = Math.max(this.length, i + 1);\n\n\t    return this;\n\t  };\n\n\t  // Subtract plain number `num` from `this`\n\t  BN.prototype.isubn = function isubn (num) {\n\t    assert(typeof num === \'number\');\n\t    assert(num < 0x4000000);\n\t    if (num < 0) return this.iaddn(-num);\n\n\t    if (this.negative !== 0) {\n\t      this.negative = 0;\n\t      this.iaddn(num);\n\t      this.negative = 1;\n\t      return this;\n\t    }\n\n\t    this.words[0] -= num;\n\n\t    if (this.length === 1 && this.words[0] < 0) {\n\t      this.words[0] = -this.words[0];\n\t      this.negative = 1;\n\t    } else {\n\t      // Carry\n\t      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n\t        this.words[i] += 0x4000000;\n\t        this.words[i + 1] -= 1;\n\t      }\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.addn = function addn (num) {\n\t    return this.clone().iaddn(num);\n\t  };\n\n\t  BN.prototype.subn = function subn (num) {\n\t    return this.clone().isubn(num);\n\t  };\n\n\t  BN.prototype.iabs = function iabs () {\n\t    this.negative = 0;\n\n\t    return this;\n\t  };\n\n\t  BN.prototype.abs = function abs () {\n\t    return this.clone().iabs();\n\t  };\n\n\t  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n\t    var len = num.length + shift;\n\t    var i;\n\n\t    this._expand(len);\n\n\t    var w;\n\t    var carry = 0;\n\t    for (i = 0; i < num.length; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      var right = (num.words[i] | 0) * mul;\n\t      w -= right & 0x3ffffff;\n\t      carry = (w >> 26) - ((right / 0x4000000) | 0);\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\t    for (; i < this.length - shift; i++) {\n\t      w = (this.words[i + shift] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i + shift] = w & 0x3ffffff;\n\t    }\n\n\t    if (carry === 0) return this.strip();\n\n\t    // Subtraction overflow\n\t    assert(carry === -1);\n\t    carry = 0;\n\t    for (i = 0; i < this.length; i++) {\n\t      w = -(this.words[i] | 0) + carry;\n\t      carry = w >> 26;\n\t      this.words[i] = w & 0x3ffffff;\n\t    }\n\t    this.negative = 1;\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n\t    var shift = this.length - num.length;\n\n\t    var a = this.clone();\n\t    var b = num;\n\n\t    // Normalize\n\t    var bhi = b.words[b.length - 1] | 0;\n\t    var bhiBits = this._countBits(bhi);\n\t    shift = 26 - bhiBits;\n\t    if (shift !== 0) {\n\t      b = b.ushln(shift);\n\t      a.iushln(shift);\n\t      bhi = b.words[b.length - 1] | 0;\n\t    }\n\n\t    // Initialize quotient\n\t    var m = a.length - b.length;\n\t    var q;\n\n\t    if (mode !== \'mod\') {\n\t      q = new BN(null);\n\t      q.length = m + 1;\n\t      q.words = new Array(q.length);\n\t      for (var i = 0; i < q.length; i++) {\n\t        q.words[i] = 0;\n\t      }\n\t    }\n\n\t    var diff = a.clone()._ishlnsubmul(b, 1, m);\n\t    if (diff.negative === 0) {\n\t      a = diff;\n\t      if (q) {\n\t        q.words[m] = 1;\n\t      }\n\t    }\n\n\t    for (var j = m - 1; j >= 0; j--) {\n\t      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n\t        (a.words[b.length + j - 1] | 0);\n\n\t      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n\t      // (0x7ffffff)\n\t      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n\t      a._ishlnsubmul(b, qj, j);\n\t      while (a.negative !== 0) {\n\t        qj--;\n\t        a.negative = 0;\n\t        a._ishlnsubmul(b, 1, j);\n\t        if (!a.isZero()) {\n\t          a.negative ^= 1;\n\t        }\n\t      }\n\t      if (q) {\n\t        q.words[j] = qj;\n\t      }\n\t    }\n\t    if (q) {\n\t      q.strip();\n\t    }\n\t    a.strip();\n\n\t    // Denormalize\n\t    if (mode !== \'div\' && shift !== 0) {\n\t      a.iushrn(shift);\n\t    }\n\n\t    return {\n\t      div: q || null,\n\t      mod: a\n\t    };\n\t  };\n\n\t  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n\t  //       to `div` to request div only, or be absent to\n\t  //       request both div & mod\n\t  //       2) `positive` is true if unsigned mod is requested\n\t  BN.prototype.divmod = function divmod (num, mode, positive) {\n\t    assert(!num.isZero());\n\n\t    if (this.isZero()) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: new BN(0)\n\t      };\n\t    }\n\n\t    var div, mod, res;\n\t    if (this.negative !== 0 && num.negative === 0) {\n\t      res = this.neg().divmod(num, mode);\n\n\t      if (mode !== \'mod\') {\n\t        div = res.div.neg();\n\t      }\n\n\t      if (mode !== \'div\') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.iadd(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    if (this.negative === 0 && num.negative !== 0) {\n\t      res = this.divmod(num.neg(), mode);\n\n\t      if (mode !== \'mod\') {\n\t        div = res.div.neg();\n\t      }\n\n\t      return {\n\t        div: div,\n\t        mod: res.mod\n\t      };\n\t    }\n\n\t    if ((this.negative & num.negative) !== 0) {\n\t      res = this.neg().divmod(num.neg(), mode);\n\n\t      if (mode !== \'div\') {\n\t        mod = res.mod.neg();\n\t        if (positive && mod.negative !== 0) {\n\t          mod.isub(num);\n\t        }\n\t      }\n\n\t      return {\n\t        div: res.div,\n\t        mod: mod\n\t      };\n\t    }\n\n\t    // Both numbers are positive at this point\n\n\t    // Strip both numbers to approximate shift value\n\t    if (num.length > this.length || this.cmp(num) < 0) {\n\t      return {\n\t        div: new BN(0),\n\t        mod: this\n\t      };\n\t    }\n\n\t    // Very short reduction\n\t    if (num.length === 1) {\n\t      if (mode === \'div\') {\n\t        return {\n\t          div: this.divn(num.words[0]),\n\t          mod: null\n\t        };\n\t      }\n\n\t      if (mode === \'mod\') {\n\t        return {\n\t          div: null,\n\t          mod: new BN(this.modn(num.words[0]))\n\t        };\n\t      }\n\n\t      return {\n\t        div: this.divn(num.words[0]),\n\t        mod: new BN(this.modn(num.words[0]))\n\t      };\n\t    }\n\n\t    return this._wordDiv(num, mode);\n\t  };\n\n\t  // Find `this` / `num`\n\t  BN.prototype.div = function div (num) {\n\t    return this.divmod(num, \'div\', false).div;\n\t  };\n\n\t  // Find `this` % `num`\n\t  BN.prototype.mod = function mod (num) {\n\t    return this.divmod(num, \'mod\', false).mod;\n\t  };\n\n\t  BN.prototype.umod = function umod (num) {\n\t    return this.divmod(num, \'mod\', true).mod;\n\t  };\n\n\t  // Find Round(`this` / `num`)\n\t  BN.prototype.divRound = function divRound (num) {\n\t    var dm = this.divmod(num);\n\n\t    // Fast case - exact division\n\t    if (dm.mod.isZero()) return dm.div;\n\n\t    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n\t    var half = num.ushrn(1);\n\t    var r2 = num.andln(1);\n\t    var cmp = mod.cmp(half);\n\n\t    // Round down\n\t    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;\n\n\t    // Round up\n\t    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n\t  };\n\n\t  BN.prototype.modn = function modn (num) {\n\t    assert(num <= 0x3ffffff);\n\t    var p = (1 << 26) % num;\n\n\t    var acc = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      acc = (p * acc + (this.words[i] | 0)) % num;\n\t    }\n\n\t    return acc;\n\t  };\n\n\t  // In-place division by number\n\t  BN.prototype.idivn = function idivn (num) {\n\t    assert(num <= 0x3ffffff);\n\n\t    var carry = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var w = (this.words[i] | 0) + carry * 0x4000000;\n\t      this.words[i] = (w / num) | 0;\n\t      carry = w % num;\n\t    }\n\n\t    return this.strip();\n\t  };\n\n\t  BN.prototype.divn = function divn (num) {\n\t    return this.clone().idivn(num);\n\t  };\n\n\t  BN.prototype.egcd = function egcd (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var x = this;\n\t    var y = p.clone();\n\n\t    if (x.negative !== 0) {\n\t      x = x.umod(p);\n\t    } else {\n\t      x = x.clone();\n\t    }\n\n\t    // A * x + B * y = x\n\t    var A = new BN(1);\n\t    var B = new BN(0);\n\n\t    // C * x + D * y = y\n\t    var C = new BN(0);\n\t    var D = new BN(1);\n\n\t    var g = 0;\n\n\t    while (x.isEven() && y.isEven()) {\n\t      x.iushrn(1);\n\t      y.iushrn(1);\n\t      ++g;\n\t    }\n\n\t    var yp = y.clone();\n\t    var xp = x.clone();\n\n\t    while (!x.isZero()) {\n\t      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        x.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (A.isOdd() || B.isOdd()) {\n\t            A.iadd(yp);\n\t            B.isub(xp);\n\t          }\n\n\t          A.iushrn(1);\n\t          B.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        y.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (C.isOdd() || D.isOdd()) {\n\t            C.iadd(yp);\n\t            D.isub(xp);\n\t          }\n\n\t          C.iushrn(1);\n\t          D.iushrn(1);\n\t        }\n\t      }\n\n\t      if (x.cmp(y) >= 0) {\n\t        x.isub(y);\n\t        A.isub(C);\n\t        B.isub(D);\n\t      } else {\n\t        y.isub(x);\n\t        C.isub(A);\n\t        D.isub(B);\n\t      }\n\t    }\n\n\t    return {\n\t      a: C,\n\t      b: D,\n\t      gcd: y.iushln(g)\n\t    };\n\t  };\n\n\t  // This is reduced incarnation of the binary EEA\n\t  // above, designated to invert members of the\n\t  // _prime_ fields F(p) at a maximal speed\n\t  BN.prototype._invmp = function _invmp (p) {\n\t    assert(p.negative === 0);\n\t    assert(!p.isZero());\n\n\t    var a = this;\n\t    var b = p.clone();\n\n\t    if (a.negative !== 0) {\n\t      a = a.umod(p);\n\t    } else {\n\t      a = a.clone();\n\t    }\n\n\t    var x1 = new BN(1);\n\t    var x2 = new BN(0);\n\n\t    var delta = b.clone();\n\n\t    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n\t      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n\t      if (i > 0) {\n\t        a.iushrn(i);\n\t        while (i-- > 0) {\n\t          if (x1.isOdd()) {\n\t            x1.iadd(delta);\n\t          }\n\n\t          x1.iushrn(1);\n\t        }\n\t      }\n\n\t      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n\t      if (j > 0) {\n\t        b.iushrn(j);\n\t        while (j-- > 0) {\n\t          if (x2.isOdd()) {\n\t            x2.iadd(delta);\n\t          }\n\n\t          x2.iushrn(1);\n\t        }\n\t      }\n\n\t      if (a.cmp(b) >= 0) {\n\t        a.isub(b);\n\t        x1.isub(x2);\n\t      } else {\n\t        b.isub(a);\n\t        x2.isub(x1);\n\t      }\n\t    }\n\n\t    var res;\n\t    if (a.cmpn(1) === 0) {\n\t      res = x1;\n\t    } else {\n\t      res = x2;\n\t    }\n\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(p);\n\t    }\n\n\t    return res;\n\t  };\n\n\t  BN.prototype.gcd = function gcd (num) {\n\t    if (this.isZero()) return num.abs();\n\t    if (num.isZero()) return this.abs();\n\n\t    var a = this.clone();\n\t    var b = num.clone();\n\t    a.negative = 0;\n\t    b.negative = 0;\n\n\t    // Remove common factor of two\n\t    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n\t      a.iushrn(1);\n\t      b.iushrn(1);\n\t    }\n\n\t    do {\n\t      while (a.isEven()) {\n\t        a.iushrn(1);\n\t      }\n\t      while (b.isEven()) {\n\t        b.iushrn(1);\n\t      }\n\n\t      var r = a.cmp(b);\n\t      if (r < 0) {\n\t        // Swap `a` and `b` to make `a` always bigger than `b`\n\t        var t = a;\n\t        a = b;\n\t        b = t;\n\t      } else if (r === 0 || b.cmpn(1) === 0) {\n\t        break;\n\t      }\n\n\t      a.isub(b);\n\t    } while (true);\n\n\t    return b.iushln(shift);\n\t  };\n\n\t  // Invert number in the field F(num)\n\t  BN.prototype.invm = function invm (num) {\n\t    return this.egcd(num).a.umod(num);\n\t  };\n\n\t  BN.prototype.isEven = function isEven () {\n\t    return (this.words[0] & 1) === 0;\n\t  };\n\n\t  BN.prototype.isOdd = function isOdd () {\n\t    return (this.words[0] & 1) === 1;\n\t  };\n\n\t  // And first word and num\n\t  BN.prototype.andln = function andln (num) {\n\t    return this.words[0] & num;\n\t  };\n\n\t  // Increment at the bit position in-line\n\t  BN.prototype.bincn = function bincn (bit) {\n\t    assert(typeof bit === \'number\');\n\t    var r = bit % 26;\n\t    var s = (bit - r) / 26;\n\t    var q = 1 << r;\n\n\t    // Fast case: bit is much higher than all existing words\n\t    if (this.length <= s) {\n\t      this._expand(s + 1);\n\t      this.words[s] |= q;\n\t      return this;\n\t    }\n\n\t    // Add bit and propagate, if needed\n\t    var carry = q;\n\t    for (var i = s; carry !== 0 && i < this.length; i++) {\n\t      var w = this.words[i] | 0;\n\t      w += carry;\n\t      carry = w >>> 26;\n\t      w &= 0x3ffffff;\n\t      this.words[i] = w;\n\t    }\n\t    if (carry !== 0) {\n\t      this.words[i] = carry;\n\t      this.length++;\n\t    }\n\t    return this;\n\t  };\n\n\t  BN.prototype.isZero = function isZero () {\n\t    return this.length === 1 && this.words[0] === 0;\n\t  };\n\n\t  BN.prototype.cmpn = function cmpn (num) {\n\t    var negative = num < 0;\n\n\t    if (this.negative !== 0 && !negative) return -1;\n\t    if (this.negative === 0 && negative) return 1;\n\n\t    this.strip();\n\n\t    var res;\n\t    if (this.length > 1) {\n\t      res = 1;\n\t    } else {\n\t      if (negative) {\n\t        num = -num;\n\t      }\n\n\t      assert(num <= 0x3ffffff, \'Number is too big\');\n\n\t      var w = this.words[0] | 0;\n\t      res = w === num ? 0 : w < num ? -1 : 1;\n\t    }\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Compare two numbers and return:\n\t  // 1 - if `this` > `num`\n\t  // 0 - if `this` == `num`\n\t  // -1 - if `this` < `num`\n\t  BN.prototype.cmp = function cmp (num) {\n\t    if (this.negative !== 0 && num.negative === 0) return -1;\n\t    if (this.negative === 0 && num.negative !== 0) return 1;\n\n\t    var res = this.ucmp(num);\n\t    if (this.negative !== 0) return -res | 0;\n\t    return res;\n\t  };\n\n\t  // Unsigned comparison\n\t  BN.prototype.ucmp = function ucmp (num) {\n\t    // At this point both numbers have the same sign\n\t    if (this.length > num.length) return 1;\n\t    if (this.length < num.length) return -1;\n\n\t    var res = 0;\n\t    for (var i = this.length - 1; i >= 0; i--) {\n\t      var a = this.words[i] | 0;\n\t      var b = num.words[i] | 0;\n\n\t      if (a === b) continue;\n\t      if (a < b) {\n\t        res = -1;\n\t      } else if (a > b) {\n\t        res = 1;\n\t      }\n\t      break;\n\t    }\n\t    return res;\n\t  };\n\n\t  BN.prototype.gtn = function gtn (num) {\n\t    return this.cmpn(num) === 1;\n\t  };\n\n\t  BN.prototype.gt = function gt (num) {\n\t    return this.cmp(num) === 1;\n\t  };\n\n\t  BN.prototype.gten = function gten (num) {\n\t    return this.cmpn(num) >= 0;\n\t  };\n\n\t  BN.prototype.gte = function gte (num) {\n\t    return this.cmp(num) >= 0;\n\t  };\n\n\t  BN.prototype.ltn = function ltn (num) {\n\t    return this.cmpn(num) === -1;\n\t  };\n\n\t  BN.prototype.lt = function lt (num) {\n\t    return this.cmp(num) === -1;\n\t  };\n\n\t  BN.prototype.lten = function lten (num) {\n\t    return this.cmpn(num) <= 0;\n\t  };\n\n\t  BN.prototype.lte = function lte (num) {\n\t    return this.cmp(num) <= 0;\n\t  };\n\n\t  BN.prototype.eqn = function eqn (num) {\n\t    return this.cmpn(num) === 0;\n\t  };\n\n\t  BN.prototype.eq = function eq (num) {\n\t    return this.cmp(num) === 0;\n\t  };\n\n\t  //\n\t  // A reduce context, could be using montgomery or something better, depending\n\t  // on the `m` itself.\n\t  //\n\t  BN.red = function red (num) {\n\t    return new Red(num);\n\t  };\n\n\t  BN.prototype.toRed = function toRed (ctx) {\n\t    assert(!this.red, \'Already a number in reduction context\');\n\t    assert(this.negative === 0, \'red works only with positives\');\n\t    return ctx.convertTo(this)._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.fromRed = function fromRed () {\n\t    assert(this.red, \'fromRed works only with numbers in reduction context\');\n\t    return this.red.convertFrom(this);\n\t  };\n\n\t  BN.prototype._forceRed = function _forceRed (ctx) {\n\t    this.red = ctx;\n\t    return this;\n\t  };\n\n\t  BN.prototype.forceRed = function forceRed (ctx) {\n\t    assert(!this.red, \'Already a number in reduction context\');\n\t    return this._forceRed(ctx);\n\t  };\n\n\t  BN.prototype.redAdd = function redAdd (num) {\n\t    assert(this.red, \'redAdd works only with red numbers\');\n\t    return this.red.add(this, num);\n\t  };\n\n\t  BN.prototype.redIAdd = function redIAdd (num) {\n\t    assert(this.red, \'redIAdd works only with red numbers\');\n\t    return this.red.iadd(this, num);\n\t  };\n\n\t  BN.prototype.redSub = function redSub (num) {\n\t    assert(this.red, \'redSub works only with red numbers\');\n\t    return this.red.sub(this, num);\n\t  };\n\n\t  BN.prototype.redISub = function redISub (num) {\n\t    assert(this.red, \'redISub works only with red numbers\');\n\t    return this.red.isub(this, num);\n\t  };\n\n\t  BN.prototype.redShl = function redShl (num) {\n\t    assert(this.red, \'redShl works only with red numbers\');\n\t    return this.red.shl(this, num);\n\t  };\n\n\t  BN.prototype.redMul = function redMul (num) {\n\t    assert(this.red, \'redMul works only with red numbers\');\n\t    this.red._verify2(this, num);\n\t    return this.red.mul(this, num);\n\t  };\n\n\t  BN.prototype.redIMul = function redIMul (num) {\n\t    assert(this.red, \'redMul works only with red numbers\');\n\t    this.red._verify2(this, num);\n\t    return this.red.imul(this, num);\n\t  };\n\n\t  BN.prototype.redSqr = function redSqr () {\n\t    assert(this.red, \'redSqr works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.sqr(this);\n\t  };\n\n\t  BN.prototype.redISqr = function redISqr () {\n\t    assert(this.red, \'redISqr works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.isqr(this);\n\t  };\n\n\t  // Square root over p\n\t  BN.prototype.redSqrt = function redSqrt () {\n\t    assert(this.red, \'redSqrt works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.sqrt(this);\n\t  };\n\n\t  BN.prototype.redInvm = function redInvm () {\n\t    assert(this.red, \'redInvm works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.invm(this);\n\t  };\n\n\t  // Return negative clone of `this` % `red modulo`\n\t  BN.prototype.redNeg = function redNeg () {\n\t    assert(this.red, \'redNeg works only with red numbers\');\n\t    this.red._verify1(this);\n\t    return this.red.neg(this);\n\t  };\n\n\t  BN.prototype.redPow = function redPow (num) {\n\t    assert(this.red && !num.red, \'redPow(normalNum)\');\n\t    this.red._verify1(this);\n\t    return this.red.pow(this, num);\n\t  };\n\n\t  // Prime numbers with efficient reduction\n\t  var primes = {\n\t    k256: null,\n\t    p224: null,\n\t    p192: null,\n\t    p25519: null\n\t  };\n\n\t  // Pseudo-Mersenne prime\n\t  function MPrime (name, p) {\n\t    // P = 2 ^ N - K\n\t    this.name = name;\n\t    this.p = new BN(p, 16);\n\t    this.n = this.p.bitLength();\n\t    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n\t    this.tmp = this._tmp();\n\t  }\n\n\t  MPrime.prototype._tmp = function _tmp () {\n\t    var tmp = new BN(null);\n\t    tmp.words = new Array(Math.ceil(this.n / 13));\n\t    return tmp;\n\t  };\n\n\t  MPrime.prototype.ireduce = function ireduce (num) {\n\t    // Assumes that `num` is less than `P^2`\n\t    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n\t    var r = num;\n\t    var rlen;\n\n\t    do {\n\t      this.split(r, this.tmp);\n\t      r = this.imulK(r);\n\t      r = r.iadd(this.tmp);\n\t      rlen = r.bitLength();\n\t    } while (rlen > this.n);\n\n\t    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n\t    if (cmp === 0) {\n\t      r.words[0] = 0;\n\t      r.length = 1;\n\t    } else if (cmp > 0) {\n\t      r.isub(this.p);\n\t    } else {\n\t      if (r.strip !== undefined) {\n\t        // r is BN v4 instance\n\t        r.strip();\n\t      } else {\n\t        // r is BN v5 instance\n\t        r._strip();\n\t      }\n\t    }\n\n\t    return r;\n\t  };\n\n\t  MPrime.prototype.split = function split (input, out) {\n\t    input.iushrn(this.n, 0, out);\n\t  };\n\n\t  MPrime.prototype.imulK = function imulK (num) {\n\t    return num.imul(this.k);\n\t  };\n\n\t  function K256 () {\n\t    MPrime.call(\n\t      this,\n\t      \'k256\',\n\t      \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\');\n\t  }\n\t  inherits(K256, MPrime);\n\n\t  K256.prototype.split = function split (input, output) {\n\t    // 256 = 9 * 26 + 22\n\t    var mask = 0x3fffff;\n\n\t    var outLen = Math.min(input.length, 9);\n\t    for (var i = 0; i < outLen; i++) {\n\t      output.words[i] = input.words[i];\n\t    }\n\t    output.length = outLen;\n\n\t    if (input.length <= 9) {\n\t      input.words[0] = 0;\n\t      input.length = 1;\n\t      return;\n\t    }\n\n\t    // Shift by 9 limbs\n\t    var prev = input.words[9];\n\t    output.words[output.length++] = prev & mask;\n\n\t    for (i = 10; i < input.length; i++) {\n\t      var next = input.words[i] | 0;\n\t      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n\t      prev = next;\n\t    }\n\t    prev >>>= 22;\n\t    input.words[i - 10] = prev;\n\t    if (prev === 0 && input.length > 10) {\n\t      input.length -= 10;\n\t    } else {\n\t      input.length -= 9;\n\t    }\n\t  };\n\n\t  K256.prototype.imulK = function imulK (num) {\n\t    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n\t    num.words[num.length] = 0;\n\t    num.words[num.length + 1] = 0;\n\t    num.length += 2;\n\n\t    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n\t    var lo = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var w = num.words[i] | 0;\n\t      lo += w * 0x3d1;\n\t      num.words[i] = lo & 0x3ffffff;\n\t      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n\t    }\n\n\t    // Fast length reduction\n\t    if (num.words[num.length - 1] === 0) {\n\t      num.length--;\n\t      if (num.words[num.length - 1] === 0) {\n\t        num.length--;\n\t      }\n\t    }\n\t    return num;\n\t  };\n\n\t  function P224 () {\n\t    MPrime.call(\n\t      this,\n\t      \'p224\',\n\t      \'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\');\n\t  }\n\t  inherits(P224, MPrime);\n\n\t  function P192 () {\n\t    MPrime.call(\n\t      this,\n\t      \'p192\',\n\t      \'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\');\n\t  }\n\t  inherits(P192, MPrime);\n\n\t  function P25519 () {\n\t    // 2 ^ 255 - 19\n\t    MPrime.call(\n\t      this,\n\t      \'25519\',\n\t      \'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\');\n\t  }\n\t  inherits(P25519, MPrime);\n\n\t  P25519.prototype.imulK = function imulK (num) {\n\t    // K = 0x13\n\t    var carry = 0;\n\t    for (var i = 0; i < num.length; i++) {\n\t      var hi = (num.words[i] | 0) * 0x13 + carry;\n\t      var lo = hi & 0x3ffffff;\n\t      hi >>>= 26;\n\n\t      num.words[i] = lo;\n\t      carry = hi;\n\t    }\n\t    if (carry !== 0) {\n\t      num.words[num.length++] = carry;\n\t    }\n\t    return num;\n\t  };\n\n\t  // Exported mostly for testing purposes, use plain name instead\n\t  BN._prime = function prime (name) {\n\t    // Cached version of prime\n\t    if (primes[name]) return primes[name];\n\n\t    var prime;\n\t    if (name === \'k256\') {\n\t      prime = new K256();\n\t    } else if (name === \'p224\') {\n\t      prime = new P224();\n\t    } else if (name === \'p192\') {\n\t      prime = new P192();\n\t    } else if (name === \'p25519\') {\n\t      prime = new P25519();\n\t    } else {\n\t      throw new Error(\'Unknown prime \' + name);\n\t    }\n\t    primes[name] = prime;\n\n\t    return prime;\n\t  };\n\n\t  //\n\t  // Base reduction engine\n\t  //\n\t  function Red (m) {\n\t    if (typeof m === \'string\') {\n\t      var prime = BN._prime(m);\n\t      this.m = prime.p;\n\t      this.prime = prime;\n\t    } else {\n\t      assert(m.gtn(1), \'modulus must be greater than 1\');\n\t      this.m = m;\n\t      this.prime = null;\n\t    }\n\t  }\n\n\t  Red.prototype._verify1 = function _verify1 (a) {\n\t    assert(a.negative === 0, \'red works only with positives\');\n\t    assert(a.red, \'red works only with red numbers\');\n\t  };\n\n\t  Red.prototype._verify2 = function _verify2 (a, b) {\n\t    assert((a.negative | b.negative) === 0, \'red works only with positives\');\n\t    assert(a.red && a.red === b.red,\n\t      \'red works only with red numbers\');\n\t  };\n\n\t  Red.prototype.imod = function imod (a) {\n\t    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\t    return a.umod(this.m)._forceRed(this);\n\t  };\n\n\t  Red.prototype.neg = function neg (a) {\n\t    if (a.isZero()) {\n\t      return a.clone();\n\t    }\n\n\t    return this.m.sub(a)._forceRed(this);\n\t  };\n\n\t  Red.prototype.add = function add (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.add(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.iadd = function iadd (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.iadd(b);\n\t    if (res.cmp(this.m) >= 0) {\n\t      res.isub(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.sub = function sub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.sub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res._forceRed(this);\n\t  };\n\n\t  Red.prototype.isub = function isub (a, b) {\n\t    this._verify2(a, b);\n\n\t    var res = a.isub(b);\n\t    if (res.cmpn(0) < 0) {\n\t      res.iadd(this.m);\n\t    }\n\t    return res;\n\t  };\n\n\t  Red.prototype.shl = function shl (a, num) {\n\t    this._verify1(a);\n\t    return this.imod(a.ushln(num));\n\t  };\n\n\t  Red.prototype.imul = function imul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.imul(b));\n\t  };\n\n\t  Red.prototype.mul = function mul (a, b) {\n\t    this._verify2(a, b);\n\t    return this.imod(a.mul(b));\n\t  };\n\n\t  Red.prototype.isqr = function isqr (a) {\n\t    return this.imul(a, a.clone());\n\t  };\n\n\t  Red.prototype.sqr = function sqr (a) {\n\t    return this.mul(a, a);\n\t  };\n\n\t  Red.prototype.sqrt = function sqrt (a) {\n\t    if (a.isZero()) return a.clone();\n\n\t    var mod3 = this.m.andln(3);\n\t    assert(mod3 % 2 === 1);\n\n\t    // Fast case\n\t    if (mod3 === 3) {\n\t      var pow = this.m.add(new BN(1)).iushrn(2);\n\t      return this.pow(a, pow);\n\t    }\n\n\t    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n\t    //\n\t    // Find Q and S, that Q * 2 ^ S = (P - 1)\n\t    var q = this.m.subn(1);\n\t    var s = 0;\n\t    while (!q.isZero() && q.andln(1) === 0) {\n\t      s++;\n\t      q.iushrn(1);\n\t    }\n\t    assert(!q.isZero());\n\n\t    var one = new BN(1).toRed(this);\n\t    var nOne = one.redNeg();\n\n\t    // Find quadratic non-residue\n\t    // NOTE: Max is such because of generalized Riemann hypothesis.\n\t    var lpow = this.m.subn(1).iushrn(1);\n\t    var z = this.m.bitLength();\n\t    z = new BN(2 * z * z).toRed(this);\n\n\t    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n\t      z.redIAdd(nOne);\n\t    }\n\n\t    var c = this.pow(z, q);\n\t    var r = this.pow(a, q.addn(1).iushrn(1));\n\t    var t = this.pow(a, q);\n\t    var m = s;\n\t    while (t.cmp(one) !== 0) {\n\t      var tmp = t;\n\t      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n\t        tmp = tmp.redSqr();\n\t      }\n\t      assert(i < m);\n\t      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n\t      r = r.redMul(b);\n\t      c = b.redSqr();\n\t      t = t.redMul(c);\n\t      m = i;\n\t    }\n\n\t    return r;\n\t  };\n\n\t  Red.prototype.invm = function invm (a) {\n\t    var inv = a._invmp(this.m);\n\t    if (inv.negative !== 0) {\n\t      inv.negative = 0;\n\t      return this.imod(inv).redNeg();\n\t    } else {\n\t      return this.imod(inv);\n\t    }\n\t  };\n\n\t  Red.prototype.pow = function pow (a, num) {\n\t    if (num.isZero()) return new BN(1).toRed(this);\n\t    if (num.cmpn(1) === 0) return a.clone();\n\n\t    var windowSize = 4;\n\t    var wnd = new Array(1 << windowSize);\n\t    wnd[0] = new BN(1).toRed(this);\n\t    wnd[1] = a;\n\t    for (var i = 2; i < wnd.length; i++) {\n\t      wnd[i] = this.mul(wnd[i - 1], a);\n\t    }\n\n\t    var res = wnd[0];\n\t    var current = 0;\n\t    var currentLen = 0;\n\t    var start = num.bitLength() % 26;\n\t    if (start === 0) {\n\t      start = 26;\n\t    }\n\n\t    for (i = num.length - 1; i >= 0; i--) {\n\t      var word = num.words[i];\n\t      for (var j = start - 1; j >= 0; j--) {\n\t        var bit = (word >> j) & 1;\n\t        if (res !== wnd[0]) {\n\t          res = this.sqr(res);\n\t        }\n\n\t        if (bit === 0 && current === 0) {\n\t          currentLen = 0;\n\t          continue;\n\t        }\n\n\t        current <<= 1;\n\t        current |= bit;\n\t        currentLen++;\n\t        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n\t        res = this.mul(res, wnd[current]);\n\t        currentLen = 0;\n\t        current = 0;\n\t      }\n\t      start = 26;\n\t    }\n\n\t    return res;\n\t  };\n\n\t  Red.prototype.convertTo = function convertTo (num) {\n\t    var r = num.umod(this.m);\n\n\t    return r === num ? r.clone() : r;\n\t  };\n\n\t  Red.prototype.convertFrom = function convertFrom (num) {\n\t    var res = num.clone();\n\t    res.red = null;\n\t    return res;\n\t  };\n\n\t  //\n\t  // Montgomery method engine\n\t  //\n\n\t  BN.mont = function mont (num) {\n\t    return new Mont(num);\n\t  };\n\n\t  function Mont (m) {\n\t    Red.call(this, m);\n\n\t    this.shift = this.m.bitLength();\n\t    if (this.shift % 26 !== 0) {\n\t      this.shift += 26 - (this.shift % 26);\n\t    }\n\n\t    this.r = new BN(1).iushln(this.shift);\n\t    this.r2 = this.imod(this.r.sqr());\n\t    this.rinv = this.r._invmp(this.m);\n\n\t    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n\t    this.minv = this.minv.umod(this.r);\n\t    this.minv = this.r.sub(this.minv);\n\t  }\n\t  inherits(Mont, Red);\n\n\t  Mont.prototype.convertTo = function convertTo (num) {\n\t    return this.imod(num.ushln(this.shift));\n\t  };\n\n\t  Mont.prototype.convertFrom = function convertFrom (num) {\n\t    var r = this.imod(num.mul(this.rinv));\n\t    r.red = null;\n\t    return r;\n\t  };\n\n\t  Mont.prototype.imul = function imul (a, b) {\n\t    if (a.isZero() || b.isZero()) {\n\t      a.words[0] = 0;\n\t      a.length = 1;\n\t      return a;\n\t    }\n\n\t    var t = a.imul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.mul = function mul (a, b) {\n\t    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n\t    var t = a.mul(b);\n\t    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n\t    var u = t.isub(c).iushrn(this.shift);\n\t    var res = u;\n\t    if (u.cmp(this.m) >= 0) {\n\t      res = u.isub(this.m);\n\t    } else if (u.cmpn(0) < 0) {\n\t      res = u.iadd(this.m);\n\t    }\n\n\t    return res._forceRed(this);\n\t  };\n\n\t  Mont.prototype.invm = function invm (a) {\n\t    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n\t    var res = this.imod(a._invmp(this.m).mul(this.r2));\n\t    return res._forceRed(this);\n\t  };\n\t})( false || module, commonjsGlobal);\n\t});\n\n\tvar utils_1 = createCommonjsModule(function (module, exports) {\n\t\'use strict\';\n\n\tvar utils = exports;\n\n\tfunction toArray(msg, enc) {\n\t  if (Array.isArray(msg))\n\t    return msg.slice();\n\t  if (!msg)\n\t    return [];\n\t  var res = [];\n\t  if (typeof msg !== \'string\') {\n\t    for (var i = 0; i < msg.length; i++)\n\t      res[i] = msg[i] | 0;\n\t    return res;\n\t  }\n\t  if (enc === \'hex\') {\n\t    msg = msg.replace(/[^a-z0-9]+/ig, \'\');\n\t    if (msg.length % 2 !== 0)\n\t      msg = \'0\' + msg;\n\t    for (var i = 0; i < msg.length; i += 2)\n\t      res.push(parseInt(msg[i] + msg[i + 1], 16));\n\t  } else {\n\t    for (var i = 0; i < msg.length; i++) {\n\t      var c = msg.charCodeAt(i);\n\t      var hi = c >> 8;\n\t      var lo = c & 0xff;\n\t      if (hi)\n\t        res.push(hi, lo);\n\t      else\n\t        res.push(lo);\n\t    }\n\t  }\n\t  return res;\n\t}\n\tutils.toArray = toArray;\n\n\tfunction zero2(word) {\n\t  if (word.length === 1)\n\t    return \'0\' + word;\n\t  else\n\t    return word;\n\t}\n\tutils.zero2 = zero2;\n\n\tfunction toHex(msg) {\n\t  var res = \'\';\n\t  for (var i = 0; i < msg.length; i++)\n\t    res += zero2(msg[i].toString(16));\n\t  return res;\n\t}\n\tutils.toHex = toHex;\n\n\tutils.encode = function encode(arr, enc) {\n\t  if (enc === \'hex\')\n\t    return toHex(arr);\n\t  else\n\t    return arr;\n\t};\n\t});\n\n\tvar utils_1$1 = createCommonjsModule(function (module, exports) {\n\t\'use strict\';\n\n\tvar utils = exports;\n\n\n\n\n\tutils.assert = minimalisticAssert;\n\tutils.toArray = utils_1.toArray;\n\tutils.zero2 = utils_1.zero2;\n\tutils.toHex = utils_1.toHex;\n\tutils.encode = utils_1.encode;\n\n\t// Represent num in a w-NAF form\n\tfunction getNAF(num, w, bits) {\n\t  var naf = new Array(Math.max(num.bitLength(), bits) + 1);\n\t  naf.fill(0);\n\n\t  var ws = 1 << (w + 1);\n\t  var k = num.clone();\n\n\t  for (var i = 0; i < naf.length; i++) {\n\t    var z;\n\t    var mod = k.andln(ws - 1);\n\t    if (k.isOdd()) {\n\t      if (mod > (ws >> 1) - 1)\n\t        z = (ws >> 1) - mod;\n\t      else\n\t        z = mod;\n\t      k.isubn(z);\n\t    } else {\n\t      z = 0;\n\t    }\n\n\t    naf[i] = z;\n\t    k.iushrn(1);\n\t  }\n\n\t  return naf;\n\t}\n\tutils.getNAF = getNAF;\n\n\t// Represent k1, k2 in a Joint Sparse Form\n\tfunction getJSF(k1, k2) {\n\t  var jsf = [\n\t    [],\n\t    []\n\t  ];\n\n\t  k1 = k1.clone();\n\t  k2 = k2.clone();\n\t  var d1 = 0;\n\t  var d2 = 0;\n\t  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {\n\n\t    // First phase\n\t    var m14 = (k1.andln(3) + d1) & 3;\n\t    var m24 = (k2.andln(3) + d2) & 3;\n\t    if (m14 === 3)\n\t      m14 = -1;\n\t    if (m24 === 3)\n\t      m24 = -1;\n\t    var u1;\n\t    if ((m14 & 1) === 0) {\n\t      u1 = 0;\n\t    } else {\n\t      var m8 = (k1.andln(7) + d1) & 7;\n\t      if ((m8 === 3 || m8 === 5) && m24 === 2)\n\t        u1 = -m14;\n\t      else\n\t        u1 = m14;\n\t    }\n\t    jsf[0].push(u1);\n\n\t    var u2;\n\t    if ((m24 & 1) === 0) {\n\t      u2 = 0;\n\t    } else {\n\t      var m8 = (k2.andln(7) + d2) & 7;\n\t      if ((m8 === 3 || m8 === 5) && m14 === 2)\n\t        u2 = -m24;\n\t      else\n\t        u2 = m24;\n\t    }\n\t    jsf[1].push(u2);\n\n\t    // Second phase\n\t    if (2 * d1 === u1 + 1)\n\t      d1 = 1 - d1;\n\t    if (2 * d2 === u2 + 1)\n\t      d2 = 1 - d2;\n\t    k1.iushrn(1);\n\t    k2.iushrn(1);\n\t  }\n\n\t  return jsf;\n\t}\n\tutils.getJSF = getJSF;\n\n\tfunction cachedProperty(obj, name, computer) {\n\t  var key = \'_\' + name;\n\t  obj.prototype[name] = function cachedProperty() {\n\t    return this[key] !== undefined ? this[key] :\n\t           this[key] = computer.call(this);\n\t  };\n\t}\n\tutils.cachedProperty = cachedProperty;\n\n\tfunction parseBytes(bytes) {\n\t  return typeof bytes === \'string\' ? utils.toArray(bytes, \'hex\') :\n\t                                     bytes;\n\t}\n\tutils.parseBytes = parseBytes;\n\n\tfunction intFromLE(bytes) {\n\t  return new bn$1(bytes, \'hex\', \'le\');\n\t}\n\tutils.intFromLE = intFromLE;\n\t});\n\n\tvar brorand = function(length) { var result = new Uint8Array(length); (commonjsGlobal.crypto || commonjsGlobal.msCrypto).getRandomValues(result); return result; };\n\n\t\'use strict\';\n\n\n\n\tvar getNAF = utils_1$1.getNAF;\n\tvar getJSF = utils_1$1.getJSF;\n\tvar assert$1 = utils_1$1.assert;\n\n\tfunction BaseCurve(type, conf) {\n\t  this.type = type;\n\t  this.p = new bn$1(conf.p, 16);\n\n\t  // Use Montgomery, when there is no fast reduction for the prime\n\t  this.red = conf.prime ? bn$1.red(conf.prime) : bn$1.mont(this.p);\n\n\t  // Useful for many curves\n\t  this.zero = new bn$1(0).toRed(this.red);\n\t  this.one = new bn$1(1).toRed(this.red);\n\t  this.two = new bn$1(2).toRed(this.red);\n\n\t  // Curve configuration, optional\n\t  this.n = conf.n && new bn$1(conf.n, 16);\n\t  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);\n\n\t  // Temporary arrays\n\t  this._wnafT1 = new Array(4);\n\t  this._wnafT2 = new Array(4);\n\t  this._wnafT3 = new Array(4);\n\t  this._wnafT4 = new Array(4);\n\n\t  this._bitLength = this.n ? this.n.bitLength() : 0;\n\n\t  // Generalized Greg Maxwell\'s trick\n\t  var adjustCount = this.n && this.p.div(this.n);\n\t  if (!adjustCount || adjustCount.cmpn(100) > 0) {\n\t    this.redN = null;\n\t  } else {\n\t    this._maxwellTrick = true;\n\t    this.redN = this.n.toRed(this.red);\n\t  }\n\t}\n\tvar base = BaseCurve;\n\n\tBaseCurve.prototype.point = function point() {\n\t  throw new Error(\'Not implemented\');\n\t};\n\n\tBaseCurve.prototype.validate = function validate() {\n\t  throw new Error(\'Not implemented\');\n\t};\n\n\tBaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {\n\t  assert$1(p.precomputed);\n\t  var doubles = p._getDoubles();\n\n\t  var naf = getNAF(k, 1, this._bitLength);\n\t  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);\n\t  I /= 3;\n\n\t  // Translate into more windowed form\n\t  var repr = [];\n\t  for (var j = 0; j < naf.length; j += doubles.step) {\n\t    var nafW = 0;\n\t    for (var k = j + doubles.step - 1; k >= j; k--)\n\t      nafW = (nafW << 1) + naf[k];\n\t    repr.push(nafW);\n\t  }\n\n\t  var a = this.jpoint(null, null, null);\n\t  var b = this.jpoint(null, null, null);\n\t  for (var i = I; i > 0; i--) {\n\t    for (var j = 0; j < repr.length; j++) {\n\t      var nafW = repr[j];\n\t      if (nafW === i)\n\t        b = b.mixedAdd(doubles.points[j]);\n\t      else if (nafW === -i)\n\t        b = b.mixedAdd(doubles.points[j].neg());\n\t    }\n\t    a = a.add(b);\n\t  }\n\t  return a.toP();\n\t};\n\n\tBaseCurve.prototype._wnafMul = function _wnafMul(p, k) {\n\t  var w = 4;\n\n\t  // Precompute window\n\t  var nafPoints = p._getNAFPoints(w);\n\t  w = nafPoints.wnd;\n\t  var wnd = nafPoints.points;\n\n\t  // Get NAF form\n\t  var naf = getNAF(k, w, this._bitLength);\n\n\t  // Add `this`*(N+1) for every w-NAF index\n\t  var acc = this.jpoint(null, null, null);\n\t  for (var i = naf.length - 1; i >= 0; i--) {\n\t    // Count zeroes\n\t    for (var k = 0; i >= 0 && naf[i] === 0; i--)\n\t      k++;\n\t    if (i >= 0)\n\t      k++;\n\t    acc = acc.dblp(k);\n\n\t    if (i < 0)\n\t      break;\n\t    var z = naf[i];\n\t    assert$1(z !== 0);\n\t    if (p.type === \'affine\') {\n\t      // J +- P\n\t      if (z > 0)\n\t        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);\n\t      else\n\t        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());\n\t    } else {\n\t      // J +- J\n\t      if (z > 0)\n\t        acc = acc.add(wnd[(z - 1) >> 1]);\n\t      else\n\t        acc = acc.add(wnd[(-z - 1) >> 1].neg());\n\t    }\n\t  }\n\t  return p.type === \'affine\' ? acc.toP() : acc;\n\t};\n\n\tBaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,\n\t                                                       points,\n\t                                                       coeffs,\n\t                                                       len,\n\t                                                       jacobianResult) {\n\t  var wndWidth = this._wnafT1;\n\t  var wnd = this._wnafT2;\n\t  var naf = this._wnafT3;\n\n\t  // Fill all arrays\n\t  var max = 0;\n\t  for (var i = 0; i < len; i++) {\n\t    var p = points[i];\n\t    var nafPoints = p._getNAFPoints(defW);\n\t    wndWidth[i] = nafPoints.wnd;\n\t    wnd[i] = nafPoints.points;\n\t  }\n\n\t  // Comb small window NAFs\n\t  for (var i = len - 1; i >= 1; i -= 2) {\n\t    var a = i - 1;\n\t    var b = i;\n\t    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {\n\t      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);\n\t      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);\n\t      max = Math.max(naf[a].length, max);\n\t      max = Math.max(naf[b].length, max);\n\t      continue;\n\t    }\n\n\t    var comb = [\n\t      points[a], /* 1 */\n\t      null, /* 3 */\n\t      null, /* 5 */\n\t      points[b] /* 7 */\n\t    ];\n\n\t    // Try to avoid Projective points, if possible\n\t    if (points[a].y.cmp(points[b].y) === 0) {\n\t      comb[1] = points[a].add(points[b]);\n\t      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n\t    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {\n\t      comb[1] = points[a].toJ().mixedAdd(points[b]);\n\t      comb[2] = points[a].add(points[b].neg());\n\t    } else {\n\t      comb[1] = points[a].toJ().mixedAdd(points[b]);\n\t      comb[2] = points[a].toJ().mixedAdd(points[b].neg());\n\t    }\n\n\t    var index = [\n\t      -3, /* -1 -1 */\n\t      -1, /* -1 0 */\n\t      -5, /* -1 1 */\n\t      -7, /* 0 -1 */\n\t      0, /* 0 0 */\n\t      7, /* 0 1 */\n\t      5, /* 1 -1 */\n\t      1, /* 1 0 */\n\t      3  /* 1 1 */\n\t    ];\n\n\t    var jsf = getJSF(coeffs[a], coeffs[b]);\n\t    max = Math.max(jsf[0].length, max);\n\t    naf[a] = new Array(max);\n\t    naf[b] = new Array(max);\n\t    for (var j = 0; j < max; j++) {\n\t      var ja = jsf[0][j] | 0;\n\t      var jb = jsf[1][j] | 0;\n\n\t      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];\n\t      naf[b][j] = 0;\n\t      wnd[a] = comb;\n\t    }\n\t  }\n\n\t  var acc = this.jpoint(null, null, null);\n\t  var tmp = this._wnafT4;\n\t  for (var i = max; i >= 0; i--) {\n\t    var k = 0;\n\n\t    while (i >= 0) {\n\t      var zero = true;\n\t      for (var j = 0; j < len; j++) {\n\t        tmp[j] = naf[j][i] | 0;\n\t        if (tmp[j] !== 0)\n\t          zero = false;\n\t      }\n\t      if (!zero)\n\t        break;\n\t      k++;\n\t      i--;\n\t    }\n\t    if (i >= 0)\n\t      k++;\n\t    acc = acc.dblp(k);\n\t    if (i < 0)\n\t      break;\n\n\t    for (var j = 0; j < len; j++) {\n\t      var z = tmp[j];\n\t      var p;\n\t      if (z === 0)\n\t        continue;\n\t      else if (z > 0)\n\t        p = wnd[j][(z - 1) >> 1];\n\t      else if (z < 0)\n\t        p = wnd[j][(-z - 1) >> 1].neg();\n\n\t      if (p.type === \'affine\')\n\t        acc = acc.mixedAdd(p);\n\t      else\n\t        acc = acc.add(p);\n\t    }\n\t  }\n\t  // Zeroify references\n\t  for (var i = 0; i < len; i++)\n\t    wnd[i] = null;\n\n\t  if (jacobianResult)\n\t    return acc;\n\t  else\n\t    return acc.toP();\n\t};\n\n\tfunction BasePoint(curve, type) {\n\t  this.curve = curve;\n\t  this.type = type;\n\t  this.precomputed = null;\n\t}\n\tBaseCurve.BasePoint = BasePoint;\n\n\tBasePoint.prototype.eq = function eq(/*other*/) {\n\t  throw new Error(\'Not implemented\');\n\t};\n\n\tBasePoint.prototype.validate = function validate() {\n\t  return this.curve.validate(this);\n\t};\n\n\tBaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {\n\t  bytes = utils_1$1.toArray(bytes, enc);\n\n\t  var len = this.p.byteLength();\n\n\t  // uncompressed, hybrid-odd, hybrid-even\n\t  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&\n\t      bytes.length - 1 === 2 * len) {\n\t    if (bytes[0] === 0x06)\n\t      assert$1(bytes[bytes.length - 1] % 2 === 0);\n\t    else if (bytes[0] === 0x07)\n\t      assert$1(bytes[bytes.length - 1] % 2 === 1);\n\n\t    var res =  this.point(bytes.slice(1, 1 + len),\n\t                          bytes.slice(1 + len, 1 + 2 * len));\n\n\t    return res;\n\t  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&\n\t              bytes.length - 1 === len) {\n\t    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);\n\t  }\n\t  throw new Error(\'Unknown point format\');\n\t};\n\n\tBasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {\n\t  return this.encode(enc, true);\n\t};\n\n\tBasePoint.prototype._encode = function _encode(compact) {\n\t  var len = this.curve.p.byteLength();\n\t  var x = this.getX().toArray(\'be\', len);\n\n\t  if (compact)\n\t    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);\n\n\t  return [ 0x04 ].concat(x, this.getY().toArray(\'be\', len)) ;\n\t};\n\n\tBasePoint.prototype.encode = function encode(enc, compact) {\n\t  return utils_1$1.encode(this._encode(compact), enc);\n\t};\n\n\tBasePoint.prototype.precompute = function precompute(power) {\n\t  if (this.precomputed)\n\t    return this;\n\n\t  var precomputed = {\n\t    doubles: null,\n\t    naf: null,\n\t    beta: null\n\t  };\n\t  precomputed.naf = this._getNAFPoints(8);\n\t  precomputed.doubles = this._getDoubles(4, power);\n\t  precomputed.beta = this._getBeta();\n\t  this.precomputed = precomputed;\n\n\t  return this;\n\t};\n\n\tBasePoint.prototype._hasDoubles = function _hasDoubles(k) {\n\t  if (!this.precomputed)\n\t    return false;\n\n\t  var doubles = this.precomputed.doubles;\n\t  if (!doubles)\n\t    return false;\n\n\t  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);\n\t};\n\n\tBasePoint.prototype._getDoubles = function _getDoubles(step, power) {\n\t  if (this.precomputed && this.precomputed.doubles)\n\t    return this.precomputed.doubles;\n\n\t  var doubles = [ this ];\n\t  var acc = this;\n\t  for (var i = 0; i < power; i += step) {\n\t    for (var j = 0; j < step; j++)\n\t      acc = acc.dbl();\n\t    doubles.push(acc);\n\t  }\n\t  return {\n\t    step: step,\n\t    points: doubles\n\t  };\n\t};\n\n\tBasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {\n\t  if (this.precomputed && this.precomputed.naf)\n\t    return this.precomputed.naf;\n\n\t  var res = [ this ];\n\t  var max = (1 << wnd) - 1;\n\t  var dbl = max === 1 ? null : this.dbl();\n\t  for (var i = 1; i < max; i++)\n\t    res[i] = res[i - 1].add(dbl);\n\t  return {\n\t    wnd: wnd,\n\t    points: res\n\t  };\n\t};\n\n\tBasePoint.prototype._getBeta = function _getBeta() {\n\t  return null;\n\t};\n\n\tBasePoint.prototype.dblp = function dblp(k) {\n\t  var r = this;\n\t  for (var i = 0; i < k; i++)\n\t    r = r.dbl();\n\t  return r;\n\t};\n\n\t\'use strict\';\n\n\n\n\n\n\n\tvar assert$2 = utils_1$1.assert;\n\n\tfunction ShortCurve(conf) {\n\t  base.call(this, \'short\', conf);\n\n\t  this.a = new bn$1(conf.a, 16).toRed(this.red);\n\t  this.b = new bn$1(conf.b, 16).toRed(this.red);\n\t  this.tinv = this.two.redInvm();\n\n\t  this.zeroA = this.a.fromRed().cmpn(0) === 0;\n\t  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;\n\n\t  // If the curve is endomorphic, precalculate beta and lambda\n\t  this.endo = this._getEndomorphism(conf);\n\t  this._endoWnafT1 = new Array(4);\n\t  this._endoWnafT2 = new Array(4);\n\t}\n\tinherits_browser(ShortCurve, base);\n\tvar short_1 = ShortCurve;\n\n\tShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {\n\t  // No efficient endomorphism\n\t  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)\n\t    return;\n\n\t  // Compute beta and lambda, that lambda * P = (beta * Px; Py)\n\t  var beta;\n\t  var lambda;\n\t  if (conf.beta) {\n\t    beta = new bn$1(conf.beta, 16).toRed(this.red);\n\t  } else {\n\t    var betas = this._getEndoRoots(this.p);\n\t    // Choose the smallest beta\n\t    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];\n\t    beta = beta.toRed(this.red);\n\t  }\n\t  if (conf.lambda) {\n\t    lambda = new bn$1(conf.lambda, 16);\n\t  } else {\n\t    // Choose the lambda that is matching selected beta\n\t    var lambdas = this._getEndoRoots(this.n);\n\t    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {\n\t      lambda = lambdas[0];\n\t    } else {\n\t      lambda = lambdas[1];\n\t      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);\n\t    }\n\t  }\n\n\t  // Get basis vectors, used for balanced length-two representation\n\t  var basis;\n\t  if (conf.basis) {\n\t    basis = conf.basis.map(function(vec) {\n\t      return {\n\t        a: new bn$1(vec.a, 16),\n\t        b: new bn$1(vec.b, 16)\n\t      };\n\t    });\n\t  } else {\n\t    basis = this._getEndoBasis(lambda);\n\t  }\n\n\t  return {\n\t    beta: beta,\n\t    lambda: lambda,\n\t    basis: basis\n\t  };\n\t};\n\n\tShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {\n\t  // Find roots of for x^2 + x + 1 in F\n\t  // Root = (-1 +- Sqrt(-3)) / 2\n\t  //\n\t  var red = num === this.p ? this.red : bn$1.mont(num);\n\t  var tinv = new bn$1(2).toRed(red).redInvm();\n\t  var ntinv = tinv.redNeg();\n\n\t  var s = new bn$1(3).toRed(red).redNeg().redSqrt().redMul(tinv);\n\n\t  var l1 = ntinv.redAdd(s).fromRed();\n\t  var l2 = ntinv.redSub(s).fromRed();\n\t  return [ l1, l2 ];\n\t};\n\n\tShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {\n\t  // aprxSqrt >= sqrt(this.n)\n\t  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));\n\n\t  // 3.74\n\t  // Run EGCD, until r(L + 1) < aprxSqrt\n\t  var u = lambda;\n\t  var v = this.n.clone();\n\t  var x1 = new bn$1(1);\n\t  var y1 = new bn$1(0);\n\t  var x2 = new bn$1(0);\n\t  var y2 = new bn$1(1);\n\n\t  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)\n\t  var a0;\n\t  var b0;\n\t  // First vector\n\t  var a1;\n\t  var b1;\n\t  // Second vector\n\t  var a2;\n\t  var b2;\n\n\t  var prevR;\n\t  var i = 0;\n\t  var r;\n\t  var x;\n\t  while (u.cmpn(0) !== 0) {\n\t    var q = v.div(u);\n\t    r = v.sub(q.mul(u));\n\t    x = x2.sub(q.mul(x1));\n\t    var y = y2.sub(q.mul(y1));\n\n\t    if (!a1 && r.cmp(aprxSqrt) < 0) {\n\t      a0 = prevR.neg();\n\t      b0 = x1;\n\t      a1 = r.neg();\n\t      b1 = x;\n\t    } else if (a1 && ++i === 2) {\n\t      break;\n\t    }\n\t    prevR = r;\n\n\t    v = u;\n\t    u = r;\n\t    x2 = x1;\n\t    x1 = x;\n\t    y2 = y1;\n\t    y1 = y;\n\t  }\n\t  a2 = r.neg();\n\t  b2 = x;\n\n\t  var len1 = a1.sqr().add(b1.sqr());\n\t  var len2 = a2.sqr().add(b2.sqr());\n\t  if (len2.cmp(len1) >= 0) {\n\t    a2 = a0;\n\t    b2 = b0;\n\t  }\n\n\t  // Normalize signs\n\t  if (a1.negative) {\n\t    a1 = a1.neg();\n\t    b1 = b1.neg();\n\t  }\n\t  if (a2.negative) {\n\t    a2 = a2.neg();\n\t    b2 = b2.neg();\n\t  }\n\n\t  return [\n\t    { a: a1, b: b1 },\n\t    { a: a2, b: b2 }\n\t  ];\n\t};\n\n\tShortCurve.prototype._endoSplit = function _endoSplit(k) {\n\t  var basis = this.endo.basis;\n\t  var v1 = basis[0];\n\t  var v2 = basis[1];\n\n\t  var c1 = v2.b.mul(k).divRound(this.n);\n\t  var c2 = v1.b.neg().mul(k).divRound(this.n);\n\n\t  var p1 = c1.mul(v1.a);\n\t  var p2 = c2.mul(v2.a);\n\t  var q1 = c1.mul(v1.b);\n\t  var q2 = c2.mul(v2.b);\n\n\t  // Calculate answer\n\t  var k1 = k.sub(p1).sub(p2);\n\t  var k2 = q1.add(q2).neg();\n\t  return { k1: k1, k2: k2 };\n\t};\n\n\tShortCurve.prototype.pointFromX = function pointFromX(x, odd) {\n\t  x = new bn$1(x, 16);\n\t  if (!x.red)\n\t    x = x.toRed(this.red);\n\n\t  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);\n\t  var y = y2.redSqrt();\n\t  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)\n\t    throw new Error(\'invalid point\');\n\n\t  // XXX Is there any way to tell if the number is odd without converting it\n\t  // to non-red form?\n\t  var isOdd = y.fromRed().isOdd();\n\t  if (odd && !isOdd || !odd && isOdd)\n\t    y = y.redNeg();\n\n\t  return this.point(x, y);\n\t};\n\n\tShortCurve.prototype.validate = function validate(point) {\n\t  if (point.inf)\n\t    return true;\n\n\t  var x = point.x;\n\t  var y = point.y;\n\n\t  var ax = this.a.redMul(x);\n\t  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);\n\t  return y.redSqr().redISub(rhs).cmpn(0) === 0;\n\t};\n\n\tShortCurve.prototype._endoWnafMulAdd =\n\t    function _endoWnafMulAdd(points, coeffs, jacobianResult) {\n\t  var npoints = this._endoWnafT1;\n\t  var ncoeffs = this._endoWnafT2;\n\t  for (var i = 0; i < points.length; i++) {\n\t    var split = this._endoSplit(coeffs[i]);\n\t    var p = points[i];\n\t    var beta = p._getBeta();\n\n\t    if (split.k1.negative) {\n\t      split.k1.ineg();\n\t      p = p.neg(true);\n\t    }\n\t    if (split.k2.negative) {\n\t      split.k2.ineg();\n\t      beta = beta.neg(true);\n\t    }\n\n\t    npoints[i * 2] = p;\n\t    npoints[i * 2 + 1] = beta;\n\t    ncoeffs[i * 2] = split.k1;\n\t    ncoeffs[i * 2 + 1] = split.k2;\n\t  }\n\t  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);\n\n\t  // Clean-up references to points and coefficients\n\t  for (var j = 0; j < i * 2; j++) {\n\t    npoints[j] = null;\n\t    ncoeffs[j] = null;\n\t  }\n\t  return res;\n\t};\n\n\tfunction Point(curve, x, y, isRed) {\n\t  base.BasePoint.call(this, curve, \'affine\');\n\t  if (x === null && y === null) {\n\t    this.x = null;\n\t    this.y = null;\n\t    this.inf = true;\n\t  } else {\n\t    this.x = new bn$1(x, 16);\n\t    this.y = new bn$1(y, 16);\n\t    // Force redgomery representation when loading from JSON\n\t    if (isRed) {\n\t      this.x.forceRed(this.curve.red);\n\t      this.y.forceRed(this.curve.red);\n\t    }\n\t    if (!this.x.red)\n\t      this.x = this.x.toRed(this.curve.red);\n\t    if (!this.y.red)\n\t      this.y = this.y.toRed(this.curve.red);\n\t    this.inf = false;\n\t  }\n\t}\n\tinherits_browser(Point, base.BasePoint);\n\n\tShortCurve.prototype.point = function point(x, y, isRed) {\n\t  return new Point(this, x, y, isRed);\n\t};\n\n\tShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {\n\t  return Point.fromJSON(this, obj, red);\n\t};\n\n\tPoint.prototype._getBeta = function _getBeta() {\n\t  if (!this.curve.endo)\n\t    return;\n\n\t  var pre = this.precomputed;\n\t  if (pre && pre.beta)\n\t    return pre.beta;\n\n\t  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);\n\t  if (pre) {\n\t    var curve = this.curve;\n\t    var endoMul = function(p) {\n\t      return curve.point(p.x.redMul(curve.endo.beta), p.y);\n\t    };\n\t    pre.beta = beta;\n\t    beta.precomputed = {\n\t      beta: null,\n\t      naf: pre.naf && {\n\t        wnd: pre.naf.wnd,\n\t        points: pre.naf.points.map(endoMul)\n\t      },\n\t      doubles: pre.doubles && {\n\t        step: pre.doubles.step,\n\t        points: pre.doubles.points.map(endoMul)\n\t      }\n\t    };\n\t  }\n\t  return beta;\n\t};\n\n\tPoint.prototype.toJSON = function toJSON() {\n\t  if (!this.precomputed)\n\t    return [ this.x, this.y ];\n\n\t  return [ this.x, this.y, this.precomputed && {\n\t    doubles: this.precomputed.doubles && {\n\t      step: this.precomputed.doubles.step,\n\t      points: this.precomputed.doubles.points.slice(1)\n\t    },\n\t    naf: this.precomputed.naf && {\n\t      wnd: this.precomputed.naf.wnd,\n\t      points: this.precomputed.naf.points.slice(1)\n\t    }\n\t  } ];\n\t};\n\n\tPoint.fromJSON = function fromJSON(curve, obj, red) {\n\t  if (typeof obj === \'string\')\n\t    obj = JSON.parse(obj);\n\t  var res = curve.point(obj[0], obj[1], red);\n\t  if (!obj[2])\n\t    return res;\n\n\t  function obj2point(obj) {\n\t    return curve.point(obj[0], obj[1], red);\n\t  }\n\n\t  var pre = obj[2];\n\t  res.precomputed = {\n\t    beta: null,\n\t    doubles: pre.doubles && {\n\t      step: pre.doubles.step,\n\t      points: [ res ].concat(pre.doubles.points.map(obj2point))\n\t    },\n\t    naf: pre.naf && {\n\t      wnd: pre.naf.wnd,\n\t      points: [ res ].concat(pre.naf.points.map(obj2point))\n\t    }\n\t  };\n\t  return res;\n\t};\n\n\tPoint.prototype.inspect = function inspect() {\n\t  if (this.isInfinity())\n\t    return \'<EC Point Infinity>\';\n\t  return \'<EC Point x: \' + this.x.fromRed().toString(16, 2) +\n\t      \' y: \' + this.y.fromRed().toString(16, 2) + \'>\';\n\t};\n\n\tPoint.prototype.isInfinity = function isInfinity() {\n\t  return this.inf;\n\t};\n\n\tPoint.prototype.add = function add(p) {\n\t  // O + P = P\n\t  if (this.inf)\n\t    return p;\n\n\t  // P + O = P\n\t  if (p.inf)\n\t    return this;\n\n\t  // P + P = 2P\n\t  if (this.eq(p))\n\t    return this.dbl();\n\n\t  // P + (-P) = O\n\t  if (this.neg().eq(p))\n\t    return this.curve.point(null, null);\n\n\t  // P + Q = O\n\t  if (this.x.cmp(p.x) === 0)\n\t    return this.curve.point(null, null);\n\n\t  var c = this.y.redSub(p.y);\n\t  if (c.cmpn(0) !== 0)\n\t    c = c.redMul(this.x.redSub(p.x).redInvm());\n\t  var nx = c.redSqr().redISub(this.x).redISub(p.x);\n\t  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n\t  return this.curve.point(nx, ny);\n\t};\n\n\tPoint.prototype.dbl = function dbl() {\n\t  if (this.inf)\n\t    return this;\n\n\t  // 2P = O\n\t  var ys1 = this.y.redAdd(this.y);\n\t  if (ys1.cmpn(0) === 0)\n\t    return this.curve.point(null, null);\n\n\t  var a = this.curve.a;\n\n\t  var x2 = this.x.redSqr();\n\t  var dyinv = ys1.redInvm();\n\t  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);\n\n\t  var nx = c.redSqr().redISub(this.x.redAdd(this.x));\n\t  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);\n\t  return this.curve.point(nx, ny);\n\t};\n\n\tPoint.prototype.getX = function getX() {\n\t  return this.x.fromRed();\n\t};\n\n\tPoint.prototype.getY = function getY() {\n\t  return this.y.fromRed();\n\t};\n\n\tPoint.prototype.mul = function mul(k) {\n\t  k = new bn$1(k, 16);\n\t  if (this.isInfinity())\n\t    return this;\n\t  else if (this._hasDoubles(k))\n\t    return this.curve._fixedNafMul(this, k);\n\t  else if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd([ this ], [ k ]);\n\t  else\n\t    return this.curve._wnafMul(this, k);\n\t};\n\n\tPoint.prototype.mulAdd = function mulAdd(k1, p2, k2) {\n\t  var points = [ this, p2 ];\n\t  var coeffs = [ k1, k2 ];\n\t  if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd(points, coeffs);\n\t  else\n\t    return this.curve._wnafMulAdd(1, points, coeffs, 2);\n\t};\n\n\tPoint.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {\n\t  var points = [ this, p2 ];\n\t  var coeffs = [ k1, k2 ];\n\t  if (this.curve.endo)\n\t    return this.curve._endoWnafMulAdd(points, coeffs, true);\n\t  else\n\t    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);\n\t};\n\n\tPoint.prototype.eq = function eq(p) {\n\t  return this === p ||\n\t         this.inf === p.inf &&\n\t             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);\n\t};\n\n\tPoint.prototype.neg = function neg(_precompute) {\n\t  if (this.inf)\n\t    return this;\n\n\t  var res = this.curve.point(this.x, this.y.redNeg());\n\t  if (_precompute && this.precomputed) {\n\t    var pre = this.precomputed;\n\t    var negate = function(p) {\n\t      return p.neg();\n\t    };\n\t    res.precomputed = {\n\t      naf: pre.naf && {\n\t        wnd: pre.naf.wnd,\n\t        points: pre.naf.points.map(negate)\n\t      },\n\t      doubles: pre.doubles && {\n\t        step: pre.doubles.step,\n\t        points: pre.doubles.points.map(negate)\n\t      }\n\t    };\n\t  }\n\t  return res;\n\t};\n\n\tPoint.prototype.toJ = function toJ() {\n\t  if (this.inf)\n\t    return this.curve.jpoint(null, null, null);\n\n\t  var res = this.curve.jpoint(this.x, this.y, this.curve.one);\n\t  return res;\n\t};\n\n\tfunction JPoint(curve, x, y, z) {\n\t  base.BasePoint.call(this, curve, \'jacobian\');\n\t  if (x === null && y === null && z === null) {\n\t    this.x = this.curve.one;\n\t    this.y = this.curve.one;\n\t    this.z = new bn$1(0);\n\t  } else {\n\t    this.x = new bn$1(x, 16);\n\t    this.y = new bn$1(y, 16);\n\t    this.z = new bn$1(z, 16);\n\t  }\n\t  if (!this.x.red)\n\t    this.x = this.x.toRed(this.curve.red);\n\t  if (!this.y.red)\n\t    this.y = this.y.toRed(this.curve.red);\n\t  if (!this.z.red)\n\t    this.z = this.z.toRed(this.curve.red);\n\n\t  this.zOne = this.z === this.curve.one;\n\t}\n\tinherits_browser(JPoint, base.BasePoint);\n\n\tShortCurve.prototype.jpoint = function jpoint(x, y, z) {\n\t  return new JPoint(this, x, y, z);\n\t};\n\n\tJPoint.prototype.toP = function toP() {\n\t  if (this.isInfinity())\n\t    return this.curve.point(null, null);\n\n\t  var zinv = this.z.redInvm();\n\t  var zinv2 = zinv.redSqr();\n\t  var ax = this.x.redMul(zinv2);\n\t  var ay = this.y.redMul(zinv2).redMul(zinv);\n\n\t  return this.curve.point(ax, ay);\n\t};\n\n\tJPoint.prototype.neg = function neg() {\n\t  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);\n\t};\n\n\tJPoint.prototype.add = function add(p) {\n\t  // O + P = P\n\t  if (this.isInfinity())\n\t    return p;\n\n\t  // P + O = P\n\t  if (p.isInfinity())\n\t    return this;\n\n\t  // 12M + 4S + 7A\n\t  var pz2 = p.z.redSqr();\n\t  var z2 = this.z.redSqr();\n\t  var u1 = this.x.redMul(pz2);\n\t  var u2 = p.x.redMul(z2);\n\t  var s1 = this.y.redMul(pz2.redMul(p.z));\n\t  var s2 = p.y.redMul(z2.redMul(this.z));\n\n\t  var h = u1.redSub(u2);\n\t  var r = s1.redSub(s2);\n\t  if (h.cmpn(0) === 0) {\n\t    if (r.cmpn(0) !== 0)\n\t      return this.curve.jpoint(null, null, null);\n\t    else\n\t      return this.dbl();\n\t  }\n\n\t  var h2 = h.redSqr();\n\t  var h3 = h2.redMul(h);\n\t  var v = u1.redMul(h2);\n\n\t  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n\t  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n\t  var nz = this.z.redMul(p.z).redMul(h);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.mixedAdd = function mixedAdd(p) {\n\t  // O + P = P\n\t  if (this.isInfinity())\n\t    return p.toJ();\n\n\t  // P + O = P\n\t  if (p.isInfinity())\n\t    return this;\n\n\t  // 8M + 3S + 7A\n\t  var z2 = this.z.redSqr();\n\t  var u1 = this.x;\n\t  var u2 = p.x.redMul(z2);\n\t  var s1 = this.y;\n\t  var s2 = p.y.redMul(z2).redMul(this.z);\n\n\t  var h = u1.redSub(u2);\n\t  var r = s1.redSub(s2);\n\t  if (h.cmpn(0) === 0) {\n\t    if (r.cmpn(0) !== 0)\n\t      return this.curve.jpoint(null, null, null);\n\t    else\n\t      return this.dbl();\n\t  }\n\n\t  var h2 = h.redSqr();\n\t  var h3 = h2.redMul(h);\n\t  var v = u1.redMul(h2);\n\n\t  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);\n\t  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));\n\t  var nz = this.z.redMul(h);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.dblp = function dblp(pow) {\n\t  if (pow === 0)\n\t    return this;\n\t  if (this.isInfinity())\n\t    return this;\n\t  if (!pow)\n\t    return this.dbl();\n\n\t  if (this.curve.zeroA || this.curve.threeA) {\n\t    var r = this;\n\t    for (var i = 0; i < pow; i++)\n\t      r = r.dbl();\n\t    return r;\n\t  }\n\n\t  // 1M + 2S + 1A + N * (4S + 5M + 8A)\n\t  // N = 1 => 6M + 6S + 9A\n\t  var a = this.curve.a;\n\t  var tinv = this.curve.tinv;\n\n\t  var jx = this.x;\n\t  var jy = this.y;\n\t  var jz = this.z;\n\t  var jz4 = jz.redSqr().redSqr();\n\n\t  // Reuse results\n\t  var jyd = jy.redAdd(jy);\n\t  for (var i = 0; i < pow; i++) {\n\t    var jx2 = jx.redSqr();\n\t    var jyd2 = jyd.redSqr();\n\t    var jyd4 = jyd2.redSqr();\n\t    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n\t    var t1 = jx.redMul(jyd2);\n\t    var nx = c.redSqr().redISub(t1.redAdd(t1));\n\t    var t2 = t1.redISub(nx);\n\t    var dny = c.redMul(t2);\n\t    dny = dny.redIAdd(dny).redISub(jyd4);\n\t    var nz = jyd.redMul(jz);\n\t    if (i + 1 < pow)\n\t      jz4 = jz4.redMul(jyd4);\n\n\t    jx = nx;\n\t    jz = nz;\n\t    jyd = dny;\n\t  }\n\n\t  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);\n\t};\n\n\tJPoint.prototype.dbl = function dbl() {\n\t  if (this.isInfinity())\n\t    return this;\n\n\t  if (this.curve.zeroA)\n\t    return this._zeroDbl();\n\t  else if (this.curve.threeA)\n\t    return this._threeDbl();\n\t  else\n\t    return this._dbl();\n\t};\n\n\tJPoint.prototype._zeroDbl = function _zeroDbl() {\n\t  var nx;\n\t  var ny;\n\t  var nz;\n\t  // Z = 1\n\t  if (this.zOne) {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n\t    //     #doubling-mdbl-2007-bl\n\t    // 1M + 5S + 14A\n\n\t    // XX = X1^2\n\t    var xx = this.x.redSqr();\n\t    // YY = Y1^2\n\t    var yy = this.y.redSqr();\n\t    // YYYY = YY^2\n\t    var yyyy = yy.redSqr();\n\t    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\t    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t    s = s.redIAdd(s);\n\t    // M = 3 * XX + a; a = 0\n\t    var m = xx.redAdd(xx).redIAdd(xx);\n\t    // T = M ^ 2 - 2*S\n\t    var t = m.redSqr().redISub(s).redISub(s);\n\n\t    // 8 * YYYY\n\t    var yyyy8 = yyyy.redIAdd(yyyy);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\n\t    // X3 = T\n\t    nx = t;\n\t    // Y3 = M * (S - T) - 8 * YYYY\n\t    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n\t    // Z3 = 2*Y1\n\t    nz = this.y.redAdd(this.y);\n\t  } else {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html\n\t    //     #doubling-dbl-2009-l\n\t    // 2M + 5S + 13A\n\n\t    // A = X1^2\n\t    var a = this.x.redSqr();\n\t    // B = Y1^2\n\t    var b = this.y.redSqr();\n\t    // C = B^2\n\t    var c = b.redSqr();\n\t    // D = 2 * ((X1 + B)^2 - A - C)\n\t    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);\n\t    d = d.redIAdd(d);\n\t    // E = 3 * A\n\t    var e = a.redAdd(a).redIAdd(a);\n\t    // F = E^2\n\t    var f = e.redSqr();\n\n\t    // 8 * C\n\t    var c8 = c.redIAdd(c);\n\t    c8 = c8.redIAdd(c8);\n\t    c8 = c8.redIAdd(c8);\n\n\t    // X3 = F - 2 * D\n\t    nx = f.redISub(d).redISub(d);\n\t    // Y3 = E * (D - X3) - 8 * C\n\t    ny = e.redMul(d.redISub(nx)).redISub(c8);\n\t    // Z3 = 2 * Y1 * Z1\n\t    nz = this.y.redMul(this.z);\n\t    nz = nz.redIAdd(nz);\n\t  }\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype._threeDbl = function _threeDbl() {\n\t  var nx;\n\t  var ny;\n\t  var nz;\n\t  // Z = 1\n\t  if (this.zOne) {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html\n\t    //     #doubling-mdbl-2007-bl\n\t    // 1M + 5S + 15A\n\n\t    // XX = X1^2\n\t    var xx = this.x.redSqr();\n\t    // YY = Y1^2\n\t    var yy = this.y.redSqr();\n\t    // YYYY = YY^2\n\t    var yyyy = yy.redSqr();\n\t    // S = 2 * ((X1 + YY)^2 - XX - YYYY)\n\t    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t    s = s.redIAdd(s);\n\t    // M = 3 * XX + a\n\t    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);\n\t    // T = M^2 - 2 * S\n\t    var t = m.redSqr().redISub(s).redISub(s);\n\t    // X3 = T\n\t    nx = t;\n\t    // Y3 = M * (S - T) - 8 * YYYY\n\t    var yyyy8 = yyyy.redIAdd(yyyy);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    yyyy8 = yyyy8.redIAdd(yyyy8);\n\t    ny = m.redMul(s.redISub(t)).redISub(yyyy8);\n\t    // Z3 = 2 * Y1\n\t    nz = this.y.redAdd(this.y);\n\t  } else {\n\t    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b\n\t    // 3M + 5S\n\n\t    // delta = Z1^2\n\t    var delta = this.z.redSqr();\n\t    // gamma = Y1^2\n\t    var gamma = this.y.redSqr();\n\t    // beta = X1 * gamma\n\t    var beta = this.x.redMul(gamma);\n\t    // alpha = 3 * (X1 - delta) * (X1 + delta)\n\t    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));\n\t    alpha = alpha.redAdd(alpha).redIAdd(alpha);\n\t    // X3 = alpha^2 - 8 * beta\n\t    var beta4 = beta.redIAdd(beta);\n\t    beta4 = beta4.redIAdd(beta4);\n\t    var beta8 = beta4.redAdd(beta4);\n\t    nx = alpha.redSqr().redISub(beta8);\n\t    // Z3 = (Y1 + Z1)^2 - gamma - delta\n\t    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);\n\t    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2\n\t    var ggamma8 = gamma.redSqr();\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ggamma8 = ggamma8.redIAdd(ggamma8);\n\t    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);\n\t  }\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype._dbl = function _dbl() {\n\t  var a = this.curve.a;\n\n\t  // 4M + 6S + 10A\n\t  var jx = this.x;\n\t  var jy = this.y;\n\t  var jz = this.z;\n\t  var jz4 = jz.redSqr().redSqr();\n\n\t  var jx2 = jx.redSqr();\n\t  var jy2 = jy.redSqr();\n\n\t  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));\n\n\t  var jxd4 = jx.redAdd(jx);\n\t  jxd4 = jxd4.redIAdd(jxd4);\n\t  var t1 = jxd4.redMul(jy2);\n\t  var nx = c.redSqr().redISub(t1.redAdd(t1));\n\t  var t2 = t1.redISub(nx);\n\n\t  var jyd8 = jy2.redSqr();\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  jyd8 = jyd8.redIAdd(jyd8);\n\t  var ny = c.redMul(t2).redISub(jyd8);\n\t  var nz = jy.redAdd(jy).redMul(jz);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.trpl = function trpl() {\n\t  if (!this.curve.zeroA)\n\t    return this.dbl().add(this);\n\n\t  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl\n\t  // 5M + 10S + ...\n\n\t  // XX = X1^2\n\t  var xx = this.x.redSqr();\n\t  // YY = Y1^2\n\t  var yy = this.y.redSqr();\n\t  // ZZ = Z1^2\n\t  var zz = this.z.redSqr();\n\t  // YYYY = YY^2\n\t  var yyyy = yy.redSqr();\n\t  // M = 3 * XX + a * ZZ2; a = 0\n\t  var m = xx.redAdd(xx).redIAdd(xx);\n\t  // MM = M^2\n\t  var mm = m.redSqr();\n\t  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM\n\t  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);\n\t  e = e.redIAdd(e);\n\t  e = e.redAdd(e).redIAdd(e);\n\t  e = e.redISub(mm);\n\t  // EE = E^2\n\t  var ee = e.redSqr();\n\t  // T = 16*YYYY\n\t  var t = yyyy.redIAdd(yyyy);\n\t  t = t.redIAdd(t);\n\t  t = t.redIAdd(t);\n\t  t = t.redIAdd(t);\n\t  // U = (M + E)^2 - MM - EE - T\n\t  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);\n\t  // X3 = 4 * (X1 * EE - 4 * YY * U)\n\t  var yyu4 = yy.redMul(u);\n\t  yyu4 = yyu4.redIAdd(yyu4);\n\t  yyu4 = yyu4.redIAdd(yyu4);\n\t  var nx = this.x.redMul(ee).redISub(yyu4);\n\t  nx = nx.redIAdd(nx);\n\t  nx = nx.redIAdd(nx);\n\t  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)\n\t  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));\n\t  ny = ny.redIAdd(ny);\n\t  ny = ny.redIAdd(ny);\n\t  ny = ny.redIAdd(ny);\n\t  // Z3 = (Z1 + E)^2 - ZZ - EE\n\t  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);\n\n\t  return this.curve.jpoint(nx, ny, nz);\n\t};\n\n\tJPoint.prototype.mul = function mul(k, kbase) {\n\t  k = new bn$1(k, kbase);\n\n\t  return this.curve._wnafMul(this, k);\n\t};\n\n\tJPoint.prototype.eq = function eq(p) {\n\t  if (p.type === \'affine\')\n\t    return this.eq(p.toJ());\n\n\t  if (this === p)\n\t    return true;\n\n\t  // x1 * z2^2 == x2 * z1^2\n\t  var z2 = this.z.redSqr();\n\t  var pz2 = p.z.redSqr();\n\t  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)\n\t    return false;\n\n\t  // y1 * z2^3 == y2 * z1^3\n\t  var z3 = z2.redMul(this.z);\n\t  var pz3 = pz2.redMul(p.z);\n\t  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;\n\t};\n\n\tJPoint.prototype.eqXToP = function eqXToP(x) {\n\t  var zs = this.z.redSqr();\n\t  var rx = x.toRed(this.curve.red).redMul(zs);\n\t  if (this.x.cmp(rx) === 0)\n\t    return true;\n\n\t  var xc = x.clone();\n\t  var t = this.curve.redN.redMul(zs);\n\t  for (;;) {\n\t    xc.iadd(this.curve.n);\n\t    if (xc.cmp(this.curve.p) >= 0)\n\t      return false;\n\n\t    rx.redIAdd(t);\n\t    if (this.x.cmp(rx) === 0)\n\t      return true;\n\t  }\n\t};\n\n\tJPoint.prototype.inspect = function inspect() {\n\t  if (this.isInfinity())\n\t    return \'<EC JPoint Infinity>\';\n\t  return \'<EC JPoint x: \' + this.x.toString(16, 2) +\n\t      \' y: \' + this.y.toString(16, 2) +\n\t      \' z: \' + this.z.toString(16, 2) + \'>\';\n\t};\n\n\tJPoint.prototype.isInfinity = function isInfinity() {\n\t  // XXX This code assumes that zero is always zero in red\n\t  return this.z.cmpn(0) === 0;\n\t};\n\n\tvar mont = {};\n\n\tvar edwards = {};\n\n\tvar curve_1 = createCommonjsModule(function (module, exports) {\n\t\'use strict\';\n\n\tvar curve = exports;\n\n\tcurve.base = base;\n\tcurve.short = short_1;\n\tcurve.mont = mont;\n\tcurve.edwards = edwards;\n\t});\n\n\tvar secp256k1 = undefined;\n\n\tvar curves_1 = createCommonjsModule(function (module, exports) {\n\t\'use strict\';\n\n\tvar curves = exports;\n\n\n\n\n\n\tvar assert = utils_1$1.assert;\n\n\tfunction PresetCurve(options) {\n\t  if (options.type === \'short\')\n\t    this.curve = new curve_1.short(options);\n\t  else if (options.type === \'edwards\')\n\t    this.curve = new curve_1.edwards(options);\n\t  else\n\t    this.curve = new curve_1.mont(options);\n\t  this.g = this.curve.g;\n\t  this.n = this.curve.n;\n\t  this.hash = options.hash;\n\n\t  assert(this.g.validate(), \'Invalid curve\');\n\t  assert(this.g.mul(this.n).isInfinity(), \'Invalid curve, G*N != O\');\n\t}\n\tcurves.PresetCurve = PresetCurve;\n\n\tfunction defineCurve(name, options) {\n\t  Object.defineProperty(curves, name, {\n\t    configurable: true,\n\t    enumerable: true,\n\t    get: function() {\n\t      var curve = new PresetCurve(options);\n\t      Object.defineProperty(curves, name, {\n\t        configurable: true,\n\t        enumerable: true,\n\t        value: curve\n\t      });\n\t      return curve;\n\t    }\n\t  });\n\t}\n\n\tdefineCurve(\'p192\', {\n\t  type: \'short\',\n\t  prime: \'p192\',\n\t  p: \'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\',\n\t  a: \'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc\',\n\t  b: \'64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1\',\n\t  n: \'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831\',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    \'188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012\',\n\t    \'07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811\'\n\t  ]\n\t});\n\n\tdefineCurve(\'p224\', {\n\t  type: \'short\',\n\t  prime: \'p224\',\n\t  p: \'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\',\n\t  a: \'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe\',\n\t  b: \'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4\',\n\t  n: \'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d\',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    \'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21\',\n\t    \'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34\'\n\t  ]\n\t});\n\n\tdefineCurve(\'p256\', {\n\t  type: \'short\',\n\t  prime: null,\n\t  p: \'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff\',\n\t  a: \'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc\',\n\t  b: \'5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b\',\n\t  n: \'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551\',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    \'6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296\',\n\t    \'4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5\'\n\t  ]\n\t});\n\n\tdefineCurve(\'p384\', {\n\t  type: \'short\',\n\t  prime: null,\n\t  p: \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \' +\n\t     \'fffffffe ffffffff 00000000 00000000 ffffffff\',\n\t  a: \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \' +\n\t     \'fffffffe ffffffff 00000000 00000000 fffffffc\',\n\t  b: \'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f \' +\n\t     \'5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef\',\n\t  n: \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 \' +\n\t     \'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973\',\n\t  hash: hash_1.sha384,\n\t  gRed: false,\n\t  g: [\n\t    \'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 \' +\n\t    \'5502f25d bf55296c 3a545e38 72760ab7\',\n\t    \'3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 \' +\n\t    \'0a60b1ce 1d7e819d 7a431d7c 90ea0e5f\'\n\t  ]\n\t});\n\n\tdefineCurve(\'p521\', {\n\t  type: \'short\',\n\t  prime: null,\n\t  p: \'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \' +\n\t     \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \' +\n\t     \'ffffffff ffffffff ffffffff ffffffff ffffffff\',\n\t  a: \'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \' +\n\t     \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff \' +\n\t     \'ffffffff ffffffff ffffffff ffffffff fffffffc\',\n\t  b: \'00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b \' +\n\t     \'99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd \' +\n\t     \'3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00\',\n\t  n: \'000001ff ffffffff ffffffff ffffffff ffffffff ffffffff \' +\n\t     \'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 \' +\n\t     \'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409\',\n\t  hash: hash_1.sha512,\n\t  gRed: false,\n\t  g: [\n\t    \'000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 \' +\n\t    \'053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 \' +\n\t    \'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66\',\n\t    \'00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 \' +\n\t    \'579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 \' +\n\t    \'3fad0761 353c7086 a272c240 88be9476 9fd16650\'\n\t  ]\n\t});\n\n\tdefineCurve(\'curve25519\', {\n\t  type: \'mont\',\n\t  prime: \'p25519\',\n\t  p: \'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\',\n\t  a: \'76d06\',\n\t  b: \'1\',\n\t  n: \'1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    \'9\'\n\t  ]\n\t});\n\n\tdefineCurve(\'ed25519\', {\n\t  type: \'edwards\',\n\t  prime: \'p25519\',\n\t  p: \'7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\',\n\t  a: \'-1\',\n\t  c: \'1\',\n\t  // -121665 * (121666^(-1)) (mod P)\n\t  d: \'52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3\',\n\t  n: \'1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed\',\n\t  hash: hash_1.sha256,\n\t  gRed: false,\n\t  g: [\n\t    \'216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\',\n\n\t    // 4/5\n\t    \'6666666666666666666666666666666666666666666666666666666666666658\'\n\t  ]\n\t});\n\n\tvar pre;\n\ttry {\n\t  pre = secp256k1;\n\t} catch (e) {\n\t  pre = undefined;\n\t}\n\n\tdefineCurve(\'secp256k1\', {\n\t  type: \'short\',\n\t  prime: \'k256\',\n\t  p: \'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\',\n\t  a: \'0\',\n\t  b: \'7\',\n\t  n: \'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141\',\n\t  h: \'1\',\n\t  hash: hash_1.sha256,\n\n\t  // Precomputed endomorphism\n\t  beta: \'7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\',\n\t  lambda: \'5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72\',\n\t  basis: [\n\t    {\n\t      a: \'3086d221a7d46bcde86c90e49284eb15\',\n\t      b: \'-e4437ed6010e88286f547fa90abfe4c3\'\n\t    },\n\t    {\n\t      a: \'114ca50f7a8e2f3f657c1108d9d44cfd8\',\n\t      b: \'3086d221a7d46bcde86c90e49284eb15\'\n\t    }\n\t  ],\n\n\t  gRed: false,\n\t  g: [\n\t    \'79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\',\n\t    \'483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\',\n\t    pre\n\t  ]\n\t});\n\t});\n\n\t\'use strict\';\n\n\n\n\n\n\tfunction HmacDRBG(options) {\n\t  if (!(this instanceof HmacDRBG))\n\t    return new HmacDRBG(options);\n\t  this.hash = options.hash;\n\t  this.predResist = !!options.predResist;\n\n\t  this.outLen = this.hash.outSize;\n\t  this.minEntropy = options.minEntropy || this.hash.hmacStrength;\n\n\t  this._reseed = null;\n\t  this.reseedInterval = null;\n\t  this.K = null;\n\t  this.V = null;\n\n\t  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || \'hex\');\n\t  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || \'hex\');\n\t  var pers = utils_1.toArray(options.pers, options.persEnc || \'hex\');\n\t  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n\t         \'Not enough entropy. Minimum is: \' + this.minEntropy + \' bits\');\n\t  this._init(entropy, nonce, pers);\n\t}\n\tvar hmacDrbg = HmacDRBG;\n\n\tHmacDRBG.prototype._init = function init(entropy, nonce, pers) {\n\t  var seed = entropy.concat(nonce).concat(pers);\n\n\t  this.K = new Array(this.outLen / 8);\n\t  this.V = new Array(this.outLen / 8);\n\t  for (var i = 0; i < this.V.length; i++) {\n\t    this.K[i] = 0x00;\n\t    this.V[i] = 0x01;\n\t  }\n\n\t  this._update(seed);\n\t  this._reseed = 1;\n\t  this.reseedInterval = 0x1000000000000;  // 2^48\n\t};\n\n\tHmacDRBG.prototype._hmac = function hmac() {\n\t  return new hash_1.hmac(this.hash, this.K);\n\t};\n\n\tHmacDRBG.prototype._update = function update(seed) {\n\t  var kmac = this._hmac()\n\t                 .update(this.V)\n\t                 .update([ 0x00 ]);\n\t  if (seed)\n\t    kmac = kmac.update(seed);\n\t  this.K = kmac.digest();\n\t  this.V = this._hmac().update(this.V).digest();\n\t  if (!seed)\n\t    return;\n\n\t  this.K = this._hmac()\n\t               .update(this.V)\n\t               .update([ 0x01 ])\n\t               .update(seed)\n\t               .digest();\n\t  this.V = this._hmac().update(this.V).digest();\n\t};\n\n\tHmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {\n\t  // Optional entropy enc\n\t  if (typeof entropyEnc !== \'string\') {\n\t    addEnc = add;\n\t    add = entropyEnc;\n\t    entropyEnc = null;\n\t  }\n\n\t  entropy = utils_1.toArray(entropy, entropyEnc);\n\t  add = utils_1.toArray(add, addEnc);\n\n\t  minimalisticAssert(entropy.length >= (this.minEntropy / 8),\n\t         \'Not enough entropy. Minimum is: \' + this.minEntropy + \' bits\');\n\n\t  this._update(entropy.concat(add || []));\n\t  this._reseed = 1;\n\t};\n\n\tHmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {\n\t  if (this._reseed > this.reseedInterval)\n\t    throw new Error(\'Reseed is required\');\n\n\t  // Optional encoding\n\t  if (typeof enc !== \'string\') {\n\t    addEnc = add;\n\t    add = enc;\n\t    enc = null;\n\t  }\n\n\t  // Optional additional data\n\t  if (add) {\n\t    add = utils_1.toArray(add, addEnc || \'hex\');\n\t    this._update(add);\n\t  }\n\n\t  var temp = [];\n\t  while (temp.length < len) {\n\t    this.V = this._hmac().update(this.V).digest();\n\t    temp = temp.concat(this.V);\n\t  }\n\n\t  var res = temp.slice(0, len);\n\t  this._update(add);\n\t  this._reseed++;\n\t  return utils_1.encode(res, enc);\n\t};\n\n\t\'use strict\';\n\n\n\n\tvar assert$3 = utils_1$1.assert;\n\n\tfunction KeyPair(ec, options) {\n\t  this.ec = ec;\n\t  this.priv = null;\n\t  this.pub = null;\n\n\t  // KeyPair(ec, { priv: ..., pub: ... })\n\t  if (options.priv)\n\t    this._importPrivate(options.priv, options.privEnc);\n\t  if (options.pub)\n\t    this._importPublic(options.pub, options.pubEnc);\n\t}\n\tvar key = KeyPair;\n\n\tKeyPair.fromPublic = function fromPublic(ec, pub, enc) {\n\t  if (pub instanceof KeyPair)\n\t    return pub;\n\n\t  return new KeyPair(ec, {\n\t    pub: pub,\n\t    pubEnc: enc\n\t  });\n\t};\n\n\tKeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {\n\t  if (priv instanceof KeyPair)\n\t    return priv;\n\n\t  return new KeyPair(ec, {\n\t    priv: priv,\n\t    privEnc: enc\n\t  });\n\t};\n\n\tKeyPair.prototype.validate = function validate() {\n\t  var pub = this.getPublic();\n\n\t  if (pub.isInfinity())\n\t    return { result: false, reason: \'Invalid public key\' };\n\t  if (!pub.validate())\n\t    return { result: false, reason: \'Public key is not a point\' };\n\t  if (!pub.mul(this.ec.curve.n).isInfinity())\n\t    return { result: false, reason: \'Public key * N != O\' };\n\n\t  return { result: true, reason: null };\n\t};\n\n\tKeyPair.prototype.getPublic = function getPublic(compact, enc) {\n\t  // compact is optional argument\n\t  if (typeof compact === \'string\') {\n\t    enc = compact;\n\t    compact = null;\n\t  }\n\n\t  if (!this.pub)\n\t    this.pub = this.ec.g.mul(this.priv);\n\n\t  if (!enc)\n\t    return this.pub;\n\n\t  return this.pub.encode(enc, compact);\n\t};\n\n\tKeyPair.prototype.getPrivate = function getPrivate(enc) {\n\t  if (enc === \'hex\')\n\t    return this.priv.toString(16, 2);\n\t  else\n\t    return this.priv;\n\t};\n\n\tKeyPair.prototype._importPrivate = function _importPrivate(key, enc) {\n\t  this.priv = new bn$1(key, enc || 16);\n\n\t  // Ensure that the priv won\'t be bigger than n, otherwise we may fail\n\t  // in fixed multiplication method\n\t  this.priv = this.priv.umod(this.ec.curve.n);\n\t};\n\n\tKeyPair.prototype._importPublic = function _importPublic(key, enc) {\n\t  if (key.x || key.y) {\n\t    // Montgomery points only have an `x` coordinate.\n\t    // Weierstrass/Edwards points on the other hand have both `x` and\n\t    // `y` coordinates.\n\t    if (this.ec.curve.type === \'mont\') {\n\t      assert$3(key.x, \'Need x coordinate\');\n\t    } else if (this.ec.curve.type === \'short\' ||\n\t               this.ec.curve.type === \'edwards\') {\n\t      assert$3(key.x && key.y, \'Need both x and y coordinate\');\n\t    }\n\t    this.pub = this.ec.curve.point(key.x, key.y);\n\t    return;\n\t  }\n\t  this.pub = this.ec.curve.decodePoint(key, enc);\n\t};\n\n\t// ECDH\n\tKeyPair.prototype.derive = function derive(pub) {\n\t  return pub.mul(this.priv).getX();\n\t};\n\n\t// ECDSA\n\tKeyPair.prototype.sign = function sign(msg, enc, options) {\n\t  return this.ec.sign(msg, this, enc, options);\n\t};\n\n\tKeyPair.prototype.verify = function verify(msg, signature) {\n\t  return this.ec.verify(msg, signature, this);\n\t};\n\n\tKeyPair.prototype.inspect = function inspect() {\n\t  return \'<Key priv: \' + (this.priv && this.priv.toString(16, 2)) +\n\t         \' pub: \' + (this.pub && this.pub.inspect()) + \' >\';\n\t};\n\n\t\'use strict\';\n\n\n\n\n\tvar assert$4 = utils_1$1.assert;\n\n\tfunction Signature(options, enc) {\n\t  if (options instanceof Signature)\n\t    return options;\n\n\t  if (this._importDER(options, enc))\n\t    return;\n\n\t  assert$4(options.r && options.s, \'Signature without r or s\');\n\t  this.r = new bn$1(options.r, 16);\n\t  this.s = new bn$1(options.s, 16);\n\t  if (options.recoveryParam === undefined)\n\t    this.recoveryParam = null;\n\t  else\n\t    this.recoveryParam = options.recoveryParam;\n\t}\n\tvar signature = Signature;\n\n\tfunction Position() {\n\t  this.place = 0;\n\t}\n\n\tfunction getLength(buf, p) {\n\t  var initial = buf[p.place++];\n\t  if (!(initial & 0x80)) {\n\t    return initial;\n\t  }\n\t  var octetLen = initial & 0xf;\n\n\t  // Indefinite length or overflow\n\t  if (octetLen === 0 || octetLen > 4) {\n\t    return false;\n\t  }\n\n\t  var val = 0;\n\t  for (var i = 0, off = p.place; i < octetLen; i++, off++) {\n\t    val <<= 8;\n\t    val |= buf[off];\n\t    val >>>= 0;\n\t  }\n\n\t  // Leading zeroes\n\t  if (val <= 0x7f) {\n\t    return false;\n\t  }\n\n\t  p.place = off;\n\t  return val;\n\t}\n\n\tfunction rmPadding(buf) {\n\t  var i = 0;\n\t  var len = buf.length - 1;\n\t  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {\n\t    i++;\n\t  }\n\t  if (i === 0) {\n\t    return buf;\n\t  }\n\t  return buf.slice(i);\n\t}\n\n\tSignature.prototype._importDER = function _importDER(data, enc) {\n\t  data = utils_1$1.toArray(data, enc);\n\t  var p = new Position();\n\t  if (data[p.place++] !== 0x30) {\n\t    return false;\n\t  }\n\t  var len = getLength(data, p);\n\t  if (len === false) {\n\t    return false;\n\t  }\n\t  if ((len + p.place) !== data.length) {\n\t    return false;\n\t  }\n\t  if (data[p.place++] !== 0x02) {\n\t    return false;\n\t  }\n\t  var rlen = getLength(data, p);\n\t  if (rlen === false) {\n\t    return false;\n\t  }\n\t  var r = data.slice(p.place, rlen + p.place);\n\t  p.place += rlen;\n\t  if (data[p.place++] !== 0x02) {\n\t    return false;\n\t  }\n\t  var slen = getLength(data, p);\n\t  if (slen === false) {\n\t    return false;\n\t  }\n\t  if (data.length !== slen + p.place) {\n\t    return false;\n\t  }\n\t  var s = data.slice(p.place, slen + p.place);\n\t  if (r[0] === 0) {\n\t    if (r[1] & 0x80) {\n\t      r = r.slice(1);\n\t    } else {\n\t      // Leading zeroes\n\t      return false;\n\t    }\n\t  }\n\t  if (s[0] === 0) {\n\t    if (s[1] & 0x80) {\n\t      s = s.slice(1);\n\t    } else {\n\t      // Leading zeroes\n\t      return false;\n\t    }\n\t  }\n\n\t  this.r = new bn$1(r);\n\t  this.s = new bn$1(s);\n\t  this.recoveryParam = null;\n\n\t  return true;\n\t};\n\n\tfunction constructLength(arr, len) {\n\t  if (len < 0x80) {\n\t    arr.push(len);\n\t    return;\n\t  }\n\t  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);\n\t  arr.push(octets | 0x80);\n\t  while (--octets) {\n\t    arr.push((len >>> (octets << 3)) & 0xff);\n\t  }\n\t  arr.push(len);\n\t}\n\n\tSignature.prototype.toDER = function toDER(enc) {\n\t  var r = this.r.toArray();\n\t  var s = this.s.toArray();\n\n\t  // Pad values\n\t  if (r[0] & 0x80)\n\t    r = [ 0 ].concat(r);\n\t  // Pad values\n\t  if (s[0] & 0x80)\n\t    s = [ 0 ].concat(s);\n\n\t  r = rmPadding(r);\n\t  s = rmPadding(s);\n\n\t  while (!s[0] && !(s[1] & 0x80)) {\n\t    s = s.slice(1);\n\t  }\n\t  var arr = [ 0x02 ];\n\t  constructLength(arr, r.length);\n\t  arr = arr.concat(r);\n\t  arr.push(0x02);\n\t  constructLength(arr, s.length);\n\t  var backHalf = arr.concat(s);\n\t  var res = [ 0x30 ];\n\t  constructLength(res, backHalf.length);\n\t  res = res.concat(backHalf);\n\t  return utils_1$1.encode(res, enc);\n\t};\n\n\t\'use strict\';\n\n\n\n\n\n\n\tvar assert$5 = utils_1$1.assert;\n\n\n\n\n\tfunction EC(options) {\n\t  if (!(this instanceof EC))\n\t    return new EC(options);\n\n\t  // Shortcut `elliptic.ec(curve-name)`\n\t  if (typeof options === \'string\') {\n\t    assert$5(curves_1.hasOwnProperty(options), \'Unknown curve \' + options);\n\n\t    options = curves_1[options];\n\t  }\n\n\t  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`\n\t  if (options instanceof curves_1.PresetCurve)\n\t    options = { curve: options };\n\n\t  this.curve = options.curve.curve;\n\t  this.n = this.curve.n;\n\t  this.nh = this.n.ushrn(1);\n\t  this.g = this.curve.g;\n\n\t  // Point on curve\n\t  this.g = options.curve.g;\n\t  this.g.precompute(options.curve.n.bitLength() + 1);\n\n\t  // Hash for function for DRBG\n\t  this.hash = options.hash || options.curve.hash;\n\t}\n\tvar ec = EC;\n\n\tEC.prototype.keyPair = function keyPair(options) {\n\t  return new key(this, options);\n\t};\n\n\tEC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {\n\t  return key.fromPrivate(this, priv, enc);\n\t};\n\n\tEC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {\n\t  return key.fromPublic(this, pub, enc);\n\t};\n\n\tEC.prototype.genKeyPair = function genKeyPair(options) {\n\t  if (!options)\n\t    options = {};\n\n\t  // Instantiate Hmac_DRBG\n\t  var drbg = new hmacDrbg({\n\t    hash: this.hash,\n\t    pers: options.pers,\n\t    persEnc: options.persEnc || \'utf8\',\n\t    entropy: options.entropy || brorand(this.hash.hmacStrength),\n\t    entropyEnc: options.entropy && options.entropyEnc || \'utf8\',\n\t    nonce: this.n.toArray()\n\t  });\n\n\t  var bytes = this.n.byteLength();\n\t  var ns2 = this.n.sub(new bn$1(2));\n\t  do {\n\t    var priv = new bn$1(drbg.generate(bytes));\n\t    if (priv.cmp(ns2) > 0)\n\t      continue;\n\n\t    priv.iaddn(1);\n\t    return this.keyFromPrivate(priv);\n\t  } while (true);\n\t};\n\n\tEC.prototype._truncateToN = function truncateToN(msg, truncOnly) {\n\t  var delta = msg.byteLength() * 8 - this.n.bitLength();\n\t  if (delta > 0)\n\t    msg = msg.ushrn(delta);\n\t  if (!truncOnly && msg.cmp(this.n) >= 0)\n\t    return msg.sub(this.n);\n\t  else\n\t    return msg;\n\t};\n\n\tEC.prototype.sign = function sign(msg, key, enc, options) {\n\t  if (typeof enc === \'object\') {\n\t    options = enc;\n\t    enc = null;\n\t  }\n\t  if (!options)\n\t    options = {};\n\n\t  key = this.keyFromPrivate(key, enc);\n\t  msg = this._truncateToN(new bn$1(msg, 16));\n\n\t  // Zero-extend key to provide enough entropy\n\t  var bytes = this.n.byteLength();\n\t  var bkey = key.getPrivate().toArray(\'be\', bytes);\n\n\t  // Zero-extend nonce to have the same byte size as N\n\t  var nonce = msg.toArray(\'be\', bytes);\n\n\t  // Instantiate Hmac_DRBG\n\t  var drbg = new hmacDrbg({\n\t    hash: this.hash,\n\t    entropy: bkey,\n\t    nonce: nonce,\n\t    pers: options.pers,\n\t    persEnc: options.persEnc || \'utf8\'\n\t  });\n\n\t  // Number of bytes to generate\n\t  var ns1 = this.n.sub(new bn$1(1));\n\n\t  for (var iter = 0; true; iter++) {\n\t    var k = options.k ?\n\t        options.k(iter) :\n\t        new bn$1(drbg.generate(this.n.byteLength()));\n\t    k = this._truncateToN(k, true);\n\t    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)\n\t      continue;\n\n\t    var kp = this.g.mul(k);\n\t    if (kp.isInfinity())\n\t      continue;\n\n\t    var kpX = kp.getX();\n\t    var r = kpX.umod(this.n);\n\t    if (r.cmpn(0) === 0)\n\t      continue;\n\n\t    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));\n\t    s = s.umod(this.n);\n\t    if (s.cmpn(0) === 0)\n\t      continue;\n\n\t    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |\n\t                        (kpX.cmp(r) !== 0 ? 2 : 0);\n\n\t    // Use complement of `s`, if it is > `n / 2`\n\t    if (options.canonical && s.cmp(this.nh) > 0) {\n\t      s = this.n.sub(s);\n\t      recoveryParam ^= 1;\n\t    }\n\n\t    return new signature({ r: r, s: s, recoveryParam: recoveryParam });\n\t  }\n\t};\n\n\tEC.prototype.verify = function verify(msg, signature$1, key, enc) {\n\t  msg = this._truncateToN(new bn$1(msg, 16));\n\t  key = this.keyFromPublic(key, enc);\n\t  signature$1 = new signature(signature$1, \'hex\');\n\n\t  // Perform primitive values validation\n\t  var r = signature$1.r;\n\t  var s = signature$1.s;\n\t  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)\n\t    return false;\n\t  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)\n\t    return false;\n\n\t  // Validate signature\n\t  var sinv = s.invm(this.n);\n\t  var u1 = sinv.mul(msg).umod(this.n);\n\t  var u2 = sinv.mul(r).umod(this.n);\n\n\t  if (!this.curve._maxwellTrick) {\n\t    var p = this.g.mulAdd(u1, key.getPublic(), u2);\n\t    if (p.isInfinity())\n\t      return false;\n\n\t    return p.getX().umod(this.n).cmp(r) === 0;\n\t  }\n\n\t  // NOTE: Greg Maxwell\'s trick, inspired by:\n\t  // https://git.io/vad3K\n\n\t  var p = this.g.jmulAdd(u1, key.getPublic(), u2);\n\t  if (p.isInfinity())\n\t    return false;\n\n\t  // Compare `p.x` of Jacobian point with `r`,\n\t  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the\n\t  // inverse of `p.z^2`\n\t  return p.eqXToP(r);\n\t};\n\n\tEC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {\n\t  assert$5((3 & j) === j, \'The recovery param is more than two bits\');\n\t  signature$1 = new signature(signature$1, enc);\n\n\t  var n = this.n;\n\t  var e = new bn$1(msg);\n\t  var r = signature$1.r;\n\t  var s = signature$1.s;\n\n\t  // A set LSB signifies that the y-coordinate is odd\n\t  var isYOdd = j & 1;\n\t  var isSecondKey = j >> 1;\n\t  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)\n\t    throw new Error(\'Unable to find sencond key candinate\');\n\n\t  // 1.1. Let x = r + jn.\n\t  if (isSecondKey)\n\t    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);\n\t  else\n\t    r = this.curve.pointFromX(r, isYOdd);\n\n\t  var rInv = signature$1.r.invm(n);\n\t  var s1 = n.sub(e).mul(rInv).umod(n);\n\t  var s2 = s.mul(rInv).umod(n);\n\n\t  // 1.6.1 Compute Q = r^-1 (sR -  eG)\n\t  //               Q = r^-1 (sR + -eG)\n\t  return this.g.mulAdd(s1, r, s2);\n\t};\n\n\tEC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {\n\t  signature$1 = new signature(signature$1, enc);\n\t  if (signature$1.recoveryParam !== null)\n\t    return signature$1.recoveryParam;\n\n\t  for (var i = 0; i < 4; i++) {\n\t    var Qprime;\n\t    try {\n\t      Qprime = this.recoverPubKey(e, signature$1, i);\n\t    } catch (e) {\n\t      continue;\n\t    }\n\n\t    if (Qprime.eq(Q))\n\t      return i;\n\t  }\n\t  throw new Error(\'Unable to find valid recovery factor\');\n\t};\n\n\tvar eddsa = {};\n\n\tvar require$$0$1 = getCjsExportFromNamespace(_package$1);\n\n\tvar elliptic_1 = createCommonjsModule(function (module, exports) {\n\t\'use strict\';\n\n\tvar elliptic = exports;\n\n\telliptic.version = require$$0$1.version;\n\telliptic.utils = utils_1$1;\n\telliptic.rand = brorand;\n\telliptic.curve = curve_1;\n\telliptic.curves = curves_1;\n\n\t// Protocols\n\telliptic.ec = ec;\n\telliptic.eddsa = eddsa;\n\t});\n\tvar elliptic_2 = elliptic_1.ec;\n\n\tvar _version$q = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "signing-key/5.0.4";\n\n\t});\n\n\tvar _version$r = unwrapExports(_version$q);\n\tvar _version_1$d = _version$q.version;\n\n\tvar lib$f = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$q.version);\n\tvar _curve = null;\n\tfunction getCurve() {\n\t    if (!_curve) {\n\t        _curve = new elliptic_1.ec("secp256k1");\n\t    }\n\t    return _curve;\n\t}\n\tvar SigningKey = /** @class */ (function () {\n\t    function SigningKey(privateKey) {\n\t        lib$3.defineReadOnly(this, "curve", "secp256k1");\n\t        lib$3.defineReadOnly(this, "privateKey", lib$1.hexlify(privateKey));\n\t        var keyPair = getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));\n\t        lib$3.defineReadOnly(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));\n\t        lib$3.defineReadOnly(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));\n\t        lib$3.defineReadOnly(this, "_isSigningKey", true);\n\t    }\n\t    SigningKey.prototype._addPoint = function (other) {\n\t        var p0 = getCurve().keyFromPublic(lib$1.arrayify(this.publicKey));\n\t        var p1 = getCurve().keyFromPublic(lib$1.arrayify(other));\n\t        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");\n\t    };\n\t    SigningKey.prototype.signDigest = function (digest) {\n\t        var keyPair = getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));\n\t        var signature = keyPair.sign(lib$1.arrayify(digest), { canonical: true });\n\t        return lib$1.splitSignature({\n\t            recoveryParam: signature.recoveryParam,\n\t            r: lib$1.hexZeroPad("0x" + signature.r.toString(16), 32),\n\t            s: lib$1.hexZeroPad("0x" + signature.s.toString(16), 32),\n\t        });\n\t    };\n\t    SigningKey.prototype.computeSharedSecret = function (otherKey) {\n\t        var keyPair = getCurve().keyFromPrivate(lib$1.arrayify(this.privateKey));\n\t        var otherKeyPair = getCurve().keyFromPublic(lib$1.arrayify(computePublicKey(otherKey)));\n\t        return lib$1.hexZeroPad("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);\n\t    };\n\t    SigningKey.isSigningKey = function (value) {\n\t        return !!(value && value._isSigningKey);\n\t    };\n\t    return SigningKey;\n\t}());\n\texports.SigningKey = SigningKey;\n\tfunction recoverPublicKey(digest, signature) {\n\t    var sig = lib$1.splitSignature(signature);\n\t    var rs = { r: lib$1.arrayify(sig.r), s: lib$1.arrayify(sig.s) };\n\t    return "0x" + getCurve().recoverPubKey(lib$1.arrayify(digest), rs, sig.recoveryParam).encode("hex", false);\n\t}\n\texports.recoverPublicKey = recoverPublicKey;\n\tfunction computePublicKey(key, compressed) {\n\t    var bytes = lib$1.arrayify(key);\n\t    if (bytes.length === 32) {\n\t        var signingKey = new SigningKey(bytes);\n\t        if (compressed) {\n\t            return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");\n\t        }\n\t        return signingKey.publicKey;\n\t    }\n\t    else if (bytes.length === 33) {\n\t        if (compressed) {\n\t            return lib$1.hexlify(bytes);\n\t        }\n\t        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");\n\t    }\n\t    else if (bytes.length === 65) {\n\t        if (!compressed) {\n\t            return lib$1.hexlify(bytes);\n\t        }\n\t        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");\n\t    }\n\t    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");\n\t}\n\texports.computePublicKey = computePublicKey;\n\n\t});\n\n\tvar index$f = unwrapExports(lib$f);\n\tvar lib_1$f = lib$f.SigningKey;\n\tvar lib_2$e = lib$f.recoverPublicKey;\n\tvar lib_3$b = lib$f.computePublicKey;\n\n\tvar _version$s = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "transactions/5.0.5";\n\n\t});\n\n\tvar _version$t = unwrapExports(_version$s);\n\tvar _version_1$e = _version$s.version;\n\n\tvar lib$g = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result["default"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\tvar RLP = __importStar(lib$5);\n\n\n\n\tvar logger = new lib.Logger(_version$s.version);\n\t///////////////////////////////\n\tfunction handleAddress(value) {\n\t    if (value === "0x") {\n\t        return null;\n\t    }\n\t    return lib$6.getAddress(value);\n\t}\n\tfunction handleNumber(value) {\n\t    if (value === "0x") {\n\t        return lib$7.Zero;\n\t    }\n\t    return lib$2.BigNumber.from(value);\n\t}\n\tvar transactionFields = [\n\t    { name: "nonce", maxLength: 32, numeric: true },\n\t    { name: "gasPrice", maxLength: 32, numeric: true },\n\t    { name: "gasLimit", maxLength: 32, numeric: true },\n\t    { name: "to", length: 20 },\n\t    { name: "value", maxLength: 32, numeric: true },\n\t    { name: "data" },\n\t];\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n\t};\n\tfunction computeAddress(key) {\n\t    var publicKey = lib$f.computePublicKey(key);\n\t    return lib$6.getAddress(lib$1.hexDataSlice(lib$4.keccak256(lib$1.hexDataSlice(publicKey, 1)), 12));\n\t}\n\texports.computeAddress = computeAddress;\n\tfunction recoverAddress(digest, signature) {\n\t    return computeAddress(lib$f.recoverPublicKey(lib$1.arrayify(digest), signature));\n\t}\n\texports.recoverAddress = recoverAddress;\n\tfunction serialize(transaction, signature) {\n\t    lib$3.checkProperties(transaction, allowedTransactionKeys);\n\t    var raw = [];\n\t    transactionFields.forEach(function (fieldInfo) {\n\t        var value = transaction[fieldInfo.name] || ([]);\n\t        var options = {};\n\t        if (fieldInfo.numeric) {\n\t            options.hexPad = "left";\n\t        }\n\t        value = lib$1.arrayify(lib$1.hexlify(value, options));\n\t        // Fixed-width field\n\t        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {\n\t            logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);\n\t        }\n\t        // Variable-width (with a maximum)\n\t        if (fieldInfo.maxLength) {\n\t            value = lib$1.stripZeros(value);\n\t            if (value.length > fieldInfo.maxLength) {\n\t                logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);\n\t            }\n\t        }\n\t        raw.push(lib$1.hexlify(value));\n\t    });\n\t    var chainId = 0;\n\t    if (transaction.chainId != null) {\n\t        // A chainId was provided; if non-zero we\'ll use EIP-155\n\t        chainId = transaction.chainId;\n\t        if (typeof (chainId) !== "number") {\n\t            logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);\n\t        }\n\t    }\n\t    else if (signature && !lib$1.isBytesLike(signature) && signature.v > 28) {\n\t        // No chainId provided, but the signature is signing with EIP-155; derive chainId\n\t        chainId = Math.floor((signature.v - 35) / 2);\n\t    }\n\t    // We have an EIP-155 transaction (chainId was specified and non-zero)\n\t    if (chainId !== 0) {\n\t        raw.push(lib$1.hexlify(chainId)); // @TODO: hexValue?\n\t        raw.push("0x");\n\t        raw.push("0x");\n\t    }\n\t    // Requesting an unsigned transation\n\t    if (!signature) {\n\t        return RLP.encode(raw);\n\t    }\n\t    // The splitSignature will ensure the transaction has a recoveryParam in the\n\t    // case that the signTransaction function only adds a v.\n\t    var sig = lib$1.splitSignature(signature);\n\t    // We pushed a chainId and null r, s on for hashing only; remove those\n\t    var v = 27 + sig.recoveryParam;\n\t    if (chainId !== 0) {\n\t        raw.pop();\n\t        raw.pop();\n\t        raw.pop();\n\t        v += chainId * 2 + 8;\n\t        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!\n\t        if (sig.v > 28 && sig.v !== v) {\n\t            logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);\n\t        }\n\t    }\n\t    else if (sig.v !== v) {\n\t        logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);\n\t    }\n\t    raw.push(lib$1.hexlify(v));\n\t    raw.push(lib$1.stripZeros(lib$1.arrayify(sig.r)));\n\t    raw.push(lib$1.stripZeros(lib$1.arrayify(sig.s)));\n\t    return RLP.encode(raw);\n\t}\n\texports.serialize = serialize;\n\tfunction parse(rawTransaction) {\n\t    var transaction = RLP.decode(rawTransaction);\n\t    if (transaction.length !== 9 && transaction.length !== 6) {\n\t        logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);\n\t    }\n\t    var tx = {\n\t        nonce: handleNumber(transaction[0]).toNumber(),\n\t        gasPrice: handleNumber(transaction[1]),\n\t        gasLimit: handleNumber(transaction[2]),\n\t        to: handleAddress(transaction[3]),\n\t        value: handleNumber(transaction[4]),\n\t        data: transaction[5],\n\t        chainId: 0\n\t    };\n\t    // Legacy unsigned transaction\n\t    if (transaction.length === 6) {\n\t        return tx;\n\t    }\n\t    try {\n\t        tx.v = lib$2.BigNumber.from(transaction[6]).toNumber();\n\t    }\n\t    catch (error) {\n\t        console.log(error);\n\t        return tx;\n\t    }\n\t    tx.r = lib$1.hexZeroPad(transaction[7], 32);\n\t    tx.s = lib$1.hexZeroPad(transaction[8], 32);\n\t    if (lib$2.BigNumber.from(tx.r).isZero() && lib$2.BigNumber.from(tx.s).isZero()) {\n\t        // EIP-155 unsigned transaction\n\t        tx.chainId = tx.v;\n\t        tx.v = 0;\n\t    }\n\t    else {\n\t        // Signed Tranasaction\n\t        tx.chainId = Math.floor((tx.v - 35) / 2);\n\t        if (tx.chainId < 0) {\n\t            tx.chainId = 0;\n\t        }\n\t        var recoveryParam = tx.v - 27;\n\t        var raw = transaction.slice(0, 6);\n\t        if (tx.chainId !== 0) {\n\t            raw.push(lib$1.hexlify(tx.chainId));\n\t            raw.push("0x");\n\t            raw.push("0x");\n\t            recoveryParam -= tx.chainId * 2 + 8;\n\t        }\n\t        var digest = lib$4.keccak256(RLP.encode(raw));\n\t        try {\n\t            tx.from = recoverAddress(digest, { r: lib$1.hexlify(tx.r), s: lib$1.hexlify(tx.s), recoveryParam: recoveryParam });\n\t        }\n\t        catch (error) {\n\t            console.log(error);\n\t        }\n\t        tx.hash = lib$4.keccak256(rawTransaction);\n\t    }\n\t    return tx;\n\t}\n\texports.parse = parse;\n\n\t});\n\n\tvar index$g = unwrapExports(lib$g);\n\tvar lib_1$g = lib$g.computeAddress;\n\tvar lib_2$f = lib$g.recoverAddress;\n\tvar lib_3$c = lib$g.serialize;\n\tvar lib_4$9 = lib$g.parse;\n\n\tvar _version$u = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "wordlists/5.0.4";\n\n\t});\n\n\tvar _version$v = unwrapExports(_version$u);\n\tvar _version_1$f = _version$u.version;\n\n\tvar wordlist = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\t// This gets overridden by rollup\n\tvar exportWordlist = false;\n\n\n\n\n\texports.logger = new lib.Logger(_version$u.version);\n\tvar Wordlist = /** @class */ (function () {\n\t    function Wordlist(locale) {\n\t        var _newTarget = this.constructor;\n\t        exports.logger.checkAbstract(_newTarget, Wordlist);\n\t        lib$3.defineReadOnly(this, "locale", locale);\n\t    }\n\t    // Subclasses may override this\n\t    Wordlist.prototype.split = function (mnemonic) {\n\t        return mnemonic.toLowerCase().split(/ +/g);\n\t    };\n\t    // Subclasses may override this\n\t    Wordlist.prototype.join = function (words) {\n\t        return words.join(" ");\n\t    };\n\t    Wordlist.check = function (wordlist) {\n\t        var words = [];\n\t        for (var i = 0; i < 2048; i++) {\n\t            var word = wordlist.getWord(i);\n\t            /* istanbul ignore if */\n\t            if (i !== wordlist.getWordIndex(word)) {\n\t                return "0x";\n\t            }\n\t            words.push(word);\n\t        }\n\t        return lib$9.id(words.join("\\n") + "\\n");\n\t    };\n\t    Wordlist.register = function (lang, name) {\n\t        if (!name) {\n\t            name = lang.locale;\n\t        }\n\t        /* istanbul ignore if */\n\t        if (exportWordlist) {\n\t            try {\n\t                var anyGlobal = window;\n\t                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {\n\t                    if (!anyGlobal._ethers.wordlists[name]) {\n\t                        lib$3.defineReadOnly(anyGlobal._ethers.wordlists, name, lang);\n\t                    }\n\t                }\n\t            }\n\t            catch (error) { }\n\t        }\n\t    };\n\t    return Wordlist;\n\t}());\n\texports.Wordlist = Wordlist;\n\n\t});\n\n\tvar wordlist$1 = unwrapExports(wordlist);\n\tvar wordlist_1 = wordlist.logger;\n\tvar wordlist_2 = wordlist.Wordlist;\n\n\tvar langEn_1 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tvar words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";\n\tvar wordlist$1 = null;\n\tfunction loadWords(lang) {\n\t    if (wordlist$1 != null) {\n\t        return;\n\t    }\n\t    wordlist$1 = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");\n\t    // Verify the computed list matches the official list\n\t    /* istanbul ignore if */\n\t    if (wordlist.Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {\n\t        wordlist$1 = null;\n\t        throw new Error("BIP39 Wordlist for en (English) FAILED");\n\t    }\n\t}\n\tvar LangEn = /** @class */ (function (_super) {\n\t    __extends(LangEn, _super);\n\t    function LangEn() {\n\t        return _super.call(this, "en") || this;\n\t    }\n\t    LangEn.prototype.getWord = function (index) {\n\t        loadWords(this);\n\t        return wordlist$1[index];\n\t    };\n\t    LangEn.prototype.getWordIndex = function (word) {\n\t        loadWords(this);\n\t        return wordlist$1.indexOf(word);\n\t    };\n\t    return LangEn;\n\t}(wordlist.Wordlist));\n\tvar langEn = new LangEn();\n\texports.langEn = langEn;\n\twordlist.Wordlist.register(langEn);\n\n\t});\n\n\tvar langEn = unwrapExports(langEn_1);\n\tvar langEn_2 = langEn_1.langEn;\n\n\tvar browser$4 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\t// Wordlists\n\t// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md\n\n\texports.Wordlist = wordlist.Wordlist;\n\n\tvar wordlists = { en: langEn_1.langEn };\n\texports.wordlists = wordlists;\n\n\t});\n\n\tvar browser$5 = unwrapExports(browser$4);\n\tvar browser_1$2 = browser$4.Wordlist;\n\tvar browser_2$1 = browser$4.wordlists;\n\n\tvar _version$w = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "hdnode/5.0.4";\n\n\t});\n\n\tvar _version$x = unwrapExports(_version$w);\n\tvar _version_1$g = _version$w.version;\n\n\tvar lib$h = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$w.version);\n\tvar N = lib$2.BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");\n\t// "Bitcoin seed"\n\tvar MasterSecret = lib$8.toUtf8Bytes("Bitcoin seed");\n\tvar HardenedBit = 0x80000000;\n\t// Returns a byte with the MSB bits set\n\tfunction getUpperMask(bits) {\n\t    return ((1 << bits) - 1) << (8 - bits);\n\t}\n\t// Returns a byte with the LSB bits set\n\tfunction getLowerMask(bits) {\n\t    return (1 << bits) - 1;\n\t}\n\tfunction bytes32(value) {\n\t    return lib$1.hexZeroPad(lib$1.hexlify(value), 32);\n\t}\n\tfunction base58check(data) {\n\t    return lib$e.Base58.encode(lib$1.concat([data, lib$1.hexDataSlice(browser.sha256(browser.sha256(data)), 0, 4)]));\n\t}\n\tfunction getWordlist(wordlist) {\n\t    if (wordlist == null) {\n\t        return browser$4.wordlists["en"];\n\t    }\n\t    if (typeof (wordlist) === "string") {\n\t        var words = browser$4.wordlists[wordlist];\n\t        if (words == null) {\n\t            logger.throwArgumentError("unknown locale", "wordlist", wordlist);\n\t        }\n\t        return words;\n\t    }\n\t    return wordlist;\n\t}\n\tvar _constructorGuard = {};\n\texports.defaultPath = "m/44\'/60\'/0\'/0/0";\n\t;\n\tvar HDNode = /** @class */ (function () {\n\t    /**\n\t     *  This constructor should not be called directly.\n\t     *\n\t     *  Please use:\n\t     *   - fromMnemonic\n\t     *   - fromSeed\n\t     */\n\t    function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, HDNode);\n\t        /* istanbul ignore if */\n\t        if (constructorGuard !== _constructorGuard) {\n\t            throw new Error("HDNode constructor cannot be called directly");\n\t        }\n\t        if (privateKey) {\n\t            var signingKey = new lib$f.SigningKey(privateKey);\n\t            lib$3.defineReadOnly(this, "privateKey", signingKey.privateKey);\n\t            lib$3.defineReadOnly(this, "publicKey", signingKey.compressedPublicKey);\n\t        }\n\t        else {\n\t            lib$3.defineReadOnly(this, "privateKey", null);\n\t            lib$3.defineReadOnly(this, "publicKey", lib$1.hexlify(publicKey));\n\t        }\n\t        lib$3.defineReadOnly(this, "parentFingerprint", parentFingerprint);\n\t        lib$3.defineReadOnly(this, "fingerprint", lib$1.hexDataSlice(browser.ripemd160(browser.sha256(this.publicKey)), 0, 4));\n\t        lib$3.defineReadOnly(this, "address", lib$g.computeAddress(this.publicKey));\n\t        lib$3.defineReadOnly(this, "chainCode", chainCode);\n\t        lib$3.defineReadOnly(this, "index", index);\n\t        lib$3.defineReadOnly(this, "depth", depth);\n\t        if (mnemonicOrPath == null) {\n\t            // From a source that does not preserve the path (e.g. extended keys)\n\t            lib$3.defineReadOnly(this, "mnemonic", null);\n\t            lib$3.defineReadOnly(this, "path", null);\n\t        }\n\t        else if (typeof (mnemonicOrPath) === "string") {\n\t            // From a source that does not preserve the mnemonic (e.g. neutered)\n\t            lib$3.defineReadOnly(this, "mnemonic", null);\n\t            lib$3.defineReadOnly(this, "path", mnemonicOrPath);\n\t        }\n\t        else {\n\t            // From a fully qualified source\n\t            lib$3.defineReadOnly(this, "mnemonic", mnemonicOrPath);\n\t            lib$3.defineReadOnly(this, "path", mnemonicOrPath.path);\n\t        }\n\t    }\n\t    Object.defineProperty(HDNode.prototype, "extendedKey", {\n\t        get: function () {\n\t            // We only support the mainnet values for now, but if anyone needs\n\t            // testnet values, let me know. I believe current senitment is that\n\t            // we should always use mainnet, and use BIP-44 to derive the network\n\t            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n\t            //   - Testnet: public=0x043587CF, private=0x04358394\n\t            if (this.depth >= 256) {\n\t                throw new Error("Depth too large!");\n\t            }\n\t            return base58check(lib$1.concat([\n\t                ((this.privateKey != null) ? "0x0488ADE4" : "0x0488B21E"),\n\t                lib$1.hexlify(this.depth),\n\t                this.parentFingerprint,\n\t                lib$1.hexZeroPad(lib$1.hexlify(this.index), 4),\n\t                this.chainCode,\n\t                ((this.privateKey != null) ? lib$1.concat(["0x00", this.privateKey]) : this.publicKey),\n\t            ]));\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    HDNode.prototype.neuter = function () {\n\t        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);\n\t    };\n\t    HDNode.prototype._derive = function (index) {\n\t        if (index > 0xffffffff) {\n\t            throw new Error("invalid index - " + String(index));\n\t        }\n\t        // Base path\n\t        var path = this.path;\n\t        if (path) {\n\t            path += "/" + (index & ~HardenedBit);\n\t        }\n\t        var data = new Uint8Array(37);\n\t        if (index & HardenedBit) {\n\t            if (!this.privateKey) {\n\t                throw new Error("cannot derive child of neutered node");\n\t            }\n\t            // Data = 0x00 || ser_256(k_par)\n\t            data.set(lib$1.arrayify(this.privateKey), 1);\n\t            // Hardened path\n\t            if (path) {\n\t                path += "\'";\n\t            }\n\t        }\n\t        else {\n\t            // Data = ser_p(point(k_par))\n\t            data.set(lib$1.arrayify(this.publicKey));\n\t        }\n\t        // Data += ser_32(i)\n\t        for (var i = 24; i >= 0; i -= 8) {\n\t            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n\t        }\n\t        var I = lib$1.arrayify(browser.computeHmac(browser.SupportedAlgorithm.sha512, this.chainCode, data));\n\t        var IL = I.slice(0, 32);\n\t        var IR = I.slice(32);\n\t        // The private key\n\t        var ki = null;\n\t        // The public key\n\t        var Ki = null;\n\t        if (this.privateKey) {\n\t            ki = bytes32(lib$2.BigNumber.from(IL).add(this.privateKey).mod(N));\n\t        }\n\t        else {\n\t            var ek = new lib$f.SigningKey(lib$1.hexlify(IL));\n\t            Ki = ek._addPoint(this.publicKey);\n\t        }\n\t        var mnemonicOrPath = path;\n\t        var srcMnemonic = this.mnemonic;\n\t        if (srcMnemonic) {\n\t            mnemonicOrPath = Object.freeze({\n\t                phrase: srcMnemonic.phrase,\n\t                path: path,\n\t                locale: (srcMnemonic.locale || "en")\n\t            });\n\t        }\n\t        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);\n\t    };\n\t    HDNode.prototype.derivePath = function (path) {\n\t        var components = path.split("/");\n\t        if (components.length === 0 || (components[0] === "m" && this.depth !== 0)) {\n\t            throw new Error("invalid path - " + path);\n\t        }\n\t        if (components[0] === "m") {\n\t            components.shift();\n\t        }\n\t        var result = this;\n\t        for (var i = 0; i < components.length; i++) {\n\t            var component = components[i];\n\t            if (component.match(/^[0-9]+\'$/)) {\n\t                var index = parseInt(component.substring(0, component.length - 1));\n\t                if (index >= HardenedBit) {\n\t                    throw new Error("invalid path index - " + component);\n\t                }\n\t                result = result._derive(HardenedBit + index);\n\t            }\n\t            else if (component.match(/^[0-9]+$/)) {\n\t                var index = parseInt(component);\n\t                if (index >= HardenedBit) {\n\t                    throw new Error("invalid path index - " + component);\n\t                }\n\t                result = result._derive(index);\n\t            }\n\t            else {\n\t                throw new Error("invalid path component - " + component);\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    HDNode._fromSeed = function (seed, mnemonic) {\n\t        var seedArray = lib$1.arrayify(seed);\n\t        if (seedArray.length < 16 || seedArray.length > 64) {\n\t            throw new Error("invalid seed");\n\t        }\n\t        var I = lib$1.arrayify(browser.computeHmac(browser.SupportedAlgorithm.sha512, MasterSecret, seedArray));\n\t        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);\n\t    };\n\t    HDNode.fromMnemonic = function (mnemonic, password, wordlist) {\n\t        // If a locale name was passed in, find the associated wordlist\n\t        wordlist = getWordlist(wordlist);\n\t        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)\n\t        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);\n\t        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {\n\t            phrase: mnemonic,\n\t            path: "m",\n\t            locale: wordlist.locale\n\t        });\n\t    };\n\t    HDNode.fromSeed = function (seed) {\n\t        return HDNode._fromSeed(seed, null);\n\t    };\n\t    HDNode.fromExtendedKey = function (extendedKey) {\n\t        var bytes = lib$e.Base58.decode(extendedKey);\n\t        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n\t            logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");\n\t        }\n\t        var depth = bytes[4];\n\t        var parentFingerprint = lib$1.hexlify(bytes.slice(5, 9));\n\t        var index = parseInt(lib$1.hexlify(bytes.slice(9, 13)).substring(2), 16);\n\t        var chainCode = lib$1.hexlify(bytes.slice(13, 45));\n\t        var key = bytes.slice(45, 78);\n\t        switch (lib$1.hexlify(bytes.slice(0, 4))) {\n\t            // Public Key\n\t            case "0x0488b21e":\n\t            case "0x043587cf":\n\t                return new HDNode(_constructorGuard, null, lib$1.hexlify(key), parentFingerprint, chainCode, index, depth, null);\n\t            // Private Key\n\t            case "0x0488ade4":\n\t            case "0x04358394 ":\n\t                if (key[0] !== 0) {\n\t                    break;\n\t                }\n\t                return new HDNode(_constructorGuard, lib$1.hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);\n\t        }\n\t        return logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");\n\t    };\n\t    return HDNode;\n\t}());\n\texports.HDNode = HDNode;\n\tfunction mnemonicToSeed(mnemonic, password) {\n\t    if (!password) {\n\t        password = "";\n\t    }\n\t    var salt = lib$8.toUtf8Bytes("mnemonic" + password, lib$8.UnicodeNormalizationForm.NFKD);\n\t    return browser$2.pbkdf2(lib$8.toUtf8Bytes(mnemonic, lib$8.UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");\n\t}\n\texports.mnemonicToSeed = mnemonicToSeed;\n\tfunction mnemonicToEntropy(mnemonic, wordlist) {\n\t    wordlist = getWordlist(wordlist);\n\t    logger.checkNormalize();\n\t    var words = wordlist.split(mnemonic);\n\t    if ((words.length % 3) !== 0) {\n\t        throw new Error("invalid mnemonic");\n\t    }\n\t    var entropy = lib$1.arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n\t    var offset = 0;\n\t    for (var i = 0; i < words.length; i++) {\n\t        var index = wordlist.getWordIndex(words[i].normalize("NFKD"));\n\t        if (index === -1) {\n\t            throw new Error("invalid mnemonic");\n\t        }\n\t        for (var bit = 0; bit < 11; bit++) {\n\t            if (index & (1 << (10 - bit))) {\n\t                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n\t            }\n\t            offset++;\n\t        }\n\t    }\n\t    var entropyBits = 32 * words.length / 3;\n\t    var checksumBits = words.length / 3;\n\t    var checksumMask = getUpperMask(checksumBits);\n\t    var checksum = lib$1.arrayify(browser.sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;\n\t    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n\t        throw new Error("invalid checksum");\n\t    }\n\t    return lib$1.hexlify(entropy.slice(0, entropyBits / 8));\n\t}\n\texports.mnemonicToEntropy = mnemonicToEntropy;\n\tfunction entropyToMnemonic(entropy, wordlist) {\n\t    wordlist = getWordlist(wordlist);\n\t    entropy = lib$1.arrayify(entropy);\n\t    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n\t        throw new Error("invalid entropy");\n\t    }\n\t    var indices = [0];\n\t    var remainingBits = 11;\n\t    for (var i = 0; i < entropy.length; i++) {\n\t        // Consume the whole byte (with still more to go)\n\t        if (remainingBits > 8) {\n\t            indices[indices.length - 1] <<= 8;\n\t            indices[indices.length - 1] |= entropy[i];\n\t            remainingBits -= 8;\n\t            // This byte will complete an 11-bit index\n\t        }\n\t        else {\n\t            indices[indices.length - 1] <<= remainingBits;\n\t            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n\t            // Start the next word\n\t            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n\t            remainingBits += 3;\n\t        }\n\t    }\n\t    // Compute the checksum bits\n\t    var checksumBits = entropy.length / 4;\n\t    var checksum = lib$1.arrayify(browser.sha256(entropy))[0] & getUpperMask(checksumBits);\n\t    // Shift the checksum into the word indices\n\t    indices[indices.length - 1] <<= checksumBits;\n\t    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n\t    return wordlist.join(indices.map(function (index) { return wordlist.getWord(index); }));\n\t}\n\texports.entropyToMnemonic = entropyToMnemonic;\n\tfunction isValidMnemonic(mnemonic, wordlist) {\n\t    try {\n\t        mnemonicToEntropy(mnemonic, wordlist);\n\t        return true;\n\t    }\n\t    catch (error) { }\n\t    return false;\n\t}\n\texports.isValidMnemonic = isValidMnemonic;\n\n\t});\n\n\tvar index$h = unwrapExports(lib$h);\n\tvar lib_1$h = lib$h.defaultPath;\n\tvar lib_2$g = lib$h.HDNode;\n\tvar lib_3$d = lib$h.mnemonicToSeed;\n\tvar lib_4$a = lib$h.mnemonicToEntropy;\n\tvar lib_5$9 = lib$h.entropyToMnemonic;\n\tvar lib_6$5 = lib$h.isValidMnemonic;\n\n\tvar _version$y = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "random/5.0.3";\n\n\t});\n\n\tvar _version$z = unwrapExports(_version$y);\n\tvar _version_1$h = _version$y.version;\n\n\tvar shuffle = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tfunction shuffled(array) {\n\t    array = array.slice();\n\t    for (var i = array.length - 1; i > 0; i--) {\n\t        var j = Math.floor(Math.random() * (i + 1));\n\t        var tmp = array[i];\n\t        array[i] = array[j];\n\t        array[j] = tmp;\n\t    }\n\t    return array;\n\t}\n\texports.shuffled = shuffled;\n\n\t});\n\n\tvar shuffle$1 = unwrapExports(shuffle);\n\tvar shuffle_1 = shuffle.shuffled;\n\n\tvar browser$6 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$y.version);\n\n\texports.shuffled = shuffle.shuffled;\n\tvar anyGlobal = null;\n\ttry {\n\t    anyGlobal = window;\n\t    if (anyGlobal == null) {\n\t        throw new Error("try next");\n\t    }\n\t}\n\tcatch (error) {\n\t    try {\n\t        anyGlobal = commonjsGlobal;\n\t        if (anyGlobal == null) {\n\t            throw new Error("try next");\n\t        }\n\t    }\n\t    catch (error) {\n\t        anyGlobal = {};\n\t    }\n\t}\n\tvar crypto = anyGlobal.crypto || anyGlobal.msCrypto;\n\tif (!crypto || !crypto.getRandomValues) {\n\t    logger.warn("WARNING: Missing strong random number source");\n\t    crypto = {\n\t        getRandomValues: function (buffer) {\n\t            return logger.throwError("no secure random source avaialble", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "crypto.getRandomValues"\n\t            });\n\t        }\n\t    };\n\t}\n\tfunction randomBytes(length) {\n\t    if (length <= 0 || length > 1024 || (length % 1)) {\n\t        logger.throwArgumentError("invalid length", "length", length);\n\t    }\n\t    var result = new Uint8Array(length);\n\t    crypto.getRandomValues(result);\n\t    return lib$1.arrayify(result);\n\t}\n\texports.randomBytes = randomBytes;\n\t;\n\n\t});\n\n\tvar browser$7 = unwrapExports(browser$6);\n\tvar browser_1$3 = browser$6.shuffled;\n\tvar browser_2$2 = browser$6.randomBytes;\n\n\tvar aesJs = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\n\t(function(root) {\n\n\t    function checkInt(value) {\n\t        return (parseInt(value) === value);\n\t    }\n\n\t    function checkInts(arrayish) {\n\t        if (!checkInt(arrayish.length)) { return false; }\n\n\t        for (var i = 0; i < arrayish.length; i++) {\n\t            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    function coerceArray(arg, copy) {\n\n\t        // ArrayBuffer view\n\t        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === \'Uint8Array\') {\n\n\t            if (copy) {\n\t                if (arg.slice) {\n\t                    arg = arg.slice();\n\t                } else {\n\t                    arg = Array.prototype.slice.call(arg);\n\t                }\n\t            }\n\n\t            return arg;\n\t        }\n\n\t        // It\'s an array; check it is a valid representation of a byte\n\t        if (Array.isArray(arg)) {\n\t            if (!checkInts(arg)) {\n\t                throw new Error(\'Array contains invalid value: \' + arg);\n\t            }\n\n\t            return new Uint8Array(arg);\n\t        }\n\n\t        // Something else, but behaves like an array (maybe a Buffer? Arguments?)\n\t        if (checkInt(arg.length) && checkInts(arg)) {\n\t            return new Uint8Array(arg);\n\t        }\n\n\t        throw new Error(\'unsupported array-like object\');\n\t    }\n\n\t    function createArray(length) {\n\t        return new Uint8Array(length);\n\t    }\n\n\t    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {\n\t        if (sourceStart != null || sourceEnd != null) {\n\t            if (sourceArray.slice) {\n\t                sourceArray = sourceArray.slice(sourceStart, sourceEnd);\n\t            } else {\n\t                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);\n\t            }\n\t        }\n\t        targetArray.set(sourceArray, targetStart);\n\t    }\n\n\n\n\t    var convertUtf8 = (function() {\n\t        function toBytes(text) {\n\t            var result = [], i = 0;\n\t            text = encodeURI(text);\n\t            while (i < text.length) {\n\t                var c = text.charCodeAt(i++);\n\n\t                // if it is a % sign, encode the following 2 bytes as a hex value\n\t                if (c === 37) {\n\t                    result.push(parseInt(text.substr(i, 2), 16));\n\t                    i += 2;\n\n\t                // otherwise, just the actual byte\n\t                } else {\n\t                    result.push(c);\n\t                }\n\t            }\n\n\t            return coerceArray(result);\n\t        }\n\n\t        function fromBytes(bytes) {\n\t            var result = [], i = 0;\n\n\t            while (i < bytes.length) {\n\t                var c = bytes[i];\n\n\t                if (c < 128) {\n\t                    result.push(String.fromCharCode(c));\n\t                    i++;\n\t                } else if (c > 191 && c < 224) {\n\t                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));\n\t                    i += 2;\n\t                } else {\n\t                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));\n\t                    i += 3;\n\t                }\n\t            }\n\n\t            return result.join(\'\');\n\t        }\n\n\t        return {\n\t            toBytes: toBytes,\n\t            fromBytes: fromBytes,\n\t        }\n\t    })();\n\n\t    var convertHex = (function() {\n\t        function toBytes(text) {\n\t            var result = [];\n\t            for (var i = 0; i < text.length; i += 2) {\n\t                result.push(parseInt(text.substr(i, 2), 16));\n\t            }\n\n\t            return result;\n\t        }\n\n\t        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html\n\t        var Hex = \'0123456789abcdef\';\n\n\t        function fromBytes(bytes) {\n\t                var result = [];\n\t                for (var i = 0; i < bytes.length; i++) {\n\t                    var v = bytes[i];\n\t                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);\n\t                }\n\t                return result.join(\'\');\n\t        }\n\n\t        return {\n\t            toBytes: toBytes,\n\t            fromBytes: fromBytes,\n\t        }\n\t    })();\n\n\n\t    // Number of rounds by keysize\n\t    var numberOfRounds = {16: 10, 24: 12, 32: 14};\n\n\t    // Round constant words\n\t    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];\n\n\t    // S-box and Inverse S-box (S is for Substitution)\n\t    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];\n\t    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];\n\n\t    // Transformations for encryption\n\t    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];\n\t    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];\n\t    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];\n\t    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];\n\n\t    // Transformations for decryption\n\t    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];\n\t    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];\n\t    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];\n\t    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];\n\n\t    // Transformations for decryption key expansion\n\t    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];\n\t    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];\n\t    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];\n\t    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];\n\n\t    function convertToInt32(bytes) {\n\t        var result = [];\n\t        for (var i = 0; i < bytes.length; i += 4) {\n\t            result.push(\n\t                (bytes[i    ] << 24) |\n\t                (bytes[i + 1] << 16) |\n\t                (bytes[i + 2] <<  8) |\n\t                 bytes[i + 3]\n\t            );\n\t        }\n\t        return result;\n\t    }\n\n\t    var AES = function(key) {\n\t        if (!(this instanceof AES)) {\n\t            throw Error(\'AES must be instanitated with `new`\');\n\t        }\n\n\t        Object.defineProperty(this, \'key\', {\n\t            value: coerceArray(key, true)\n\t        });\n\n\t        this._prepare();\n\t    };\n\n\n\t    AES.prototype._prepare = function() {\n\n\t        var rounds = numberOfRounds[this.key.length];\n\t        if (rounds == null) {\n\t            throw new Error(\'invalid key size (must be 16, 24 or 32 bytes)\');\n\t        }\n\n\t        // encryption round keys\n\t        this._Ke = [];\n\n\t        // decryption round keys\n\t        this._Kd = [];\n\n\t        for (var i = 0; i <= rounds; i++) {\n\t            this._Ke.push([0, 0, 0, 0]);\n\t            this._Kd.push([0, 0, 0, 0]);\n\t        }\n\n\t        var roundKeyCount = (rounds + 1) * 4;\n\t        var KC = this.key.length / 4;\n\n\t        // convert the key into ints\n\t        var tk = convertToInt32(this.key);\n\n\t        // copy values into round key arrays\n\t        var index;\n\t        for (var i = 0; i < KC; i++) {\n\t            index = i >> 2;\n\t            this._Ke[index][i % 4] = tk[i];\n\t            this._Kd[rounds - index][i % 4] = tk[i];\n\t        }\n\n\t        // key expansion (fips-197 section 5.2)\n\t        var rconpointer = 0;\n\t        var t = KC, tt;\n\t        while (t < roundKeyCount) {\n\t            tt = tk[KC - 1];\n\t            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n\t                      (S[(tt >>  8) & 0xFF] << 16) ^\n\t                      (S[ tt        & 0xFF] <<  8) ^\n\t                       S[(tt >> 24) & 0xFF]        ^\n\t                      (rcon[rconpointer] << 24));\n\t            rconpointer += 1;\n\n\t            // key expansion (for non-256 bit)\n\t            if (KC != 8) {\n\t                for (var i = 1; i < KC; i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\n\t            // key expansion for 256-bit keys is "slightly different" (fips-197)\n\t            } else {\n\t                for (var i = 1; i < (KC / 2); i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\t                tt = tk[(KC / 2) - 1];\n\n\t                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^\n\t                              (S[(tt >>  8) & 0xFF] <<  8) ^\n\t                              (S[(tt >> 16) & 0xFF] << 16) ^\n\t                              (S[(tt >> 24) & 0xFF] << 24));\n\n\t                for (var i = (KC / 2) + 1; i < KC; i++) {\n\t                    tk[i] ^= tk[i - 1];\n\t                }\n\t            }\n\n\t            // copy values into round key arrays\n\t            var i = 0, r, c;\n\t            while (i < KC && t < roundKeyCount) {\n\t                r = t >> 2;\n\t                c = t % 4;\n\t                this._Ke[r][c] = tk[i];\n\t                this._Kd[rounds - r][c] = tk[i++];\n\t                t++;\n\t            }\n\t        }\n\n\t        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var c = 0; c < 4; c++) {\n\t                tt = this._Kd[r][c];\n\t                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^\n\t                                  U2[(tt >> 16) & 0xFF] ^\n\t                                  U3[(tt >>  8) & 0xFF] ^\n\t                                  U4[ tt        & 0xFF]);\n\t            }\n\t        }\n\t    };\n\n\t    AES.prototype.encrypt = function(plaintext) {\n\t        if (plaintext.length != 16) {\n\t            throw new Error(\'invalid plaintext size (must be 16 bytes)\');\n\t        }\n\n\t        var rounds = this._Ke.length - 1;\n\t        var a = [0, 0, 0, 0];\n\n\t        // convert plaintext to (ints ^ key)\n\t        var t = convertToInt32(plaintext);\n\t        for (var i = 0; i < 4; i++) {\n\t            t[i] ^= this._Ke[0][i];\n\t        }\n\n\t        // apply round transforms\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var i = 0; i < 4; i++) {\n\t                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^\n\t                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^\n\t                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^\n\t                        T4[ t[(i + 3) % 4]        & 0xff] ^\n\t                        this._Ke[r][i]);\n\t            }\n\t            t = a.slice();\n\t        }\n\n\t        // the last round is special\n\t        var result = createArray(16), tt;\n\t        for (var i = 0; i < 4; i++) {\n\t            tt = this._Ke[rounds][i];\n\t            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n\t            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n\t            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n\t            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;\n\t        }\n\n\t        return result;\n\t    };\n\n\t    AES.prototype.decrypt = function(ciphertext) {\n\t        if (ciphertext.length != 16) {\n\t            throw new Error(\'invalid ciphertext size (must be 16 bytes)\');\n\t        }\n\n\t        var rounds = this._Kd.length - 1;\n\t        var a = [0, 0, 0, 0];\n\n\t        // convert plaintext to (ints ^ key)\n\t        var t = convertToInt32(ciphertext);\n\t        for (var i = 0; i < 4; i++) {\n\t            t[i] ^= this._Kd[0][i];\n\t        }\n\n\t        // apply round transforms\n\t        for (var r = 1; r < rounds; r++) {\n\t            for (var i = 0; i < 4; i++) {\n\t                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^\n\t                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^\n\t                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^\n\t                        T8[ t[(i + 1) % 4]        & 0xff] ^\n\t                        this._Kd[r][i]);\n\t            }\n\t            t = a.slice();\n\t        }\n\n\t        // the last round is special\n\t        var result = createArray(16), tt;\n\t        for (var i = 0; i < 4; i++) {\n\t            tt = this._Kd[rounds][i];\n\t            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;\n\t            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;\n\t            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;\n\t            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;\n\t        }\n\n\t        return result;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Electonic Codebook (ECB)\n\t     */\n\t    var ModeOfOperationECB = function(key) {\n\t        if (!(this instanceof ModeOfOperationECB)) {\n\t            throw Error(\'AES must be instanitated with `new`\');\n\t        }\n\n\t        this.description = "Electronic Code Block";\n\t        this.name = "ecb";\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationECB.prototype.encrypt = function(plaintext) {\n\t        plaintext = coerceArray(plaintext);\n\n\t        if ((plaintext.length % 16) !== 0) {\n\t            throw new Error(\'invalid plaintext size (must be multiple of 16 bytes)\');\n\t        }\n\n\t        var ciphertext = createArray(plaintext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < plaintext.length; i += 16) {\n\t            copyArray(plaintext, block, 0, i, i + 16);\n\t            block = this._aes.encrypt(block);\n\t            copyArray(block, ciphertext, i);\n\t        }\n\n\t        return ciphertext;\n\t    };\n\n\t    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {\n\t        ciphertext = coerceArray(ciphertext);\n\n\t        if ((ciphertext.length % 16) !== 0) {\n\t            throw new Error(\'invalid ciphertext size (must be multiple of 16 bytes)\');\n\t        }\n\n\t        var plaintext = createArray(ciphertext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < ciphertext.length; i += 16) {\n\t            copyArray(ciphertext, block, 0, i, i + 16);\n\t            block = this._aes.decrypt(block);\n\t            copyArray(block, plaintext, i);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Cipher Block Chaining (CBC)\n\t     */\n\t    var ModeOfOperationCBC = function(key, iv) {\n\t        if (!(this instanceof ModeOfOperationCBC)) {\n\t            throw Error(\'AES must be instanitated with `new`\');\n\t        }\n\n\t        this.description = "Cipher Block Chaining";\n\t        this.name = "cbc";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error(\'invalid initialation vector size (must be 16 bytes)\');\n\t        }\n\n\t        this._lastCipherblock = coerceArray(iv, true);\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {\n\t        plaintext = coerceArray(plaintext);\n\n\t        if ((plaintext.length % 16) !== 0) {\n\t            throw new Error(\'invalid plaintext size (must be multiple of 16 bytes)\');\n\t        }\n\n\t        var ciphertext = createArray(plaintext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < plaintext.length; i += 16) {\n\t            copyArray(plaintext, block, 0, i, i + 16);\n\n\t            for (var j = 0; j < 16; j++) {\n\t                block[j] ^= this._lastCipherblock[j];\n\t            }\n\n\t            this._lastCipherblock = this._aes.encrypt(block);\n\t            copyArray(this._lastCipherblock, ciphertext, i);\n\t        }\n\n\t        return ciphertext;\n\t    };\n\n\t    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {\n\t        ciphertext = coerceArray(ciphertext);\n\n\t        if ((ciphertext.length % 16) !== 0) {\n\t            throw new Error(\'invalid ciphertext size (must be multiple of 16 bytes)\');\n\t        }\n\n\t        var plaintext = createArray(ciphertext.length);\n\t        var block = createArray(16);\n\n\t        for (var i = 0; i < ciphertext.length; i += 16) {\n\t            copyArray(ciphertext, block, 0, i, i + 16);\n\t            block = this._aes.decrypt(block);\n\n\t            for (var j = 0; j < 16; j++) {\n\t                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];\n\t            }\n\n\t            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Cipher Feedback (CFB)\n\t     */\n\t    var ModeOfOperationCFB = function(key, iv, segmentSize) {\n\t        if (!(this instanceof ModeOfOperationCFB)) {\n\t            throw Error(\'AES must be instanitated with `new`\');\n\t        }\n\n\t        this.description = "Cipher Feedback";\n\t        this.name = "cfb";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error(\'invalid initialation vector size (must be 16 size)\');\n\t        }\n\n\t        if (!segmentSize) { segmentSize = 1; }\n\n\t        this.segmentSize = segmentSize;\n\n\t        this._shiftRegister = coerceArray(iv, true);\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {\n\t        if ((plaintext.length % this.segmentSize) != 0) {\n\t            throw new Error(\'invalid plaintext size (must be segmentSize bytes)\');\n\t        }\n\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        var xorSegment;\n\t        for (var i = 0; i < encrypted.length; i += this.segmentSize) {\n\t            xorSegment = this._aes.encrypt(this._shiftRegister);\n\t            for (var j = 0; j < this.segmentSize; j++) {\n\t                encrypted[i + j] ^= xorSegment[j];\n\t            }\n\n\t            // Shift the register\n\t            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n\t            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {\n\t        if ((ciphertext.length % this.segmentSize) != 0) {\n\t            throw new Error(\'invalid ciphertext size (must be segmentSize bytes)\');\n\t        }\n\n\t        var plaintext = coerceArray(ciphertext, true);\n\n\t        var xorSegment;\n\t        for (var i = 0; i < plaintext.length; i += this.segmentSize) {\n\t            xorSegment = this._aes.encrypt(this._shiftRegister);\n\n\t            for (var j = 0; j < this.segmentSize; j++) {\n\t                plaintext[i + j] ^= xorSegment[j];\n\t            }\n\n\t            // Shift the register\n\t            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);\n\t            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);\n\t        }\n\n\t        return plaintext;\n\t    };\n\n\t    /**\n\t     *  Mode Of Operation - Output Feedback (OFB)\n\t     */\n\t    var ModeOfOperationOFB = function(key, iv) {\n\t        if (!(this instanceof ModeOfOperationOFB)) {\n\t            throw Error(\'AES must be instanitated with `new`\');\n\t        }\n\n\t        this.description = "Output Feedback";\n\t        this.name = "ofb";\n\n\t        if (!iv) {\n\t            iv = createArray(16);\n\n\t        } else if (iv.length != 16) {\n\t            throw new Error(\'invalid initialation vector size (must be 16 bytes)\');\n\t        }\n\n\t        this._lastPrecipher = coerceArray(iv, true);\n\t        this._lastPrecipherIndex = 16;\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        for (var i = 0; i < encrypted.length; i++) {\n\t            if (this._lastPrecipherIndex === 16) {\n\t                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);\n\t                this._lastPrecipherIndex = 0;\n\t            }\n\t            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    // Decryption is symetric\n\t    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;\n\n\n\t    /**\n\t     *  Counter object for CTR common mode of operation\n\t     */\n\t    var Counter = function(initialValue) {\n\t        if (!(this instanceof Counter)) {\n\t            throw Error(\'Counter must be instanitated with `new`\');\n\t        }\n\n\t        // We allow 0, but anything false-ish uses the default 1\n\t        if (initialValue !== 0 && !initialValue) { initialValue = 1; }\n\n\t        if (typeof(initialValue) === \'number\') {\n\t            this._counter = createArray(16);\n\t            this.setValue(initialValue);\n\n\t        } else {\n\t            this.setBytes(initialValue);\n\t        }\n\t    };\n\n\t    Counter.prototype.setValue = function(value) {\n\t        if (typeof(value) !== \'number\' || parseInt(value) != value) {\n\t            throw new Error(\'invalid counter value (must be an integer)\');\n\t        }\n\n\t        for (var index = 15; index >= 0; --index) {\n\t            this._counter[index] = value % 256;\n\t            value = value >> 8;\n\t        }\n\t    };\n\n\t    Counter.prototype.setBytes = function(bytes) {\n\t        bytes = coerceArray(bytes, true);\n\n\t        if (bytes.length != 16) {\n\t            throw new Error(\'invalid counter bytes size (must be 16 bytes)\');\n\t        }\n\n\t        this._counter = bytes;\n\t    };\n\n\t    Counter.prototype.increment = function() {\n\t        for (var i = 15; i >= 0; i--) {\n\t            if (this._counter[i] === 255) {\n\t                this._counter[i] = 0;\n\t            } else {\n\t                this._counter[i]++;\n\t                break;\n\t            }\n\t        }\n\t    };\n\n\n\t    /**\n\t     *  Mode Of Operation - Counter (CTR)\n\t     */\n\t    var ModeOfOperationCTR = function(key, counter) {\n\t        if (!(this instanceof ModeOfOperationCTR)) {\n\t            throw Error(\'AES must be instanitated with `new`\');\n\t        }\n\n\t        this.description = "Counter";\n\t        this.name = "ctr";\n\n\t        if (!(counter instanceof Counter)) {\n\t            counter = new Counter(counter);\n\t        }\n\n\t        this._counter = counter;\n\n\t        this._remainingCounter = null;\n\t        this._remainingCounterIndex = 16;\n\n\t        this._aes = new AES(key);\n\t    };\n\n\t    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {\n\t        var encrypted = coerceArray(plaintext, true);\n\n\t        for (var i = 0; i < encrypted.length; i++) {\n\t            if (this._remainingCounterIndex === 16) {\n\t                this._remainingCounter = this._aes.encrypt(this._counter._counter);\n\t                this._remainingCounterIndex = 0;\n\t                this._counter.increment();\n\t            }\n\t            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];\n\t        }\n\n\t        return encrypted;\n\t    };\n\n\t    // Decryption is symetric\n\t    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;\n\n\n\t    ///////////////////////\n\t    // Padding\n\n\t    // See:https://tools.ietf.org/html/rfc2315\n\t    function pkcs7pad(data) {\n\t        data = coerceArray(data, true);\n\t        var padder = 16 - (data.length % 16);\n\t        var result = createArray(data.length + padder);\n\t        copyArray(data, result);\n\t        for (var i = data.length; i < result.length; i++) {\n\t            result[i] = padder;\n\t        }\n\t        return result;\n\t    }\n\n\t    function pkcs7strip(data) {\n\t        data = coerceArray(data, true);\n\t        if (data.length < 16) { throw new Error(\'PKCS#7 invalid length\'); }\n\n\t        var padder = data[data.length - 1];\n\t        if (padder > 16) { throw new Error(\'PKCS#7 padding byte out of range\'); }\n\n\t        var length = data.length - padder;\n\t        for (var i = 0; i < padder; i++) {\n\t            if (data[length + i] !== padder) {\n\t                throw new Error(\'PKCS#7 invalid padding byte\');\n\t            }\n\t        }\n\n\t        var result = createArray(length);\n\t        copyArray(data, result, 0, 0, length);\n\t        return result;\n\t    }\n\n\t    ///////////////////////\n\t    // Exporting\n\n\n\t    // The block cipher\n\t    var aesjs = {\n\t        AES: AES,\n\t        Counter: Counter,\n\n\t        ModeOfOperation: {\n\t            ecb: ModeOfOperationECB,\n\t            cbc: ModeOfOperationCBC,\n\t            cfb: ModeOfOperationCFB,\n\t            ofb: ModeOfOperationOFB,\n\t            ctr: ModeOfOperationCTR\n\t        },\n\n\t        utils: {\n\t            hex: convertHex,\n\t            utf8: convertUtf8\n\t        },\n\n\t        padding: {\n\t            pkcs7: {\n\t                pad: pkcs7pad,\n\t                strip: pkcs7strip\n\t            }\n\t        },\n\n\t        _arrayTest: {\n\t            coerceArray: coerceArray,\n\t            createArray: createArray,\n\t            copyArray: copyArray,\n\t        }\n\t    };\n\n\n\t    // node.js\n\t    if (true) {\n\t        module.exports = aesjs;\n\n\t    // RequireJS/AMD\n\t    // http://www.requirejs.org/docs/api.html\n\t    // https://github.com/amdjs/amdjs-api/wiki/AMD\n\t    } else {}\n\n\n\t})(commonjsGlobal);\n\t});\n\n\tvar _version$A = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "json-wallets/5.0.6";\n\n\t});\n\n\tvar _version$B = unwrapExports(_version$A);\n\tvar _version_1$i = _version$A.version;\n\n\tvar utils$1 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tfunction looseArrayify(hexString) {\n\t    if (typeof (hexString) === \'string\' && hexString.substring(0, 2) !== \'0x\') {\n\t        hexString = \'0x\' + hexString;\n\t    }\n\t    return lib$1.arrayify(hexString);\n\t}\n\texports.looseArrayify = looseArrayify;\n\tfunction zpad(value, length) {\n\t    value = String(value);\n\t    while (value.length < length) {\n\t        value = \'0\' + value;\n\t    }\n\t    return value;\n\t}\n\texports.zpad = zpad;\n\tfunction getPassword(password) {\n\t    if (typeof (password) === \'string\') {\n\t        return lib$8.toUtf8Bytes(password, lib$8.UnicodeNormalizationForm.NFKC);\n\t    }\n\t    return lib$1.arrayify(password);\n\t}\n\texports.getPassword = getPassword;\n\tfunction searchPath(object, path) {\n\t    var currentChild = object;\n\t    var comps = path.toLowerCase().split(\'/\');\n\t    for (var i = 0; i < comps.length; i++) {\n\t        // Search for a child object with a case-insensitive matching key\n\t        var matchingChild = null;\n\t        for (var key in currentChild) {\n\t            if (key.toLowerCase() === comps[i]) {\n\t                matchingChild = currentChild[key];\n\t                break;\n\t            }\n\t        }\n\t        // Didn\'t find one. :\'(\n\t        if (matchingChild === null) {\n\t            return null;\n\t        }\n\t        // Now check this child...\n\t        currentChild = matchingChild;\n\t    }\n\t    return currentChild;\n\t}\n\texports.searchPath = searchPath;\n\t// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)\n\tfunction uuidV4(randomBytes) {\n\t    var bytes = lib$1.arrayify(randomBytes);\n\t    // Section: 4.1.3:\n\t    // - time_hi_and_version[12:16] = 0b0100\n\t    bytes[6] = (bytes[6] & 0x0f) | 0x40;\n\t    // Section 4.4\n\t    // - clock_seq_hi_and_reserved[6] = 0b0\n\t    // - clock_seq_hi_and_reserved[7] = 0b1\n\t    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n\t    var value = lib$1.hexlify(bytes);\n\t    return [\n\t        value.substring(2, 10),\n\t        value.substring(10, 14),\n\t        value.substring(14, 18),\n\t        value.substring(18, 22),\n\t        value.substring(22, 34),\n\t    ].join("-");\n\t}\n\texports.uuidV4 = uuidV4;\n\n\t});\n\n\tvar utils$2 = unwrapExports(utils$1);\n\tvar utils_1$2 = utils$1.looseArrayify;\n\tvar utils_2 = utils$1.zpad;\n\tvar utils_3 = utils$1.getPassword;\n\tvar utils_4 = utils$1.searchPath;\n\tvar utils_5 = utils$1.uuidV4;\n\n\tvar crowdsale = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { "default": mod };\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tvar aes_js_1 = __importDefault(aesJs);\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$A.version);\n\n\tvar CrowdsaleAccount = /** @class */ (function (_super) {\n\t    __extends(CrowdsaleAccount, _super);\n\t    function CrowdsaleAccount() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    CrowdsaleAccount.prototype.isCrowdsaleAccount = function (value) {\n\t        return !!(value && value._isCrowdsaleAccount);\n\t    };\n\t    return CrowdsaleAccount;\n\t}(lib$3.Description));\n\texports.CrowdsaleAccount = CrowdsaleAccount;\n\t// See: https://github.com/ethereum/pyethsaletool\n\tfunction decrypt(json, password) {\n\t    var data = JSON.parse(json);\n\t    password = utils$1.getPassword(password);\n\t    // Ethereum Address\n\t    var ethaddr = lib$6.getAddress(utils$1.searchPath(data, "ethaddr"));\n\t    // Encrypted Seed\n\t    var encseed = utils$1.looseArrayify(utils$1.searchPath(data, "encseed"));\n\t    if (!encseed || (encseed.length % 16) !== 0) {\n\t        logger.throwArgumentError("invalid encseed", "json", json);\n\t    }\n\t    var key = lib$1.arrayify(browser$2.pbkdf2(password, password, 2000, 32, "sha256")).slice(0, 16);\n\t    var iv = encseed.slice(0, 16);\n\t    var encryptedSeed = encseed.slice(16);\n\t    // Decrypt the seed\n\t    var aesCbc = new aes_js_1.default.ModeOfOperation.cbc(key, iv);\n\t    var seed = aes_js_1.default.padding.pkcs7.strip(lib$1.arrayify(aesCbc.decrypt(encryptedSeed)));\n\t    // This wallet format is weird... Convert the binary encoded hex to a string.\n\t    var seedHex = "";\n\t    for (var i = 0; i < seed.length; i++) {\n\t        seedHex += String.fromCharCode(seed[i]);\n\t    }\n\t    var seedHexBytes = lib$8.toUtf8Bytes(seedHex);\n\t    var privateKey = lib$4.keccak256(seedHexBytes);\n\t    return new CrowdsaleAccount({\n\t        _isCrowdsaleAccount: true,\n\t        address: ethaddr,\n\t        privateKey: privateKey\n\t    });\n\t}\n\texports.decrypt = decrypt;\n\n\t});\n\n\tvar crowdsale$1 = unwrapExports(crowdsale);\n\tvar crowdsale_1 = crowdsale.CrowdsaleAccount;\n\tvar crowdsale_2 = crowdsale.decrypt;\n\n\tvar inspect = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tfunction isCrowdsaleWallet(json) {\n\t    var data = null;\n\t    try {\n\t        data = JSON.parse(json);\n\t    }\n\t    catch (error) {\n\t        return false;\n\t    }\n\t    return (data.encseed && data.ethaddr);\n\t}\n\texports.isCrowdsaleWallet = isCrowdsaleWallet;\n\tfunction isKeystoreWallet(json) {\n\t    var data = null;\n\t    try {\n\t        data = JSON.parse(json);\n\t    }\n\t    catch (error) {\n\t        return false;\n\t    }\n\t    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {\n\t        return false;\n\t    }\n\t    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff\n\t    return true;\n\t}\n\texports.isKeystoreWallet = isKeystoreWallet;\n\t//export function isJsonWallet(json: string): boolean {\n\t//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));\n\t//}\n\tfunction getJsonWalletAddress(json) {\n\t    if (isCrowdsaleWallet(json)) {\n\t        try {\n\t            return lib$6.getAddress(JSON.parse(json).ethaddr);\n\t        }\n\t        catch (error) {\n\t            return null;\n\t        }\n\t    }\n\t    if (isKeystoreWallet(json)) {\n\t        try {\n\t            return lib$6.getAddress(JSON.parse(json).address);\n\t        }\n\t        catch (error) {\n\t            return null;\n\t        }\n\t    }\n\t    return null;\n\t}\n\texports.getJsonWalletAddress = getJsonWalletAddress;\n\n\t});\n\n\tvar inspect$1 = unwrapExports(inspect);\n\tvar inspect_1 = inspect.isCrowdsaleWallet;\n\tvar inspect_2 = inspect.isKeystoreWallet;\n\tvar inspect_3 = inspect.getJsonWalletAddress;\n\n\tvar scrypt = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\n\t(function(root) {\n\t    const MAX_VALUE = 0x7fffffff;\n\n\t    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:\n\t    // See: https://github.com/dchest/scrypt-async-js\n\t    function SHA256(m) {\n\t        const K = new Uint32Array([\n\t           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,\n\t           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,\n\t           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,\n\t           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n\t           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,\n\t           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n\t           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,\n\t           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n\t           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,\n\t           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,\n\t           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,\n\t           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n\t           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n\t       ]);\n\n\t        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;\n\t        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;\n\t        const w = new Uint32Array(64);\n\n\t        function blocks(p) {\n\t            let off = 0, len = p.length;\n\t            while (len >= 64) {\n\t                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;\n\n\t                for (i = 0; i < 16; i++) {\n\t                    j = off + i*4;\n\t                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |\n\t                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);\n\t                }\n\n\t                for (i = 16; i < 64; i++) {\n\t                    u = w[i-2];\n\t                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);\n\n\t                    u = w[i-15];\n\t                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);\n\n\t                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;\n\t                }\n\n\t                for (i = 0; i < 64; i++) {\n\t                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^\n\t                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +\n\t                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;\n\n\t                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^\n\t                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;\n\n\t                    h = g;\n\t                    g = f;\n\t                    f = e;\n\t                    e = (d + t1) | 0;\n\t                    d = c;\n\t                    c = b;\n\t                    b = a;\n\t                    a = (t1 + t2) | 0;\n\t                }\n\n\t                h0 = (h0 + a) | 0;\n\t                h1 = (h1 + b) | 0;\n\t                h2 = (h2 + c) | 0;\n\t                h3 = (h3 + d) | 0;\n\t                h4 = (h4 + e) | 0;\n\t                h5 = (h5 + f) | 0;\n\t                h6 = (h6 + g) | 0;\n\t                h7 = (h7 + h) | 0;\n\n\t                off += 64;\n\t                len -= 64;\n\t            }\n\t        }\n\n\t        blocks(m);\n\n\t        let i, bytesLeft = m.length % 64,\n\t        bitLenHi = (m.length / 0x20000000) | 0,\n\t        bitLenLo = m.length << 3,\n\t        numZeros = (bytesLeft < 56) ? 56 : 120,\n\t        p = m.slice(m.length - bytesLeft, m.length);\n\n\t        p.push(0x80);\n\t        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }\n\t        p.push((bitLenHi >>> 24) & 0xff);\n\t        p.push((bitLenHi >>> 16) & 0xff);\n\t        p.push((bitLenHi >>> 8)  & 0xff);\n\t        p.push((bitLenHi >>> 0)  & 0xff);\n\t        p.push((bitLenLo >>> 24) & 0xff);\n\t        p.push((bitLenLo >>> 16) & 0xff);\n\t        p.push((bitLenLo >>> 8)  & 0xff);\n\t        p.push((bitLenLo >>> 0)  & 0xff);\n\n\t        blocks(p);\n\n\t        return [\n\t            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,\n\t            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,\n\t            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,\n\t            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,\n\t            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,\n\t            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,\n\t            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,\n\t            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff\n\t        ];\n\t    }\n\n\t    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {\n\t        // compress password if it\'s longer than hash block length\n\t        password = (password.length <= 64) ? password : SHA256(password);\n\n\t        const innerLen = 64 + salt.length + 4;\n\t        const inner = new Array(innerLen);\n\t        const outerKey = new Array(64);\n\n\t        let i;\n\t        let dk = [];\n\n\t        // inner = (password ^ ipad) || salt || counter\n\t        for (i = 0; i < 64; i++) { inner[i] = 0x36; }\n\t        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }\n\t        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }\n\t        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }\n\n\t        // outerKey = password ^ opad\n\t        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;\n\t        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];\n\n\t        // increments counter inside inner\n\t        function incrementCounter() {\n\t            for (let i = innerLen - 1; i >= innerLen - 4; i--) {\n\t                inner[i]++;\n\t                if (inner[i] <= 0xff) return;\n\t                inner[i] = 0;\n\t            }\n\t        }\n\n\t        // output blocks = SHA256(outerKey || SHA256(inner)) ...\n\t        while (dkLen >= 32) {\n\t            incrementCounter();\n\t            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));\n\t            dkLen -= 32;\n\t        }\n\t        if (dkLen > 0) {\n\t            incrementCounter();\n\t            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));\n\t        }\n\n\t        return dk;\n\t    }\n\n\t    // The following is an adaptation of scryptsy\n\t    // See: https://www.npmjs.com/package/scryptsy\n\t    function blockmix_salsa8(BY, Yi, r, x, _X) {\n\t        let i;\n\n\t        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);\n\t        for (i = 0; i < 2 * r; i++) {\n\t            blockxor(BY, i * 16, _X, 16);\n\t            salsa20_8(_X, x);\n\t            arraycopy(_X, 0, BY, Yi + (i * 16), 16);\n\t        }\n\n\t        for (i = 0; i < r; i++) {\n\t            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);\n\t        }\n\n\t        for (i = 0; i < r; i++) {\n\t            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);\n\t        }\n\t    }\n\n\t    function R(a, b) {\n\t        return (a << b) | (a >>> (32 - b));\n\t    }\n\n\t    function salsa20_8(B, x) {\n\t        arraycopy(B, 0, x, 0, 16);\n\n\t        for (let i = 8; i > 0; i -= 2) {\n\t            x[ 4] ^= R(x[ 0] + x[12], 7);\n\t            x[ 8] ^= R(x[ 4] + x[ 0], 9);\n\t            x[12] ^= R(x[ 8] + x[ 4], 13);\n\t            x[ 0] ^= R(x[12] + x[ 8], 18);\n\t            x[ 9] ^= R(x[ 5] + x[ 1], 7);\n\t            x[13] ^= R(x[ 9] + x[ 5], 9);\n\t            x[ 1] ^= R(x[13] + x[ 9], 13);\n\t            x[ 5] ^= R(x[ 1] + x[13], 18);\n\t            x[14] ^= R(x[10] + x[ 6], 7);\n\t            x[ 2] ^= R(x[14] + x[10], 9);\n\t            x[ 6] ^= R(x[ 2] + x[14], 13);\n\t            x[10] ^= R(x[ 6] + x[ 2], 18);\n\t            x[ 3] ^= R(x[15] + x[11], 7);\n\t            x[ 7] ^= R(x[ 3] + x[15], 9);\n\t            x[11] ^= R(x[ 7] + x[ 3], 13);\n\t            x[15] ^= R(x[11] + x[ 7], 18);\n\t            x[ 1] ^= R(x[ 0] + x[ 3], 7);\n\t            x[ 2] ^= R(x[ 1] + x[ 0], 9);\n\t            x[ 3] ^= R(x[ 2] + x[ 1], 13);\n\t            x[ 0] ^= R(x[ 3] + x[ 2], 18);\n\t            x[ 6] ^= R(x[ 5] + x[ 4], 7);\n\t            x[ 7] ^= R(x[ 6] + x[ 5], 9);\n\t            x[ 4] ^= R(x[ 7] + x[ 6], 13);\n\t            x[ 5] ^= R(x[ 4] + x[ 7], 18);\n\t            x[11] ^= R(x[10] + x[ 9], 7);\n\t            x[ 8] ^= R(x[11] + x[10], 9);\n\t            x[ 9] ^= R(x[ 8] + x[11], 13);\n\t            x[10] ^= R(x[ 9] + x[ 8], 18);\n\t            x[12] ^= R(x[15] + x[14], 7);\n\t            x[13] ^= R(x[12] + x[15], 9);\n\t            x[14] ^= R(x[13] + x[12], 13);\n\t            x[15] ^= R(x[14] + x[13], 18);\n\t        }\n\n\t        for (let i = 0; i < 16; ++i) {\n\t            B[i] += x[i];\n\t        }\n\t    }\n\n\t    // naive approach... going back to loop unrolling may yield additional performance\n\t    function blockxor(S, Si, D, len) {\n\t        for (let i = 0; i < len; i++) {\n\t            D[i] ^= S[Si + i];\n\t        }\n\t    }\n\n\t    function arraycopy(src, srcPos, dest, destPos, length) {\n\t        while (length--) {\n\t            dest[destPos++] = src[srcPos++];\n\t        }\n\t    }\n\n\t    function checkBufferish(o) {\n\t        if (!o || typeof(o.length) !== \'number\') { return false; }\n\n\t        for (let i = 0; i < o.length; i++) {\n\t            const v = o[i];\n\t            if (typeof(v) !== \'number\' || v % 1 || v < 0 || v >= 256) {\n\t                return false;\n\t            }\n\t        }\n\n\t        return true;\n\t    }\n\n\t    function ensureInteger(value, name) {\n\t        if (typeof(value) !== "number" || (value % 1)) { throw new Error(\'invalid \' + name); }\n\t        return value;\n\t    }\n\n\t    // N = Cpu cost, r = Memory cost, p = parallelization cost\n\t    // callback(error, progress, key)\n\t    function _scrypt(password, salt, N, r, p, dkLen, callback) {\n\n\t        N = ensureInteger(N, \'N\');\n\t        r = ensureInteger(r, \'r\');\n\t        p = ensureInteger(p, \'p\');\n\n\t        dkLen = ensureInteger(dkLen, \'dkLen\');\n\n\t        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error(\'N must be power of 2\'); }\n\n\t        if (N > MAX_VALUE / 128 / r) { throw new Error(\'N too large\'); }\n\t        if (r > MAX_VALUE / 128 / p) { throw new Error(\'r too large\'); }\n\n\t        if (!checkBufferish(password)) {\n\t            throw new Error(\'password must be an array or buffer\');\n\t        }\n\t        password = Array.prototype.slice.call(password);\n\n\t        if (!checkBufferish(salt)) {\n\t            throw new Error(\'salt must be an array or buffer\');\n\t        }\n\t        salt = Array.prototype.slice.call(salt);\n\n\t        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);\n\t        const B = new Uint32Array(p * 32 * r);\n\t        for (let i = 0; i < B.length; i++) {\n\t            const j = i * 4;\n\t            B[i] = ((b[j + 3] & 0xff) << 24) |\n\t                   ((b[j + 2] & 0xff) << 16) |\n\t                   ((b[j + 1] & 0xff) << 8) |\n\t                   ((b[j + 0] & 0xff) << 0);\n\t        }\n\n\t        const XY = new Uint32Array(64 * r);\n\t        const V = new Uint32Array(32 * r * N);\n\n\t        const Yi = 32 * r;\n\n\t        // scratch space\n\t        const x = new Uint32Array(16);       // salsa20_8\n\t        const _X = new Uint32Array(16);      // blockmix_salsa8\n\n\t        const totalOps = p * N * 2;\n\t        let currentOp = 0;\n\t        let lastPercent10 = null;\n\n\t        // Set this to true to abandon the scrypt on the next step\n\t        let stop = false;\n\n\t        // State information\n\t        let state = 0;\n\t        let i0 = 0, i1;\n\t        let Bi;\n\n\t        // How many blockmix_salsa8 can we do per step?\n\t        const limit = callback ? parseInt(1000 / r): 0xffffffff;\n\n\t        // Trick from scrypt-async; if there is a setImmediate shim in place, use it\n\t        const nextTick = (typeof(setImmediate) !== \'undefined\') ? setImmediate : setTimeout;\n\n\t        // This is really all I changed; making scryptsy a state machine so we occasionally\n\t        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo\n\t        const incrementalSMix = function() {\n\t            if (stop) {\n\t                return callback(new Error(\'cancelled\'), currentOp / totalOps);\n\t            }\n\n\t            let steps;\n\n\t            switch (state) {\n\t                case 0:\n\t                    // for (var i = 0; i < p; i++)...\n\t                    Bi = i0 * 32 * r;\n\n\t                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1\n\n\t                    state = 1;                                         // Move to ROMix 2\n\t                    i1 = 0;\n\n\t                    // Fall through\n\n\t                case 1:\n\n\t                    // Run up to 1000 steps of the first inner smix loop\n\t                    steps = N - i1;\n\t                    if (steps > limit) { steps = limit; }\n\t                    for (let i = 0; i < steps; i++) {                  // ROMix - 2\n\t                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi);         // ROMix - 3\n\t                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4\n\t                    }\n\n\t                    // for (var i = 0; i < N; i++)\n\t                    i1 += steps;\n\t                    currentOp += steps;\n\n\t                    if (callback) {\n\t                        // Call the callback with the progress (optionally stopping us)\n\t                        const percent10 = parseInt(1000 * currentOp / totalOps);\n\t                        if (percent10 !== lastPercent10) {\n\t                            stop = callback(null, currentOp / totalOps);\n\t                            if (stop) { break; }\n\t                            lastPercent10 = percent10;\n\t                        }\n\t                    }\n\n\t                    if (i1 < N) { break; }\n\n\t                    i1 = 0;                                          // Move to ROMix 6\n\t                    state = 2;\n\n\t                    // Fall through\n\n\t                case 2:\n\n\t                    // Run up to 1000 steps of the second inner smix loop\n\t                    steps = N - i1;\n\t                    if (steps > limit) { steps = limit; }\n\t                    for (let i = 0; i < steps; i++) {                // ROMix - 6\n\t                        const offset = (2 * r - 1) * 16;             // ROMix - 7\n\t                        const j = XY[offset] & (N - 1);\n\t                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)\n\t                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)\n\t                    }\n\n\t                    // for (var i = 0; i < N; i++)...\n\t                    i1 += steps;\n\t                    currentOp += steps;\n\n\t                    // Call the callback with the progress (optionally stopping us)\n\t                    if (callback) {\n\t                        const percent10 = parseInt(1000 * currentOp / totalOps);\n\t                        if (percent10 !== lastPercent10) {\n\t                            stop = callback(null, currentOp / totalOps);\n\t                            if (stop) { break; }\n\t                            lastPercent10 = percent10;\n\t                        }\n\t                    }\n\n\t                    if (i1 < N) { break; }\n\n\t                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10\n\n\t                    // for (var i = 0; i < p; i++)...\n\t                    i0++;\n\t                    if (i0 < p) {\n\t                        state = 0;\n\t                        break;\n\t                    }\n\n\t                    b = [];\n\t                    for (let i = 0; i < B.length; i++) {\n\t                        b.push((B[i] >>  0) & 0xff);\n\t                        b.push((B[i] >>  8) & 0xff);\n\t                        b.push((B[i] >> 16) & 0xff);\n\t                        b.push((B[i] >> 24) & 0xff);\n\t                    }\n\n\t                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);\n\n\t                    // Send the result to the callback\n\t                    if (callback) { callback(null, 1.0, derivedKey); }\n\n\t                    // Done; don\'t break (which would reschedule)\n\t                    return derivedKey;\n\t            }\n\n\t            // Schedule the next steps\n\t            if (callback) { nextTick(incrementalSMix); }\n\t        };\n\n\t        // Run the smix state machine until completion\n\t        if (!callback) {\n\t            while (true) {\n\t                const derivedKey = incrementalSMix();\n\t                if (derivedKey != undefined) { return derivedKey; }\n\t            }\n\t        }\n\n\t        // Bootstrap the async incremental smix\n\t        incrementalSMix();\n\t    }\n\n\t    const lib = {\n\t        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {\n\t            return new Promise(function(resolve, reject) {\n\t                let lastProgress = 0;\n\t                if (progressCallback) { progressCallback(0); }\n\t                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {\n\t                    if (error) {\n\t                        reject(error);\n\t                    } else if (key) {\n\t                        if (progressCallback && lastProgress !== 1) {\n\t                            progressCallback(1);\n\t                        }\n\t                        resolve(new Uint8Array(key));\n\t                    } else if (progressCallback && progress !== lastProgress) {\n\t                        lastProgress = progress;\n\t                        return progressCallback(progress);\n\t                    }\n\t                });\n\t            });\n\t        },\n\t        syncScrypt: function(password, salt, N, r, p, dkLen) {\n\t            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));\n\t        }\n\t    };\n\n\t    // node.js\n\t    if (true) {\n\t       module.exports = lib;\n\n\t    // RequireJS/AMD\n\t    // http://www.requirejs.org/docs/api.html\n\t    // https://github.com/amdjs/amdjs-api/wiki/AMD\n\t    } else {}\n\n\t})(commonjsGlobal);\n\t});\n\tvar scrypt_1 = scrypt.scrypt;\n\tvar scrypt_2 = scrypt.syncScrypt;\n\n\tvar keystore = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { "default": mod };\n\t};\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result["default"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tvar aes_js_1 = __importDefault(aesJs);\n\tvar scrypt$1 = __importStar(scrypt);\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$A.version);\n\t// Exported Types\n\tfunction hasMnemonic(value) {\n\t    return (value != null && value.mnemonic && value.mnemonic.phrase);\n\t}\n\tvar KeystoreAccount = /** @class */ (function (_super) {\n\t    __extends(KeystoreAccount, _super);\n\t    function KeystoreAccount() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    KeystoreAccount.prototype.isKeystoreAccount = function (value) {\n\t        return !!(value && value._isKeystoreAccount);\n\t    };\n\t    return KeystoreAccount;\n\t}(lib$3.Description));\n\texports.KeystoreAccount = KeystoreAccount;\n\tfunction _decrypt(data, key, ciphertext) {\n\t    var cipher = utils$1.searchPath(data, "crypto/cipher");\n\t    if (cipher === "aes-128-ctr") {\n\t        var iv = utils$1.looseArrayify(utils$1.searchPath(data, "crypto/cipherparams/iv"));\n\t        var counter = new aes_js_1.default.Counter(iv);\n\t        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(key, counter);\n\t        return lib$1.arrayify(aesCtr.decrypt(ciphertext));\n\t    }\n\t    return null;\n\t}\n\tfunction _getAccount(data, key) {\n\t    var ciphertext = utils$1.looseArrayify(utils$1.searchPath(data, "crypto/ciphertext"));\n\t    var computedMAC = lib$1.hexlify(lib$4.keccak256(lib$1.concat([key.slice(16, 32), ciphertext]))).substring(2);\n\t    if (computedMAC !== utils$1.searchPath(data, "crypto/mac").toLowerCase()) {\n\t        throw new Error("invalid password");\n\t    }\n\t    var privateKey = _decrypt(data, key.slice(0, 16), ciphertext);\n\t    if (!privateKey) {\n\t        logger.throwError("unsupported cipher", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: "decrypt"\n\t        });\n\t    }\n\t    var mnemonicKey = key.slice(32, 64);\n\t    var address = lib$g.computeAddress(privateKey);\n\t    if (data.address) {\n\t        var check = data.address.toLowerCase();\n\t        if (check.substring(0, 2) !== "0x") {\n\t            check = "0x" + check;\n\t        }\n\t        if (lib$6.getAddress(check) !== address) {\n\t            throw new Error("address mismatch");\n\t        }\n\t    }\n\t    var account = {\n\t        _isKeystoreAccount: true,\n\t        address: address,\n\t        privateKey: lib$1.hexlify(privateKey)\n\t    };\n\t    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase\n\t    if (utils$1.searchPath(data, "x-ethers/version") === "0.1") {\n\t        var mnemonicCiphertext = utils$1.looseArrayify(utils$1.searchPath(data, "x-ethers/mnemonicCiphertext"));\n\t        var mnemonicIv = utils$1.looseArrayify(utils$1.searchPath(data, "x-ethers/mnemonicCounter"));\n\t        var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n\t        var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\t        var path = utils$1.searchPath(data, "x-ethers/path") || lib$h.defaultPath;\n\t        var locale = utils$1.searchPath(data, "x-ethers/locale") || "en";\n\t        var entropy = lib$1.arrayify(mnemonicAesCtr.decrypt(mnemonicCiphertext));\n\t        try {\n\t            var mnemonic = lib$h.entropyToMnemonic(entropy, locale);\n\t            var node = lib$h.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);\n\t            if (node.privateKey != account.privateKey) {\n\t                throw new Error("mnemonic mismatch");\n\t            }\n\t            account.mnemonic = node.mnemonic;\n\t        }\n\t        catch (error) {\n\t            // If we don\'t have the locale wordlist installed to\n\t            // read this mnemonic, just bail and don\'t set the\n\t            // mnemonic\n\t            if (error.code !== lib.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {\n\t                throw error;\n\t            }\n\t        }\n\t    }\n\t    return new KeystoreAccount(account);\n\t}\n\tfunction pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {\n\t    return lib$1.arrayify(browser$2.pbkdf2(passwordBytes, salt, count, dkLen, prfFunc));\n\t}\n\tfunction pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {\n\t    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));\n\t}\n\tfunction _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {\n\t    var passwordBytes = utils$1.getPassword(password);\n\t    var kdf = utils$1.searchPath(data, "crypto/kdf");\n\t    if (kdf && typeof (kdf) === "string") {\n\t        var throwError = function (name, value) {\n\t            return logger.throwArgumentError("invalid key-derivation function parameters", name, value);\n\t        };\n\t        if (kdf.toLowerCase() === "scrypt") {\n\t            var salt = utils$1.looseArrayify(utils$1.searchPath(data, "crypto/kdfparams/salt"));\n\t            var N = parseInt(utils$1.searchPath(data, "crypto/kdfparams/n"));\n\t            var r = parseInt(utils$1.searchPath(data, "crypto/kdfparams/r"));\n\t            var p = parseInt(utils$1.searchPath(data, "crypto/kdfparams/p"));\n\t            // Check for all required parameters\n\t            if (!N || !r || !p) {\n\t                throwError("kdf", kdf);\n\t            }\n\t            // Make sure N is a power of 2\n\t            if ((N & (N - 1)) !== 0) {\n\t                throwError("N", N);\n\t            }\n\t            var dkLen = parseInt(utils$1.searchPath(data, "crypto/kdfparams/dklen"));\n\t            if (dkLen !== 32) {\n\t                throwError("dklen", dkLen);\n\t            }\n\t            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);\n\t        }\n\t        else if (kdf.toLowerCase() === "pbkdf2") {\n\t            var salt = utils$1.looseArrayify(utils$1.searchPath(data, "crypto/kdfparams/salt"));\n\t            var prfFunc = null;\n\t            var prf = utils$1.searchPath(data, "crypto/kdfparams/prf");\n\t            if (prf === "hmac-sha256") {\n\t                prfFunc = "sha256";\n\t            }\n\t            else if (prf === "hmac-sha512") {\n\t                prfFunc = "sha512";\n\t            }\n\t            else {\n\t                throwError("prf", prf);\n\t            }\n\t            var count = parseInt(utils$1.searchPath(data, "crypto/kdfparams/c"));\n\t            var dkLen = parseInt(utils$1.searchPath(data, "crypto/kdfparams/dklen"));\n\t            if (dkLen !== 32) {\n\t                throwError("dklen", dkLen);\n\t            }\n\t            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);\n\t        }\n\t    }\n\t    return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);\n\t}\n\tfunction decryptSync(json, password) {\n\t    var data = JSON.parse(json);\n\t    var key = _computeKdfKey(data, password, pbkdf2Sync, scrypt$1.syncScrypt);\n\t    return _getAccount(data, key);\n\t}\n\texports.decryptSync = decryptSync;\n\tfunction decrypt(json, password, progressCallback) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var data, key;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    data = JSON.parse(json);\n\t                    return [4 /*yield*/, _computeKdfKey(data, password, pbkdf2, scrypt$1.scrypt, progressCallback)];\n\t                case 1:\n\t                    key = _a.sent();\n\t                    return [2 /*return*/, _getAccount(data, key)];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.decrypt = decrypt;\n\tfunction encrypt(account, password, options, progressCallback) {\n\t    try {\n\t        // Check the address matches the private key\n\t        if (lib$6.getAddress(account.address) !== lib$g.computeAddress(account.privateKey)) {\n\t            throw new Error("address/privateKey mismatch");\n\t        }\n\t        // Check the mnemonic (if any) matches the private key\n\t        if (hasMnemonic(account)) {\n\t            var mnemonic = account.mnemonic;\n\t            var node = lib$h.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || lib$h.defaultPath);\n\t            if (node.privateKey != account.privateKey) {\n\t                throw new Error("mnemonic mismatch");\n\t            }\n\t        }\n\t    }\n\t    catch (e) {\n\t        return Promise.reject(e);\n\t    }\n\t    // The options are optional, so adjust the call as needed\n\t    if (typeof (options) === "function" && !progressCallback) {\n\t        progressCallback = options;\n\t        options = {};\n\t    }\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    var privateKey = lib$1.arrayify(account.privateKey);\n\t    var passwordBytes = utils$1.getPassword(password);\n\t    var entropy = null;\n\t    var path = null;\n\t    var locale = null;\n\t    if (hasMnemonic(account)) {\n\t        var srcMnemonic = account.mnemonic;\n\t        entropy = lib$1.arrayify(lib$h.mnemonicToEntropy(srcMnemonic.phrase, srcMnemonic.locale || "en"));\n\t        path = srcMnemonic.path || lib$h.defaultPath;\n\t        locale = srcMnemonic.locale || "en";\n\t    }\n\t    var client = options.client;\n\t    if (!client) {\n\t        client = "ethers.js";\n\t    }\n\t    // Check/generate the salt\n\t    var salt = null;\n\t    if (options.salt) {\n\t        salt = lib$1.arrayify(options.salt);\n\t    }\n\t    else {\n\t        salt = browser$6.randomBytes(32);\n\t        ;\n\t    }\n\t    // Override initialization vector\n\t    var iv = null;\n\t    if (options.iv) {\n\t        iv = lib$1.arrayify(options.iv);\n\t        if (iv.length !== 16) {\n\t            throw new Error("invalid iv");\n\t        }\n\t    }\n\t    else {\n\t        iv = browser$6.randomBytes(16);\n\t    }\n\t    // Override the uuid\n\t    var uuidRandom = null;\n\t    if (options.uuid) {\n\t        uuidRandom = lib$1.arrayify(options.uuid);\n\t        if (uuidRandom.length !== 16) {\n\t            throw new Error("invalid uuid");\n\t        }\n\t    }\n\t    else {\n\t        uuidRandom = browser$6.randomBytes(16);\n\t    }\n\t    // Override the scrypt password-based key derivation function parameters\n\t    var N = (1 << 17), r = 8, p = 1;\n\t    if (options.scrypt) {\n\t        if (options.scrypt.N) {\n\t            N = options.scrypt.N;\n\t        }\n\t        if (options.scrypt.r) {\n\t            r = options.scrypt.r;\n\t        }\n\t        if (options.scrypt.p) {\n\t            p = options.scrypt.p;\n\t        }\n\t    }\n\t    // We take 64 bytes:\n\t    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)\n\t    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)\n\t    return scrypt$1.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(function (key) {\n\t        key = lib$1.arrayify(key);\n\t        // This will be used to encrypt the wallet (as per Web3 secret storage)\n\t        var derivedKey = key.slice(0, 16);\n\t        var macPrefix = key.slice(16, 32);\n\t        // This will be used to encrypt the mnemonic phrase (if any)\n\t        var mnemonicKey = key.slice(32, 64);\n\t        // Encrypt the private key\n\t        var counter = new aes_js_1.default.Counter(iv);\n\t        var aesCtr = new aes_js_1.default.ModeOfOperation.ctr(derivedKey, counter);\n\t        var ciphertext = lib$1.arrayify(aesCtr.encrypt(privateKey));\n\t        // Compute the message authentication code, used to check the password\n\t        var mac = lib$4.keccak256(lib$1.concat([macPrefix, ciphertext]));\n\t        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition\n\t        var data = {\n\t            address: account.address.substring(2).toLowerCase(),\n\t            id: utils$1.uuidV4(uuidRandom),\n\t            version: 3,\n\t            Crypto: {\n\t                cipher: "aes-128-ctr",\n\t                cipherparams: {\n\t                    iv: lib$1.hexlify(iv).substring(2),\n\t                },\n\t                ciphertext: lib$1.hexlify(ciphertext).substring(2),\n\t                kdf: "scrypt",\n\t                kdfparams: {\n\t                    salt: lib$1.hexlify(salt).substring(2),\n\t                    n: N,\n\t                    dklen: 32,\n\t                    p: p,\n\t                    r: r\n\t                },\n\t                mac: mac.substring(2)\n\t            }\n\t        };\n\t        // If we have a mnemonic, encrypt it into the JSON wallet\n\t        if (entropy) {\n\t            var mnemonicIv = browser$6.randomBytes(16);\n\t            var mnemonicCounter = new aes_js_1.default.Counter(mnemonicIv);\n\t            var mnemonicAesCtr = new aes_js_1.default.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);\n\t            var mnemonicCiphertext = lib$1.arrayify(mnemonicAesCtr.encrypt(entropy));\n\t            var now = new Date();\n\t            var timestamp = (now.getUTCFullYear() + "-" +\n\t                utils$1.zpad(now.getUTCMonth() + 1, 2) + "-" +\n\t                utils$1.zpad(now.getUTCDate(), 2) + "T" +\n\t                utils$1.zpad(now.getUTCHours(), 2) + "-" +\n\t                utils$1.zpad(now.getUTCMinutes(), 2) + "-" +\n\t                utils$1.zpad(now.getUTCSeconds(), 2) + ".0Z");\n\t            data["x-ethers"] = {\n\t                client: client,\n\t                gethFilename: ("UTC--" + timestamp + "--" + data.address),\n\t                mnemonicCounter: lib$1.hexlify(mnemonicIv).substring(2),\n\t                mnemonicCiphertext: lib$1.hexlify(mnemonicCiphertext).substring(2),\n\t                path: path,\n\t                locale: locale,\n\t                version: "0.1"\n\t            };\n\t        }\n\t        return JSON.stringify(data);\n\t    });\n\t}\n\texports.encrypt = encrypt;\n\n\t});\n\n\tvar keystore$1 = unwrapExports(keystore);\n\tvar keystore_1 = keystore.KeystoreAccount;\n\tvar keystore_2 = keystore.decryptSync;\n\tvar keystore_3 = keystore.decrypt;\n\tvar keystore_4 = keystore.encrypt;\n\n\tvar lib$i = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\texports.decryptCrowdsale = crowdsale.decrypt;\n\n\texports.getJsonWalletAddress = inspect.getJsonWalletAddress;\n\texports.isCrowdsaleWallet = inspect.isCrowdsaleWallet;\n\texports.isKeystoreWallet = inspect.isKeystoreWallet;\n\n\texports.decryptKeystore = keystore.decrypt;\n\texports.decryptKeystoreSync = keystore.decryptSync;\n\texports.encryptKeystore = keystore.encrypt;\n\tfunction decryptJsonWallet(json, password, progressCallback) {\n\t    if (inspect.isCrowdsaleWallet(json)) {\n\t        if (progressCallback) {\n\t            progressCallback(0);\n\t        }\n\t        var account = crowdsale.decrypt(json, password);\n\t        if (progressCallback) {\n\t            progressCallback(1);\n\t        }\n\t        return Promise.resolve(account);\n\t    }\n\t    if (inspect.isKeystoreWallet(json)) {\n\t        return keystore.decrypt(json, password, progressCallback);\n\t    }\n\t    return Promise.reject(new Error("invalid JSON wallet"));\n\t}\n\texports.decryptJsonWallet = decryptJsonWallet;\n\tfunction decryptJsonWalletSync(json, password) {\n\t    if (inspect.isCrowdsaleWallet(json)) {\n\t        return crowdsale.decrypt(json, password);\n\t    }\n\t    if (inspect.isKeystoreWallet(json)) {\n\t        return keystore.decryptSync(json, password);\n\t    }\n\t    throw new Error("invalid JSON wallet");\n\t}\n\texports.decryptJsonWalletSync = decryptJsonWalletSync;\n\n\t});\n\n\tvar index$i = unwrapExports(lib$i);\n\tvar lib_1$i = lib$i.decryptCrowdsale;\n\tvar lib_2$h = lib$i.getJsonWalletAddress;\n\tvar lib_3$e = lib$i.isCrowdsaleWallet;\n\tvar lib_4$b = lib$i.isKeystoreWallet;\n\tvar lib_5$a = lib$i.decryptKeystore;\n\tvar lib_6$6 = lib$i.decryptKeystoreSync;\n\tvar lib_7$5 = lib$i.encryptKeystore;\n\tvar lib_8$4 = lib$i.decryptJsonWallet;\n\tvar lib_9$4 = lib$i.decryptJsonWalletSync;\n\n\tvar _version$C = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "wallet/5.0.4";\n\n\t});\n\n\tvar _version$D = unwrapExports(_version$C);\n\tvar _version_1$j = _version$C.version;\n\n\tvar lib$j = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$C.version);\n\tfunction isAccount(value) {\n\t    return (value != null && lib$1.isHexString(value.privateKey, 32) && value.address != null);\n\t}\n\tfunction hasMnemonic(value) {\n\t    var mnemonic = value.mnemonic;\n\t    return (mnemonic && mnemonic.phrase);\n\t}\n\tvar Wallet = /** @class */ (function (_super) {\n\t    __extends(Wallet, _super);\n\t    function Wallet(privateKey, provider) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Wallet);\n\t        _this = _super.call(this) || this;\n\t        if (isAccount(privateKey)) {\n\t            var signingKey_1 = new lib$f.SigningKey(privateKey.privateKey);\n\t            lib$3.defineReadOnly(_this, "_signingKey", function () { return signingKey_1; });\n\t            lib$3.defineReadOnly(_this, "address", lib$g.computeAddress(_this.publicKey));\n\t            if (_this.address !== lib$6.getAddress(privateKey.address)) {\n\t                logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");\n\t            }\n\t            if (hasMnemonic(privateKey)) {\n\t                var srcMnemonic_1 = privateKey.mnemonic;\n\t                lib$3.defineReadOnly(_this, "_mnemonic", function () { return ({\n\t                    phrase: srcMnemonic_1.phrase,\n\t                    path: srcMnemonic_1.path || lib$h.defaultPath,\n\t                    locale: srcMnemonic_1.locale || "en"\n\t                }); });\n\t                var mnemonic = _this.mnemonic;\n\t                var node = lib$h.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);\n\t                if (lib$g.computeAddress(node.privateKey) !== _this.address) {\n\t                    logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");\n\t                }\n\t            }\n\t            else {\n\t                lib$3.defineReadOnly(_this, "_mnemonic", function () { return null; });\n\t            }\n\t        }\n\t        else {\n\t            if (lib$f.SigningKey.isSigningKey(privateKey)) {\n\t                /* istanbul ignore if */\n\t                if (privateKey.curve !== "secp256k1") {\n\t                    logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");\n\t                }\n\t                lib$3.defineReadOnly(_this, "_signingKey", function () { return privateKey; });\n\t            }\n\t            else {\n\t                var signingKey_2 = new lib$f.SigningKey(privateKey);\n\t                lib$3.defineReadOnly(_this, "_signingKey", function () { return signingKey_2; });\n\t            }\n\t            lib$3.defineReadOnly(_this, "_mnemonic", function () { return null; });\n\t            lib$3.defineReadOnly(_this, "address", lib$g.computeAddress(_this.publicKey));\n\t        }\n\t        /* istanbul ignore if */\n\t        if (provider && !lib$b.Provider.isProvider(provider)) {\n\t            logger.throwArgumentError("invalid provider", "provider", provider);\n\t        }\n\t        lib$3.defineReadOnly(_this, "provider", provider || null);\n\t        return _this;\n\t    }\n\t    Object.defineProperty(Wallet.prototype, "mnemonic", {\n\t        get: function () { return this._mnemonic(); },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Wallet.prototype, "privateKey", {\n\t        get: function () { return this._signingKey().privateKey; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Wallet.prototype, "publicKey", {\n\t        get: function () { return this._signingKey().publicKey; },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Wallet.prototype.getAddress = function () {\n\t        return Promise.resolve(this.address);\n\t    };\n\t    Wallet.prototype.connect = function (provider) {\n\t        return new Wallet(this, provider);\n\t    };\n\t    Wallet.prototype.signTransaction = function (transaction) {\n\t        var _this = this;\n\t        return lib$3.resolveProperties(transaction).then(function (tx) {\n\t            if (tx.from != null) {\n\t                if (lib$6.getAddress(tx.from) !== _this.address) {\n\t                    logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);\n\t                }\n\t                delete tx.from;\n\t            }\n\t            var signature = _this._signingKey().signDigest(lib$4.keccak256(lib$g.serialize(tx)));\n\t            return lib$g.serialize(tx, signature);\n\t        });\n\t    };\n\t    Wallet.prototype.signMessage = function (message) {\n\t        return Promise.resolve(lib$1.joinSignature(this._signingKey().signDigest(lib$9.hashMessage(message))));\n\t    };\n\t    Wallet.prototype.encrypt = function (password, options, progressCallback) {\n\t        if (typeof (options) === "function" && !progressCallback) {\n\t            progressCallback = options;\n\t            options = {};\n\t        }\n\t        if (progressCallback && typeof (progressCallback) !== "function") {\n\t            throw new Error("invalid callback");\n\t        }\n\t        if (!options) {\n\t            options = {};\n\t        }\n\t        return lib$i.encryptKeystore(this, password, options, progressCallback);\n\t    };\n\t    /**\n\t     *  Static methods to create Wallet instances.\n\t     */\n\t    Wallet.createRandom = function (options) {\n\t        var entropy = browser$6.randomBytes(16);\n\t        if (!options) {\n\t            options = {};\n\t        }\n\t        if (options.extraEntropy) {\n\t            entropy = lib$1.arrayify(lib$1.hexDataSlice(lib$4.keccak256(lib$1.concat([entropy, options.extraEntropy])), 0, 16));\n\t        }\n\t        var mnemonic = lib$h.entropyToMnemonic(entropy, options.locale);\n\t        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);\n\t    };\n\t    Wallet.fromEncryptedJson = function (json, password, progressCallback) {\n\t        return lib$i.decryptJsonWallet(json, password, progressCallback).then(function (account) {\n\t            return new Wallet(account);\n\t        });\n\t    };\n\t    Wallet.fromEncryptedJsonSync = function (json, password) {\n\t        return new Wallet(lib$i.decryptJsonWalletSync(json, password));\n\t    };\n\t    Wallet.fromMnemonic = function (mnemonic, path, wordlist) {\n\t        if (!path) {\n\t            path = lib$h.defaultPath;\n\t        }\n\t        return new Wallet(lib$h.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));\n\t    };\n\t    return Wallet;\n\t}(lib$c.Signer));\n\texports.Wallet = Wallet;\n\tfunction verifyMessage(message, signature) {\n\t    return lib$g.recoverAddress(lib$9.hashMessage(message), signature);\n\t}\n\texports.verifyMessage = verifyMessage;\n\n\t});\n\n\tvar index$j = unwrapExports(lib$j);\n\tvar lib_1$j = lib$j.Wallet;\n\tvar lib_2$i = lib$j.verifyMessage;\n\n\tvar _version$E = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "networks/5.0.3";\n\n\t});\n\n\tvar _version$F = unwrapExports(_version$E);\n\tvar _version_1$k = _version$E.version;\n\n\tvar lib$k = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar logger = new lib.Logger(_version$E.version);\n\t;\n\tfunction isRenetworkable(value) {\n\t    return (value && typeof (value.renetwork) === "function");\n\t}\n\tfunction ethDefaultProvider(network) {\n\t    var func = function (providers, options) {\n\t        if (options == null) {\n\t            options = {};\n\t        }\n\t        var providerList = [];\n\t        if (providers.InfuraProvider) {\n\t            try {\n\t                providerList.push(new providers.InfuraProvider(network, options.infura));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.EtherscanProvider) {\n\t            try {\n\t                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.AlchemyProvider) {\n\t            try {\n\t                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providers.CloudflareProvider) {\n\t            try {\n\t                providerList.push(new providers.CloudflareProvider(network));\n\t            }\n\t            catch (error) { }\n\t        }\n\t        if (providerList.length === 0) {\n\t            return null;\n\t        }\n\t        if (providers.FallbackProvider) {\n\t            var quorum = 1;\n\t            if (options.quorum != null) {\n\t                quorum = options.quorum;\n\t            }\n\t            else if (network === "homestead") {\n\t                quorum = 2;\n\t            }\n\t            return new providers.FallbackProvider(providerList, quorum);\n\t        }\n\t        return providerList[0];\n\t    };\n\t    func.renetwork = function (network) {\n\t        return ethDefaultProvider(network);\n\t    };\n\t    return func;\n\t}\n\tfunction etcDefaultProvider(url, network) {\n\t    var func = function (providers, options) {\n\t        if (providers.JsonRpcProvider) {\n\t            return new providers.JsonRpcProvider(url, network);\n\t        }\n\t        return null;\n\t    };\n\t    func.renetwork = function (network) {\n\t        return etcDefaultProvider(url, network);\n\t    };\n\t    return func;\n\t}\n\tvar homestead = {\n\t    chainId: 1,\n\t    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",\n\t    name: "homestead",\n\t    _defaultProvider: ethDefaultProvider("homestead")\n\t};\n\tvar ropsten = {\n\t    chainId: 3,\n\t    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",\n\t    name: "ropsten",\n\t    _defaultProvider: ethDefaultProvider("ropsten")\n\t};\n\tvar classicMordor = {\n\t    chainId: 63,\n\t    name: "classicMordor",\n\t    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")\n\t};\n\tvar networks = {\n\t    unspecified: {\n\t        chainId: 0,\n\t        name: "unspecified"\n\t    },\n\t    homestead: homestead,\n\t    mainnet: homestead,\n\t    morden: {\n\t        chainId: 2,\n\t        name: "morden"\n\t    },\n\t    ropsten: ropsten,\n\t    testnet: ropsten,\n\t    rinkeby: {\n\t        chainId: 4,\n\t        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",\n\t        name: "rinkeby",\n\t        _defaultProvider: ethDefaultProvider("rinkeby")\n\t    },\n\t    kovan: {\n\t        chainId: 42,\n\t        name: "kovan",\n\t        _defaultProvider: ethDefaultProvider("kovan")\n\t    },\n\t    goerli: {\n\t        chainId: 5,\n\t        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",\n\t        name: "goerli",\n\t        _defaultProvider: ethDefaultProvider("goerli")\n\t    },\n\t    // ETC (See: #351)\n\t    classic: {\n\t        chainId: 61,\n\t        name: "classic",\n\t        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/etc", "classic")\n\t    },\n\t    classicMorden: {\n\t        chainId: 62,\n\t        name: "classicMorden",\n\t    },\n\t    classicMordor: classicMordor,\n\t    classicTestnet: classicMordor,\n\t    classicKotti: {\n\t        chainId: 6,\n\t        name: "classicKotti",\n\t        _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/kotti", "classicKotti")\n\t    },\n\t};\n\t/**\n\t *  getNetwork\n\t *\n\t *  Converts a named common networks or chain ID (network ID) to a Network\n\t *  and verifies a network is a valid Network..\n\t */\n\tfunction getNetwork(network) {\n\t    // No network (null)\n\t    if (network == null) {\n\t        return null;\n\t    }\n\t    if (typeof (network) === "number") {\n\t        for (var name_1 in networks) {\n\t            var standard_1 = networks[name_1];\n\t            if (standard_1.chainId === network) {\n\t                return {\n\t                    name: standard_1.name,\n\t                    chainId: standard_1.chainId,\n\t                    ensAddress: (standard_1.ensAddress || null),\n\t                    _defaultProvider: (standard_1._defaultProvider || null)\n\t                };\n\t            }\n\t        }\n\t        return {\n\t            chainId: network,\n\t            name: "unknown"\n\t        };\n\t    }\n\t    if (typeof (network) === "string") {\n\t        var standard_2 = networks[network];\n\t        if (standard_2 == null) {\n\t            return null;\n\t        }\n\t        return {\n\t            name: standard_2.name,\n\t            chainId: standard_2.chainId,\n\t            ensAddress: standard_2.ensAddress,\n\t            _defaultProvider: (standard_2._defaultProvider || null)\n\t        };\n\t    }\n\t    var standard = networks[network.name];\n\t    // Not a standard network; check that it is a valid network in general\n\t    if (!standard) {\n\t        if (typeof (network.chainId) !== "number") {\n\t            logger.throwArgumentError("invalid network chainId", "network", network);\n\t        }\n\t        return network;\n\t    }\n\t    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n\t    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n\t        logger.throwArgumentError("network chainId mismatch", "network", network);\n\t    }\n\t    // @TODO: In the next major version add an attach function to a defaultProvider\n\t    // class and move the _defaultProvider internal to this file (extend Network)\n\t    var defaultProvider = network._defaultProvider || null;\n\t    if (defaultProvider == null && standard._defaultProvider) {\n\t        if (isRenetworkable(standard._defaultProvider)) {\n\t            defaultProvider = standard._defaultProvider.renetwork(network);\n\t        }\n\t        else {\n\t            defaultProvider = standard._defaultProvider;\n\t        }\n\t    }\n\t    // Standard Network (allow overriding the ENS address)\n\t    return {\n\t        name: network.name,\n\t        chainId: standard.chainId,\n\t        ensAddress: (network.ensAddress || standard.ensAddress || null),\n\t        _defaultProvider: defaultProvider\n\t    };\n\t}\n\texports.getNetwork = getNetwork;\n\n\t});\n\n\tvar index$k = unwrapExports(lib$k);\n\tvar lib_1$k = lib$k.getNetwork;\n\n\tvar browser$8 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tfunction decode(textData) {\n\t    textData = atob(textData);\n\t    var data = [];\n\t    for (var i = 0; i < textData.length; i++) {\n\t        data.push(textData.charCodeAt(i));\n\t    }\n\t    return lib$1.arrayify(data);\n\t}\n\texports.decode = decode;\n\tfunction encode(data) {\n\t    data = lib$1.arrayify(data);\n\t    var textData = "";\n\t    for (var i = 0; i < data.length; i++) {\n\t        textData += String.fromCharCode(data[i]);\n\t    }\n\t    return btoa(textData);\n\t}\n\texports.encode = encode;\n\n\t});\n\n\tvar browser$9 = unwrapExports(browser$8);\n\tvar browser_1$4 = browser$8.decode;\n\tvar browser_2$3 = browser$8.encode;\n\n\tvar _version$G = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "web/5.0.7";\n\n\t});\n\n\tvar _version$H = unwrapExports(_version$G);\n\tvar _version_1$l = _version$G.version;\n\n\tvar browserGeturl = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\tfunction getUrl(href, options) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var request, response, body, headers;\n\t        return __generator(this, function (_a) {\n\t            switch (_a.label) {\n\t                case 0:\n\t                    if (options == null) {\n\t                        options = {};\n\t                    }\n\t                    request = {\n\t                        method: (options.method || "GET"),\n\t                        headers: (options.headers || {}),\n\t                        body: (options.body || undefined),\n\t                        mode: "cors",\n\t                        cache: "no-cache",\n\t                        credentials: "same-origin",\n\t                        redirect: "follow",\n\t                        referrer: "client",\n\t                    };\n\t                    return [4 /*yield*/, fetch(href, request)];\n\t                case 1:\n\t                    response = _a.sent();\n\t                    return [4 /*yield*/, response.arrayBuffer()];\n\t                case 2:\n\t                    body = _a.sent();\n\t                    headers = {};\n\t                    if (response.headers.forEach) {\n\t                        response.headers.forEach(function (value, key) {\n\t                            headers[key.toLowerCase()] = value;\n\t                        });\n\t                    }\n\t                    else {\n\t                        ((response.headers).keys)().forEach(function (key) {\n\t                            headers[key.toLowerCase()] = response.headers.get(key);\n\t                        });\n\t                    }\n\t                    return [2 /*return*/, {\n\t                            headers: headers,\n\t                            statusCode: response.status,\n\t                            statusMessage: response.statusText,\n\t                            body: lib$1.arrayify(new Uint8Array(body)),\n\t                        }];\n\t            }\n\t        });\n\t    });\n\t}\n\texports.getUrl = getUrl;\n\n\t});\n\n\tvar browserGeturl$1 = unwrapExports(browserGeturl);\n\tvar browserGeturl_1 = browserGeturl.getUrl;\n\n\tvar lib$l = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$G.version);\n\n\tfunction staller(duration) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, duration);\n\t    });\n\t}\n\tfunction bodyify(value, type) {\n\t    if (value == null) {\n\t        return null;\n\t    }\n\t    if (typeof (value) === "string") {\n\t        return value;\n\t    }\n\t    if (lib$1.isBytesLike(value)) {\n\t        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {\n\t            try {\n\t                return lib$8.toUtf8String(value);\n\t            }\n\t            catch (error) { }\n\t            ;\n\t        }\n\t        return lib$1.hexlify(value);\n\t    }\n\t    return value;\n\t}\n\t// This API is still a work in progress; the future changes will likely be:\n\t// - ConnectionInfo => FetchDataRequest<T = any>\n\t// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n\t//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n\t// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n\t// For this reason, it should be considered internal until the API is finalized\n\tfunction _fetchData(connection, body, processFunc) {\n\t    // How many times to retry in the event of a throttle\n\t    var attemptLimit = (typeof (connection) === "object" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n\t    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);\n\t    var throttleCallback = ((typeof (connection) === "object") ? connection.throttleCallback : null);\n\t    var throttleSlotInterval = ((typeof (connection) === "object" && typeof (connection.throttleSlotInterval) === "number") ? connection.throttleSlotInterval : 100);\n\t    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);\n\t    var headers = {};\n\t    var url = null;\n\t    // @TODO: Allow ConnectionInfo to override some of these values\n\t    var options = {\n\t        method: "GET",\n\t    };\n\t    var allow304 = false;\n\t    var timeout = 2 * 60 * 1000;\n\t    if (typeof (connection) === "string") {\n\t        url = connection;\n\t    }\n\t    else if (typeof (connection) === "object") {\n\t        if (connection == null || connection.url == null) {\n\t            logger.throwArgumentError("missing URL", "connection.url", connection);\n\t        }\n\t        url = connection.url;\n\t        if (typeof (connection.timeout) === "number" && connection.timeout > 0) {\n\t            timeout = connection.timeout;\n\t        }\n\t        if (connection.headers) {\n\t            for (var key in connection.headers) {\n\t                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n\t                if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {\n\t                    allow304 = true;\n\t                }\n\t            }\n\t        }\n\t        if (connection.user != null && connection.password != null) {\n\t            if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {\n\t                logger.throwError("basic authentication requires a secure https url", lib.Logger.errors.INVALID_ARGUMENT, { argument: "url", url: url, user: connection.user, password: "[REDACTED]" });\n\t            }\n\t            var authorization = connection.user + ":" + connection.password;\n\t            headers["authorization"] = {\n\t                key: "Authorization",\n\t                value: "Basic " + browser$8.encode(lib$8.toUtf8Bytes(authorization))\n\t            };\n\t        }\n\t    }\n\t    if (body) {\n\t        options.method = "POST";\n\t        options.body = body;\n\t        if (headers["content-type"] == null) {\n\t            headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };\n\t        }\n\t        if (headers["content-length"] == null) {\n\t            headers["content-length"] = { key: "Content-Length", value: String(body.length) };\n\t        }\n\t    }\n\t    var flatHeaders = {};\n\t    Object.keys(headers).forEach(function (key) {\n\t        var header = headers[key];\n\t        flatHeaders[header.key] = header.value;\n\t    });\n\t    options.headers = flatHeaders;\n\t    var runningTimeout = (function () {\n\t        var timer = null;\n\t        var promise = new Promise(function (resolve, reject) {\n\t            if (timeout) {\n\t                timer = setTimeout(function () {\n\t                    if (timer == null) {\n\t                        return;\n\t                    }\n\t                    timer = null;\n\t                    reject(logger.makeError("timeout", lib.Logger.errors.TIMEOUT, {\n\t                        requestBody: bodyify(options.body, flatHeaders["content-type"]),\n\t                        requestMethod: options.method,\n\t                        timeout: timeout,\n\t                        url: url\n\t                    }));\n\t                }, timeout);\n\t            }\n\t        });\n\t        var cancel = function () {\n\t            if (timer == null) {\n\t                return;\n\t            }\n\t            clearTimeout(timer);\n\t            timer = null;\n\t        };\n\t        return { promise: promise, cancel: cancel };\n\t    })();\n\t    var runningFetch = (function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var attempt, response, tryAgain, stall, retryAfter, error_1, body_1, result, error_2, tryAgain, timeout_1;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        attempt = 0;\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        if (!(attempt < attemptLimit)) return [3 /*break*/, 19];\n\t                        response = null;\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        _a.trys.push([2, 8, , 9]);\n\t                        return [4 /*yield*/, browserGeturl.getUrl(url, options)];\n\t                    case 3:\n\t                        response = _a.sent();\n\t                        if (!(response.statusCode === 429 && attempt < attemptLimit)) return [3 /*break*/, 7];\n\t                        tryAgain = true;\n\t                        if (!throttleCallback) return [3 /*break*/, 5];\n\t                        return [4 /*yield*/, throttleCallback(attempt, url)];\n\t                    case 4:\n\t                        tryAgain = _a.sent();\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        if (!tryAgain) return [3 /*break*/, 7];\n\t                        stall = 0;\n\t                        retryAfter = response.headers["retry-after"];\n\t                        if (typeof (retryAfter) === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {\n\t                            stall = parseInt(retryAfter) * 1000;\n\t                        }\n\t                        else {\n\t                            stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\t                        }\n\t                        //console.log("Stalling 429");\n\t                        return [4 /*yield*/, staller(stall)];\n\t                    case 6:\n\t                        //console.log("Stalling 429");\n\t                        _a.sent();\n\t                        return [3 /*break*/, 18];\n\t                    case 7: return [3 /*break*/, 9];\n\t                    case 8:\n\t                        error_1 = _a.sent();\n\t                        response = error_1.response;\n\t                        if (response == null) {\n\t                            runningTimeout.cancel();\n\t                            logger.throwError("missing response", lib.Logger.errors.SERVER_ERROR, {\n\t                                requestBody: bodyify(options.body, flatHeaders["content-type"]),\n\t                                requestMethod: options.method,\n\t                                serverError: error_1,\n\t                                url: url\n\t                            });\n\t                        }\n\t                        return [3 /*break*/, 9];\n\t                    case 9:\n\t                        body_1 = response.body;\n\t                        if (allow304 && response.statusCode === 304) {\n\t                            body_1 = null;\n\t                        }\n\t                        else if (response.statusCode < 200 || response.statusCode >= 300) {\n\t                            runningTimeout.cancel();\n\t                            logger.throwError("bad response", lib.Logger.errors.SERVER_ERROR, {\n\t                                status: response.statusCode,\n\t                                headers: response.headers,\n\t                                body: bodyify(body_1, ((response.headers) ? response.headers["content-type"] : null)),\n\t                                requestBody: bodyify(options.body, flatHeaders["content-type"]),\n\t                                requestMethod: options.method,\n\t                                url: url\n\t                            });\n\t                        }\n\t                        if (!processFunc) return [3 /*break*/, 17];\n\t                        _a.label = 10;\n\t                    case 10:\n\t                        _a.trys.push([10, 12, , 17]);\n\t                        return [4 /*yield*/, processFunc(body_1, response)];\n\t                    case 11:\n\t                        result = _a.sent();\n\t                        runningTimeout.cancel();\n\t                        return [2 /*return*/, result];\n\t                    case 12:\n\t                        error_2 = _a.sent();\n\t                        if (!(error_2.throttleRetry && attempt < attemptLimit)) return [3 /*break*/, 16];\n\t                        tryAgain = true;\n\t                        if (!throttleCallback) return [3 /*break*/, 14];\n\t                        return [4 /*yield*/, throttleCallback(attempt, url)];\n\t                    case 13:\n\t                        tryAgain = _a.sent();\n\t                        _a.label = 14;\n\t                    case 14:\n\t                        if (!tryAgain) return [3 /*break*/, 16];\n\t                        timeout_1 = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\t                        //console.log("Stalling callback");\n\t                        return [4 /*yield*/, staller(timeout_1)];\n\t                    case 15:\n\t                        //console.log("Stalling callback");\n\t                        _a.sent();\n\t                        return [3 /*break*/, 18];\n\t                    case 16:\n\t                        runningTimeout.cancel();\n\t                        logger.throwError("processing response error", lib.Logger.errors.SERVER_ERROR, {\n\t                            body: bodyify(body_1, ((response.headers) ? response.headers["content-type"] : null)),\n\t                            error: error_2,\n\t                            requestBody: bodyify(options.body, flatHeaders["content-type"]),\n\t                            requestMethod: options.method,\n\t                            url: url\n\t                        });\n\t                        return [3 /*break*/, 17];\n\t                    case 17:\n\t                        runningTimeout.cancel();\n\t                        // If we had a processFunc, it eitehr returned a T or threw above.\n\t                        // The "body" is now a Uint8Array.\n\t                        return [2 /*return*/, body_1];\n\t                    case 18:\n\t                        attempt++;\n\t                        return [3 /*break*/, 1];\n\t                    case 19: return [2 /*return*/, logger.throwError("failed response", lib.Logger.errors.SERVER_ERROR, {\n\t                            requestBody: bodyify(options.body, flatHeaders["content-type"]),\n\t                            requestMethod: options.method,\n\t                            url: url\n\t                        })];\n\t                }\n\t            });\n\t        });\n\t    })();\n\t    return Promise.race([runningTimeout.promise, runningFetch]);\n\t}\n\texports._fetchData = _fetchData;\n\tfunction fetchJson(connection, json, processFunc) {\n\t    var processJsonFunc = function (value, response) {\n\t        var result = null;\n\t        if (value != null) {\n\t            try {\n\t                result = JSON.parse(lib$8.toUtf8String(value));\n\t            }\n\t            catch (error) {\n\t                logger.throwError("invalid JSON", lib.Logger.errors.SERVER_ERROR, {\n\t                    body: value,\n\t                    error: error\n\t                });\n\t            }\n\t        }\n\t        if (processFunc) {\n\t            result = processFunc(result, response);\n\t        }\n\t        return result;\n\t    };\n\t    // If we have json to send, we must\n\t    // - add content-type of application/json (unless already overridden)\n\t    // - convert the json to bytes\n\t    var body = null;\n\t    if (json != null) {\n\t        body = lib$8.toUtf8Bytes(json);\n\t        // Create a connection with the content-type set for JSON\n\t        var updated = (typeof (connection) === "string") ? ({ url: connection }) : lib$3.shallowCopy(connection);\n\t        if (updated.headers) {\n\t            var hasContentType = (Object.keys(updated.headers).filter(function (k) { return (k.toLowerCase() === "content-type"); }).length) !== 0;\n\t            if (!hasContentType) {\n\t                updated.headers = lib$3.shallowCopy(updated.headers);\n\t                updated.headers["content-type"] = "application/json";\n\t            }\n\t        }\n\t        else {\n\t            updated.headers = { "content-type": "application/json" };\n\t        }\n\t        connection = updated;\n\t    }\n\t    return _fetchData(connection, body, processJsonFunc);\n\t}\n\texports.fetchJson = fetchJson;\n\tfunction poll(func, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t    options = lib$3.shallowCopy(options);\n\t    if (options.floor == null) {\n\t        options.floor = 0;\n\t    }\n\t    if (options.ceiling == null) {\n\t        options.ceiling = 10000;\n\t    }\n\t    if (options.interval == null) {\n\t        options.interval = 250;\n\t    }\n\t    return new Promise(function (resolve, reject) {\n\t        var timer = null;\n\t        var done = false;\n\t        // Returns true if cancel was successful. Unsuccessful cancel means we\'re already done.\n\t        var cancel = function () {\n\t            if (done) {\n\t                return false;\n\t            }\n\t            done = true;\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t            }\n\t            return true;\n\t        };\n\t        if (options.timeout) {\n\t            timer = setTimeout(function () {\n\t                if (cancel()) {\n\t                    reject(new Error("timeout"));\n\t                }\n\t            }, options.timeout);\n\t        }\n\t        var retryLimit = options.retryLimit;\n\t        var attempt = 0;\n\t        function check() {\n\t            return func().then(function (result) {\n\t                // If we have a result, or are allowed null then we\'re done\n\t                if (result !== undefined) {\n\t                    if (cancel()) {\n\t                        resolve(result);\n\t                    }\n\t                }\n\t                else if (options.oncePoll) {\n\t                    options.oncePoll.once("poll", check);\n\t                }\n\t                else if (options.onceBlock) {\n\t                    options.onceBlock.once("block", check);\n\t                    // Otherwise, exponential back-off (up to 10s) our next request\n\t                }\n\t                else if (!done) {\n\t                    attempt++;\n\t                    if (attempt > retryLimit) {\n\t                        if (cancel()) {\n\t                            reject(new Error("retry limit reached"));\n\t                        }\n\t                        return;\n\t                    }\n\t                    var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n\t                    if (timeout < options.floor) {\n\t                        timeout = options.floor;\n\t                    }\n\t                    if (timeout > options.ceiling) {\n\t                        timeout = options.ceiling;\n\t                    }\n\t                    setTimeout(check, timeout);\n\t                }\n\t                return null;\n\t            }, function (error) {\n\t                if (cancel()) {\n\t                    reject(error);\n\t                }\n\t            });\n\t        }\n\t        check();\n\t    });\n\t}\n\texports.poll = poll;\n\n\t});\n\n\tvar index$l = unwrapExports(lib$l);\n\tvar lib_1$l = lib$l._fetchData;\n\tvar lib_2$j = lib$l.fetchJson;\n\tvar lib_3$f = lib$l.poll;\n\n\t\'use strict\';\n\tvar ALPHABET = \'qpzry9x8gf2tvdw0s3jn54khce6mua7l\';\n\n\t// pre-compute lookup table\n\tvar ALPHABET_MAP = {};\n\tfor (var z = 0; z < ALPHABET.length; z++) {\n\t  var x = ALPHABET.charAt(z);\n\n\t  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + \' is ambiguous\')\n\t  ALPHABET_MAP[x] = z;\n\t}\n\n\tfunction polymodStep (pre) {\n\t  var b = pre >> 25;\n\t  return ((pre & 0x1FFFFFF) << 5) ^\n\t    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n\t    (-((b >> 1) & 1) & 0x26508e6d) ^\n\t    (-((b >> 2) & 1) & 0x1ea119fa) ^\n\t    (-((b >> 3) & 1) & 0x3d4233dd) ^\n\t    (-((b >> 4) & 1) & 0x2a1462b3)\n\t}\n\n\tfunction prefixChk (prefix) {\n\t  var chk = 1;\n\t  for (var i = 0; i < prefix.length; ++i) {\n\t    var c = prefix.charCodeAt(i);\n\t    if (c < 33 || c > 126) return \'Invalid prefix (\' + prefix + \')\'\n\n\t    chk = polymodStep(chk) ^ (c >> 5);\n\t  }\n\t  chk = polymodStep(chk);\n\n\t  for (i = 0; i < prefix.length; ++i) {\n\t    var v = prefix.charCodeAt(i);\n\t    chk = polymodStep(chk) ^ (v & 0x1f);\n\t  }\n\t  return chk\n\t}\n\n\tfunction encode (prefix, words, LIMIT) {\n\t  LIMIT = LIMIT || 90;\n\t  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError(\'Exceeds length limit\')\n\n\t  prefix = prefix.toLowerCase();\n\n\t  // determine chk mod\n\t  var chk = prefixChk(prefix);\n\t  if (typeof chk === \'string\') throw new Error(chk)\n\n\t  var result = prefix + \'1\';\n\t  for (var i = 0; i < words.length; ++i) {\n\t    var x = words[i];\n\t    if ((x >> 5) !== 0) throw new Error(\'Non 5-bit word\')\n\n\t    chk = polymodStep(chk) ^ x;\n\t    result += ALPHABET.charAt(x);\n\t  }\n\n\t  for (i = 0; i < 6; ++i) {\n\t    chk = polymodStep(chk);\n\t  }\n\t  chk ^= 1;\n\n\t  for (i = 0; i < 6; ++i) {\n\t    var v = (chk >> ((5 - i) * 5)) & 0x1f;\n\t    result += ALPHABET.charAt(v);\n\t  }\n\n\t  return result\n\t}\n\n\tfunction __decode (str, LIMIT) {\n\t  LIMIT = LIMIT || 90;\n\t  if (str.length < 8) return str + \' too short\'\n\t  if (str.length > LIMIT) return \'Exceeds length limit\'\n\n\t  // don\'t allow mixed case\n\t  var lowered = str.toLowerCase();\n\t  var uppered = str.toUpperCase();\n\t  if (str !== lowered && str !== uppered) return \'Mixed-case string \' + str\n\t  str = lowered;\n\n\t  var split = str.lastIndexOf(\'1\');\n\t  if (split === -1) return \'No separator character for \' + str\n\t  if (split === 0) return \'Missing prefix for \' + str\n\n\t  var prefix = str.slice(0, split);\n\t  var wordChars = str.slice(split + 1);\n\t  if (wordChars.length < 6) return \'Data too short\'\n\n\t  var chk = prefixChk(prefix);\n\t  if (typeof chk === \'string\') return chk\n\n\t  var words = [];\n\t  for (var i = 0; i < wordChars.length; ++i) {\n\t    var c = wordChars.charAt(i);\n\t    var v = ALPHABET_MAP[c];\n\t    if (v === undefined) return \'Unknown character \' + c\n\t    chk = polymodStep(chk) ^ v;\n\n\t    // not in the checksum?\n\t    if (i + 6 >= wordChars.length) continue\n\t    words.push(v);\n\t  }\n\n\t  if (chk !== 1) return \'Invalid checksum for \' + str\n\t  return { prefix: prefix, words: words }\n\t}\n\n\tfunction decodeUnsafe () {\n\t  var res = __decode.apply(null, arguments);\n\t  if (typeof res === \'object\') return res\n\t}\n\n\tfunction decode (str) {\n\t  var res = __decode.apply(null, arguments);\n\t  if (typeof res === \'object\') return res\n\n\t  throw new Error(res)\n\t}\n\n\tfunction convert (data, inBits, outBits, pad) {\n\t  var value = 0;\n\t  var bits = 0;\n\t  var maxV = (1 << outBits) - 1;\n\n\t  var result = [];\n\t  for (var i = 0; i < data.length; ++i) {\n\t    value = (value << inBits) | data[i];\n\t    bits += inBits;\n\n\t    while (bits >= outBits) {\n\t      bits -= outBits;\n\t      result.push((value >> bits) & maxV);\n\t    }\n\t  }\n\n\t  if (pad) {\n\t    if (bits > 0) {\n\t      result.push((value << (outBits - bits)) & maxV);\n\t    }\n\t  } else {\n\t    if (bits >= inBits) return \'Excess padding\'\n\t    if ((value << (outBits - bits)) & maxV) return \'Non-zero padding\'\n\t  }\n\n\t  return result\n\t}\n\n\tfunction toWordsUnsafe (bytes) {\n\t  var res = convert(bytes, 8, 5, true);\n\t  if (Array.isArray(res)) return res\n\t}\n\n\tfunction toWords (bytes) {\n\t  var res = convert(bytes, 8, 5, true);\n\t  if (Array.isArray(res)) return res\n\n\t  throw new Error(res)\n\t}\n\n\tfunction fromWordsUnsafe (words) {\n\t  var res = convert(words, 5, 8, false);\n\t  if (Array.isArray(res)) return res\n\t}\n\n\tfunction fromWords (words) {\n\t  var res = convert(words, 5, 8, false);\n\t  if (Array.isArray(res)) return res\n\n\t  throw new Error(res)\n\t}\n\n\tvar bech32 = {\n\t  decodeUnsafe: decodeUnsafe,\n\t  decode: decode,\n\t  encode: encode,\n\t  toWordsUnsafe: toWordsUnsafe,\n\t  toWords: toWords,\n\t  fromWordsUnsafe: fromWordsUnsafe,\n\t  fromWords: fromWords\n\t};\n\tvar bech32_1 = bech32.decodeUnsafe;\n\tvar bech32_2 = bech32.decode;\n\tvar bech32_3 = bech32.encode;\n\tvar bech32_4 = bech32.toWordsUnsafe;\n\tvar bech32_5 = bech32.toWords;\n\tvar bech32_6 = bech32.fromWordsUnsafe;\n\tvar bech32_7 = bech32.fromWords;\n\n\tvar _version$I = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "providers/5.0.9";\n\n\t});\n\n\tvar _version$J = unwrapExports(_version$I);\n\tvar _version_1$m = _version$I.version;\n\n\tvar formatter = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tvar Formatter = /** @class */ (function () {\n\t    function Formatter() {\n\t        var _newTarget = this.constructor;\n\t        logger.checkNew(_newTarget, Formatter);\n\t        this.formats = this.getDefaultFormats();\n\t    }\n\t    Formatter.prototype.getDefaultFormats = function () {\n\t        var _this = this;\n\t        var formats = ({});\n\t        var address = this.address.bind(this);\n\t        var bigNumber = this.bigNumber.bind(this);\n\t        var blockTag = this.blockTag.bind(this);\n\t        var data = this.data.bind(this);\n\t        var hash = this.hash.bind(this);\n\t        var hex = this.hex.bind(this);\n\t        var number = this.number.bind(this);\n\t        var strictData = function (v) { return _this.data(v, true); };\n\t        formats.transaction = {\n\t            hash: hash,\n\t            blockHash: Formatter.allowNull(hash, null),\n\t            blockNumber: Formatter.allowNull(number, null),\n\t            transactionIndex: Formatter.allowNull(number, null),\n\t            confirmations: Formatter.allowNull(number, null),\n\t            from: address,\n\t            gasPrice: bigNumber,\n\t            gasLimit: bigNumber,\n\t            to: Formatter.allowNull(address, null),\n\t            value: bigNumber,\n\t            nonce: number,\n\t            data: data,\n\t            r: Formatter.allowNull(this.uint256),\n\t            s: Formatter.allowNull(this.uint256),\n\t            v: Formatter.allowNull(number),\n\t            creates: Formatter.allowNull(address, null),\n\t            raw: Formatter.allowNull(data),\n\t        };\n\t        formats.transactionRequest = {\n\t            from: Formatter.allowNull(address),\n\t            nonce: Formatter.allowNull(number),\n\t            gasLimit: Formatter.allowNull(bigNumber),\n\t            gasPrice: Formatter.allowNull(bigNumber),\n\t            to: Formatter.allowNull(address),\n\t            value: Formatter.allowNull(bigNumber),\n\t            data: Formatter.allowNull(strictData),\n\t        };\n\t        formats.receiptLog = {\n\t            transactionIndex: number,\n\t            blockNumber: number,\n\t            transactionHash: hash,\n\t            address: address,\n\t            topics: Formatter.arrayOf(hash),\n\t            data: data,\n\t            logIndex: number,\n\t            blockHash: hash,\n\t        };\n\t        formats.receipt = {\n\t            to: Formatter.allowNull(this.address, null),\n\t            from: Formatter.allowNull(this.address, null),\n\t            contractAddress: Formatter.allowNull(address, null),\n\t            transactionIndex: number,\n\t            root: Formatter.allowNull(hash),\n\t            gasUsed: bigNumber,\n\t            logsBloom: Formatter.allowNull(data),\n\t            blockHash: hash,\n\t            transactionHash: hash,\n\t            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n\t            blockNumber: number,\n\t            confirmations: Formatter.allowNull(number, null),\n\t            cumulativeGasUsed: bigNumber,\n\t            status: Formatter.allowNull(number)\n\t        };\n\t        formats.block = {\n\t            hash: hash,\n\t            parentHash: hash,\n\t            number: number,\n\t            timestamp: number,\n\t            nonce: Formatter.allowNull(hex),\n\t            difficulty: this.difficulty.bind(this),\n\t            gasLimit: bigNumber,\n\t            gasUsed: bigNumber,\n\t            miner: address,\n\t            extraData: data,\n\t            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n\t        };\n\t        formats.blockWithTransactions = lib$3.shallowCopy(formats.block);\n\t        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n\t        formats.filter = {\n\t            fromBlock: Formatter.allowNull(blockTag, undefined),\n\t            toBlock: Formatter.allowNull(blockTag, undefined),\n\t            blockHash: Formatter.allowNull(hash, undefined),\n\t            address: Formatter.allowNull(address, undefined),\n\t            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n\t        };\n\t        formats.filterLog = {\n\t            blockNumber: Formatter.allowNull(number),\n\t            blockHash: Formatter.allowNull(hash),\n\t            transactionIndex: number,\n\t            removed: Formatter.allowNull(this.boolean.bind(this)),\n\t            address: address,\n\t            data: Formatter.allowFalsish(data, "0x"),\n\t            topics: Formatter.arrayOf(hash),\n\t            transactionHash: hash,\n\t            logIndex: number,\n\t        };\n\t        return formats;\n\t    };\n\t    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n\t    // Strict! Used on input.\n\t    Formatter.prototype.number = function (number) {\n\t        return lib$2.BigNumber.from(number).toNumber();\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.bigNumber = function (value) {\n\t        return lib$2.BigNumber.from(value);\n\t    };\n\t    // Requires a boolean, "true" or  "false"; returns a boolean\n\t    Formatter.prototype.boolean = function (value) {\n\t        if (typeof (value) === "boolean") {\n\t            return value;\n\t        }\n\t        if (typeof (value) === "string") {\n\t            value = value.toLowerCase();\n\t            if (value === "true") {\n\t                return true;\n\t            }\n\t            if (value === "false") {\n\t                return false;\n\t            }\n\t        }\n\t        throw new Error("invalid boolean - " + value);\n\t    };\n\t    Formatter.prototype.hex = function (value, strict) {\n\t        if (typeof (value) === "string") {\n\t            if (!strict && value.substring(0, 2) !== "0x") {\n\t                value = "0x" + value;\n\t            }\n\t            if (lib$1.isHexString(value)) {\n\t                return value.toLowerCase();\n\t            }\n\t        }\n\t        return logger.throwArgumentError("invalid hash", "value", value);\n\t    };\n\t    Formatter.prototype.data = function (value, strict) {\n\t        var result = this.hex(value, strict);\n\t        if ((result.length % 2) !== 0) {\n\t            throw new Error("invalid data; odd-length - " + value);\n\t        }\n\t        return result;\n\t    };\n\t    // Requires an address\n\t    // Strict! Used on input.\n\t    Formatter.prototype.address = function (value) {\n\t        return lib$6.getAddress(value);\n\t    };\n\t    Formatter.prototype.callAddress = function (value) {\n\t        if (!lib$1.isHexString(value, 32)) {\n\t            return null;\n\t        }\n\t        var address = lib$6.getAddress(lib$1.hexDataSlice(value, 12));\n\t        return (address === lib$7.AddressZero) ? null : address;\n\t    };\n\t    Formatter.prototype.contractAddress = function (value) {\n\t        return lib$6.getContractAddress(value);\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.blockTag = function (blockTag) {\n\t        if (blockTag == null) {\n\t            return "latest";\n\t        }\n\t        if (blockTag === "earliest") {\n\t            return "0x0";\n\t        }\n\t        if (blockTag === "latest" || blockTag === "pending") {\n\t            return blockTag;\n\t        }\n\t        if (typeof (blockTag) === "number" || lib$1.isHexString(blockTag)) {\n\t            return lib$1.hexValue(blockTag);\n\t        }\n\t        throw new Error("invalid blockTag");\n\t    };\n\t    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n\t    Formatter.prototype.hash = function (value, strict) {\n\t        var result = this.hex(value, strict);\n\t        if (lib$1.hexDataLength(result) !== 32) {\n\t            return logger.throwArgumentError("invalid hash", "value", value);\n\t        }\n\t        return result;\n\t    };\n\t    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n\t    Formatter.prototype.difficulty = function (value) {\n\t        if (value == null) {\n\t            return null;\n\t        }\n\t        var v = lib$2.BigNumber.from(value);\n\t        try {\n\t            return v.toNumber();\n\t        }\n\t        catch (error) { }\n\t        return null;\n\t    };\n\t    Formatter.prototype.uint256 = function (value) {\n\t        if (!lib$1.isHexString(value)) {\n\t            throw new Error("invalid uint256");\n\t        }\n\t        return lib$1.hexZeroPad(value, 32);\n\t    };\n\t    Formatter.prototype._block = function (value, format) {\n\t        if (value.author != null && value.miner == null) {\n\t            value.miner = value.author;\n\t        }\n\t        return Formatter.check(format, value);\n\t    };\n\t    Formatter.prototype.block = function (value) {\n\t        return this._block(value, this.formats.block);\n\t    };\n\t    Formatter.prototype.blockWithTransactions = function (value) {\n\t        return this._block(value, this.formats.blockWithTransactions);\n\t    };\n\t    // Strict! Used on input.\n\t    Formatter.prototype.transactionRequest = function (value) {\n\t        return Formatter.check(this.formats.transactionRequest, value);\n\t    };\n\t    Formatter.prototype.transactionResponse = function (transaction) {\n\t        // Rename gas to gasLimit\n\t        if (transaction.gas != null && transaction.gasLimit == null) {\n\t            transaction.gasLimit = transaction.gas;\n\t        }\n\t        // Some clients (TestRPC) do strange things like return 0x0 for the\n\t        // 0 address; correct this to be a real address\n\t        if (transaction.to && lib$2.BigNumber.from(transaction.to).isZero()) {\n\t            transaction.to = "0x0000000000000000000000000000000000000000";\n\t        }\n\t        // Rename input to data\n\t        if (transaction.input != null && transaction.data == null) {\n\t            transaction.data = transaction.input;\n\t        }\n\t        // If to and creates are empty, populate the creates from the transaction\n\t        if (transaction.to == null && transaction.creates == null) {\n\t            transaction.creates = this.contractAddress(transaction);\n\t        }\n\t        // @TODO: use transaction.serialize? Have to add support for including v, r, and s...\n\t        /*\n\t        if (!transaction.raw) {\n\t \n\t             // Very loose providers (e.g. TestRPC) do not provide a signature or raw\n\t             if (transaction.v && transaction.r && transaction.s) {\n\t                 let raw = [\n\t                     stripZeros(hexlify(transaction.nonce)),\n\t                     stripZeros(hexlify(transaction.gasPrice)),\n\t                     stripZeros(hexlify(transaction.gasLimit)),\n\t                     (transaction.to || "0x"),\n\t                     stripZeros(hexlify(transaction.value || "0x")),\n\t                     hexlify(transaction.data || "0x"),\n\t                     stripZeros(hexlify(transaction.v || "0x")),\n\t                     stripZeros(hexlify(transaction.r)),\n\t                     stripZeros(hexlify(transaction.s)),\n\t                 ];\n\t \n\t                 transaction.raw = rlpEncode(raw);\n\t             }\n\t         }\n\t         */\n\t        var result = Formatter.check(this.formats.transaction, transaction);\n\t        if (transaction.chainId != null) {\n\t            var chainId = transaction.chainId;\n\t            if (lib$1.isHexString(chainId)) {\n\t                chainId = lib$2.BigNumber.from(chainId).toNumber();\n\t            }\n\t            result.chainId = chainId;\n\t        }\n\t        else {\n\t            var chainId = transaction.networkId;\n\t            // geth-etc returns chainId\n\t            if (chainId == null && result.v == null) {\n\t                chainId = transaction.chainId;\n\t            }\n\t            if (lib$1.isHexString(chainId)) {\n\t                chainId = lib$2.BigNumber.from(chainId).toNumber();\n\t            }\n\t            if (typeof (chainId) !== "number" && result.v != null) {\n\t                chainId = (result.v - 35) / 2;\n\t                if (chainId < 0) {\n\t                    chainId = 0;\n\t                }\n\t                chainId = parseInt(chainId);\n\t            }\n\t            if (typeof (chainId) !== "number") {\n\t                chainId = 0;\n\t            }\n\t            result.chainId = chainId;\n\t        }\n\t        // 0x0000... should actually be null\n\t        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {\n\t            result.blockHash = null;\n\t        }\n\t        return result;\n\t    };\n\t    Formatter.prototype.transaction = function (value) {\n\t        return lib$g.parse(value);\n\t    };\n\t    Formatter.prototype.receiptLog = function (value) {\n\t        return Formatter.check(this.formats.receiptLog, value);\n\t    };\n\t    Formatter.prototype.receipt = function (value) {\n\t        var result = Formatter.check(this.formats.receipt, value);\n\t        if (value.status != null) {\n\t            result.byzantium = true;\n\t        }\n\t        return result;\n\t    };\n\t    Formatter.prototype.topics = function (value) {\n\t        var _this = this;\n\t        if (Array.isArray(value)) {\n\t            return value.map(function (v) { return _this.topics(v); });\n\t        }\n\t        else if (value != null) {\n\t            return this.hash(value, true);\n\t        }\n\t        return null;\n\t    };\n\t    Formatter.prototype.filter = function (value) {\n\t        return Formatter.check(this.formats.filter, value);\n\t    };\n\t    Formatter.prototype.filterLog = function (value) {\n\t        return Formatter.check(this.formats.filterLog, value);\n\t    };\n\t    Formatter.check = function (format, object) {\n\t        var result = {};\n\t        for (var key in format) {\n\t            try {\n\t                var value = format[key](object[key]);\n\t                if (value !== undefined) {\n\t                    result[key] = value;\n\t                }\n\t            }\n\t            catch (error) {\n\t                error.checkKey = key;\n\t                error.checkValue = object[key];\n\t                throw error;\n\t            }\n\t        }\n\t        return result;\n\t    };\n\t    // if value is null-ish, nullValue is returned\n\t    Formatter.allowNull = function (format, nullValue) {\n\t        return (function (value) {\n\t            if (value == null) {\n\t                return nullValue;\n\t            }\n\t            return format(value);\n\t        });\n\t    };\n\t    // If value is false-ish, replaceValue is returned\n\t    Formatter.allowFalsish = function (format, replaceValue) {\n\t        return (function (value) {\n\t            if (!value) {\n\t                return replaceValue;\n\t            }\n\t            return format(value);\n\t        });\n\t    };\n\t    // Requires an Array satisfying check\n\t    Formatter.arrayOf = function (format) {\n\t        return (function (array) {\n\t            if (!Array.isArray(array)) {\n\t                throw new Error("not an array");\n\t            }\n\t            var result = [];\n\t            array.forEach(function (value) {\n\t                result.push(format(value));\n\t            });\n\t            return result;\n\t        });\n\t    };\n\t    return Formatter;\n\t}());\n\texports.Formatter = Formatter;\n\t// Show the throttle message only once\n\tvar throttleMessage = false;\n\tfunction showThrottleMessage() {\n\t    if (throttleMessage) {\n\t        return;\n\t    }\n\t    throttleMessage = true;\n\t    console.log("========= NOTICE =========");\n\t    console.log("Request-Rate Exceeded  (this message will not be repeated)");\n\t    console.log("");\n\t    console.log("The default API keys for each service are provided as a highly-throttled,");\n\t    console.log("community resource for low-traffic projects and early prototyping.");\n\t    console.log("");\n\t    console.log("While your application will continue to function, we highly recommended");\n\t    console.log("signing up for your own API keys to improve performance, increase your");\n\t    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");\n\t    console.log("");\n\t    console.log("For more details: https:/\\/docs.ethers.io/api-keys/");\n\t    console.log("==========================");\n\t}\n\texports.showThrottleMessage = showThrottleMessage;\n\n\t});\n\n\tvar formatter$1 = unwrapExports(formatter);\n\tvar formatter_1 = formatter.Formatter;\n\tvar formatter_2 = formatter.showThrottleMessage;\n\n\tvar baseProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t//////////////////////////////\n\t// Event Serializeing\n\tfunction checkTopic(topic) {\n\t    if (topic == null) {\n\t        return "null";\n\t    }\n\t    if (lib$1.hexDataLength(topic) !== 32) {\n\t        logger.throwArgumentError("invalid topic", "topic", topic);\n\t    }\n\t    return topic.toLowerCase();\n\t}\n\tfunction serializeTopics(topics) {\n\t    // Remove trailing null AND-topics; they are redundant\n\t    topics = topics.slice();\n\t    while (topics.length > 0 && topics[topics.length - 1] == null) {\n\t        topics.pop();\n\t    }\n\t    return topics.map(function (topic) {\n\t        if (Array.isArray(topic)) {\n\t            // Only track unique OR-topics\n\t            var unique_1 = {};\n\t            topic.forEach(function (topic) {\n\t                unique_1[checkTopic(topic)] = true;\n\t            });\n\t            // The order of OR-topics does not matter\n\t            var sorted = Object.keys(unique_1);\n\t            sorted.sort();\n\t            return sorted.join("|");\n\t        }\n\t        else {\n\t            return checkTopic(topic);\n\t        }\n\t    }).join("&");\n\t}\n\tfunction deserializeTopics(data) {\n\t    if (data === "") {\n\t        return [];\n\t    }\n\t    return data.split(/&/g).map(function (topic) {\n\t        if (topic === "") {\n\t            return [];\n\t        }\n\t        var comps = topic.split("|").map(function (topic) {\n\t            return ((topic === "null") ? null : topic);\n\t        });\n\t        return ((comps.length === 1) ? comps[0] : comps);\n\t    });\n\t}\n\tfunction getEventTag(eventName) {\n\t    if (typeof (eventName) === "string") {\n\t        eventName = eventName.toLowerCase();\n\t        if (lib$1.hexDataLength(eventName) === 32) {\n\t            return "tx:" + eventName;\n\t        }\n\t        if (eventName.indexOf(":") === -1) {\n\t            return eventName;\n\t        }\n\t    }\n\t    else if (Array.isArray(eventName)) {\n\t        return "filter:*:" + serializeTopics(eventName);\n\t    }\n\t    else if (lib$b.ForkEvent.isForkEvent(eventName)) {\n\t        logger.warn("not implemented");\n\t        throw new Error("not implemented");\n\t    }\n\t    else if (eventName && typeof (eventName) === "object") {\n\t        return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);\n\t    }\n\t    throw new Error("invalid event - " + eventName);\n\t}\n\t//////////////////////////////\n\t// Helper Object\n\tfunction getTime() {\n\t    return (new Date()).getTime();\n\t}\n\tfunction stall(duration) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, duration);\n\t    });\n\t}\n\t//////////////////////////////\n\t// Provider Object\n\t/**\n\t *  EventType\n\t *   - "block"\n\t *   - "poll"\n\t *   - "didPoll"\n\t *   - "pending"\n\t *   - "error"\n\t *   - "network"\n\t *   - filter\n\t *   - topics array\n\t *   - transaction hash\n\t */\n\tvar PollableEvents = ["block", "network", "pending", "poll"];\n\tvar Event = /** @class */ (function () {\n\t    function Event(tag, listener, once) {\n\t        lib$3.defineReadOnly(this, "tag", tag);\n\t        lib$3.defineReadOnly(this, "listener", listener);\n\t        lib$3.defineReadOnly(this, "once", once);\n\t    }\n\t    Object.defineProperty(Event.prototype, "event", {\n\t        get: function () {\n\t            switch (this.type) {\n\t                case "tx":\n\t                    return this.hash;\n\t                case "filter":\n\t                    return this.filter;\n\t            }\n\t            return this.tag;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, "type", {\n\t        get: function () {\n\t            return this.tag.split(":")[0];\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, "hash", {\n\t        get: function () {\n\t            var comps = this.tag.split(":");\n\t            if (comps[0] !== "tx") {\n\t                return null;\n\t            }\n\t            return comps[1];\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(Event.prototype, "filter", {\n\t        get: function () {\n\t            var comps = this.tag.split(":");\n\t            if (comps[0] !== "filter") {\n\t                return null;\n\t            }\n\t            var address = comps[1];\n\t            var topics = deserializeTopics(comps[2]);\n\t            var filter = {};\n\t            if (topics.length > 0) {\n\t                filter.topics = topics;\n\t            }\n\t            if (address && address !== "*") {\n\t                filter.address = address;\n\t            }\n\t            return filter;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Event.prototype.pollable = function () {\n\t        return (this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n\t    };\n\t    return Event;\n\t}());\n\texports.Event = Event;\n\t;\n\t// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\n\tvar coinInfos = {\n\t    "0": { symbol: "btc", p2pkh: 0x00, p2sh: 0x05, prefix: "bc" },\n\t    "2": { symbol: "ltc", p2pkh: 0x30, p2sh: 0x32, prefix: "ltc" },\n\t    "3": { symbol: "doge", p2pkh: 0x1e, p2sh: 0x16 },\n\t    "60": { symbol: "eth", ilk: "eth" },\n\t    "61": { symbol: "etc", ilk: "eth" },\n\t    "700": { symbol: "xdai", ilk: "eth" },\n\t};\n\tfunction bytes32ify(value) {\n\t    return lib$1.hexZeroPad(lib$2.BigNumber.from(value).toHexString(), 32);\n\t}\n\t// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\n\tfunction base58Encode(data) {\n\t    return lib$e.Base58.encode(lib$1.concat([data, lib$1.hexDataSlice(browser.sha256(browser.sha256(data)), 0, 4)]));\n\t}\n\tvar Resolver = /** @class */ (function () {\n\t    function Resolver(provider, address, name) {\n\t        lib$3.defineReadOnly(this, "provider", provider);\n\t        lib$3.defineReadOnly(this, "name", name);\n\t        lib$3.defineReadOnly(this, "address", provider.formatter.address(address));\n\t    }\n\t    Resolver.prototype._fetchBytes = function (selector, parameters) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var transaction, result, offset, length;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        transaction = {\n\t                            to: this.address,\n\t                            data: lib$1.hexConcat([selector, lib$9.namehash(this.name), (parameters || "0x")])\n\t                        };\n\t                        return [4 /*yield*/, this.provider.call(transaction)];\n\t                    case 1:\n\t                        result = _a.sent();\n\t                        if (result === "0x") {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        offset = lib$2.BigNumber.from(lib$1.hexDataSlice(result, 0, 32)).toNumber();\n\t                        length = lib$2.BigNumber.from(lib$1.hexDataSlice(result, offset, offset + 32)).toNumber();\n\t                        return [2 /*return*/, lib$1.hexDataSlice(result, offset + 32, offset + 32 + length)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Resolver.prototype._getAddress = function (coinType, hexBytes) {\n\t        var coinInfo = coinInfos[String(coinType)];\n\t        if (coinInfo == null) {\n\t            logger.throwError("unsupported coin type: " + coinType, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "getAddress(" + coinType + ")"\n\t            });\n\t        }\n\t        if (coinInfo.ilk === "eth") {\n\t            return this.provider.formatter.address(hexBytes);\n\t        }\n\t        var bytes = lib$1.arrayify(hexBytes);\n\t        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n\t        if (coinInfo.p2pkh != null) {\n\t            var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n\t            if (p2pkh) {\n\t                var length_1 = parseInt(p2pkh[1], 16);\n\t                if (p2pkh[2].length === length_1 * 2 && length_1 >= 1 && length_1 <= 75) {\n\t                    return base58Encode(lib$1.concat([[coinInfo.p2pkh], ("0x" + p2pkh[2])]));\n\t                }\n\t            }\n\t        }\n\t        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n\t        if (coinInfo.p2sh != null) {\n\t            var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n\t            if (p2sh) {\n\t                var length_2 = parseInt(p2sh[1], 16);\n\t                if (p2sh[2].length === length_2 * 2 && length_2 >= 1 && length_2 <= 75) {\n\t                    return base58Encode(lib$1.concat([[coinInfo.p2sh], ("0x" + p2sh[2])]));\n\t                }\n\t            }\n\t        }\n\t        // Bech32\n\t        if (coinInfo.prefix != null) {\n\t            var length_3 = bytes[1];\n\t            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n\t            var version_1 = bytes[0];\n\t            if (version_1 === 0x00) {\n\t                if (length_3 !== 20 && length_3 !== 32) {\n\t                    version_1 = -1;\n\t                }\n\t            }\n\t            else {\n\t                version_1 = -1;\n\t            }\n\t            if (version_1 >= 0 && bytes.length === 2 + length_3 && length_3 >= 1 && length_3 <= 75) {\n\t                var words = bech32.toWords(bytes.slice(2));\n\t                words.unshift(version_1);\n\t                return bech32.encode(coinInfo.prefix, words);\n\t            }\n\t        }\n\t        return null;\n\t    };\n\t    Resolver.prototype.getAddress = function (coinType) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var transaction, hexBytes_1, hexBytes, address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (coinType == null) {\n\t                            coinType = 60;\n\t                        }\n\t                        if (!(coinType === 60)) return [3 /*break*/, 2];\n\t                        transaction = {\n\t                            to: this.address,\n\t                            data: ("0x3b3b57de" + lib$9.namehash(this.name).substring(2))\n\t                        };\n\t                        return [4 /*yield*/, this.provider.call(transaction)];\n\t                    case 1:\n\t                        hexBytes_1 = _a.sent();\n\t                        // No address\n\t                        if (hexBytes_1 === "0x" || hexBytes_1 === lib$7.HashZero) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, this.provider.formatter.callAddress(hexBytes_1)];\n\t                    case 2: return [4 /*yield*/, this._fetchBytes("0xf1cb7e06", bytes32ify(coinType))];\n\t                    case 3:\n\t                        hexBytes = _a.sent();\n\t                        // No address\n\t                        if (hexBytes == null || hexBytes === "0x") {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        address = this._getAddress(coinType, hexBytes);\n\t                        if (address == null) {\n\t                            logger.throwError("invalid or unsupported coin data", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: "getAddress(" + coinType + ")",\n\t                                coinType: coinType,\n\t                                data: hexBytes\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, address];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Resolver.prototype.getContentHash = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var hexBytes, ipfs, length_4, swarm;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this._fetchBytes("0xbc1c58d1")];\n\t                    case 1:\n\t                        hexBytes = _a.sent();\n\t                        // No contenthash\n\t                        if (hexBytes == null || hexBytes === "0x") {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n\t                        if (ipfs) {\n\t                            length_4 = parseInt(ipfs[3], 16);\n\t                            if (ipfs[4].length === length_4 * 2) {\n\t                                return [2 /*return*/, "ipfs:/\\/" + lib$e.Base58.encode("0x" + ipfs[1])];\n\t                            }\n\t                        }\n\t                        swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n\t                        if (swarm) {\n\t                            if (swarm[1].length === (32 * 2)) {\n\t                                return [2 /*return*/, "bzz:/\\/" + swarm[1]];\n\t                            }\n\t                        }\n\t                        return [2 /*return*/, logger.throwError("invalid or unsupported content hash data", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: "getContentHash()",\n\t                                data: hexBytes\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Resolver.prototype.getText = function (key) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var keyBytes, hexBytes;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        keyBytes = lib$8.toUtf8Bytes(key);\n\t                        // The nodehash consumes the first slot, so the string pointer targets\n\t                        // offset 64, with the length at offset 64 and data starting at offset 96\n\t                        keyBytes = lib$1.concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n\t                        // Pad to word-size (32 bytes)\n\t                        if ((keyBytes.length % 32) !== 0) {\n\t                            keyBytes = lib$1.concat([keyBytes, lib$1.hexZeroPad("0x", 32 - (key.length % 32))]);\n\t                        }\n\t                        return [4 /*yield*/, this._fetchBytes("0x59d1d43c", lib$1.hexlify(keyBytes))];\n\t                    case 1:\n\t                        hexBytes = _a.sent();\n\t                        if (hexBytes == null || hexBytes === "0x") {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, lib$8.toUtf8String(hexBytes)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return Resolver;\n\t}());\n\texports.Resolver = Resolver;\n\tvar defaultFormatter = null;\n\tvar nextPollId = 1;\n\tvar BaseProvider = /** @class */ (function (_super) {\n\t    __extends(BaseProvider, _super);\n\t    /**\n\t     *  ready\n\t     *\n\t     *  A Promise<Network> that resolves only once the provider is ready.\n\t     *\n\t     *  Sub-classes that call the super with a network without a chainId\n\t     *  MUST set this. Standard named networks have a known chainId.\n\t     *\n\t     */\n\t    function BaseProvider(network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, lib$b.Provider);\n\t        _this = _super.call(this) || this;\n\t        // Events being listened to\n\t        _this._events = [];\n\t        _this._emitted = { block: -2 };\n\t        _this.formatter = _newTarget.getFormatter();\n\t        // If network is any, this Provider allows the underlying\n\t        // network to change dynamically, and we auto-detect the\n\t        // current network\n\t        lib$3.defineReadOnly(_this, "anyNetwork", (network === "any"));\n\t        if (_this.anyNetwork) {\n\t            network = _this.detectNetwork();\n\t        }\n\t        if (network instanceof Promise) {\n\t            _this._networkPromise = network;\n\t            // Squash any "unhandled promise" errors; that do not need to be handled\n\t            network.catch(function (error) { });\n\t            // Trigger initial network setting (async)\n\t            _this._ready().catch(function (error) { });\n\t        }\n\t        else {\n\t            var knownNetwork = lib$3.getStatic((_newTarget), "getNetwork")(network);\n\t            if (knownNetwork) {\n\t                lib$3.defineReadOnly(_this, "_network", knownNetwork);\n\t                _this.emit("network", knownNetwork, null);\n\t            }\n\t            else {\n\t                logger.throwArgumentError("invalid network", "network", network);\n\t            }\n\t        }\n\t        _this._maxInternalBlockNumber = -1024;\n\t        _this._lastBlockNumber = -2;\n\t        _this._pollingInterval = 4000;\n\t        _this._fastQueryDate = 0;\n\t        return _this;\n\t    }\n\t    BaseProvider.prototype._ready = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, error_1;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(this._network == null)) return [3 /*break*/, 7];\n\t                        network = null;\n\t                        if (!this._networkPromise) return [3 /*break*/, 4];\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        _a.trys.push([1, 3, , 4]);\n\t                        return [4 /*yield*/, this._networkPromise];\n\t                    case 2:\n\t                        network = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 3:\n\t                        error_1 = _a.sent();\n\t                        return [3 /*break*/, 4];\n\t                    case 4:\n\t                        if (!(network == null)) return [3 /*break*/, 6];\n\t                        return [4 /*yield*/, this.detectNetwork()];\n\t                    case 5:\n\t                        network = _a.sent();\n\t                        _a.label = 6;\n\t                    case 6:\n\t                        // This should never happen; every Provider sub-class should have\n\t                        // suggested a network by here (or have thrown).\n\t                        if (!network) {\n\t                            logger.throwError("no network detected", lib.Logger.errors.UNKNOWN_ERROR, {});\n\t                        }\n\t                        // Possible this call stacked so do not call defineReadOnly again\n\t                        if (this._network == null) {\n\t                            if (this.anyNetwork) {\n\t                                this._network = network;\n\t                            }\n\t                            else {\n\t                                lib$3.defineReadOnly(this, "_network", network);\n\t                            }\n\t                            this.emit("network", network, null);\n\t                        }\n\t                        _a.label = 7;\n\t                    case 7: return [2 /*return*/, this._network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, "ready", {\n\t        // This will always return the most recently established network.\n\t        // For "any", this can change (a "network" event is emitted before\n\t        // any change is refelcted); otherwise this cannot change\n\t        get: function () {\n\t            var _this = this;\n\t            return lib$l.poll(function () {\n\t                return _this._ready().then(function (network) {\n\t                    return network;\n\t                }, function (error) {\n\t                    // If the network isn\'t running yet, we will wait\n\t                    if (error.code === lib.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {\n\t                        return undefined;\n\t                    }\n\t                    throw error;\n\t                });\n\t            });\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    // @TODO: Remove this and just create a singleton formatter\n\t    BaseProvider.getFormatter = function () {\n\t        if (defaultFormatter == null) {\n\t            defaultFormatter = new formatter.Formatter();\n\t        }\n\t        return defaultFormatter;\n\t    };\n\t    // @TODO: Remove this and just use getNetwork\n\t    BaseProvider.getNetwork = function (network) {\n\t        return lib$k.getNetwork((network == null) ? "homestead" : network);\n\t    };\n\t    // Fetches the blockNumber, but will reuse any result that is less\n\t    // than maxAge old or has been requested since the last request\n\t    BaseProvider.prototype._getInternalBlockNumber = function (maxAge) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var internalBlockNumber, result, reqTime, checkInternalBlockNumber;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this._ready()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        internalBlockNumber = this._internalBlockNumber;\n\t                        if (!(maxAge > 0 && this._internalBlockNumber)) return [3 /*break*/, 3];\n\t                        return [4 /*yield*/, internalBlockNumber];\n\t                    case 2:\n\t                        result = _a.sent();\n\t                        if ((getTime() - result.respTime) <= maxAge) {\n\t                            return [2 /*return*/, result.blockNumber];\n\t                        }\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        reqTime = getTime();\n\t                        checkInternalBlockNumber = lib$3.resolveProperties({\n\t                            blockNumber: this.perform("getBlockNumber", {}),\n\t                            networkError: this.getNetwork().then(function (network) { return (null); }, function (error) { return (error); })\n\t                        }).then(function (_a) {\n\t                            var blockNumber = _a.blockNumber, networkError = _a.networkError;\n\t                            if (networkError) {\n\t                                // Unremember this bad internal block number\n\t                                if (_this._internalBlockNumber === checkInternalBlockNumber) {\n\t                                    _this._internalBlockNumber = null;\n\t                                }\n\t                                throw networkError;\n\t                            }\n\t                            var respTime = getTime();\n\t                            blockNumber = lib$2.BigNumber.from(blockNumber).toNumber();\n\t                            if (blockNumber < _this._maxInternalBlockNumber) {\n\t                                blockNumber = _this._maxInternalBlockNumber;\n\t                            }\n\t                            _this._maxInternalBlockNumber = blockNumber;\n\t                            _this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n\t                            return { blockNumber: blockNumber, reqTime: reqTime, respTime: respTime };\n\t                        });\n\t                        this._internalBlockNumber = checkInternalBlockNumber;\n\t                        return [4 /*yield*/, checkInternalBlockNumber];\n\t                    case 4: return [2 /*return*/, (_a.sent()).blockNumber];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.poll = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var pollId, runners, blockNumber, i;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        pollId = nextPollId++;\n\t                        runners = [];\n\t                        return [4 /*yield*/, this._getInternalBlockNumber(100 + this.pollingInterval / 2)];\n\t                    case 1:\n\t                        blockNumber = _a.sent();\n\t                        this._setFastBlockNumber(blockNumber);\n\t                        // Emit a poll event after we have the latest (fast) block number\n\t                        this.emit("poll", pollId, blockNumber);\n\t                        // If the block has not changed, meh.\n\t                        if (blockNumber === this._lastBlockNumber) {\n\t                            this.emit("didPoll", pollId);\n\t                            return [2 /*return*/];\n\t                        }\n\t                        // First polling cycle, trigger a "block" events\n\t                        if (this._emitted.block === -2) {\n\t                            this._emitted.block = blockNumber - 1;\n\t                        }\n\t                        if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n\t                            logger.warn("network block skew detected; skipping block events");\n\t                            this.emit("error", logger.makeError("network block skew detected", lib.Logger.errors.NETWORK_ERROR, {\n\t                                blockNumber: blockNumber,\n\t                                event: "blockSkew",\n\t                                previousBlockNumber: this._emitted.block\n\t                            }));\n\t                            this.emit("block", blockNumber);\n\t                        }\n\t                        else {\n\t                            // Notify all listener for each block that has passed\n\t                            for (i = this._emitted.block + 1; i <= blockNumber; i++) {\n\t                                this.emit("block", i);\n\t                            }\n\t                        }\n\t                        // The emitted block was updated, check for obsolete events\n\t                        if (this._emitted.block !== blockNumber) {\n\t                            this._emitted.block = blockNumber;\n\t                            Object.keys(this._emitted).forEach(function (key) {\n\t                                // The block event does not expire\n\t                                if (key === "block") {\n\t                                    return;\n\t                                }\n\t                                // The block we were at when we emitted this event\n\t                                var eventBlockNumber = _this._emitted[key];\n\t                                // We cannot garbage collect pending transactions or blocks here\n\t                                // They should be garbage collected by the Provider when setting\n\t                                // "pending" events\n\t                                if (eventBlockNumber === "pending") {\n\t                                    return;\n\t                                }\n\t                                // Evict any transaction hashes or block hashes over 12 blocks\n\t                                // old, since they should not return null anyways\n\t                                if (blockNumber - eventBlockNumber > 12) {\n\t                                    delete _this._emitted[key];\n\t                                }\n\t                            });\n\t                        }\n\t                        // First polling cycle\n\t                        if (this._lastBlockNumber === -2) {\n\t                            this._lastBlockNumber = blockNumber - 1;\n\t                        }\n\t                        // Find all transaction hashes we are waiting on\n\t                        this._events.forEach(function (event) {\n\t                            switch (event.type) {\n\t                                case "tx": {\n\t                                    var hash_2 = event.hash;\n\t                                    var runner = _this.getTransactionReceipt(hash_2).then(function (receipt) {\n\t                                        if (!receipt || receipt.blockNumber == null) {\n\t                                            return null;\n\t                                        }\n\t                                        _this._emitted["t:" + hash_2] = receipt.blockNumber;\n\t                                        _this.emit(hash_2, receipt);\n\t                                        return null;\n\t                                    }).catch(function (error) { _this.emit("error", error); });\n\t                                    runners.push(runner);\n\t                                    break;\n\t                                }\n\t                                case "filter": {\n\t                                    var filter_1 = event.filter;\n\t                                    filter_1.fromBlock = _this._lastBlockNumber + 1;\n\t                                    filter_1.toBlock = blockNumber;\n\t                                    var runner = _this.getLogs(filter_1).then(function (logs) {\n\t                                        if (logs.length === 0) {\n\t                                            return;\n\t                                        }\n\t                                        logs.forEach(function (log) {\n\t                                            _this._emitted["b:" + log.blockHash] = log.blockNumber;\n\t                                            _this._emitted["t:" + log.transactionHash] = log.blockNumber;\n\t                                            _this.emit(filter_1, log);\n\t                                        });\n\t                                    }).catch(function (error) { _this.emit("error", error); });\n\t                                    runners.push(runner);\n\t                                    break;\n\t                                }\n\t                            }\n\t                        });\n\t                        this._lastBlockNumber = blockNumber;\n\t                        // Once all events for this loop have been processed, emit "didPoll"\n\t                        Promise.all(runners).then(function () {\n\t                            _this.emit("didPoll", pollId);\n\t                        });\n\t                        return [2 /*return*/, null];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // Deprecated; do not use this\n\t    BaseProvider.prototype.resetEventsBlock = function (blockNumber) {\n\t        this._lastBlockNumber = blockNumber - 1;\n\t        if (this.polling) {\n\t            this.poll();\n\t        }\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, "network", {\n\t        get: function () {\n\t            return this._network;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    // This method should query the network if the underlying network\n\t    // can change, such as when connected to a JSON-RPC backend\n\t    BaseProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, logger.throwError("provider does not support network detection", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                        operation: "provider.detectNetwork"\n\t                    })];\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, currentNetwork, error;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this._ready()];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        return [4 /*yield*/, this.detectNetwork()];\n\t                    case 2:\n\t                        currentNetwork = _a.sent();\n\t                        if (!(network.chainId !== currentNetwork.chainId)) return [3 /*break*/, 5];\n\t                        if (!this.anyNetwork) return [3 /*break*/, 4];\n\t                        this._network = currentNetwork;\n\t                        // Reset all internal block number guards and caches\n\t                        this._lastBlockNumber = -2;\n\t                        this._fastBlockNumber = null;\n\t                        this._fastBlockNumberPromise = null;\n\t                        this._fastQueryDate = 0;\n\t                        this._emitted.block = -2;\n\t                        this._maxInternalBlockNumber = -1024;\n\t                        this._internalBlockNumber = null;\n\t                        // The "network" event MUST happen before this method resolves\n\t                        // so any events have a chance to unregister, so we stall an\n\t                        // additional event loop before returning from /this/ call\n\t                        this.emit("network", currentNetwork, network);\n\t                        return [4 /*yield*/, stall(0)];\n\t                    case 3:\n\t                        _a.sent();\n\t                        return [2 /*return*/, this._network];\n\t                    case 4:\n\t                        error = logger.makeError("underlying network changed", lib.Logger.errors.NETWORK_ERROR, {\n\t                            event: "changed",\n\t                            network: network,\n\t                            detectedNetwork: currentNetwork\n\t                        });\n\t                        this.emit("error", error);\n\t                        throw error;\n\t                    case 5: return [2 /*return*/, network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(BaseProvider.prototype, "blockNumber", {\n\t        get: function () {\n\t            var _this = this;\n\t            this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function (blockNumber) {\n\t                _this._setFastBlockNumber(blockNumber);\n\t            });\n\t            return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(BaseProvider.prototype, "polling", {\n\t        get: function () {\n\t            return (this._poller != null);\n\t        },\n\t        set: function (value) {\n\t            var _this = this;\n\t            if (value && !this._poller) {\n\t                this._poller = setInterval(this.poll.bind(this), this.pollingInterval);\n\t                if (!this._bootstrapPoll) {\n\t                    this._bootstrapPoll = setTimeout(function () {\n\t                        _this.poll();\n\t                        // We block additional polls until the polling interval\n\t                        // is done, to prevent overwhelming the poll function\n\t                        _this._bootstrapPoll = setTimeout(function () {\n\t                            // If polling was disabled, something may require a poke\n\t                            // since starting the bootstrap poll and it was disabled\n\t                            if (!_this._poller) {\n\t                                _this.poll();\n\t                            }\n\t                            // Clear out the bootstrap so we can do another\n\t                            _this._bootstrapPoll = null;\n\t                        }, _this.pollingInterval);\n\t                    }, 0);\n\t                }\n\t            }\n\t            else if (!value && this._poller) {\n\t                clearInterval(this._poller);\n\t                this._poller = null;\n\t            }\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    Object.defineProperty(BaseProvider.prototype, "pollingInterval", {\n\t        get: function () {\n\t            return this._pollingInterval;\n\t        },\n\t        set: function (value) {\n\t            var _this = this;\n\t            if (typeof (value) !== "number" || value <= 0 || parseInt(String(value)) != value) {\n\t                throw new Error("invalid polling interval");\n\t            }\n\t            this._pollingInterval = value;\n\t            if (this._poller) {\n\t                clearInterval(this._poller);\n\t                this._poller = setInterval(function () { _this.poll(); }, this._pollingInterval);\n\t            }\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    BaseProvider.prototype._getFastBlockNumber = function () {\n\t        var _this = this;\n\t        var now = getTime();\n\t        // Stale block number, request a newer value\n\t        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n\t            this._fastQueryDate = now;\n\t            this._fastBlockNumberPromise = this.getBlockNumber().then(function (blockNumber) {\n\t                if (_this._fastBlockNumber == null || blockNumber > _this._fastBlockNumber) {\n\t                    _this._fastBlockNumber = blockNumber;\n\t                }\n\t                return _this._fastBlockNumber;\n\t            });\n\t        }\n\t        return this._fastBlockNumberPromise;\n\t    };\n\t    BaseProvider.prototype._setFastBlockNumber = function (blockNumber) {\n\t        // Older block, maybe a stale request\n\t        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n\t            return;\n\t        }\n\t        // Update the time we updated the blocknumber\n\t        this._fastQueryDate = getTime();\n\t        // Newer block number, use  it\n\t        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n\t            this._fastBlockNumber = blockNumber;\n\t            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n\t        }\n\t    };\n\t    BaseProvider.prototype.waitForTransaction = function (transactionHash, confirmations, timeout) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var receipt;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (confirmations == null) {\n\t                            confirmations = 1;\n\t                        }\n\t                        return [4 /*yield*/, this.getTransactionReceipt(transactionHash)];\n\t                    case 1:\n\t                        receipt = _a.sent();\n\t                        // Receipt is already good\n\t                        if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n\t                            return [2 /*return*/, receipt];\n\t                        }\n\t                        // Poll until the receipt is good...\n\t                        return [2 /*return*/, new Promise(function (resolve, reject) {\n\t                                var timer = null;\n\t                                var done = false;\n\t                                var handler = function (receipt) {\n\t                                    if (receipt.confirmations < confirmations) {\n\t                                        return;\n\t                                    }\n\t                                    if (timer) {\n\t                                        clearTimeout(timer);\n\t                                    }\n\t                                    if (done) {\n\t                                        return;\n\t                                    }\n\t                                    done = true;\n\t                                    _this.removeListener(transactionHash, handler);\n\t                                    resolve(receipt);\n\t                                };\n\t                                _this.on(transactionHash, handler);\n\t                                if (typeof (timeout) === "number" && timeout > 0) {\n\t                                    timer = setTimeout(function () {\n\t                                        if (done) {\n\t                                            return;\n\t                                        }\n\t                                        timer = null;\n\t                                        done = true;\n\t                                        _this.removeListener(transactionHash, handler);\n\t                                        reject(logger.makeError("timeout exceeded", lib.Logger.errors.TIMEOUT, { timeout: timeout }));\n\t                                    }, timeout);\n\t                                    if (timer.unref) {\n\t                                        timer.unref();\n\t                                    }\n\t                                }\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBlockNumber = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this._getInternalBlockNumber(0)];\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getGasPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform("getGasPrice", {})];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBalance = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform("getBalance", params)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getTransactionCount = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform("getTransactionCount", params)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()]).toNumber()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getCode = function (addressOrName, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _b.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _b.sent();\n\t                        _a = lib$1.hexlify;\n\t                        return [4 /*yield*/, this.perform("getCode", params)];\n\t                    case 3: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getStorageAt = function (addressOrName, position, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _b.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                address: this._getAddress(addressOrName),\n\t                                blockTag: this._getBlockTag(blockTag),\n\t                                position: Promise.resolve(position).then(function (p) { return lib$1.hexValue(p); })\n\t                            })];\n\t                    case 2:\n\t                        params = _b.sent();\n\t                        _a = lib$1.hexlify;\n\t                        return [4 /*yield*/, this.perform("getStorageAt", params)];\n\t                    case 3: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // This should be called by any subclass wrapping a TransactionResponse\n\t    BaseProvider.prototype._wrapTransaction = function (tx, hash) {\n\t        var _this = this;\n\t        if (hash != null && lib$1.hexDataLength(hash) !== 32) {\n\t            throw new Error("invalid response - sendTransaction");\n\t        }\n\t        var result = tx;\n\t        // Check the hash we expect is the same as the hash the server reported\n\t        if (hash != null && tx.hash !== hash) {\n\t            logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", lib.Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n\t        }\n\t        // @TODO: (confirmations? number, timeout? number)\n\t        result.wait = function (confirmations) { return __awaiter(_this, void 0, void 0, function () {\n\t            var receipt;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        // We know this transaction *must* exist (whether it gets mined is\n\t                        // another story), so setting an emitted value forces us to\n\t                        // wait even if the node returns null for the receipt\n\t                        if (confirmations !== 0) {\n\t                            this._emitted["t:" + tx.hash] = "pending";\n\t                        }\n\t                        return [4 /*yield*/, this.waitForTransaction(tx.hash, confirmations)];\n\t                    case 1:\n\t                        receipt = _a.sent();\n\t                        if (receipt == null && confirmations === 0) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        // No longer pending, allow the polling loop to garbage collect this\n\t                        this._emitted["t:" + tx.hash] = receipt.blockNumber;\n\t                        if (receipt.status === 0) {\n\t                            logger.throwError("transaction failed", lib.Logger.errors.CALL_EXCEPTION, {\n\t                                transactionHash: tx.hash,\n\t                                transaction: tx,\n\t                                receipt: receipt\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, receipt];\n\t                }\n\t            });\n\t        }); };\n\t        return result;\n\t    };\n\t    BaseProvider.prototype.sendTransaction = function (signedTransaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var hexTx, tx, hash, error_2;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, Promise.resolve(signedTransaction).then(function (t) { return lib$1.hexlify(t); })];\n\t                    case 2:\n\t                        hexTx = _a.sent();\n\t                        tx = this.formatter.transaction(signedTransaction);\n\t                        _a.label = 3;\n\t                    case 3:\n\t                        _a.trys.push([3, 5, , 6]);\n\t                        return [4 /*yield*/, this.perform("sendTransaction", { signedTransaction: hexTx })];\n\t                    case 4:\n\t                        hash = _a.sent();\n\t                        return [2 /*return*/, this._wrapTransaction(tx, hash)];\n\t                    case 5:\n\t                        error_2 = _a.sent();\n\t                        error_2.transaction = tx;\n\t                        error_2.transactionHash = tx.hash;\n\t                        throw error_2;\n\t                    case 6: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getTransactionRequest = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var values, tx, _a, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, transaction];\n\t                    case 1:\n\t                        values = _c.sent();\n\t                        tx = {};\n\t                        ["from", "to"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? _this._getAddress(v) : null); });\n\t                        });\n\t                        ["gasLimit", "gasPrice", "value"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? lib$2.BigNumber.from(v) : null); });\n\t                        });\n\t                        ["data"].forEach(function (key) {\n\t                            if (values[key] == null) {\n\t                                return;\n\t                            }\n\t                            tx[key] = Promise.resolve(values[key]).then(function (v) { return (v ? lib$1.hexlify(v) : null); });\n\t                        });\n\t                        _b = (_a = this.formatter).transactionRequest;\n\t                        return [4 /*yield*/, lib$3.resolveProperties(tx)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getFilter = function (filter) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var result, _a, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, filter];\n\t                    case 1:\n\t                        filter = _c.sent();\n\t                        result = {};\n\t                        if (filter.address != null) {\n\t                            result.address = this._getAddress(filter.address);\n\t                        }\n\t                        ["blockHash", "topics"].forEach(function (key) {\n\t                            if (filter[key] == null) {\n\t                                return;\n\t                            }\n\t                            result[key] = filter[key];\n\t                        });\n\t                        ["fromBlock", "toBlock"].forEach(function (key) {\n\t                            if (filter[key] == null) {\n\t                                return;\n\t                            }\n\t                            result[key] = _this._getBlockTag(filter[key]);\n\t                        });\n\t                        _b = (_a = this.formatter).filter;\n\t                        return [4 /*yield*/, lib$3.resolveProperties(result)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.call = function (transaction, blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _b.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                transaction: this._getTransactionRequest(transaction),\n\t                                blockTag: this._getBlockTag(blockTag)\n\t                            })];\n\t                    case 2:\n\t                        params = _b.sent();\n\t                        _a = lib$1.hexlify;\n\t                        return [4 /*yield*/, this.perform("call", params)];\n\t                    case 3: return [2 /*return*/, _a.apply(void 0, [_b.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.estimateGas = function (transaction) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _c.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({\n\t                                transaction: this._getTransactionRequest(transaction)\n\t                            })];\n\t                    case 2:\n\t                        params = _c.sent();\n\t                        _b = (_a = lib$2.BigNumber).from;\n\t                        return [4 /*yield*/, this.perform("estimateGas", params)];\n\t                    case 3: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getAddress = function (addressOrName) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.resolveName(addressOrName)];\n\t                    case 1:\n\t                        address = _a.sent();\n\t                        if (address == null) {\n\t                            logger.throwError("ENS name not configured", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                                operation: "resolveName(" + JSON.stringify(addressOrName) + ")"\n\t                            });\n\t                        }\n\t                        return [2 /*return*/, address];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getBlock = function (blockHashOrBlockTag, includeTransactions) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockNumber, params, _a, _b, _c, error_3;\n\t            var _this = this;\n\t            return __generator(this, function (_d) {\n\t                switch (_d.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _d.sent();\n\t                        return [4 /*yield*/, blockHashOrBlockTag];\n\t                    case 2:\n\t                        blockHashOrBlockTag = _d.sent();\n\t                        blockNumber = -128;\n\t                        params = {\n\t                            includeTransactions: !!includeTransactions\n\t                        };\n\t                        if (!lib$1.isHexString(blockHashOrBlockTag, 32)) return [3 /*break*/, 3];\n\t                        params.blockHash = blockHashOrBlockTag;\n\t                        return [3 /*break*/, 6];\n\t                    case 3:\n\t                        _d.trys.push([3, 5, , 6]);\n\t                        _a = params;\n\t                        _c = (_b = this.formatter).blockTag;\n\t                        return [4 /*yield*/, this._getBlockTag(blockHashOrBlockTag)];\n\t                    case 4:\n\t                        _a.blockTag = _c.apply(_b, [_d.sent()]);\n\t                        if (lib$1.isHexString(params.blockTag)) {\n\t                            blockNumber = parseInt(params.blockTag.substring(2), 16);\n\t                        }\n\t                        return [3 /*break*/, 6];\n\t                    case 5:\n\t                        error_3 = _d.sent();\n\t                        logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);\n\t                        return [3 /*break*/, 6];\n\t                    case 6: return [2 /*return*/, lib$l.poll(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                            var block, blockNumber_1, i, tx, confirmations;\n\t                            return __generator(this, function (_a) {\n\t                                switch (_a.label) {\n\t                                    case 0: return [4 /*yield*/, this.perform("getBlock", params)];\n\t                                    case 1:\n\t                                        block = _a.sent();\n\t                                        // Block was not found\n\t                                        if (block == null) {\n\t                                            // For blockhashes, if we didn\'t say it existed, that blockhash may\n\t                                            // not exist. If we did see it though, perhaps from a log, we know\n\t                                            // it exists, and this node is just not caught up yet.\n\t                                            if (params.blockHash != null) {\n\t                                                if (this._emitted["b:" + params.blockHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                            }\n\t                                            // For block tags, if we are asking for a future block, we return null\n\t                                            if (params.blockTag != null) {\n\t                                                if (blockNumber > this._emitted.block) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                            }\n\t                                            // Retry on the next block\n\t                                            return [2 /*return*/, undefined];\n\t                                        }\n\t                                        if (!includeTransactions) return [3 /*break*/, 8];\n\t                                        blockNumber_1 = null;\n\t                                        i = 0;\n\t                                        _a.label = 2;\n\t                                    case 2:\n\t                                        if (!(i < block.transactions.length)) return [3 /*break*/, 7];\n\t                                        tx = block.transactions[i];\n\t                                        if (!(tx.blockNumber == null)) return [3 /*break*/, 3];\n\t                                        tx.confirmations = 0;\n\t                                        return [3 /*break*/, 6];\n\t                                    case 3:\n\t                                        if (!(tx.confirmations == null)) return [3 /*break*/, 6];\n\t                                        if (!(blockNumber_1 == null)) return [3 /*break*/, 5];\n\t                                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                    case 4:\n\t                                        blockNumber_1 = _a.sent();\n\t                                        _a.label = 5;\n\t                                    case 5:\n\t                                        confirmations = (blockNumber_1 - tx.blockNumber) + 1;\n\t                                        if (confirmations <= 0) {\n\t                                            confirmations = 1;\n\t                                        }\n\t                                        tx.confirmations = confirmations;\n\t                                        _a.label = 6;\n\t                                    case 6:\n\t                                        i++;\n\t                                        return [3 /*break*/, 2];\n\t                                    case 7: return [2 /*return*/, this.formatter.blockWithTransactions(block)];\n\t                                    case 8: return [2 /*return*/, this.formatter.block(block)];\n\t                                }\n\t                            });\n\t                        }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getBlock = function (blockHashOrBlockTag) {\n\t        return (this._getBlock(blockHashOrBlockTag, false));\n\t    };\n\t    BaseProvider.prototype.getBlockWithTransactions = function (blockHashOrBlockTag) {\n\t        return (this._getBlock(blockHashOrBlockTag, true));\n\t    };\n\t    BaseProvider.prototype.getTransaction = function (transactionHash) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, transactionHash];\n\t                    case 2:\n\t                        transactionHash = _a.sent();\n\t                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\t                        return [2 /*return*/, lib$l.poll(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                                var result, tx, blockNumber, confirmations;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0: return [4 /*yield*/, this.perform("getTransaction", params)];\n\t                                        case 1:\n\t                                            result = _a.sent();\n\t                                            if (result == null) {\n\t                                                if (this._emitted["t:" + transactionHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            tx = this.formatter.transactionResponse(result);\n\t                                            if (!(tx.blockNumber == null)) return [3 /*break*/, 2];\n\t                                            tx.confirmations = 0;\n\t                                            return [3 /*break*/, 4];\n\t                                        case 2:\n\t                                            if (!(tx.confirmations == null)) return [3 /*break*/, 4];\n\t                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                        case 3:\n\t                                            blockNumber = _a.sent();\n\t                                            confirmations = (blockNumber - tx.blockNumber) + 1;\n\t                                            if (confirmations <= 0) {\n\t                                                confirmations = 1;\n\t                                            }\n\t                                            tx.confirmations = confirmations;\n\t                                            _a.label = 4;\n\t                                        case 4: return [2 /*return*/, this._wrapTransaction(tx)];\n\t                                    }\n\t                                });\n\t                            }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getTransactionReceipt = function (transactionHash) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, transactionHash];\n\t                    case 2:\n\t                        transactionHash = _a.sent();\n\t                        params = { transactionHash: this.formatter.hash(transactionHash, true) };\n\t                        return [2 /*return*/, lib$l.poll(function () { return __awaiter(_this, void 0, void 0, function () {\n\t                                var result, receipt, blockNumber, confirmations;\n\t                                return __generator(this, function (_a) {\n\t                                    switch (_a.label) {\n\t                                        case 0: return [4 /*yield*/, this.perform("getTransactionReceipt", params)];\n\t                                        case 1:\n\t                                            result = _a.sent();\n\t                                            if (result == null) {\n\t                                                if (this._emitted["t:" + transactionHash] == null) {\n\t                                                    return [2 /*return*/, null];\n\t                                                }\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            // "geth-etc" returns receipts before they are ready\n\t                                            if (result.blockHash == null) {\n\t                                                return [2 /*return*/, undefined];\n\t                                            }\n\t                                            receipt = this.formatter.receipt(result);\n\t                                            if (!(receipt.blockNumber == null)) return [3 /*break*/, 2];\n\t                                            receipt.confirmations = 0;\n\t                                            return [3 /*break*/, 4];\n\t                                        case 2:\n\t                                            if (!(receipt.confirmations == null)) return [3 /*break*/, 4];\n\t                                            return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                                        case 3:\n\t                                            blockNumber = _a.sent();\n\t                                            confirmations = (blockNumber - receipt.blockNumber) + 1;\n\t                                            if (confirmations <= 0) {\n\t                                                confirmations = 1;\n\t                                            }\n\t                                            receipt.confirmations = confirmations;\n\t                                            _a.label = 4;\n\t                                        case 4: return [2 /*return*/, receipt];\n\t                                    }\n\t                                });\n\t                            }); }, { oncePoll: this })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getLogs = function (filter) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var params, logs;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [4 /*yield*/, lib$3.resolveProperties({ filter: this._getFilter(filter) })];\n\t                    case 2:\n\t                        params = _a.sent();\n\t                        return [4 /*yield*/, this.perform("getLogs", params)];\n\t                    case 3:\n\t                        logs = _a.sent();\n\t                        logs.forEach(function (log) {\n\t                            if (log.removed == null) {\n\t                                log.removed = false;\n\t                            }\n\t                        });\n\t                        return [2 /*return*/, formatter.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getEtherPrice = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        _a.sent();\n\t                        return [2 /*return*/, this.perform("getEtherPrice", {})];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getBlockTag = function (blockTag) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var blockNumber;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, blockTag];\n\t                    case 1:\n\t                        blockTag = _a.sent();\n\t                        if (!(typeof (blockTag) === "number" && blockTag < 0)) return [3 /*break*/, 3];\n\t                        if (blockTag % 1) {\n\t                            logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);\n\t                        }\n\t                        return [4 /*yield*/, this._getInternalBlockNumber(100 + 2 * this.pollingInterval)];\n\t                    case 2:\n\t                        blockNumber = _a.sent();\n\t                        blockNumber += blockTag;\n\t                        if (blockNumber < 0) {\n\t                            blockNumber = 0;\n\t                        }\n\t                        return [2 /*return*/, this.formatter.blockTag(blockNumber)];\n\t                    case 3: return [2 /*return*/, this.formatter.blockTag(blockTag)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.getResolver = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var address;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, this._getResolver(name)];\n\t                    case 1:\n\t                        address = _a.sent();\n\t                        if (address == null) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, new Resolver(this, address, name)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype._getResolver = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network, transaction, _a, _b;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0: return [4 /*yield*/, this.getNetwork()];\n\t                    case 1:\n\t                        network = _c.sent();\n\t                        // No ENS...\n\t                        if (!network.ensAddress) {\n\t                            logger.throwError("network does not support ENS", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });\n\t                        }\n\t                        transaction = {\n\t                            to: network.ensAddress,\n\t                            data: ("0x0178b8bf" + lib$9.namehash(name).substring(2))\n\t                        };\n\t                        _b = (_a = this.formatter).callAddress;\n\t                        return [4 /*yield*/, this.call(transaction)];\n\t                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.resolveName = function (name) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var resolver;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, name];\n\t                    case 1:\n\t                        name = _a.sent();\n\t                        // If it is already an address, nothing to resolve\n\t                        try {\n\t                            return [2 /*return*/, Promise.resolve(this.formatter.address(name))];\n\t                        }\n\t                        catch (error) {\n\t                            // If is is a hexstring, the address is bad (See #694)\n\t                            if (lib$1.isHexString(name)) {\n\t                                throw error;\n\t                            }\n\t                        }\n\t                        if (typeof (name) !== "string") {\n\t                            logger.throwArgumentError("invalid ENS name", "name", name);\n\t                        }\n\t                        return [4 /*yield*/, this.getResolver(name)];\n\t                    case 2:\n\t                        resolver = _a.sent();\n\t                        if (!resolver) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [4 /*yield*/, resolver.getAddress()];\n\t                    case 3: return [2 /*return*/, _a.sent()];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.lookupAddress = function (address) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var reverseName, resolverAddress, bytes, _a, length, name, addr;\n\t            return __generator(this, function (_b) {\n\t                switch (_b.label) {\n\t                    case 0: return [4 /*yield*/, address];\n\t                    case 1:\n\t                        address = _b.sent();\n\t                        address = this.formatter.address(address);\n\t                        reverseName = address.substring(2).toLowerCase() + ".addr.reverse";\n\t                        return [4 /*yield*/, this._getResolver(reverseName)];\n\t                    case 2:\n\t                        resolverAddress = _b.sent();\n\t                        if (!resolverAddress) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        _a = lib$1.arrayify;\n\t                        return [4 /*yield*/, this.call({\n\t                                to: resolverAddress,\n\t                                data: ("0x691f3431" + lib$9.namehash(reverseName).substring(2))\n\t                            })];\n\t                    case 3:\n\t                        bytes = _a.apply(void 0, [_b.sent()]);\n\t                        // Strip off the dynamic string pointer (0x20)\n\t                        if (bytes.length < 32 || !lib$2.BigNumber.from(bytes.slice(0, 32)).eq(32)) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        bytes = bytes.slice(32);\n\t                        // Not a length-prefixed string\n\t                        if (bytes.length < 32) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        length = lib$2.BigNumber.from(bytes.slice(0, 32)).toNumber();\n\t                        bytes = bytes.slice(32);\n\t                        // Length longer than available data\n\t                        if (length > bytes.length) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        name = lib$8.toUtf8String(bytes.slice(0, length));\n\t                        return [4 /*yield*/, this.resolveName(name)];\n\t                    case 4:\n\t                        addr = _b.sent();\n\t                        if (addr != address) {\n\t                            return [2 /*return*/, null];\n\t                        }\n\t                        return [2 /*return*/, name];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    BaseProvider.prototype.perform = function (method, params) {\n\t        return logger.throwError(method + " not implemented", lib.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n\t    };\n\t    BaseProvider.prototype._startEvent = function (event) {\n\t        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n\t    };\n\t    BaseProvider.prototype._stopEvent = function (event) {\n\t        this.polling = (this._events.filter(function (e) { return e.pollable(); }).length > 0);\n\t    };\n\t    BaseProvider.prototype._addEventListener = function (eventName, listener, once) {\n\t        var event = new Event(getEventTag(eventName), listener, once);\n\t        this._events.push(event);\n\t        this._startEvent(event);\n\t        return this;\n\t    };\n\t    BaseProvider.prototype.on = function (eventName, listener) {\n\t        return this._addEventListener(eventName, listener, false);\n\t    };\n\t    BaseProvider.prototype.once = function (eventName, listener) {\n\t        return this._addEventListener(eventName, listener, true);\n\t    };\n\t    BaseProvider.prototype.emit = function (eventName) {\n\t        var _this = this;\n\t        var args = [];\n\t        for (var _i = 1; _i < arguments.length; _i++) {\n\t            args[_i - 1] = arguments[_i];\n\t        }\n\t        var result = false;\n\t        var stopped = [];\n\t        var eventTag = getEventTag(eventName);\n\t        this._events = this._events.filter(function (event) {\n\t            if (event.tag !== eventTag) {\n\t                return true;\n\t            }\n\t            setTimeout(function () {\n\t                event.listener.apply(_this, args);\n\t            }, 0);\n\t            result = true;\n\t            if (event.once) {\n\t                stopped.push(event);\n\t                return false;\n\t            }\n\t            return true;\n\t        });\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return result;\n\t    };\n\t    BaseProvider.prototype.listenerCount = function (eventName) {\n\t        if (!eventName) {\n\t            return this._events.length;\n\t        }\n\t        var eventTag = getEventTag(eventName);\n\t        return this._events.filter(function (event) {\n\t            return (event.tag === eventTag);\n\t        }).length;\n\t    };\n\t    BaseProvider.prototype.listeners = function (eventName) {\n\t        if (eventName == null) {\n\t            return this._events.map(function (event) { return event.listener; });\n\t        }\n\t        var eventTag = getEventTag(eventName);\n\t        return this._events\n\t            .filter(function (event) { return (event.tag === eventTag); })\n\t            .map(function (event) { return event.listener; });\n\t    };\n\t    BaseProvider.prototype.off = function (eventName, listener) {\n\t        var _this = this;\n\t        if (listener == null) {\n\t            return this.removeAllListeners(eventName);\n\t        }\n\t        var stopped = [];\n\t        var found = false;\n\t        var eventTag = getEventTag(eventName);\n\t        this._events = this._events.filter(function (event) {\n\t            if (event.tag !== eventTag || event.listener != listener) {\n\t                return true;\n\t            }\n\t            if (found) {\n\t                return true;\n\t            }\n\t            found = true;\n\t            stopped.push(event);\n\t            return false;\n\t        });\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return this;\n\t    };\n\t    BaseProvider.prototype.removeAllListeners = function (eventName) {\n\t        var _this = this;\n\t        var stopped = [];\n\t        if (eventName == null) {\n\t            stopped = this._events;\n\t            this._events = [];\n\t        }\n\t        else {\n\t            var eventTag_1 = getEventTag(eventName);\n\t            this._events = this._events.filter(function (event) {\n\t                if (event.tag !== eventTag_1) {\n\t                    return true;\n\t                }\n\t                stopped.push(event);\n\t                return false;\n\t            });\n\t        }\n\t        stopped.forEach(function (event) { _this._stopEvent(event); });\n\t        return this;\n\t    };\n\t    return BaseProvider;\n\t}(lib$b.Provider));\n\texports.BaseProvider = BaseProvider;\n\n\t});\n\n\tvar baseProvider$1 = unwrapExports(baseProvider);\n\tvar baseProvider_1 = baseProvider.Event;\n\tvar baseProvider_2 = baseProvider.Resolver;\n\tvar baseProvider_3 = baseProvider.BaseProvider;\n\n\tvar browserWs = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\tvar WS = null;\n\ttry {\n\t    WS = WebSocket;\n\t    if (WS == null) {\n\t        throw new Error("inject please");\n\t    }\n\t}\n\tcatch (error) {\n\t    var logger_2 = new lib.Logger(_version$I.version);\n\t    WS = function () {\n\t        logger_2.throwError("WebSockets not supported in this environment", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: "new WebSocket()"\n\t        });\n\t    };\n\t}\n\tmodule.exports = WS;\n\n\t});\n\n\tvar browserWs$1 = unwrapExports(browserWs);\n\n\tvar jsonRpcProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar errorGas = ["call", "estimateGas"];\n\tfunction checkError(method, error, params) {\n\t    var message = error.message;\n\t    if (error.code === lib.Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === "string") {\n\t        message = error.error.message;\n\t    }\n\t    else if (typeof (error.body) === "string") {\n\t        message = error.body;\n\t    }\n\t    else if (typeof (error.responseText) === "string") {\n\t        message = error.responseText;\n\t    }\n\t    message = (message || "").toLowerCase();\n\t    var transaction = params.transaction || params.signedTransaction;\n\t    // "insufficient funds for gas * price + value + cost(data)"\n\t    if (message.match(/insufficient funds/)) {\n\t        logger.throwError("insufficient funds for intrinsic transaction cost", lib.Logger.errors.INSUFFICIENT_FUNDS, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    // "nonce too low"\n\t    if (message.match(/nonce too low/)) {\n\t        logger.throwError("nonce has already been used", lib.Logger.errors.NONCE_EXPIRED, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    // "replacement transaction underpriced"\n\t    if (message.match(/replacement transaction underpriced/)) {\n\t        logger.throwError("replacement fee too low", lib.Logger.errors.REPLACEMENT_UNDERPRICED, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {\n\t        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    throw error;\n\t}\n\tfunction timer(timeout) {\n\t    return new Promise(function (resolve) {\n\t        setTimeout(resolve, timeout);\n\t    });\n\t}\n\tfunction getResult(payload) {\n\t    if (payload.error) {\n\t        // @TODO: not any\n\t        var error = new Error(payload.error.message);\n\t        error.code = payload.error.code;\n\t        error.data = payload.error.data;\n\t        throw error;\n\t    }\n\t    return payload.result;\n\t}\n\tfunction getLowerCase(value) {\n\t    if (value) {\n\t        return value.toLowerCase();\n\t    }\n\t    return value;\n\t}\n\tvar _constructorGuard = {};\n\tvar JsonRpcSigner = /** @class */ (function (_super) {\n\t    __extends(JsonRpcSigner, _super);\n\t    function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, JsonRpcSigner);\n\t        _this = _super.call(this) || this;\n\t        if (constructorGuard !== _constructorGuard) {\n\t            throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");\n\t        }\n\t        lib$3.defineReadOnly(_this, "provider", provider);\n\t        if (addressOrIndex == null) {\n\t            addressOrIndex = 0;\n\t        }\n\t        if (typeof (addressOrIndex) === "string") {\n\t            lib$3.defineReadOnly(_this, "_address", _this.provider.formatter.address(addressOrIndex));\n\t            lib$3.defineReadOnly(_this, "_index", null);\n\t        }\n\t        else if (typeof (addressOrIndex) === "number") {\n\t            lib$3.defineReadOnly(_this, "_index", addressOrIndex);\n\t            lib$3.defineReadOnly(_this, "_address", null);\n\t        }\n\t        else {\n\t            logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);\n\t        }\n\t        return _this;\n\t    }\n\t    JsonRpcSigner.prototype.connect = function (provider) {\n\t        return logger.throwError("cannot alter JSON-RPC Signer connection", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: "connect"\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.connectUnchecked = function () {\n\t        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n\t    };\n\t    JsonRpcSigner.prototype.getAddress = function () {\n\t        var _this = this;\n\t        if (this._address) {\n\t            return Promise.resolve(this._address);\n\t        }\n\t        return this.provider.send("eth_accounts", []).then(function (accounts) {\n\t            if (accounts.length <= _this._index) {\n\t                logger.throwError("unknown account #" + _this._index, lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                    operation: "getAddress"\n\t                });\n\t            }\n\t            return _this.provider.formatter.address(accounts[_this._index]);\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.sendUncheckedTransaction = function (transaction) {\n\t        var _this = this;\n\t        transaction = lib$3.shallowCopy(transaction);\n\t        var fromAddress = this.getAddress().then(function (address) {\n\t            if (address) {\n\t                address = address.toLowerCase();\n\t            }\n\t            return address;\n\t        });\n\t        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n\t        // wishes to use this, it is easy to specify explicitly, otherwise\n\t        // we look it up for them.\n\t        if (transaction.gasLimit == null) {\n\t            var estimate = lib$3.shallowCopy(transaction);\n\t            estimate.from = fromAddress;\n\t            transaction.gasLimit = this.provider.estimateGas(estimate);\n\t        }\n\t        return lib$3.resolveProperties({\n\t            tx: lib$3.resolveProperties(transaction),\n\t            sender: fromAddress\n\t        }).then(function (_a) {\n\t            var tx = _a.tx, sender = _a.sender;\n\t            if (tx.from != null) {\n\t                if (tx.from.toLowerCase() !== sender) {\n\t                    logger.throwArgumentError("from address mismatch", "transaction", transaction);\n\t                }\n\t            }\n\t            else {\n\t                tx.from = sender;\n\t            }\n\t            var hexTx = _this.provider.constructor.hexlifyTransaction(tx, { from: true });\n\t            return _this.provider.send("eth_sendTransaction", [hexTx]).then(function (hash) {\n\t                return hash;\n\t            }, function (error) {\n\t                return checkError("sendTransaction", error, hexTx);\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.signTransaction = function (transaction) {\n\t        return logger.throwError("signing transactions is unsupported", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: "signTransaction"\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.sendTransaction = function (transaction) {\n\t        var _this = this;\n\t        return this.sendUncheckedTransaction(transaction).then(function (hash) {\n\t            return lib$l.poll(function () {\n\t                return _this.provider.getTransaction(hash).then(function (tx) {\n\t                    if (tx === null) {\n\t                        return undefined;\n\t                    }\n\t                    return _this.provider._wrapTransaction(tx, hash);\n\t                });\n\t            }, { onceBlock: _this.provider }).catch(function (error) {\n\t                error.transactionHash = hash;\n\t                throw error;\n\t            });\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.signMessage = function (message) {\n\t        var _this = this;\n\t        var data = ((typeof (message) === "string") ? lib$8.toUtf8Bytes(message) : message);\n\t        return this.getAddress().then(function (address) {\n\t            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n\t            return _this.provider.send("eth_sign", [address.toLowerCase(), lib$1.hexlify(data)]);\n\t        });\n\t    };\n\t    JsonRpcSigner.prototype.unlock = function (password) {\n\t        var provider = this.provider;\n\t        return this.getAddress().then(function (address) {\n\t            return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);\n\t        });\n\t    };\n\t    return JsonRpcSigner;\n\t}(lib$c.Signer));\n\texports.JsonRpcSigner = JsonRpcSigner;\n\tvar UncheckedJsonRpcSigner = /** @class */ (function (_super) {\n\t    __extends(UncheckedJsonRpcSigner, _super);\n\t    function UncheckedJsonRpcSigner() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    UncheckedJsonRpcSigner.prototype.sendTransaction = function (transaction) {\n\t        var _this = this;\n\t        return this.sendUncheckedTransaction(transaction).then(function (hash) {\n\t            return {\n\t                hash: hash,\n\t                nonce: null,\n\t                gasLimit: null,\n\t                gasPrice: null,\n\t                data: null,\n\t                value: null,\n\t                chainId: null,\n\t                confirmations: 0,\n\t                from: null,\n\t                wait: function (confirmations) { return _this.provider.waitForTransaction(hash, confirmations); }\n\t            };\n\t        });\n\t    };\n\t    return UncheckedJsonRpcSigner;\n\t}(JsonRpcSigner));\n\tvar allowedTransactionKeys = {\n\t    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true\n\t};\n\tvar JsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(JsonRpcProvider, _super);\n\t    function JsonRpcProvider(url, network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, JsonRpcProvider);\n\t        var networkOrReady = network;\n\t        // The network is unknown, query the JSON-RPC for it\n\t        if (networkOrReady == null) {\n\t            networkOrReady = new Promise(function (resolve, reject) {\n\t                setTimeout(function () {\n\t                    _this.detectNetwork().then(function (network) {\n\t                        resolve(network);\n\t                    }, function (error) {\n\t                        reject(error);\n\t                    });\n\t                }, 0);\n\t            });\n\t        }\n\t        _this = _super.call(this, networkOrReady) || this;\n\t        // Default URL\n\t        if (!url) {\n\t            url = lib$3.getStatic(_this.constructor, "defaultUrl")();\n\t        }\n\t        if (typeof (url) === "string") {\n\t            lib$3.defineReadOnly(_this, "connection", Object.freeze({\n\t                url: url\n\t            }));\n\t        }\n\t        else {\n\t            lib$3.defineReadOnly(_this, "connection", Object.freeze(lib$3.shallowCopy(url)));\n\t        }\n\t        _this._nextId = 42;\n\t        return _this;\n\t    }\n\t    JsonRpcProvider.defaultUrl = function () {\n\t        return "http:/\\/localhost:8545";\n\t    };\n\t    JsonRpcProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var chainId, error_1, error_2, getNetwork;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, timer(0)];\n\t                    case 1:\n\t                        _a.sent();\n\t                        chainId = null;\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        _a.trys.push([2, 4, , 9]);\n\t                        return [4 /*yield*/, this.send("eth_chainId", [])];\n\t                    case 3:\n\t                        chainId = _a.sent();\n\t                        return [3 /*break*/, 9];\n\t                    case 4:\n\t                        error_1 = _a.sent();\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        _a.trys.push([5, 7, , 8]);\n\t                        return [4 /*yield*/, this.send("net_version", [])];\n\t                    case 6:\n\t                        chainId = _a.sent();\n\t                        return [3 /*break*/, 8];\n\t                    case 7:\n\t                        error_2 = _a.sent();\n\t                        return [3 /*break*/, 8];\n\t                    case 8: return [3 /*break*/, 9];\n\t                    case 9:\n\t                        if (chainId != null) {\n\t                            getNetwork = lib$3.getStatic(this.constructor, "getNetwork");\n\t                            try {\n\t                                return [2 /*return*/, getNetwork(lib$2.BigNumber.from(chainId).toNumber())];\n\t                            }\n\t                            catch (error) {\n\t                                return [2 /*return*/, logger.throwError("could not detect network", lib.Logger.errors.NETWORK_ERROR, {\n\t                                        chainId: chainId,\n\t                                        event: "invalidNetwork",\n\t                                        serverError: error\n\t                                    })];\n\t                            }\n\t                        }\n\t                        return [2 /*return*/, logger.throwError("could not detect network", lib.Logger.errors.NETWORK_ERROR, {\n\t                                event: "noNetwork"\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.getSigner = function (addressOrIndex) {\n\t        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n\t    };\n\t    JsonRpcProvider.prototype.getUncheckedSigner = function (addressOrIndex) {\n\t        return this.getSigner(addressOrIndex).connectUnchecked();\n\t    };\n\t    JsonRpcProvider.prototype.listAccounts = function () {\n\t        var _this = this;\n\t        return this.send("eth_accounts", []).then(function (accounts) {\n\t            return accounts.map(function (a) { return _this.formatter.address(a); });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.send = function (method, params) {\n\t        var _this = this;\n\t        var request = {\n\t            method: method,\n\t            params: params,\n\t            id: (this._nextId++),\n\t            jsonrpc: "2.0"\n\t        };\n\t        this.emit("debug", {\n\t            action: "request",\n\t            request: lib$3.deepCopy(request),\n\t            provider: this\n\t        });\n\t        return lib$l.fetchJson(this.connection, JSON.stringify(request), getResult).then(function (result) {\n\t            _this.emit("debug", {\n\t                action: "response",\n\t                request: request,\n\t                response: result,\n\t                provider: _this\n\t            });\n\t            return result;\n\t        }, function (error) {\n\t            _this.emit("debug", {\n\t                action: "response",\n\t                error: error,\n\t                request: request,\n\t                provider: _this\n\t            });\n\t            throw error;\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype.prepareRequest = function (method, params) {\n\t        switch (method) {\n\t            case "getBlockNumber":\n\t                return ["eth_blockNumber", []];\n\t            case "getGasPrice":\n\t                return ["eth_gasPrice", []];\n\t            case "getBalance":\n\t                return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];\n\t            case "getTransactionCount":\n\t                return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];\n\t            case "getCode":\n\t                return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];\n\t            case "getStorageAt":\n\t                return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];\n\t            case "sendTransaction":\n\t                return ["eth_sendRawTransaction", [params.signedTransaction]];\n\t            case "getBlock":\n\t                if (params.blockTag) {\n\t                    return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];\n\t                }\n\t                else if (params.blockHash) {\n\t                    return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];\n\t                }\n\t                return null;\n\t            case "getTransaction":\n\t                return ["eth_getTransactionByHash", [params.transactionHash]];\n\t            case "getTransactionReceipt":\n\t                return ["eth_getTransactionReceipt", [params.transactionHash]];\n\t            case "call": {\n\t                var hexlifyTransaction = lib$3.getStatic(this.constructor, "hexlifyTransaction");\n\t                return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n\t            }\n\t            case "estimateGas": {\n\t                var hexlifyTransaction = lib$3.getStatic(this.constructor, "hexlifyTransaction");\n\t                return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];\n\t            }\n\t            case "getLogs":\n\t                if (params.filter && params.filter.address != null) {\n\t                    params.filter.address = getLowerCase(params.filter.address);\n\t                }\n\t                return ["eth_getLogs", [params.filter]];\n\t            default:\n\t                break;\n\t        }\n\t        return null;\n\t    };\n\t    JsonRpcProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var args, error_3;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        args = this.prepareRequest(method, params);\n\t                        if (args == null) {\n\t                            logger.throwError(method + " not implemented", lib.Logger.errors.NOT_IMPLEMENTED, { operation: method });\n\t                        }\n\t                        _a.label = 1;\n\t                    case 1:\n\t                        _a.trys.push([1, 3, , 4]);\n\t                        return [4 /*yield*/, this.send(args[0], args[1])];\n\t                    case 2: return [2 /*return*/, _a.sent()];\n\t                    case 3:\n\t                        error_3 = _a.sent();\n\t                        return [2 /*return*/, checkError(method, error_3, params)];\n\t                    case 4: return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    JsonRpcProvider.prototype._startEvent = function (event) {\n\t        if (event.tag === "pending") {\n\t            this._startPending();\n\t        }\n\t        _super.prototype._startEvent.call(this, event);\n\t    };\n\t    JsonRpcProvider.prototype._startPending = function () {\n\t        if (this._pendingFilter != null) {\n\t            return;\n\t        }\n\t        var self = this;\n\t        var pendingFilter = this.send("eth_newPendingTransactionFilter", []);\n\t        this._pendingFilter = pendingFilter;\n\t        pendingFilter.then(function (filterId) {\n\t            function poll() {\n\t                self.send("eth_getFilterChanges", [filterId]).then(function (hashes) {\n\t                    if (self._pendingFilter != pendingFilter) {\n\t                        return null;\n\t                    }\n\t                    var seq = Promise.resolve();\n\t                    hashes.forEach(function (hash) {\n\t                        // @TODO: This should be garbage collected at some point... How? When?\n\t                        self._emitted["t:" + hash.toLowerCase()] = "pending";\n\t                        seq = seq.then(function () {\n\t                            return self.getTransaction(hash).then(function (tx) {\n\t                                self.emit("pending", tx);\n\t                                return null;\n\t                            });\n\t                        });\n\t                    });\n\t                    return seq.then(function () {\n\t                        return timer(1000);\n\t                    });\n\t                }).then(function () {\n\t                    if (self._pendingFilter != pendingFilter) {\n\t                        self.send("eth_uninstallFilter", [filterId]);\n\t                        return;\n\t                    }\n\t                    setTimeout(function () { poll(); }, 0);\n\t                    return null;\n\t                }).catch(function (error) { });\n\t            }\n\t            poll();\n\t            return filterId;\n\t        }).catch(function (error) { });\n\t    };\n\t    JsonRpcProvider.prototype._stopEvent = function (event) {\n\t        if (event.tag === "pending" && this.listenerCount("pending") === 0) {\n\t            this._pendingFilter = null;\n\t        }\n\t        _super.prototype._stopEvent.call(this, event);\n\t    };\n\t    // Convert an ethers.js transaction into a JSON-RPC transaction\n\t    //  - gasLimit => gas\n\t    //  - All values hexlified\n\t    //  - All numeric values zero-striped\n\t    //  - All addresses are lowercased\n\t    // NOTE: This allows a TransactionRequest, but all values should be resolved\n\t    //       before this is called\n\t    // @TODO: This will likely be removed in future versions and prepareRequest\n\t    //        will be the preferred method for this.\n\t    JsonRpcProvider.hexlifyTransaction = function (transaction, allowExtra) {\n\t        // Check only allowed properties are given\n\t        var allowed = lib$3.shallowCopy(allowedTransactionKeys);\n\t        if (allowExtra) {\n\t            for (var key in allowExtra) {\n\t                if (allowExtra[key]) {\n\t                    allowed[key] = true;\n\t                }\n\t            }\n\t        }\n\t        lib$3.checkProperties(transaction, allowed);\n\t        var result = {};\n\t        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.\n\t        ["gasLimit", "gasPrice", "nonce", "value"].forEach(function (key) {\n\t            if (transaction[key] == null) {\n\t                return;\n\t            }\n\t            var value = lib$1.hexValue(transaction[key]);\n\t            if (key === "gasLimit") {\n\t                key = "gas";\n\t            }\n\t            result[key] = value;\n\t        });\n\t        ["from", "to", "data"].forEach(function (key) {\n\t            if (transaction[key] == null) {\n\t                return;\n\t            }\n\t            result[key] = lib$1.hexlify(transaction[key]);\n\t        });\n\t        return result;\n\t    };\n\t    return JsonRpcProvider;\n\t}(baseProvider.BaseProvider));\n\texports.JsonRpcProvider = JsonRpcProvider;\n\n\t});\n\n\tvar jsonRpcProvider$1 = unwrapExports(jsonRpcProvider);\n\tvar jsonRpcProvider_1 = jsonRpcProvider.JsonRpcSigner;\n\tvar jsonRpcProvider_2 = jsonRpcProvider.JsonRpcProvider;\n\n\tvar websocketProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tvar __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {\n\t    return (mod && mod.__esModule) ? mod : { "default": mod };\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\tvar ws_1 = __importDefault(browserWs);\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t/**\n\t *  Notes:\n\t *\n\t *  This provider differs a bit from the polling providers. One main\n\t *  difference is how it handles consistency. The polling providers\n\t *  will stall responses to ensure a consistent state, while this\n\t *  WebSocket provider assumes the connected backend will manage this.\n\t *\n\t *  For example, if a polling provider emits an event which indicats\n\t *  the event occurred in blockhash XXX, a call to fetch that block by\n\t *  its hash XXX, if not present will retry until it is present. This\n\t *  can occur when querying a pool of nodes that are mildly out of sync\n\t *  with each other.\n\t */\n\tvar NextId = 1;\n\t// For more info about the Real-time Event API see:\n\t//   https://geth.ethereum.org/docs/rpc/pubsub\n\tvar WebSocketProvider = /** @class */ (function (_super) {\n\t    __extends(WebSocketProvider, _super);\n\t    function WebSocketProvider(url, network) {\n\t        var _this = this;\n\t        // This will be added in the future; please open an issue to expedite\n\t        if (network === "any") {\n\t            logger.throwError("WebSocketProvider does not support \'any\' network yet", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "network:any"\n\t            });\n\t        }\n\t        _this = _super.call(this, url, network) || this;\n\t        _this._pollingInterval = -1;\n\t        lib$3.defineReadOnly(_this, "_websocket", new ws_1.default(_this.connection.url));\n\t        lib$3.defineReadOnly(_this, "_requests", {});\n\t        lib$3.defineReadOnly(_this, "_subs", {});\n\t        lib$3.defineReadOnly(_this, "_subIds", {});\n\t        // Stall sending requests until the socket is open...\n\t        _this._wsReady = false;\n\t        _this._websocket.onopen = function () {\n\t            _this._wsReady = true;\n\t            Object.keys(_this._requests).forEach(function (id) {\n\t                _this._websocket.send(_this._requests[id].payload);\n\t            });\n\t        };\n\t        _this._websocket.onmessage = function (messageEvent) {\n\t            var data = messageEvent.data;\n\t            var result = JSON.parse(data);\n\t            if (result.id != null) {\n\t                var id = String(result.id);\n\t                var request = _this._requests[id];\n\t                delete _this._requests[id];\n\t                if (result.result !== undefined) {\n\t                    request.callback(null, result.result);\n\t                }\n\t                else {\n\t                    if (result.error) {\n\t                        var error = new Error(result.error.message || "unknown error");\n\t                        lib$3.defineReadOnly(error, "code", result.error.code || null);\n\t                        lib$3.defineReadOnly(error, "response", data);\n\t                        request.callback(error, undefined);\n\t                    }\n\t                    else {\n\t                        request.callback(new Error("unknown error"), undefined);\n\t                    }\n\t                }\n\t            }\n\t            else if (result.method === "eth_subscription") {\n\t                // Subscription...\n\t                var sub = _this._subs[result.params.subscription];\n\t                if (sub) {\n\t                    //this.emit.apply(this,                  );\n\t                    sub.processFunc(result.params.result);\n\t                }\n\t            }\n\t            else {\n\t                console.warn("this should not happen");\n\t            }\n\t        };\n\t        // This Provider does not actually poll, but we want to trigger\n\t        // poll events for things that depend on them (like stalling for\n\t        // block and transaction lookups)\n\t        var fauxPoll = setInterval(function () {\n\t            _this.emit("poll");\n\t        }, 1000);\n\t        if (fauxPoll.unref) {\n\t            fauxPoll.unref();\n\t        }\n\t        return _this;\n\t    }\n\t    Object.defineProperty(WebSocketProvider.prototype, "pollingInterval", {\n\t        get: function () {\n\t            return 0;\n\t        },\n\t        set: function (value) {\n\t            logger.throwError("cannot set polling interval on WebSocketProvider", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "setPollingInterval"\n\t            });\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    WebSocketProvider.prototype.resetEventsBlock = function (blockNumber) {\n\t        logger.throwError("cannot reset events block on WebSocketProvider", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t            operation: "resetEventBlock"\n\t        });\n\t    };\n\t    WebSocketProvider.prototype.poll = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, null];\n\t            });\n\t        });\n\t    };\n\t    Object.defineProperty(WebSocketProvider.prototype, "polling", {\n\t        set: function (value) {\n\t            if (!value) {\n\t                return;\n\t            }\n\t            logger.throwError("cannot set polling on WebSocketProvider", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "setPolling"\n\t            });\n\t        },\n\t        enumerable: true,\n\t        configurable: true\n\t    });\n\t    WebSocketProvider.prototype.send = function (method, params) {\n\t        var _this = this;\n\t        var rid = NextId++;\n\t        return new Promise(function (resolve, reject) {\n\t            function callback(error, result) {\n\t                if (error) {\n\t                    return reject(error);\n\t                }\n\t                return resolve(result);\n\t            }\n\t            var payload = JSON.stringify({\n\t                method: method,\n\t                params: params,\n\t                id: rid,\n\t                jsonrpc: "2.0"\n\t            });\n\t            _this._requests[String(rid)] = { callback: callback, payload: payload };\n\t            if (_this._wsReady) {\n\t                _this._websocket.send(payload);\n\t            }\n\t        });\n\t    };\n\t    WebSocketProvider.defaultUrl = function () {\n\t        return "ws:/\\/localhost:8546";\n\t    };\n\t    WebSocketProvider.prototype._subscribe = function (tag, param, processFunc) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var subIdPromise, subId;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        subIdPromise = this._subIds[tag];\n\t                        if (subIdPromise == null) {\n\t                            subIdPromise = Promise.all(param).then(function (param) {\n\t                                return _this.send("eth_subscribe", param);\n\t                            });\n\t                            this._subIds[tag] = subIdPromise;\n\t                        }\n\t                        return [4 /*yield*/, subIdPromise];\n\t                    case 1:\n\t                        subId = _a.sent();\n\t                        this._subs[subId] = { tag: tag, processFunc: processFunc };\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    WebSocketProvider.prototype._startEvent = function (event) {\n\t        var _this = this;\n\t        switch (event.type) {\n\t            case "block":\n\t                this._subscribe("block", ["newHeads"], function (result) {\n\t                    var blockNumber = lib$2.BigNumber.from(result.number).toNumber();\n\t                    _this._emitted.block = blockNumber;\n\t                    _this.emit("block", blockNumber);\n\t                });\n\t                break;\n\t            case "pending":\n\t                this._subscribe("pending", ["newPendingTransactions"], function (result) {\n\t                    _this.emit("pending", result);\n\t                });\n\t                break;\n\t            case "filter":\n\t                this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], function (result) {\n\t                    if (result.removed == null) {\n\t                        result.removed = false;\n\t                    }\n\t                    _this.emit(event.filter, _this.formatter.filterLog(result));\n\t                });\n\t                break;\n\t            case "tx": {\n\t                var emitReceipt_1 = function (event) {\n\t                    var hash = event.hash;\n\t                    _this.getTransactionReceipt(hash).then(function (receipt) {\n\t                        if (!receipt) {\n\t                            return;\n\t                        }\n\t                        _this.emit(hash, receipt);\n\t                    });\n\t                };\n\t                // In case it is already mined\n\t                emitReceipt_1(event);\n\t                // To keep things simple, we start up a single newHeads subscription\n\t                // to keep an eye out for transactions we are watching for.\n\t                // Starting a subscription for an event (i.e. "tx") that is already\n\t                // running is (basically) a nop.\n\t                this._subscribe("tx", ["newHeads"], function (result) {\n\t                    _this._events.filter(function (e) { return (e.type === "tx"); }).forEach(emitReceipt_1);\n\t                });\n\t                break;\n\t            }\n\t            // Nothing is needed\n\t            case "debug":\n\t            case "poll":\n\t            case "willPoll":\n\t            case "didPoll":\n\t            case "error":\n\t                break;\n\t            default:\n\t                console.log("unhandled:", event);\n\t                break;\n\t        }\n\t    };\n\t    WebSocketProvider.prototype._stopEvent = function (event) {\n\t        var _this = this;\n\t        var tag = event.tag;\n\t        if (event.type === "tx") {\n\t            // There are remaining transaction event listeners\n\t            if (this._events.filter(function (e) { return (e.type === "tx"); }).length) {\n\t                return;\n\t            }\n\t            tag = "tx";\n\t        }\n\t        else if (this.listenerCount(event.event)) {\n\t            // There are remaining event listeners\n\t            return;\n\t        }\n\t        var subId = this._subIds[tag];\n\t        if (!subId) {\n\t            return;\n\t        }\n\t        delete this._subIds[tag];\n\t        subId.then(function (subId) {\n\t            if (!_this._subs[subId]) {\n\t                return;\n\t            }\n\t            delete _this._subs[subId];\n\t            _this.send("eth_unsubscribe", [subId]);\n\t        });\n\t    };\n\t    WebSocketProvider.prototype.destroy = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(this._websocket.readyState === ws_1.default.CONNECTING)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, (new Promise(function (resolve) {\n\t                                _this._websocket.onopen = function () {\n\t                                    resolve(true);\n\t                                };\n\t                                _this._websocket.onerror = function () {\n\t                                    resolve(false);\n\t                                };\n\t                            }))];\n\t                    case 1:\n\t                        _a.sent();\n\t                        _a.label = 2;\n\t                    case 2:\n\t                        // Hangup\n\t                        // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes\n\t                        this._websocket.close(1000);\n\t                        return [2 /*return*/];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return WebSocketProvider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.WebSocketProvider = WebSocketProvider;\n\n\t});\n\n\tvar websocketProvider$1 = unwrapExports(websocketProvider);\n\tvar websocketProvider_1 = websocketProvider.WebSocketProvider;\n\n\tvar urlJsonRpcProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// A StaticJsonRpcProvider is useful when you *know* for certain that\n\t// the backend will never change, as it never calls eth_chainId to\n\t// verify its backend. However, if the backend does change, the effects\n\t// are undefined and may include:\n\t// - inconsistent results\n\t// - locking up the UI\n\t// - block skew warnings\n\t// - wrong results\n\t// If the network is not explicit (i.e. auto-detection is expected), the\n\t// node MUST be running and available to respond to requests BEFORE this\n\t// is instantiated.\n\tvar StaticJsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(StaticJsonRpcProvider, _super);\n\t    function StaticJsonRpcProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    StaticJsonRpcProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var network;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        network = this.network;\n\t                        if (!(network == null)) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, _super.prototype.detectNetwork.call(this)];\n\t                    case 1:\n\t                        network = _a.sent();\n\t                        if (!network) {\n\t                            logger.throwError("no network detected", lib.Logger.errors.UNKNOWN_ERROR, {});\n\t                        }\n\t                        // If still not set, set it\n\t                        if (this._network == null) {\n\t                            // A static network does not support "any"\n\t                            lib$3.defineReadOnly(this, "_network", network);\n\t                            this.emit("network", network, null);\n\t                        }\n\t                        _a.label = 2;\n\t                    case 2: return [2 /*return*/, network];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return StaticJsonRpcProvider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.StaticJsonRpcProvider = StaticJsonRpcProvider;\n\tvar UrlJsonRpcProvider = /** @class */ (function (_super) {\n\t    __extends(UrlJsonRpcProvider, _super);\n\t    function UrlJsonRpcProvider(network, apiKey) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkAbstract(_newTarget, UrlJsonRpcProvider);\n\t        // Normalize the Network and API Key\n\t        network = lib$3.getStatic((_newTarget), "getNetwork")(network);\n\t        apiKey = lib$3.getStatic((_newTarget), "getApiKey")(apiKey);\n\t        var connection = lib$3.getStatic((_newTarget), "getUrl")(network, apiKey);\n\t        _this = _super.call(this, connection, network) || this;\n\t        if (typeof (apiKey) === "string") {\n\t            lib$3.defineReadOnly(_this, "apiKey", apiKey);\n\t        }\n\t        else if (apiKey != null) {\n\t            Object.keys(apiKey).forEach(function (key) {\n\t                lib$3.defineReadOnly(_this, key, apiKey[key]);\n\t            });\n\t        }\n\t        return _this;\n\t    }\n\t    UrlJsonRpcProvider.prototype._startPending = function () {\n\t        logger.warn("WARNING: API provider does not support pending filters");\n\t    };\n\t    UrlJsonRpcProvider.prototype.getSigner = function (address) {\n\t        return logger.throwError("API provider does not support signing", lib.Logger.errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });\n\t    };\n\t    UrlJsonRpcProvider.prototype.listAccounts = function () {\n\t        return Promise.resolve([]);\n\t    };\n\t    // Return a defaultApiKey if null, otherwise validate the API key\n\t    UrlJsonRpcProvider.getApiKey = function (apiKey) {\n\t        return apiKey;\n\t    };\n\t    // Returns the url or connection for the given network and API key. The\n\t    // API key will have been sanitized by the getApiKey first, so any validation\n\t    // or transformations can be done there.\n\t    UrlJsonRpcProvider.getUrl = function (network, apiKey) {\n\t        return logger.throwError("not implemented; sub-classes must override getUrl", lib.Logger.errors.NOT_IMPLEMENTED, {\n\t            operation: "getUrl"\n\t        });\n\t    };\n\t    return UrlJsonRpcProvider;\n\t}(StaticJsonRpcProvider));\n\texports.UrlJsonRpcProvider = UrlJsonRpcProvider;\n\n\t});\n\n\tvar urlJsonRpcProvider$1 = unwrapExports(urlJsonRpcProvider);\n\tvar urlJsonRpcProvider_1 = urlJsonRpcProvider.StaticJsonRpcProvider;\n\tvar urlJsonRpcProvider_2 = urlJsonRpcProvider.UrlJsonRpcProvider;\n\n\tvar alchemyProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// This key was provided to ethers.js by Alchemy to be used by the\n\t// default provider, but it is recommended that for your own\n\t// production environments, that you acquire your own API key at:\n\t//   https://dashboard.alchemyapi.io\n\tvar defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";\n\tvar AlchemyProvider = /** @class */ (function (_super) {\n\t    __extends(AlchemyProvider, _super);\n\t    function AlchemyProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    AlchemyProvider.getWebSocketProvider = function (network, apiKey) {\n\t        var provider = new AlchemyProvider(network, apiKey);\n\t        var url = provider.connection.url.replace(/^http/i, "ws")\n\t            .replace(".alchemyapi.", ".ws.alchemyapi.");\n\t        return new websocketProvider.WebSocketProvider(url, provider.network);\n\t    };\n\t    AlchemyProvider.getApiKey = function (apiKey) {\n\t        if (apiKey == null) {\n\t            return defaultApiKey;\n\t        }\n\t        if (apiKey && typeof (apiKey) !== "string") {\n\t            logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);\n\t        }\n\t        return apiKey;\n\t    };\n\t    AlchemyProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network.name) {\n\t            case "homestead":\n\t                host = "eth-mainnet.alchemyapi.io/v2/";\n\t                break;\n\t            case "ropsten":\n\t                host = "eth-ropsten.alchemyapi.io/v2/";\n\t                break;\n\t            case "rinkeby":\n\t                host = "eth-rinkeby.alchemyapi.io/v2/";\n\t                break;\n\t            case "goerli":\n\t                host = "eth-goerli.alchemyapi.io/v2/";\n\t                break;\n\t            case "kovan":\n\t                host = "eth-kovan.alchemyapi.io/v2/";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError("unsupported network", "network", arguments[0]);\n\t        }\n\t        return {\n\t            url: ("https:/" + "/" + host + apiKey),\n\t            throttleCallback: function (attempt, url) {\n\t                if (apiKey === defaultApiKey) {\n\t                    formatter.showThrottleMessage();\n\t                }\n\t                return Promise.resolve(true);\n\t            }\n\t        };\n\t    };\n\t    return AlchemyProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.AlchemyProvider = AlchemyProvider;\n\n\t});\n\n\tvar alchemyProvider$1 = unwrapExports(alchemyProvider);\n\tvar alchemyProvider_1 = alchemyProvider.AlchemyProvider;\n\n\tvar cloudflareProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tvar CloudflareProvider = /** @class */ (function (_super) {\n\t    __extends(CloudflareProvider, _super);\n\t    function CloudflareProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    CloudflareProvider.getApiKey = function (apiKey) {\n\t        if (apiKey != null) {\n\t            logger.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);\n\t        }\n\t        return null;\n\t    };\n\t    CloudflareProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network.name) {\n\t            case "homestead":\n\t                host = "https://cloudflare-eth.com/";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError("unsupported network", "network", arguments[0]);\n\t        }\n\t        return host;\n\t    };\n\t    CloudflareProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var block;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(method === "getBlockNumber")) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, _super.prototype.perform.call(this, "getBlock", { blockTag: "latest" })];\n\t                    case 1:\n\t                        block = _a.sent();\n\t                        return [2 /*return*/, block.number];\n\t                    case 2: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return CloudflareProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.CloudflareProvider = CloudflareProvider;\n\n\t});\n\n\tvar cloudflareProvider$1 = unwrapExports(cloudflareProvider);\n\tvar cloudflareProvider_1 = cloudflareProvider.CloudflareProvider;\n\n\tvar etherscanProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\t// The transaction has already been sanitized by the calls in Provider\n\tfunction getTransactionString(transaction) {\n\t    var result = [];\n\t    for (var key in transaction) {\n\t        if (transaction[key] == null) {\n\t            continue;\n\t        }\n\t        var value = lib$1.hexlify(transaction[key]);\n\t        if ({ gasLimit: true, gasPrice: true, nonce: true, value: true }[key]) {\n\t            value = lib$1.hexValue(value);\n\t        }\n\t        result.push(key + "=" + value);\n\t    }\n\t    return result.join("&");\n\t}\n\tfunction getResult(result) {\n\t    // getLogs, getHistory have weird success responses\n\t    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {\n\t        return result.result;\n\t    }\n\t    if (result.status != 1 || result.message != "OK") {\n\t        var error = new Error("invalid response");\n\t        error.result = JSON.stringify(result);\n\t        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {\n\t            error.throttleRetry = true;\n\t        }\n\t        throw error;\n\t    }\n\t    return result.result;\n\t}\n\tfunction getJsonResult(result) {\n\t    // This response indicates we are being throttled\n\t    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {\n\t        var error = new Error("throttled response");\n\t        error.result = JSON.stringify(result);\n\t        error.throttleRetry = true;\n\t        throw error;\n\t    }\n\t    if (result.jsonrpc != "2.0") {\n\t        // @TODO: not any\n\t        var error = new Error("invalid response");\n\t        error.result = JSON.stringify(result);\n\t        throw error;\n\t    }\n\t    if (result.error) {\n\t        // @TODO: not any\n\t        var error = new Error(result.error.message || "unknown error");\n\t        if (result.error.code) {\n\t            error.code = result.error.code;\n\t        }\n\t        if (result.error.data) {\n\t            error.data = result.error.data;\n\t        }\n\t        throw error;\n\t    }\n\t    return result.result;\n\t}\n\t// The blockTag was normalized as a string by the Provider pre-perform operations\n\tfunction checkLogTag(blockTag) {\n\t    if (blockTag === "pending") {\n\t        throw new Error("pending not supported");\n\t    }\n\t    if (blockTag === "latest") {\n\t        return blockTag;\n\t    }\n\t    return parseInt(blockTag.substring(2), 16);\n\t}\n\tvar defaultApiKey = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";\n\tfunction checkError(method, error, transaction) {\n\t    // Get the message from any nested error structure\n\t    var message = error.message;\n\t    if (error.code === lib.Logger.errors.SERVER_ERROR) {\n\t        if (error.error && typeof (error.error.message) === "string") {\n\t            message = error.error.message;\n\t        }\n\t        else if (typeof (error.body) === "string") {\n\t            message = error.body;\n\t        }\n\t        else if (typeof (error.responseText) === "string") {\n\t            message = error.responseText;\n\t        }\n\t    }\n\t    message = (message || "").toLowerCase();\n\t    // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"\n\t    if (message.match(/insufficient funds/)) {\n\t        logger.throwError("insufficient funds for intrinsic transaction cost", lib.Logger.errors.INSUFFICIENT_FUNDS, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    // "Transaction with the same hash was already imported."\n\t    if (message.match(/same hash was already imported|transaction nonce is too low/)) {\n\t        logger.throwError("nonce has already been used", lib.Logger.errors.NONCE_EXPIRED, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."\n\t    if (message.match(/another transaction with same nonce/)) {\n\t        logger.throwError("replacement fee too low", lib.Logger.errors.REPLACEMENT_UNDERPRICED, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    if (message.match(/execution failed due to an exception/)) {\n\t        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n\t            error: error, method: method, transaction: transaction\n\t        });\n\t    }\n\t    throw error;\n\t}\n\tvar EtherscanProvider = /** @class */ (function (_super) {\n\t    __extends(EtherscanProvider, _super);\n\t    function EtherscanProvider(network, apiKey) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, EtherscanProvider);\n\t        _this = _super.call(this, network) || this;\n\t        var name = "invalid";\n\t        if (_this.network) {\n\t            name = _this.network.name;\n\t        }\n\t        var baseUrl = null;\n\t        switch (name) {\n\t            case "homestead":\n\t                baseUrl = "https://api.etherscan.io";\n\t                break;\n\t            case "ropsten":\n\t                baseUrl = "https://api-ropsten.etherscan.io";\n\t                break;\n\t            case "rinkeby":\n\t                baseUrl = "https://api-rinkeby.etherscan.io";\n\t                break;\n\t            case "kovan":\n\t                baseUrl = "https://api-kovan.etherscan.io";\n\t                break;\n\t            case "goerli":\n\t                baseUrl = "https://api-goerli.etherscan.io";\n\t                break;\n\t            default:\n\t                throw new Error("unsupported network");\n\t        }\n\t        lib$3.defineReadOnly(_this, "baseUrl", baseUrl);\n\t        lib$3.defineReadOnly(_this, "apiKey", apiKey || defaultApiKey);\n\t        return _this;\n\t    }\n\t    EtherscanProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            return __generator(this, function (_a) {\n\t                return [2 /*return*/, this.network];\n\t            });\n\t        });\n\t    };\n\t    EtherscanProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var url, apiKey, get, _a, transaction, error_1, transaction, error_2, topic0, logs, txs, i, log, tx, _b;\n\t            var _this = this;\n\t            return __generator(this, function (_c) {\n\t                switch (_c.label) {\n\t                    case 0:\n\t                        url = this.baseUrl;\n\t                        apiKey = "";\n\t                        if (this.apiKey) {\n\t                            apiKey += "&apikey=" + this.apiKey;\n\t                        }\n\t                        get = function (url, procFunc) { return __awaiter(_this, void 0, void 0, function () {\n\t                            var connection, result;\n\t                            var _this = this;\n\t                            return __generator(this, function (_a) {\n\t                                switch (_a.label) {\n\t                                    case 0:\n\t                                        this.emit("debug", {\n\t                                            action: "request",\n\t                                            request: url,\n\t                                            provider: this\n\t                                        });\n\t                                        connection = {\n\t                                            url: url,\n\t                                            throttleSlotInterval: 1000,\n\t                                            throttleCallback: function (attempt, url) {\n\t                                                if (_this.apiKey === defaultApiKey) {\n\t                                                    formatter.showThrottleMessage();\n\t                                                }\n\t                                                return Promise.resolve(true);\n\t                                            }\n\t                                        };\n\t                                        return [4 /*yield*/, lib$l.fetchJson(connection, null, procFunc || getJsonResult)];\n\t                                    case 1:\n\t                                        result = _a.sent();\n\t                                        this.emit("debug", {\n\t                                            action: "response",\n\t                                            request: url,\n\t                                            response: lib$3.deepCopy(result),\n\t                                            provider: this\n\t                                        });\n\t                                        return [2 /*return*/, result];\n\t                                }\n\t                            });\n\t                        }); };\n\t                        _a = method;\n\t                        switch (_a) {\n\t                            case "getBlockNumber": return [3 /*break*/, 1];\n\t                            case "getGasPrice": return [3 /*break*/, 2];\n\t                            case "getBalance": return [3 /*break*/, 3];\n\t                            case "getTransactionCount": return [3 /*break*/, 4];\n\t                            case "getCode": return [3 /*break*/, 5];\n\t                            case "getStorageAt": return [3 /*break*/, 6];\n\t                            case "sendTransaction": return [3 /*break*/, 7];\n\t                            case "getBlock": return [3 /*break*/, 8];\n\t                            case "getTransaction": return [3 /*break*/, 9];\n\t                            case "getTransactionReceipt": return [3 /*break*/, 10];\n\t                            case "call": return [3 /*break*/, 11];\n\t                            case "estimateGas": return [3 /*break*/, 15];\n\t                            case "getLogs": return [3 /*break*/, 19];\n\t                            case "getEtherPrice": return [3 /*break*/, 26];\n\t                        }\n\t                        return [3 /*break*/, 28];\n\t                    case 1:\n\t                        url += "/api?module=proxy&action=eth_blockNumber" + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 2:\n\t                        url += "/api?module=proxy&action=eth_gasPrice" + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 3:\n\t                        // Returns base-10 result\n\t                        url += "/api?module=account&action=balance&address=" + params.address;\n\t                        url += "&tag=" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url, getResult)];\n\t                    case 4:\n\t                        url += "/api?module=proxy&action=eth_getTransactionCount&address=" + params.address;\n\t                        url += "&tag=" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 5:\n\t                        url += "/api?module=proxy&action=eth_getCode&address=" + params.address;\n\t                        url += "&tag=" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 6:\n\t                        url += "/api?module=proxy&action=eth_getStorageAt&address=" + params.address;\n\t                        url += "&position=" + params.position;\n\t                        url += "&tag=" + params.blockTag + apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 7:\n\t                        url += "/api?module=proxy&action=eth_sendRawTransaction&hex=" + params.signedTransaction;\n\t                        url += apiKey;\n\t                        return [2 /*return*/, get(url).catch(function (error) {\n\t                                return checkError("sendTransaction", error, params.signedTransaction);\n\t                            })];\n\t                    case 8:\n\t                        if (params.blockTag) {\n\t                            url += "/api?module=proxy&action=eth_getBlockByNumber&tag=" + params.blockTag;\n\t                            if (params.includeTransactions) {\n\t                                url += "&boolean=true";\n\t                            }\n\t                            else {\n\t                                url += "&boolean=false";\n\t                            }\n\t                            url += apiKey;\n\t                            return [2 /*return*/, get(url)];\n\t                        }\n\t                        throw new Error("getBlock by blockHash not implemented");\n\t                    case 9:\n\t                        url += "/api?module=proxy&action=eth_getTransactionByHash&txhash=" + params.transactionHash;\n\t                        url += apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 10:\n\t                        url += "/api?module=proxy&action=eth_getTransactionReceipt&txhash=" + params.transactionHash;\n\t                        url += apiKey;\n\t                        return [2 /*return*/, get(url)];\n\t                    case 11:\n\t                        transaction = getTransactionString(params.transaction);\n\t                        if (transaction) {\n\t                            transaction = "&" + transaction;\n\t                        }\n\t                        url += "/api?module=proxy&action=eth_call" + transaction;\n\t                        //url += "&tag=" + params.blockTag + apiKey;\n\t                        if (params.blockTag !== "latest") {\n\t                            throw new Error("EtherscanProvider does not support blockTag for call");\n\t                        }\n\t                        url += apiKey;\n\t                        _c.label = 12;\n\t                    case 12:\n\t                        _c.trys.push([12, 14, , 15]);\n\t                        return [4 /*yield*/, get(url)];\n\t                    case 13: return [2 /*return*/, _c.sent()];\n\t                    case 14:\n\t                        error_1 = _c.sent();\n\t                        return [2 /*return*/, checkError("call", error_1, params.transaction)];\n\t                    case 15:\n\t                        transaction = getTransactionString(params.transaction);\n\t                        if (transaction) {\n\t                            transaction = "&" + transaction;\n\t                        }\n\t                        url += "/api?module=proxy&action=eth_estimateGas&" + transaction;\n\t                        url += apiKey;\n\t                        _c.label = 16;\n\t                    case 16:\n\t                        _c.trys.push([16, 18, , 19]);\n\t                        return [4 /*yield*/, get(url)];\n\t                    case 17: return [2 /*return*/, _c.sent()];\n\t                    case 18:\n\t                        error_2 = _c.sent();\n\t                        return [2 /*return*/, checkError("estimateGas", error_2, params.transaction)];\n\t                    case 19:\n\t                        url += "/api?module=logs&action=getLogs";\n\t                        if (params.filter.fromBlock) {\n\t                            url += "&fromBlock=" + checkLogTag(params.filter.fromBlock);\n\t                        }\n\t                        if (params.filter.toBlock) {\n\t                            url += "&toBlock=" + checkLogTag(params.filter.toBlock);\n\t                        }\n\t                        if (params.filter.address) {\n\t                            url += "&address=" + params.filter.address;\n\t                        }\n\t                        // @TODO: We can handle slightly more complicated logs using the logs API\n\t                        if (params.filter.topics && params.filter.topics.length > 0) {\n\t                            if (params.filter.topics.length > 1) {\n\t                                logger.throwError("unsupported topic count", lib.Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n\t                            }\n\t                            if (params.filter.topics.length === 1) {\n\t                                topic0 = params.filter.topics[0];\n\t                                if (typeof (topic0) !== "string" || topic0.length !== 66) {\n\t                                    logger.throwError("unsupported topic format", lib.Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n\t                                }\n\t                                url += "&topic0=" + topic0;\n\t                            }\n\t                        }\n\t                        url += apiKey;\n\t                        return [4 /*yield*/, get(url, getResult)];\n\t                    case 20:\n\t                        logs = _c.sent();\n\t                        txs = {};\n\t                        i = 0;\n\t                        _c.label = 21;\n\t                    case 21:\n\t                        if (!(i < logs.length)) return [3 /*break*/, 25];\n\t                        log = logs[i];\n\t                        if (log.blockHash != null) {\n\t                            return [3 /*break*/, 24];\n\t                        }\n\t                        if (!(txs[log.transactionHash] == null)) return [3 /*break*/, 23];\n\t                        return [4 /*yield*/, this.getTransaction(log.transactionHash)];\n\t                    case 22:\n\t                        tx = _c.sent();\n\t                        if (tx) {\n\t                            txs[log.transactionHash] = tx.blockHash;\n\t                        }\n\t                        _c.label = 23;\n\t                    case 23:\n\t                        log.blockHash = txs[log.transactionHash];\n\t                        _c.label = 24;\n\t                    case 24:\n\t                        i++;\n\t                        return [3 /*break*/, 21];\n\t                    case 25: return [2 /*return*/, logs];\n\t                    case 26:\n\t                        if (this.network.name !== "homestead") {\n\t                            return [2 /*return*/, 0.0];\n\t                        }\n\t                        url += "/api?module=stats&action=ethprice";\n\t                        url += apiKey;\n\t                        _b = parseFloat;\n\t                        return [4 /*yield*/, get(url, getResult)];\n\t                    case 27: return [2 /*return*/, _b.apply(void 0, [(_c.sent()).ethusd])];\n\t                    case 28: return [3 /*break*/, 29];\n\t                    case 29: return [2 /*return*/, _super.prototype.perform.call(this, method, params)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    // @TODO: Allow startBlock and endBlock to be Promises\n\t    EtherscanProvider.prototype.getHistory = function (addressOrName, startBlock, endBlock) {\n\t        var _this = this;\n\t        var url = this.baseUrl;\n\t        var apiKey = "";\n\t        if (this.apiKey) {\n\t            apiKey += "&apikey=" + this.apiKey;\n\t        }\n\t        if (startBlock == null) {\n\t            startBlock = 0;\n\t        }\n\t        if (endBlock == null) {\n\t            endBlock = 99999999;\n\t        }\n\t        return this.resolveName(addressOrName).then(function (address) {\n\t            url += "/api?module=account&action=txlist&address=" + address;\n\t            url += "&startblock=" + startBlock;\n\t            url += "&endblock=" + endBlock;\n\t            url += "&sort=asc" + apiKey;\n\t            _this.emit("debug", {\n\t                action: "request",\n\t                request: url,\n\t                provider: _this\n\t            });\n\t            var connection = {\n\t                url: url,\n\t                throttleSlotInterval: 1000,\n\t                throttleCallback: function (attempt, url) {\n\t                    if (_this.apiKey === defaultApiKey) {\n\t                        formatter.showThrottleMessage();\n\t                    }\n\t                    return Promise.resolve(true);\n\t                }\n\t            };\n\t            return lib$l.fetchJson(connection, null, getResult).then(function (result) {\n\t                _this.emit("debug", {\n\t                    action: "response",\n\t                    request: url,\n\t                    response: lib$3.deepCopy(result),\n\t                    provider: _this\n\t                });\n\t                var output = [];\n\t                result.forEach(function (tx) {\n\t                    ["contractAddress", "to"].forEach(function (key) {\n\t                        if (tx[key] == "") {\n\t                            delete tx[key];\n\t                        }\n\t                    });\n\t                    if (tx.creates == null && tx.contractAddress != null) {\n\t                        tx.creates = tx.contractAddress;\n\t                    }\n\t                    var item = _this.formatter.transactionResponse(tx);\n\t                    if (tx.timeStamp) {\n\t                        item.timestamp = parseInt(tx.timeStamp);\n\t                    }\n\t                    output.push(item);\n\t                });\n\t                return output;\n\t            });\n\t        });\n\t    };\n\t    return EtherscanProvider;\n\t}(baseProvider.BaseProvider));\n\texports.EtherscanProvider = EtherscanProvider;\n\n\t});\n\n\tvar etherscanProvider$1 = unwrapExports(etherscanProvider);\n\tvar etherscanProvider_1 = etherscanProvider.EtherscanProvider;\n\n\tvar fallbackProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tvar __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {\n\t    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n\t    return new (P || (P = Promise))(function (resolve, reject) {\n\t        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n\t        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n\t        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n\t        step((generator = generator.apply(thisArg, _arguments || [])).next());\n\t    });\n\t};\n\tvar __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {\n\t    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n\t    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n\t    function verb(n) { return function (v) { return step([n, v]); }; }\n\t    function step(op) {\n\t        if (f) throw new TypeError("Generator is already executing.");\n\t        while (_) try {\n\t            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n\t            if (y = 0, t) op = [op[0] & 2, t.value];\n\t            switch (op[0]) {\n\t                case 0: case 1: t = op; break;\n\t                case 4: _.label++; return { value: op[1], done: false };\n\t                case 5: _.label++; y = op[1]; op = [0]; continue;\n\t                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n\t                default:\n\t                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n\t                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n\t                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n\t                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n\t                    if (t[2]) _.ops.pop();\n\t                    _.trys.pop(); continue;\n\t            }\n\t            op = body.call(thisArg, _);\n\t        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n\t        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n\t    }\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\tfunction now() { return (new Date()).getTime(); }\n\t// Returns to network as long as all agree, or null if any is null.\n\t// Throws an error if any two networks do not match.\n\tfunction checkNetworks(networks) {\n\t    var result = null;\n\t    for (var i = 0; i < networks.length; i++) {\n\t        var network = networks[i];\n\t        // Null! We do not know our network; bail.\n\t        if (network == null) {\n\t            return null;\n\t        }\n\t        if (result) {\n\t            // Make sure the network matches the previous networks\n\t            if (!(result.name === network.name && result.chainId === network.chainId &&\n\t                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\t                logger.throwArgumentError("provider mismatch", "networks", networks);\n\t            }\n\t        }\n\t        else {\n\t            result = network;\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction median(values, maxDelta) {\n\t    values = values.slice().sort();\n\t    var middle = Math.floor(values.length / 2);\n\t    // Odd length; take the middle\n\t    if (values.length % 2) {\n\t        return values[middle];\n\t    }\n\t    // Even length; take the average of the two middle\n\t    var a = values[middle - 1], b = values[middle];\n\t    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n\t        return null;\n\t    }\n\t    return (a + b) / 2;\n\t}\n\tfunction serialize(value) {\n\t    if (value === null) {\n\t        return "null";\n\t    }\n\t    else if (typeof (value) === "number" || typeof (value) === "boolean") {\n\t        return JSON.stringify(value);\n\t    }\n\t    else if (typeof (value) === "string") {\n\t        return value;\n\t    }\n\t    else if (lib$2.BigNumber.isBigNumber(value)) {\n\t        return value.toString();\n\t    }\n\t    else if (Array.isArray(value)) {\n\t        return JSON.stringify(value.map(function (i) { return serialize(i); }));\n\t    }\n\t    else if (typeof (value) === "object") {\n\t        var keys = Object.keys(value);\n\t        keys.sort();\n\t        return "{" + keys.map(function (key) {\n\t            var v = value[key];\n\t            if (typeof (v) === "function") {\n\t                v = "[function]";\n\t            }\n\t            else {\n\t                v = serialize(v);\n\t            }\n\t            return JSON.stringify(key) + ":" + v;\n\t        }).join(",") + "}";\n\t    }\n\t    throw new Error("unknown value type: " + typeof (value));\n\t}\n\t// Next request ID to use for emitting debug info\n\tvar nextRid = 1;\n\t;\n\tfunction stall(duration) {\n\t    var cancel = null;\n\t    var timer = null;\n\t    var promise = (new Promise(function (resolve) {\n\t        cancel = function () {\n\t            if (timer) {\n\t                clearTimeout(timer);\n\t                timer = null;\n\t            }\n\t            resolve();\n\t        };\n\t        timer = setTimeout(cancel, duration);\n\t    }));\n\t    var wait = function (func) {\n\t        promise = promise.then(func);\n\t        return promise;\n\t    };\n\t    function getPromise() {\n\t        return promise;\n\t    }\n\t    return { cancel: cancel, getPromise: getPromise, wait: wait };\n\t}\n\tvar ForwardErrors = [\n\t    lib.Logger.errors.CALL_EXCEPTION,\n\t    lib.Logger.errors.INSUFFICIENT_FUNDS,\n\t    lib.Logger.errors.NONCE_EXPIRED,\n\t    lib.Logger.errors.REPLACEMENT_UNDERPRICED,\n\t    lib.Logger.errors.UNPREDICTABLE_GAS_LIMIT\n\t];\n\tvar ForwardProperties = [\n\t    "address",\n\t    "args",\n\t    "errorArgs",\n\t    "errorSignature",\n\t    "method",\n\t    "transaction",\n\t];\n\t;\n\tfunction exposeDebugConfig(config, now) {\n\t    var result = {\n\t        weight: config.weight\n\t    };\n\t    Object.defineProperty(result, "provider", { get: function () { return config.provider; } });\n\t    if (config.start) {\n\t        result.start = config.start;\n\t    }\n\t    if (now) {\n\t        result.duration = (now - config.start);\n\t    }\n\t    if (config.done) {\n\t        if (config.error) {\n\t            result.error = config.error;\n\t        }\n\t        else {\n\t            result.result = config.result || null;\n\t        }\n\t    }\n\t    return result;\n\t}\n\tfunction normalizedTally(normalize, quorum) {\n\t    return function (configs) {\n\t        // Count the votes for each result\n\t        var tally = {};\n\t        configs.forEach(function (c) {\n\t            var value = normalize(c.result);\n\t            if (!tally[value]) {\n\t                tally[value] = { count: 0, result: c.result };\n\t            }\n\t            tally[value].count++;\n\t        });\n\t        // Check for a quorum on any given result\n\t        var keys = Object.keys(tally);\n\t        for (var i = 0; i < keys.length; i++) {\n\t            var check = tally[keys[i]];\n\t            if (check.count >= quorum) {\n\t                return check.result;\n\t            }\n\t        }\n\t        // No quroum\n\t        return undefined;\n\t    };\n\t}\n\tfunction getProcessFunc(provider, method, params) {\n\t    var normalize = serialize;\n\t    switch (method) {\n\t        case "getBlockNumber":\n\t            // Return the median value, unless there is (median + 1) is also\n\t            // present, in which case that is probably true and the median\n\t            // is going to be stale soon. In the event of a malicious node,\n\t            // the lie will be true soon enough.\n\t            return function (configs) {\n\t                var values = configs.map(function (c) { return c.result; });\n\t                // Get the median block number\n\t                var blockNumber = median(configs.map(function (c) { return c.result; }), 2);\n\t                if (blockNumber == null) {\n\t                    return undefined;\n\t                }\n\t                blockNumber = Math.ceil(blockNumber);\n\t                // If the next block height is present, its prolly safe to use\n\t                if (values.indexOf(blockNumber + 1) >= 0) {\n\t                    blockNumber++;\n\t                }\n\t                // Don\'t ever roll back the blockNumber\n\t                if (blockNumber >= provider._highestBlockNumber) {\n\t                    provider._highestBlockNumber = blockNumber;\n\t                }\n\t                return provider._highestBlockNumber;\n\t            };\n\t        case "getGasPrice":\n\t            // Return the middle (round index up) value, similar to median\n\t            // but do not average even entries and choose the higher.\n\t            // Malicious actors must compromise 50% of the nodes to lie.\n\t            return function (configs) {\n\t                var values = configs.map(function (c) { return c.result; });\n\t                values.sort();\n\t                return values[Math.floor(values.length / 2)];\n\t            };\n\t        case "getEtherPrice":\n\t            // Returns the median price. Malicious actors must compromise at\n\t            // least 50% of the nodes to lie (in a meaningful way).\n\t            return function (configs) {\n\t                return median(configs.map(function (c) { return c.result; }));\n\t            };\n\t        // No additional normalizing required; serialize is enough\n\t        case "getBalance":\n\t        case "getTransactionCount":\n\t        case "getCode":\n\t        case "getStorageAt":\n\t        case "call":\n\t        case "estimateGas":\n\t        case "getLogs":\n\t            break;\n\t        // We drop the confirmations from transactions as it is approximate\n\t        case "getTransaction":\n\t        case "getTransactionReceipt":\n\t            normalize = function (tx) {\n\t                if (tx == null) {\n\t                    return null;\n\t                }\n\t                tx = lib$3.shallowCopy(tx);\n\t                tx.confirmations = -1;\n\t                return serialize(tx);\n\t            };\n\t            break;\n\t        // We drop the confirmations from transactions as it is approximate\n\t        case "getBlock":\n\t            // We drop the confirmations from transactions as it is approximate\n\t            if (params.includeTransactions) {\n\t                normalize = function (block) {\n\t                    if (block == null) {\n\t                        return null;\n\t                    }\n\t                    block = lib$3.shallowCopy(block);\n\t                    block.transactions = block.transactions.map(function (tx) {\n\t                        tx = lib$3.shallowCopy(tx);\n\t                        tx.confirmations = -1;\n\t                        return tx;\n\t                    });\n\t                    return serialize(block);\n\t                };\n\t            }\n\t            else {\n\t                normalize = function (block) {\n\t                    if (block == null) {\n\t                        return null;\n\t                    }\n\t                    return serialize(block);\n\t                };\n\t            }\n\t            break;\n\t        default:\n\t            throw new Error("unknown method: " + method);\n\t    }\n\t    // Return the result if and only if the expected quorum is\n\t    // satisfied and agreed upon for the final result.\n\t    return normalizedTally(normalize, provider.quorum);\n\t}\n\t// If we are doing a blockTag query, we need to make sure the backend is\n\t// caught up to the FallbackProvider, before sending a request to it.\n\tfunction waitForSync(config, blockNumber) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var provider;\n\t        return __generator(this, function (_a) {\n\t            provider = (config.provider);\n\t            if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n\t                return [2 /*return*/, provider];\n\t            }\n\t            return [2 /*return*/, lib$l.poll(function () {\n\t                    return new Promise(function (resolve, reject) {\n\t                        setTimeout(function () {\n\t                            // We are synced\n\t                            if (provider.blockNumber >= blockNumber) {\n\t                                return resolve(provider);\n\t                            }\n\t                            // We\'re done; just quit\n\t                            if (config.cancelled) {\n\t                                return resolve(null);\n\t                            }\n\t                            // Try again, next block\n\t                            return resolve(undefined);\n\t                        }, 0);\n\t                    });\n\t                }, { oncePoll: provider })];\n\t        });\n\t    });\n\t}\n\tfunction getRunner(config, currentBlockNumber, method, params) {\n\t    return __awaiter(this, void 0, void 0, function () {\n\t        var provider, _a, filter;\n\t        return __generator(this, function (_b) {\n\t            switch (_b.label) {\n\t                case 0:\n\t                    provider = config.provider;\n\t                    _a = method;\n\t                    switch (_a) {\n\t                        case "getBlockNumber": return [3 /*break*/, 1];\n\t                        case "getGasPrice": return [3 /*break*/, 1];\n\t                        case "getEtherPrice": return [3 /*break*/, 2];\n\t                        case "getBalance": return [3 /*break*/, 3];\n\t                        case "getTransactionCount": return [3 /*break*/, 3];\n\t                        case "getCode": return [3 /*break*/, 3];\n\t                        case "getStorageAt": return [3 /*break*/, 6];\n\t                        case "getBlock": return [3 /*break*/, 9];\n\t                        case "call": return [3 /*break*/, 12];\n\t                        case "estimateGas": return [3 /*break*/, 12];\n\t                        case "getTransaction": return [3 /*break*/, 15];\n\t                        case "getTransactionReceipt": return [3 /*break*/, 15];\n\t                        case "getLogs": return [3 /*break*/, 16];\n\t                    }\n\t                    return [3 /*break*/, 19];\n\t                case 1: return [2 /*return*/, provider[method]()];\n\t                case 2:\n\t                    if (provider.getEtherPrice) {\n\t                        return [2 /*return*/, provider.getEtherPrice()];\n\t                    }\n\t                    return [3 /*break*/, 19];\n\t                case 3:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 5];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 4:\n\t                    provider = _b.sent();\n\t                    _b.label = 5;\n\t                case 5: return [2 /*return*/, provider[method](params.address, params.blockTag || "latest")];\n\t                case 6:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 8];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 7:\n\t                    provider = _b.sent();\n\t                    _b.label = 8;\n\t                case 8: return [2 /*return*/, provider.getStorageAt(params.address, params.position, params.blockTag || "latest")];\n\t                case 9:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 11];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 10:\n\t                    provider = _b.sent();\n\t                    _b.label = 11;\n\t                case 11: return [2 /*return*/, provider[(params.includeTransactions ? "getBlockWithTransactions" : "getBlock")](params.blockTag || params.blockHash)];\n\t                case 12:\n\t                    if (!(params.blockTag && lib$1.isHexString(params.blockTag))) return [3 /*break*/, 14];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 13:\n\t                    provider = _b.sent();\n\t                    _b.label = 14;\n\t                case 14: return [2 /*return*/, provider[method](params.transaction)];\n\t                case 15: return [2 /*return*/, provider[method](params.transactionHash)];\n\t                case 16:\n\t                    filter = params.filter;\n\t                    if (!((filter.fromBlock && lib$1.isHexString(filter.fromBlock)) || (filter.toBlock && lib$1.isHexString(filter.toBlock)))) return [3 /*break*/, 18];\n\t                    return [4 /*yield*/, waitForSync(config, currentBlockNumber)];\n\t                case 17:\n\t                    provider = _b.sent();\n\t                    _b.label = 18;\n\t                case 18: return [2 /*return*/, provider.getLogs(filter)];\n\t                case 19: return [2 /*return*/, logger.throwError("unknown method error", lib.Logger.errors.UNKNOWN_ERROR, {\n\t                        method: method,\n\t                        params: params\n\t                    })];\n\t            }\n\t        });\n\t    });\n\t}\n\tvar FallbackProvider = /** @class */ (function (_super) {\n\t    __extends(FallbackProvider, _super);\n\t    function FallbackProvider(providers, quorum) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, FallbackProvider);\n\t        if (providers.length === 0) {\n\t            logger.throwArgumentError("missing providers", "providers", providers);\n\t        }\n\t        var providerConfigs = providers.map(function (configOrProvider, index) {\n\t            if (lib$b.Provider.isProvider(configOrProvider)) {\n\t                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout: 750, priority: 1 });\n\t            }\n\t            var config = lib$3.shallowCopy(configOrProvider);\n\t            if (config.priority == null) {\n\t                config.priority = 1;\n\t            }\n\t            if (config.stallTimeout == null) {\n\t                config.stallTimeout = 750;\n\t            }\n\t            if (config.weight == null) {\n\t                config.weight = 1;\n\t            }\n\t            var weight = config.weight;\n\t            if (weight % 1 || weight > 512 || weight < 1) {\n\t                logger.throwArgumentError("invalid weight; must be integer in [1, 512]", "providers[" + index + "].weight", weight);\n\t            }\n\t            return Object.freeze(config);\n\t        });\n\t        var total = providerConfigs.reduce(function (accum, c) { return (accum + c.weight); }, 0);\n\t        if (quorum == null) {\n\t            quorum = total / 2;\n\t        }\n\t        else if (quorum > total) {\n\t            logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);\n\t        }\n\t        // Are all providers\' networks are known\n\t        var networkOrReady = checkNetworks(providerConfigs.map(function (c) { return (c.provider).network; }));\n\t        // Not all networks are known; we must stall\n\t        if (networkOrReady == null) {\n\t            networkOrReady = new Promise(function (resolve, reject) {\n\t                setTimeout(function () {\n\t                    _this.detectNetwork().then(resolve, reject);\n\t                }, 0);\n\t            });\n\t        }\n\t        _this = _super.call(this, networkOrReady) || this;\n\t        // Preserve a copy, so we do not get mutated\n\t        lib$3.defineReadOnly(_this, "providerConfigs", Object.freeze(providerConfigs));\n\t        lib$3.defineReadOnly(_this, "quorum", quorum);\n\t        _this._highestBlockNumber = -1;\n\t        return _this;\n\t    }\n\t    FallbackProvider.prototype.detectNetwork = function () {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var networks;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0: return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) { return c.provider.getNetwork(); }))];\n\t                    case 1:\n\t                        networks = _a.sent();\n\t                        return [2 /*return*/, checkNetworks(networks)];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    FallbackProvider.prototype.perform = function (method, params) {\n\t        return __awaiter(this, void 0, void 0, function () {\n\t            var results, i_1, result, processFunc, configs, currentBlockNumber, i, first, _loop_1, this_1, state_1;\n\t            var _this = this;\n\t            return __generator(this, function (_a) {\n\t                switch (_a.label) {\n\t                    case 0:\n\t                        if (!(method === "sendTransaction")) return [3 /*break*/, 2];\n\t                        return [4 /*yield*/, Promise.all(this.providerConfigs.map(function (c) {\n\t                                return c.provider.sendTransaction(params.signedTransaction).then(function (result) {\n\t                                    return result.hash;\n\t                                }, function (error) {\n\t                                    return error;\n\t                                });\n\t                            }))];\n\t                    case 1:\n\t                        results = _a.sent();\n\t                        // Any success is good enough (other errors are likely "already seen" errors\n\t                        for (i_1 = 0; i_1 < results.length; i_1++) {\n\t                            result = results[i_1];\n\t                            if (typeof (result) === "string") {\n\t                                return [2 /*return*/, result];\n\t                            }\n\t                        }\n\t                        // They were all an error; pick the first error\n\t                        throw results[0];\n\t                    case 2:\n\t                        if (!(this._highestBlockNumber === -1 && method !== "getBlockNumber")) return [3 /*break*/, 4];\n\t                        return [4 /*yield*/, this.getBlockNumber()];\n\t                    case 3:\n\t                        _a.sent();\n\t                        _a.label = 4;\n\t                    case 4:\n\t                        processFunc = getProcessFunc(this, method, params);\n\t                        configs = browser$6.shuffled(this.providerConfigs.map(lib$3.shallowCopy));\n\t                        configs.sort(function (a, b) { return (a.priority - b.priority); });\n\t                        currentBlockNumber = this._highestBlockNumber;\n\t                        i = 0;\n\t                        first = true;\n\t                        _loop_1 = function () {\n\t                            var t0, inflightWeight, _loop_2, waiting, results, result, errors;\n\t                            return __generator(this, function (_a) {\n\t                                switch (_a.label) {\n\t                                    case 0:\n\t                                        t0 = now();\n\t                                        inflightWeight = configs.filter(function (c) { return (c.runner && ((t0 - c.start) < c.stallTimeout)); })\n\t                                            .reduce(function (accum, c) { return (accum + c.weight); }, 0);\n\t                                        _loop_2 = function () {\n\t                                            var config = configs[i++];\n\t                                            var rid = nextRid++;\n\t                                            config.start = now();\n\t                                            config.staller = stall(config.stallTimeout);\n\t                                            config.staller.wait(function () { config.staller = null; });\n\t                                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {\n\t                                                config.done = true;\n\t                                                config.result = result;\n\t                                                if (_this.listenerCount("debug")) {\n\t                                                    _this.emit("debug", {\n\t                                                        action: "request",\n\t                                                        rid: rid,\n\t                                                        backend: exposeDebugConfig(config, now()),\n\t                                                        request: { method: method, params: lib$3.deepCopy(params) },\n\t                                                        provider: _this\n\t                                                    });\n\t                                                }\n\t                                            }, function (error) {\n\t                                                config.done = true;\n\t                                                config.error = error;\n\t                                                if (_this.listenerCount("debug")) {\n\t                                                    _this.emit("debug", {\n\t                                                        action: "request",\n\t                                                        rid: rid,\n\t                                                        backend: exposeDebugConfig(config, now()),\n\t                                                        request: { method: method, params: lib$3.deepCopy(params) },\n\t                                                        provider: _this\n\t                                                    });\n\t                                                }\n\t                                            });\n\t                                            if (this_1.listenerCount("debug")) {\n\t                                                this_1.emit("debug", {\n\t                                                    action: "request",\n\t                                                    rid: rid,\n\t                                                    backend: exposeDebugConfig(config, null),\n\t                                                    request: { method: method, params: lib$3.deepCopy(params) },\n\t                                                    provider: this_1\n\t                                                });\n\t                                            }\n\t                                            inflightWeight += config.weight;\n\t                                        };\n\t                                        // Start running enough to meet quorum\n\t                                        while (inflightWeight < this_1.quorum && i < configs.length) {\n\t                                            _loop_2();\n\t                                        }\n\t                                        waiting = [];\n\t                                        configs.forEach(function (c) {\n\t                                            if (c.done || !c.runner) {\n\t                                                return;\n\t                                            }\n\t                                            waiting.push(c.runner);\n\t                                            if (c.staller) {\n\t                                                waiting.push(c.staller.getPromise());\n\t                                            }\n\t                                        });\n\t                                        if (!waiting.length) return [3 /*break*/, 2];\n\t                                        return [4 /*yield*/, Promise.race(waiting)];\n\t                                    case 1:\n\t                                        _a.sent();\n\t                                        _a.label = 2;\n\t                                    case 2:\n\t                                        results = configs.filter(function (c) { return (c.done && c.error == null); });\n\t                                        if (!(results.length >= this_1.quorum)) return [3 /*break*/, 5];\n\t                                        result = processFunc(results);\n\t                                        if (result !== undefined) {\n\t                                            // Shut down any stallers\n\t                                            configs.forEach(function (c) {\n\t                                                if (c.staller) {\n\t                                                    c.staller.cancel();\n\t                                                }\n\t                                                c.cancelled = true;\n\t                                            });\n\t                                            return [2 /*return*/, { value: result }];\n\t                                        }\n\t                                        if (!!first) return [3 /*break*/, 4];\n\t                                        return [4 /*yield*/, stall(100).getPromise()];\n\t                                    case 3:\n\t                                        _a.sent();\n\t                                        _a.label = 4;\n\t                                    case 4:\n\t                                        first = false;\n\t                                        _a.label = 5;\n\t                                    case 5:\n\t                                        errors = configs.reduce(function (accum, c) {\n\t                                            if (!c.done || c.error == null) {\n\t                                                return accum;\n\t                                            }\n\t                                            var code = (c.error).code;\n\t                                            if (ForwardErrors.indexOf(code) >= 0) {\n\t                                                if (!accum[code]) {\n\t                                                    accum[code] = { error: c.error, weight: 0 };\n\t                                                }\n\t                                                accum[code].weight += c.weight;\n\t                                            }\n\t                                            return accum;\n\t                                        }, ({}));\n\t                                        Object.keys(errors).forEach(function (errorCode) {\n\t                                            var tally = errors[errorCode];\n\t                                            if (tally.weight < _this.quorum) {\n\t                                                return;\n\t                                            }\n\t                                            // Shut down any stallers\n\t                                            configs.forEach(function (c) {\n\t                                                if (c.staller) {\n\t                                                    c.staller.cancel();\n\t                                                }\n\t                                                c.cancelled = true;\n\t                                            });\n\t                                            var e = (tally.error);\n\t                                            var props = {};\n\t                                            ForwardProperties.forEach(function (name) {\n\t                                                if (e[name] == null) {\n\t                                                    return;\n\t                                                }\n\t                                                props[name] = e[name];\n\t                                            });\n\t                                            logger.throwError(e.reason || e.message, errorCode, props);\n\t                                        });\n\t                                        // All configs have run to completion; we will never get more data\n\t                                        if (configs.filter(function (c) { return !c.done; }).length === 0) {\n\t                                            return [2 /*return*/, "break"];\n\t                                        }\n\t                                        return [2 /*return*/];\n\t                                }\n\t                            });\n\t                        };\n\t                        this_1 = this;\n\t                        _a.label = 5;\n\t                    case 5:\n\t                        if (false) {}\n\t                        return [5 /*yield**/, _loop_1()];\n\t                    case 6:\n\t                        state_1 = _a.sent();\n\t                        if (typeof state_1 === "object")\n\t                            return [2 /*return*/, state_1.value];\n\t                        if (state_1 === "break")\n\t                            return [3 /*break*/, 7];\n\t                        return [3 /*break*/, 5];\n\t                    case 7:\n\t                        // Shut down any stallers; shouldn\'t be any\n\t                        configs.forEach(function (c) {\n\t                            if (c.staller) {\n\t                                c.staller.cancel();\n\t                            }\n\t                            c.cancelled = true;\n\t                        });\n\t                        return [2 /*return*/, logger.throwError("failed to meet quorum", lib.Logger.errors.SERVER_ERROR, {\n\t                                method: method,\n\t                                params: params,\n\t                                //results: configs.map((c) => c.result),\n\t                                //errors: configs.map((c) => c.error),\n\t                                results: configs.map(function (c) { return exposeDebugConfig(c); }),\n\t                                provider: this\n\t                            })];\n\t                }\n\t            });\n\t        });\n\t    };\n\t    return FallbackProvider;\n\t}(baseProvider.BaseProvider));\n\texports.FallbackProvider = FallbackProvider;\n\n\t});\n\n\tvar fallbackProvider$1 = unwrapExports(fallbackProvider);\n\tvar fallbackProvider_1 = fallbackProvider.FallbackProvider;\n\n\t"use strict";\n\tvar IpcProvider = null;\n\n\n\tvar browserIpcProvider = {\n\t\tIpcProvider: IpcProvider\n\t};\n\n\tvar infuraProvider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar defaultProjectId = "84842078b09946638c03157f83405213";\n\tvar InfuraProvider = /** @class */ (function (_super) {\n\t    __extends(InfuraProvider, _super);\n\t    function InfuraProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    InfuraProvider.getWebSocketProvider = function (network, apiKey) {\n\t        var provider = new InfuraProvider(network, apiKey);\n\t        var connection = provider.connection;\n\t        if (connection.password) {\n\t            logger.throwError("INFURA WebSocket project secrets unsupported", lib.Logger.errors.UNSUPPORTED_OPERATION, {\n\t                operation: "InfuraProvider.getWebSocketProvider()"\n\t            });\n\t        }\n\t        var url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");\n\t        return new websocketProvider.WebSocketProvider(url, network);\n\t    };\n\t    InfuraProvider.getApiKey = function (apiKey) {\n\t        var apiKeyObj = {\n\t            apiKey: defaultProjectId,\n\t            projectId: defaultProjectId,\n\t            projectSecret: null\n\t        };\n\t        if (apiKey == null) {\n\t            return apiKeyObj;\n\t        }\n\t        if (typeof (apiKey) === "string") {\n\t            apiKeyObj.projectId = apiKey;\n\t        }\n\t        else if (apiKey.projectSecret != null) {\n\t            logger.assertArgument((typeof (apiKey.projectId) === "string"), "projectSecret requires a projectId", "projectId", apiKey.projectId);\n\t            logger.assertArgument((typeof (apiKey.projectSecret) === "string"), "invalid projectSecret", "projectSecret", "[REDACTED]");\n\t            apiKeyObj.projectId = apiKey.projectId;\n\t            apiKeyObj.projectSecret = apiKey.projectSecret;\n\t        }\n\t        else if (apiKey.projectId) {\n\t            apiKeyObj.projectId = apiKey.projectId;\n\t        }\n\t        apiKeyObj.apiKey = apiKeyObj.projectId;\n\t        return apiKeyObj;\n\t    };\n\t    InfuraProvider.getUrl = function (network, apiKey) {\n\t        var host = null;\n\t        switch (network ? network.name : "unknown") {\n\t            case "homestead":\n\t                host = "mainnet.infura.io";\n\t                break;\n\t            case "ropsten":\n\t                host = "ropsten.infura.io";\n\t                break;\n\t            case "rinkeby":\n\t                host = "rinkeby.infura.io";\n\t                break;\n\t            case "kovan":\n\t                host = "kovan.infura.io";\n\t                break;\n\t            case "goerli":\n\t                host = "goerli.infura.io";\n\t                break;\n\t            default:\n\t                logger.throwError("unsupported network", lib.Logger.errors.INVALID_ARGUMENT, {\n\t                    argument: "network",\n\t                    value: network\n\t                });\n\t        }\n\t        var connection = {\n\t            url: ("https:/" + "/" + host + "/v3/" + apiKey.projectId),\n\t            throttleCallback: function (attempt, url) {\n\t                if (apiKey.projectId === defaultProjectId) {\n\t                    formatter.showThrottleMessage();\n\t                }\n\t                return Promise.resolve(true);\n\t            }\n\t        };\n\t        if (apiKey.projectSecret != null) {\n\t            connection.user = "";\n\t            connection.password = apiKey.projectSecret;\n\t        }\n\t        return connection;\n\t    };\n\t    return InfuraProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.InfuraProvider = InfuraProvider;\n\n\t});\n\n\tvar infuraProvider$1 = unwrapExports(infuraProvider);\n\tvar infuraProvider_1 = infuraProvider.InfuraProvider;\n\n\tvar nodesmithProvider = createCommonjsModule(function (module, exports) {\n\t/* istanbul ignore file */\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t// Special API key provided by Nodesmith for ethers.js\n\tvar defaultApiKey = "ETHERS_JS_SHARED";\n\tvar NodesmithProvider = /** @class */ (function (_super) {\n\t    __extends(NodesmithProvider, _super);\n\t    function NodesmithProvider() {\n\t        return _super !== null && _super.apply(this, arguments) || this;\n\t    }\n\t    NodesmithProvider.getApiKey = function (apiKey) {\n\t        if (apiKey && typeof (apiKey) !== "string") {\n\t            logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);\n\t        }\n\t        return apiKey || defaultApiKey;\n\t    };\n\t    NodesmithProvider.getUrl = function (network, apiKey) {\n\t        logger.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");\n\t        var host = null;\n\t        switch (network.name) {\n\t            case "homestead":\n\t                host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";\n\t                break;\n\t            case "ropsten":\n\t                host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";\n\t                break;\n\t            case "rinkeby":\n\t                host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";\n\t                break;\n\t            case "goerli":\n\t                host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";\n\t                break;\n\t            case "kovan":\n\t                host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";\n\t                break;\n\t            default:\n\t                logger.throwArgumentError("unsupported network", "network", arguments[0]);\n\t        }\n\t        return (host + "?apiKey=" + apiKey);\n\t    };\n\t    return NodesmithProvider;\n\t}(urlJsonRpcProvider.UrlJsonRpcProvider));\n\texports.NodesmithProvider = NodesmithProvider;\n\n\t});\n\n\tvar nodesmithProvider$1 = unwrapExports(nodesmithProvider);\n\tvar nodesmithProvider_1 = nodesmithProvider.NodesmithProvider;\n\n\tvar web3Provider = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {\n\t    var extendStatics = function (d, b) {\n\t        extendStatics = Object.setPrototypeOf ||\n\t            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n\t            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n\t        return extendStatics(d, b);\n\t    };\n\t    return function (d, b) {\n\t        extendStatics(d, b);\n\t        function __() { this.constructor = d; }\n\t        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n\t    };\n\t})();\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\n\tvar _nextId = 1;\n\tfunction buildWeb3LegacyFetcher(provider, sendFunc) {\n\t    return function (method, params) {\n\t        // Metamask complains about eth_sign (and on some versions hangs)\n\t        if (method == "eth_sign" && provider.isMetaMask) {\n\t            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n\t            method = "personal_sign";\n\t            params = [params[1], params[0]];\n\t        }\n\t        var request = {\n\t            method: method,\n\t            params: params,\n\t            id: (_nextId++),\n\t            jsonrpc: "2.0"\n\t        };\n\t        return new Promise(function (resolve, reject) {\n\t            sendFunc(request, function (error, result) {\n\t                if (error) {\n\t                    return reject(error);\n\t                }\n\t                if (result.error) {\n\t                    var error_1 = new Error(result.error.message);\n\t                    error_1.code = result.error.code;\n\t                    error_1.data = result.error.data;\n\t                    return reject(error_1);\n\t                }\n\t                resolve(result.result);\n\t            });\n\t        });\n\t    };\n\t}\n\tfunction buildEip1193Fetcher(provider) {\n\t    return function (method, params) {\n\t        if (params == null) {\n\t            params = [];\n\t        }\n\t        // Metamask complains about eth_sign (and on some versions hangs)\n\t        if (method == "eth_sign" && provider.isMetaMask) {\n\t            // https://github.com/ethereum/go-ethereum/wiki/Management-APIs#personal_sign\n\t            method = "personal_sign";\n\t            params = [params[1], params[0]];\n\t        }\n\t        return provider.request({ method: method, params: params });\n\t    };\n\t}\n\tvar Web3Provider = /** @class */ (function (_super) {\n\t    __extends(Web3Provider, _super);\n\t    function Web3Provider(provider, network) {\n\t        var _newTarget = this.constructor;\n\t        var _this = this;\n\t        logger.checkNew(_newTarget, Web3Provider);\n\t        if (provider == null) {\n\t            logger.throwArgumentError("missing provider", "provider", provider);\n\t        }\n\t        var path = null;\n\t        var jsonRpcFetchFunc = null;\n\t        var subprovider = null;\n\t        if (typeof (provider) === "function") {\n\t            path = "unknown:";\n\t            jsonRpcFetchFunc = provider;\n\t        }\n\t        else {\n\t            path = provider.host || provider.path || "";\n\t            if (!path && provider.isMetaMask) {\n\t                path = "metamask";\n\t            }\n\t            subprovider = provider;\n\t            if (provider.request) {\n\t                if (path === "") {\n\t                    path = "eip-1193:";\n\t                }\n\t                jsonRpcFetchFunc = buildEip1193Fetcher(provider);\n\t            }\n\t            else if (provider.sendAsync) {\n\t                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));\n\t            }\n\t            else if (provider.send) {\n\t                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));\n\t            }\n\t            else {\n\t                logger.throwArgumentError("unsupported provider", "provider", provider);\n\t            }\n\t            if (!path) {\n\t                path = "unknown:";\n\t            }\n\t        }\n\t        _this = _super.call(this, path, network) || this;\n\t        lib$3.defineReadOnly(_this, "jsonRpcFetchFunc", jsonRpcFetchFunc);\n\t        lib$3.defineReadOnly(_this, "provider", subprovider);\n\t        return _this;\n\t    }\n\t    Web3Provider.prototype.send = function (method, params) {\n\t        return this.jsonRpcFetchFunc(method, params);\n\t    };\n\t    return Web3Provider;\n\t}(jsonRpcProvider.JsonRpcProvider));\n\texports.Web3Provider = Web3Provider;\n\n\t});\n\n\tvar web3Provider$1 = unwrapExports(web3Provider);\n\tvar web3Provider_1 = web3Provider.Web3Provider;\n\n\tvar lib$m = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\texports.Provider = lib$b.Provider;\n\n\texports.getNetwork = lib$k.getNetwork;\n\n\texports.BaseProvider = baseProvider.BaseProvider;\n\texports.Resolver = baseProvider.Resolver;\n\n\texports.AlchemyProvider = alchemyProvider.AlchemyProvider;\n\n\texports.CloudflareProvider = cloudflareProvider.CloudflareProvider;\n\n\texports.EtherscanProvider = etherscanProvider.EtherscanProvider;\n\n\texports.FallbackProvider = fallbackProvider.FallbackProvider;\n\n\texports.IpcProvider = browserIpcProvider.IpcProvider;\n\n\texports.InfuraProvider = infuraProvider.InfuraProvider;\n\n\texports.JsonRpcProvider = jsonRpcProvider.JsonRpcProvider;\n\texports.JsonRpcSigner = jsonRpcProvider.JsonRpcSigner;\n\n\texports.NodesmithProvider = nodesmithProvider.NodesmithProvider;\n\n\texports.StaticJsonRpcProvider = urlJsonRpcProvider.StaticJsonRpcProvider;\n\texports.UrlJsonRpcProvider = urlJsonRpcProvider.UrlJsonRpcProvider;\n\n\texports.Web3Provider = web3Provider.Web3Provider;\n\n\texports.WebSocketProvider = websocketProvider.WebSocketProvider;\n\n\texports.Formatter = formatter.Formatter;\n\n\n\tvar logger = new lib.Logger(_version$I.version);\n\t////////////////////////\n\t// Helper Functions\n\tfunction getDefaultProvider(network, options) {\n\t    if (network == null) {\n\t        network = "homestead";\n\t    }\n\t    // If passed a URL, figure out the right type of provider based on the scheme\n\t    if (typeof (network) === "string") {\n\t        // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?\n\t        // Handle http and ws (and their secure variants)\n\t        var match = network.match(/^(ws|http)s?:/i);\n\t        if (match) {\n\t            switch (match[1]) {\n\t                case "http":\n\t                    return new jsonRpcProvider.JsonRpcProvider(network);\n\t                case "ws":\n\t                    return new websocketProvider.WebSocketProvider(network);\n\t                default:\n\t                    logger.throwArgumentError("unsupported URL scheme", "network", network);\n\t            }\n\t        }\n\t    }\n\t    var n = lib$k.getNetwork(network);\n\t    if (!n || !n._defaultProvider) {\n\t        logger.throwError("unsupported getDefaultProvider network", lib.Logger.errors.NETWORK_ERROR, {\n\t            operation: "getDefaultProvider",\n\t            network: network\n\t        });\n\t    }\n\t    return n._defaultProvider({\n\t        FallbackProvider: fallbackProvider.FallbackProvider,\n\t        AlchemyProvider: alchemyProvider.AlchemyProvider,\n\t        CloudflareProvider: cloudflareProvider.CloudflareProvider,\n\t        EtherscanProvider: etherscanProvider.EtherscanProvider,\n\t        InfuraProvider: infuraProvider.InfuraProvider,\n\t        JsonRpcProvider: jsonRpcProvider.JsonRpcProvider,\n\t        NodesmithProvider: nodesmithProvider.NodesmithProvider,\n\t        Web3Provider: web3Provider.Web3Provider,\n\t        IpcProvider: browserIpcProvider.IpcProvider,\n\t    }, options);\n\t}\n\texports.getDefaultProvider = getDefaultProvider;\n\n\t});\n\n\tvar index$m = unwrapExports(lib$m);\n\tvar lib_1$m = lib$m.Provider;\n\tvar lib_2$k = lib$m.getNetwork;\n\tvar lib_3$g = lib$m.BaseProvider;\n\tvar lib_4$c = lib$m.Resolver;\n\tvar lib_5$b = lib$m.AlchemyProvider;\n\tvar lib_6$7 = lib$m.CloudflareProvider;\n\tvar lib_7$6 = lib$m.EtherscanProvider;\n\tvar lib_8$5 = lib$m.FallbackProvider;\n\tvar lib_9$5 = lib$m.IpcProvider;\n\tvar lib_10$3 = lib$m.InfuraProvider;\n\tvar lib_11$2 = lib$m.JsonRpcProvider;\n\tvar lib_12$2 = lib$m.JsonRpcSigner;\n\tvar lib_13$2 = lib$m.NodesmithProvider;\n\tvar lib_14$1 = lib$m.StaticJsonRpcProvider;\n\tvar lib_15$1 = lib$m.UrlJsonRpcProvider;\n\tvar lib_16$1 = lib$m.Web3Provider;\n\tvar lib_17 = lib$m.WebSocketProvider;\n\tvar lib_18 = lib$m.Formatter;\n\tvar lib_19 = lib$m.getDefaultProvider;\n\n\tvar lib$n = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\n\n\tvar regexBytes = new RegExp("^bytes([0-9]+)$");\n\tvar regexNumber = new RegExp("^(u?int)([0-9]*)$");\n\tvar regexArray = new RegExp("^(.*)\\\\[([0-9]*)\\\\]$");\n\tvar Zeros = "0000000000000000000000000000000000000000000000000000000000000000";\n\tfunction _pack(type, value, isArray) {\n\t    switch (type) {\n\t        case "address":\n\t            if (isArray) {\n\t                return lib$1.zeroPad(value, 32);\n\t            }\n\t            return lib$1.arrayify(value);\n\t        case "string":\n\t            return lib$8.toUtf8Bytes(value);\n\t        case "bytes":\n\t            return lib$1.arrayify(value);\n\t        case "bool":\n\t            value = (value ? "0x01" : "0x00");\n\t            if (isArray) {\n\t                return lib$1.zeroPad(value, 32);\n\t            }\n\t            return lib$1.arrayify(value);\n\t    }\n\t    var match = type.match(regexNumber);\n\t    if (match) {\n\t        //let signed = (match[1] === "int")\n\t        var size = parseInt(match[2] || "256");\n\t        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {\n\t            throw new Error("invalid number type - " + type);\n\t        }\n\t        if (isArray) {\n\t            size = 256;\n\t        }\n\t        value = lib$2.BigNumber.from(value).toTwos(size);\n\t        return lib$1.zeroPad(value, size / 8);\n\t    }\n\t    match = type.match(regexBytes);\n\t    if (match) {\n\t        var size = parseInt(match[1]);\n\t        if (String(size) !== match[1] || size === 0 || size > 32) {\n\t            throw new Error("invalid bytes type - " + type);\n\t        }\n\t        if (lib$1.arrayify(value).byteLength !== size) {\n\t            throw new Error("invalid value for " + type);\n\t        }\n\t        if (isArray) {\n\t            return lib$1.arrayify((value + Zeros).substring(0, 66));\n\t        }\n\t        return value;\n\t    }\n\t    match = type.match(regexArray);\n\t    if (match && Array.isArray(value)) {\n\t        var baseType_1 = match[1];\n\t        var count = parseInt(match[2] || String(value.length));\n\t        if (count != value.length) {\n\t            throw new Error("invalid value for " + type);\n\t        }\n\t        var result_1 = [];\n\t        value.forEach(function (value) {\n\t            result_1.push(_pack(baseType_1, value, true));\n\t        });\n\t        return lib$1.concat(result_1);\n\t    }\n\t    throw new Error("invalid type - " + type);\n\t}\n\t// @TODO: Array Enum\n\tfunction pack(types, values) {\n\t    if (types.length != values.length) {\n\t        throw new Error("type/value count mismatch");\n\t    }\n\t    var tight = [];\n\t    types.forEach(function (type, index) {\n\t        tight.push(_pack(type, values[index]));\n\t    });\n\t    return lib$1.hexlify(lib$1.concat(tight));\n\t}\n\texports.pack = pack;\n\tfunction keccak256(types, values) {\n\t    return lib$4.keccak256(pack(types, values));\n\t}\n\texports.keccak256 = keccak256;\n\tfunction sha256(types, values) {\n\t    return browser.sha256(pack(types, values));\n\t}\n\texports.sha256 = sha256;\n\n\t});\n\n\tvar index$n = unwrapExports(lib$n);\n\tvar lib_1$n = lib$n.pack;\n\tvar lib_2$l = lib$n.keccak256;\n\tvar lib_3$h = lib$n.sha256;\n\n\tvar _version$K = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "units/5.0.4";\n\n\t});\n\n\tvar _version$L = unwrapExports(_version$K);\n\tvar _version_1$n = _version$K.version;\n\n\tvar lib$o = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\n\n\tvar logger = new lib.Logger(_version$K.version);\n\tvar names = [\n\t    "wei",\n\t    "kwei",\n\t    "mwei",\n\t    "gwei",\n\t    "szabo",\n\t    "finney",\n\t    "ether",\n\t];\n\t// Some environments have issues with RegEx that contain back-tracking, so we cannot\n\t// use them.\n\tfunction commify(value) {\n\t    var comps = String(value).split(".");\n\t    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === "." || value === "-.") {\n\t        logger.throwArgumentError("invalid value", "value", value);\n\t    }\n\t    // Make sure we have at least one whole digit (0 if none)\n\t    var whole = comps[0];\n\t    var negative = "";\n\t    if (whole.substring(0, 1) === "-") {\n\t        negative = "-";\n\t        whole = whole.substring(1);\n\t    }\n\t    // Make sure we have at least 1 whole digit with no leading zeros\n\t    while (whole.substring(0, 1) === "0") {\n\t        whole = whole.substring(1);\n\t    }\n\t    if (whole === "") {\n\t        whole = "0";\n\t    }\n\t    var suffix = "";\n\t    if (comps.length === 2) {\n\t        suffix = "." + (comps[1] || "0");\n\t    }\n\t    while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {\n\t        suffix = suffix.substring(0, suffix.length - 1);\n\t    }\n\t    var formatted = [];\n\t    while (whole.length) {\n\t        if (whole.length <= 3) {\n\t            formatted.unshift(whole);\n\t            break;\n\t        }\n\t        else {\n\t            var index = whole.length - 3;\n\t            formatted.unshift(whole.substring(index));\n\t            whole = whole.substring(0, index);\n\t        }\n\t    }\n\t    return negative + formatted.join(",") + suffix;\n\t}\n\texports.commify = commify;\n\tfunction formatUnits(value, unitName) {\n\t    if (typeof (unitName) === "string") {\n\t        var index = names.indexOf(unitName);\n\t        if (index !== -1) {\n\t            unitName = 3 * index;\n\t        }\n\t    }\n\t    return lib$2.formatFixed(value, (unitName != null) ? unitName : 18);\n\t}\n\texports.formatUnits = formatUnits;\n\tfunction parseUnits(value, unitName) {\n\t    if (typeof (unitName) === "string") {\n\t        var index = names.indexOf(unitName);\n\t        if (index !== -1) {\n\t            unitName = 3 * index;\n\t        }\n\t    }\n\t    return lib$2.parseFixed(value, (unitName != null) ? unitName : 18);\n\t}\n\texports.parseUnits = parseUnits;\n\tfunction formatEther(wei) {\n\t    return formatUnits(wei, 18);\n\t}\n\texports.formatEther = formatEther;\n\tfunction parseEther(ether) {\n\t    return parseUnits(ether, 18);\n\t}\n\texports.parseEther = parseEther;\n\n\t});\n\n\tvar index$o = unwrapExports(lib$o);\n\tvar lib_1$o = lib$o.commify;\n\tvar lib_2$m = lib$o.formatUnits;\n\tvar lib_3$i = lib$o.parseUnits;\n\tvar lib_4$d = lib$o.formatEther;\n\tvar lib_5$c = lib$o.parseEther;\n\n\tvar utils$3 = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result["default"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\texports.AbiCoder = lib$a.AbiCoder;\n\texports.checkResultErrors = lib$a.checkResultErrors;\n\texports.defaultAbiCoder = lib$a.defaultAbiCoder;\n\texports.EventFragment = lib$a.EventFragment;\n\texports.FormatTypes = lib$a.FormatTypes;\n\texports.Fragment = lib$a.Fragment;\n\texports.FunctionFragment = lib$a.FunctionFragment;\n\texports.Indexed = lib$a.Indexed;\n\texports.Interface = lib$a.Interface;\n\texports.LogDescription = lib$a.LogDescription;\n\texports.ParamType = lib$a.ParamType;\n\texports.TransactionDescription = lib$a.TransactionDescription;\n\n\texports.getAddress = lib$6.getAddress;\n\texports.getCreate2Address = lib$6.getCreate2Address;\n\texports.getContractAddress = lib$6.getContractAddress;\n\texports.getIcapAddress = lib$6.getIcapAddress;\n\texports.isAddress = lib$6.isAddress;\n\tvar base64 = __importStar(browser$8);\n\texports.base64 = base64;\n\n\texports.base58 = lib$e.Base58;\n\n\texports.arrayify = lib$1.arrayify;\n\texports.concat = lib$1.concat;\n\texports.hexDataSlice = lib$1.hexDataSlice;\n\texports.hexDataLength = lib$1.hexDataLength;\n\texports.hexlify = lib$1.hexlify;\n\texports.hexStripZeros = lib$1.hexStripZeros;\n\texports.hexValue = lib$1.hexValue;\n\texports.hexZeroPad = lib$1.hexZeroPad;\n\texports.isBytes = lib$1.isBytes;\n\texports.isBytesLike = lib$1.isBytesLike;\n\texports.isHexString = lib$1.isHexString;\n\texports.joinSignature = lib$1.joinSignature;\n\texports.zeroPad = lib$1.zeroPad;\n\texports.splitSignature = lib$1.splitSignature;\n\texports.stripZeros = lib$1.stripZeros;\n\n\texports.hashMessage = lib$9.hashMessage;\n\texports.id = lib$9.id;\n\texports.isValidName = lib$9.isValidName;\n\texports.namehash = lib$9.namehash;\n\n\texports.defaultPath = lib$h.defaultPath;\n\texports.entropyToMnemonic = lib$h.entropyToMnemonic;\n\texports.HDNode = lib$h.HDNode;\n\texports.isValidMnemonic = lib$h.isValidMnemonic;\n\texports.mnemonicToEntropy = lib$h.mnemonicToEntropy;\n\texports.mnemonicToSeed = lib$h.mnemonicToSeed;\n\n\texports.getJsonWalletAddress = lib$i.getJsonWalletAddress;\n\n\texports.keccak256 = lib$4.keccak256;\n\n\texports.Logger = lib.Logger;\n\n\texports.computeHmac = browser.computeHmac;\n\texports.ripemd160 = browser.ripemd160;\n\texports.sha256 = browser.sha256;\n\texports.sha512 = browser.sha512;\n\n\texports.solidityKeccak256 = lib$n.keccak256;\n\texports.solidityPack = lib$n.pack;\n\texports.soliditySha256 = lib$n.sha256;\n\n\texports.randomBytes = browser$6.randomBytes;\n\texports.shuffled = browser$6.shuffled;\n\n\texports.checkProperties = lib$3.checkProperties;\n\texports.deepCopy = lib$3.deepCopy;\n\texports.defineReadOnly = lib$3.defineReadOnly;\n\texports.getStatic = lib$3.getStatic;\n\texports.resolveProperties = lib$3.resolveProperties;\n\texports.shallowCopy = lib$3.shallowCopy;\n\tvar RLP = __importStar(lib$5);\n\texports.RLP = RLP;\n\n\texports.computePublicKey = lib$f.computePublicKey;\n\texports.recoverPublicKey = lib$f.recoverPublicKey;\n\texports.SigningKey = lib$f.SigningKey;\n\n\texports.formatBytes32String = lib$8.formatBytes32String;\n\texports.nameprep = lib$8.nameprep;\n\texports.parseBytes32String = lib$8.parseBytes32String;\n\texports._toEscapedUtf8String = lib$8._toEscapedUtf8String;\n\texports.toUtf8Bytes = lib$8.toUtf8Bytes;\n\texports.toUtf8CodePoints = lib$8.toUtf8CodePoints;\n\texports.toUtf8String = lib$8.toUtf8String;\n\texports.Utf8ErrorFuncs = lib$8.Utf8ErrorFuncs;\n\n\texports.computeAddress = lib$g.computeAddress;\n\texports.parseTransaction = lib$g.parse;\n\texports.recoverAddress = lib$g.recoverAddress;\n\texports.serializeTransaction = lib$g.serialize;\n\n\texports.commify = lib$o.commify;\n\texports.formatEther = lib$o.formatEther;\n\texports.parseEther = lib$o.parseEther;\n\texports.formatUnits = lib$o.formatUnits;\n\texports.parseUnits = lib$o.parseUnits;\n\n\texports.verifyMessage = lib$j.verifyMessage;\n\n\texports._fetchData = lib$l._fetchData;\n\texports.fetchJson = lib$l.fetchJson;\n\texports.poll = lib$l.poll;\n\t////////////////////////\n\t// Enums\n\tvar sha2_2 = browser;\n\texports.SupportedAlgorithm = sha2_2.SupportedAlgorithm;\n\tvar strings_2 = lib$8;\n\texports.UnicodeNormalizationForm = strings_2.UnicodeNormalizationForm;\n\texports.Utf8ErrorReason = strings_2.Utf8ErrorReason;\n\n\t});\n\n\tvar utils$4 = unwrapExports(utils$3);\n\tvar utils_1$3 = utils$3.AbiCoder;\n\tvar utils_2$1 = utils$3.checkResultErrors;\n\tvar utils_3$1 = utils$3.defaultAbiCoder;\n\tvar utils_4$1 = utils$3.EventFragment;\n\tvar utils_5$1 = utils$3.FormatTypes;\n\tvar utils_6 = utils$3.Fragment;\n\tvar utils_7 = utils$3.FunctionFragment;\n\tvar utils_8 = utils$3.Indexed;\n\tvar utils_9 = utils$3.Interface;\n\tvar utils_10 = utils$3.LogDescription;\n\tvar utils_11 = utils$3.ParamType;\n\tvar utils_12 = utils$3.TransactionDescription;\n\tvar utils_13 = utils$3.getAddress;\n\tvar utils_14 = utils$3.getCreate2Address;\n\tvar utils_15 = utils$3.getContractAddress;\n\tvar utils_16 = utils$3.getIcapAddress;\n\tvar utils_17 = utils$3.isAddress;\n\tvar utils_18 = utils$3.base64;\n\tvar utils_19 = utils$3.base58;\n\tvar utils_20 = utils$3.arrayify;\n\tvar utils_21 = utils$3.concat;\n\tvar utils_22 = utils$3.hexDataSlice;\n\tvar utils_23 = utils$3.hexDataLength;\n\tvar utils_24 = utils$3.hexlify;\n\tvar utils_25 = utils$3.hexStripZeros;\n\tvar utils_26 = utils$3.hexValue;\n\tvar utils_27 = utils$3.hexZeroPad;\n\tvar utils_28 = utils$3.isBytes;\n\tvar utils_29 = utils$3.isBytesLike;\n\tvar utils_30 = utils$3.isHexString;\n\tvar utils_31 = utils$3.joinSignature;\n\tvar utils_32 = utils$3.zeroPad;\n\tvar utils_33 = utils$3.splitSignature;\n\tvar utils_34 = utils$3.stripZeros;\n\tvar utils_35 = utils$3.hashMessage;\n\tvar utils_36 = utils$3.id;\n\tvar utils_37 = utils$3.isValidName;\n\tvar utils_38 = utils$3.namehash;\n\tvar utils_39 = utils$3.defaultPath;\n\tvar utils_40 = utils$3.entropyToMnemonic;\n\tvar utils_41 = utils$3.HDNode;\n\tvar utils_42 = utils$3.isValidMnemonic;\n\tvar utils_43 = utils$3.mnemonicToEntropy;\n\tvar utils_44 = utils$3.mnemonicToSeed;\n\tvar utils_45 = utils$3.getJsonWalletAddress;\n\tvar utils_46 = utils$3.keccak256;\n\tvar utils_47 = utils$3.Logger;\n\tvar utils_48 = utils$3.computeHmac;\n\tvar utils_49 = utils$3.ripemd160;\n\tvar utils_50 = utils$3.sha256;\n\tvar utils_51 = utils$3.sha512;\n\tvar utils_52 = utils$3.solidityKeccak256;\n\tvar utils_53 = utils$3.solidityPack;\n\tvar utils_54 = utils$3.soliditySha256;\n\tvar utils_55 = utils$3.randomBytes;\n\tvar utils_56 = utils$3.shuffled;\n\tvar utils_57 = utils$3.checkProperties;\n\tvar utils_58 = utils$3.deepCopy;\n\tvar utils_59 = utils$3.defineReadOnly;\n\tvar utils_60 = utils$3.getStatic;\n\tvar utils_61 = utils$3.resolveProperties;\n\tvar utils_62 = utils$3.shallowCopy;\n\tvar utils_63 = utils$3.RLP;\n\tvar utils_64 = utils$3.computePublicKey;\n\tvar utils_65 = utils$3.recoverPublicKey;\n\tvar utils_66 = utils$3.SigningKey;\n\tvar utils_67 = utils$3.formatBytes32String;\n\tvar utils_68 = utils$3.nameprep;\n\tvar utils_69 = utils$3.parseBytes32String;\n\tvar utils_70 = utils$3._toEscapedUtf8String;\n\tvar utils_71 = utils$3.toUtf8Bytes;\n\tvar utils_72 = utils$3.toUtf8CodePoints;\n\tvar utils_73 = utils$3.toUtf8String;\n\tvar utils_74 = utils$3.Utf8ErrorFuncs;\n\tvar utils_75 = utils$3.computeAddress;\n\tvar utils_76 = utils$3.parseTransaction;\n\tvar utils_77 = utils$3.recoverAddress;\n\tvar utils_78 = utils$3.serializeTransaction;\n\tvar utils_79 = utils$3.commify;\n\tvar utils_80 = utils$3.formatEther;\n\tvar utils_81 = utils$3.parseEther;\n\tvar utils_82 = utils$3.formatUnits;\n\tvar utils_83 = utils$3.parseUnits;\n\tvar utils_84 = utils$3.verifyMessage;\n\tvar utils_85 = utils$3._fetchData;\n\tvar utils_86 = utils$3.fetchJson;\n\tvar utils_87 = utils$3.poll;\n\tvar utils_88 = utils$3.SupportedAlgorithm;\n\tvar utils_89 = utils$3.UnicodeNormalizationForm;\n\tvar utils_90 = utils$3.Utf8ErrorReason;\n\n\tvar _version$M = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\texports.version = "ethers/5.0.14";\n\n\t});\n\n\tvar _version$N = unwrapExports(_version$M);\n\tvar _version_1$o = _version$M.version;\n\n\tvar ethers = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result["default"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\n\texports.Contract = lib$d.Contract;\n\texports.ContractFactory = lib$d.ContractFactory;\n\n\texports.BigNumber = lib$2.BigNumber;\n\texports.FixedNumber = lib$2.FixedNumber;\n\n\texports.Signer = lib$c.Signer;\n\texports.VoidSigner = lib$c.VoidSigner;\n\n\texports.Wallet = lib$j.Wallet;\n\tvar constants = __importStar(lib$7);\n\texports.constants = constants;\n\tvar providers = __importStar(lib$m);\n\texports.providers = providers;\n\tvar providers_1 = lib$m;\n\texports.getDefaultProvider = providers_1.getDefaultProvider;\n\n\texports.Wordlist = browser$4.Wordlist;\n\texports.wordlists = browser$4.wordlists;\n\tvar utils = __importStar(utils$3);\n\texports.utils = utils;\n\n\texports.errors = lib.ErrorCode;\n\t////////////////////////\n\t// Compile-Time Constants\n\t// This is generated by "npm run dist"\n\n\texports.version = _version$M.version;\n\tvar logger = new lib.Logger(_version$M.version);\n\texports.logger = logger;\n\n\t});\n\n\tvar ethers$1 = unwrapExports(ethers);\n\tvar ethers_1 = ethers.Contract;\n\tvar ethers_2 = ethers.ContractFactory;\n\tvar ethers_3 = ethers.BigNumber;\n\tvar ethers_4 = ethers.FixedNumber;\n\tvar ethers_5 = ethers.Signer;\n\tvar ethers_6 = ethers.VoidSigner;\n\tvar ethers_7 = ethers.Wallet;\n\tvar ethers_8 = ethers.constants;\n\tvar ethers_9 = ethers.providers;\n\tvar ethers_10 = ethers.getDefaultProvider;\n\tvar ethers_11 = ethers.Wordlist;\n\tvar ethers_12 = ethers.wordlists;\n\tvar ethers_13 = ethers.utils;\n\tvar ethers_14 = ethers.errors;\n\tvar ethers_15 = ethers.version;\n\tvar ethers_16 = ethers.logger;\n\n\tvar lib$p = createCommonjsModule(function (module, exports) {\n\t"use strict";\n\tvar __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {\n\t    if (mod && mod.__esModule) return mod;\n\t    var result = {};\n\t    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n\t    result["default"] = mod;\n\t    return result;\n\t};\n\tObject.defineProperty(exports, "__esModule", { value: true });\n\t// To modify this file, you must update ./admin/cmds/update-exports.js\n\tvar ethers$1 = __importStar(ethers);\n\texports.ethers = ethers$1;\n\ttry {\n\t    var anyGlobal = window;\n\t    if (anyGlobal._ethers == null) {\n\t        anyGlobal._ethers = ethers$1;\n\t    }\n\t}\n\tcatch (error) { }\n\tvar ethers_1 = ethers;\n\texports.Signer = ethers_1.Signer;\n\texports.Wallet = ethers_1.Wallet;\n\texports.VoidSigner = ethers_1.VoidSigner;\n\texports.getDefaultProvider = ethers_1.getDefaultProvider;\n\texports.providers = ethers_1.providers;\n\texports.Contract = ethers_1.Contract;\n\texports.ContractFactory = ethers_1.ContractFactory;\n\texports.BigNumber = ethers_1.BigNumber;\n\texports.FixedNumber = ethers_1.FixedNumber;\n\texports.constants = ethers_1.constants;\n\texports.errors = ethers_1.errors;\n\texports.logger = ethers_1.logger;\n\texports.utils = ethers_1.utils;\n\texports.wordlists = ethers_1.wordlists;\n\t////////////////////////\n\t// Compile-Time Constants\n\texports.version = ethers_1.version;\n\texports.Wordlist = ethers_1.Wordlist;\n\n\t});\n\n\tvar index$p = unwrapExports(lib$p);\n\tvar lib_1$p = lib$p.ethers;\n\tvar lib_2$n = lib$p.Signer;\n\tvar lib_3$j = lib$p.Wallet;\n\tvar lib_4$e = lib$p.VoidSigner;\n\tvar lib_5$d = lib$p.getDefaultProvider;\n\tvar lib_6$8 = lib$p.providers;\n\tvar lib_7$7 = lib$p.Contract;\n\tvar lib_8$6 = lib$p.ContractFactory;\n\tvar lib_9$6 = lib$p.BigNumber;\n\tvar lib_10$4 = lib$p.FixedNumber;\n\tvar lib_11$3 = lib$p.constants;\n\tvar lib_12$3 = lib$p.errors;\n\tvar lib_13$3 = lib$p.logger;\n\tvar lib_14$2 = lib$p.utils;\n\tvar lib_15$2 = lib$p.wordlists;\n\tvar lib_16$2 = lib$p.version;\n\tvar lib_17$1 = lib$p.Wordlist;\n\n\texports.BigNumber = lib_9$6;\n\texports.Contract = lib_7$7;\n\texports.ContractFactory = lib_8$6;\n\texports.FixedNumber = lib_10$4;\n\texports.Signer = lib_2$n;\n\texports.VoidSigner = lib_4$e;\n\texports.Wallet = lib_3$j;\n\texports.Wordlist = lib_17$1;\n\texports.constants = lib_11$3;\n\texports.default = index$p;\n\texports.errors = lib_12$3;\n\texports.ethers = lib_1$p;\n\texports.getDefaultProvider = lib_5$d;\n\texports.logger = lib_13$3;\n\texports.providers = lib_6$8;\n\texports.utils = lib_14$2;\n\texports.version = lib_16$2;\n\texports.wordlists = lib_15$2;\n\n\tObject.defineProperty(exports, \'__esModule\', { value: true });\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba"), __webpack_require__("4362")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9ub2RlX21vZHVsZXMvZXRoZXJzL2Rpc3QvZXRoZXJzLnVtZC5qcz9lYmM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsQ0FBQyxLQUE0RDtBQUM3RCxDQUFDLFNBQ3NEO0FBQ3ZELENBQUMsMkJBQTJCOztBQUU1Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFlBQVksRUFBRTtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUJBQXlCLG1CQUFtQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0QkFBNEI7QUFDOUM7QUFDQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsZ0JBQWdCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjOzs7O0FBSTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9CQUFvQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxvQ0FBb0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHdDQUF3QyxFQUFFO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsNEJBQTRCLEVBQUU7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGdEQUFnRCxFQUFFO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQseUNBQXlDLEVBQUU7QUFDdEcsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkJBQTZCLEVBQUU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELHlDQUF5QyxFQUFFO0FBQ3RHLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLHlFQUF5RSw2QkFBNkIsRUFBRTtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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RCxzQkFBc0IsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGlEQUFpRCxFQUFFO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsaURBQWlELEVBQUU7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNB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LFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRiw4QkFBOEIsRUFBRTtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxTQUFTLGNBQWM7QUFDdkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsY0FBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCLCtDQUErQztBQUMvQztBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBLDJCQUEyQjtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsb0JBQW9CO0FBQy9DOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLGdCQUFnQjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxxRkFBcUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYzs7O0FBRzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsWUFBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTixrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2QkFBNkI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNkJBQTZCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0NBQWdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0JBQW9CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkJBQTZCLFFBQVE7QUFDckM7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUFPQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxlQUFlO0FBQ3JCLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFdBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7O0FBTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsRUFBRTs7QUFFRjs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7O0FBSUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhOztBQUViLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7O0FBT0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUEscUJBQXFC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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0MsaUJBQWlCLEVBQUU7QUFDeEYsOEJBQThCLHVEQUF1RDtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBLEVBQUU7QUFDRiwrQ0FBK0MsY0FBYzs7Ozs7Ozs7Ozs7Ozs7O0FBZTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUscUJBQXFCLEVBQUU7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixFQUFFLEVBQUU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsYUFBYSxFQUFFO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLHlFQUF5RSxtQkFBbUIsRUFBRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUscUJBQXFCLEVBQUU7QUFDaEc7QUFDQSxtRUFBbUUsYUFBYSxFQUFFO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHlCQUF5QixFQUFFO0FBQ3REO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwyQkFBMkIsc0NBQXNDLEVBQUU7QUFDbkU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLDJCQUEyQixxQ0FBcUMsRUFBRTtBQUNsRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjOzs7QUFHN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7QUFDN0Q7O0FBRUEsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYzs7Ozs7Ozs7O0FBUzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyw0QkFBNEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsd0JBQXdCLEVBQUU7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdURBQXVEO0FBQ2xFLFdBQVcsd0RBQXdEO0FBQ25FLFdBQVcsMENBQTBDO0FBQ3JELFlBQVksNEJBQTRCO0FBQ3hDLFlBQVksNEJBQTRCO0FBQ3hDLGFBQWEsNkJBQTZCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RDtBQUNoRCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQixFQUFFO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILCtCQUErQjtBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SCxpQkFBaUI7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QjtBQUM5QztBQUNBO0FBQ0EsRUFBRTtBQUNGLCtDQUErQyxjQUFjOzs7O0FBSTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGNBQWM7O0FBRTdEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjOzs7Ozs7QUFNN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjOzs7O0FBSTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtDQUErQyxjQUFjO0FBQzdEOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYzs7QUFFN0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtDQUErQyxjQUFjOztBQUU3RCxDQUFDIiwiZmlsZSI6ImViYzkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG5cdChnbG9iYWwgPSBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuZXRoZXJzID0ge30pKTtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG5cdHZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5cdGZ1bmN0aW9uIGNvbW1vbmpzUmVxdWlyZSAoKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdEeW5hbWljIHJlcXVpcmVzIGFyZSBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSByb2xsdXAtcGx1Z2luLWNvbW1vbmpzJyk7XG5cdH1cblxuXHRmdW5jdGlvbiB1bndyYXBFeHBvcnRzICh4KSB7XG5cdFx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZuLCBtb2R1bGUpIHtcblx0XHRyZXR1cm4gbW9kdWxlID0geyBleHBvcnRzOiB7fSB9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDanNFeHBvcnRGcm9tTmFtZXNwYWNlIChuKSB7XG5cdFx0cmV0dXJuIG4gJiYgblsnZGVmYXVsdCddIHx8IG47XG5cdH1cblxuXHR2YXIgX25vZGVSZXNvbHZlX2VtcHR5ID0ge307XG5cblx0dmFyIF9ub2RlUmVzb2x2ZV9lbXB0eSQxID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRcdCdkZWZhdWx0JzogX25vZGVSZXNvbHZlX2VtcHR5XG5cdH0pO1xuXG5cdHZhciByZXF1aXJlJCQwID0gZ2V0Q2pzRXhwb3J0RnJvbU5hbWVzcGFjZShfbm9kZVJlc29sdmVfZW1wdHkkMSk7XG5cblx0dmFyIGJuID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQgICd1c2Ugc3RyaWN0JztcblxuXHQgIC8vIFV0aWxzXG5cdCAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuXHQgICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcblx0ICB9XG5cblx0ICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuXHQgIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG5cdCAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuXHQgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG5cdCAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuXHQgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuXHQgIH1cblxuXHQgIC8vIEJOXG5cblx0ICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICB0aGlzLndvcmRzID0gbnVsbDtcblx0ICAgIHRoaXMubGVuZ3RoID0gMDtcblxuXHQgICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcblx0ICAgIHRoaXMucmVkID0gbnVsbDtcblxuXHQgICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG5cdCAgICAgICAgZW5kaWFuID0gYmFzZTtcblx0ICAgICAgICBiYXNlID0gMTA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcblx0ICB9IGVsc2Uge1xuXHQgICAgZXhwb3J0cy5CTiA9IEJOO1xuXHQgIH1cblxuXHQgIEJOLkJOID0gQk47XG5cdCAgQk4ud29yZFNpemUgPSAyNjtcblxuXHQgIHZhciBCdWZmZXI7XG5cdCAgdHJ5IHtcblx0ICAgIEJ1ZmZlciA9IHJlcXVpcmUkJDAuQnVmZmVyO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICB9XG5cblx0ICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG5cdCAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcblx0ICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG5cdCAgfTtcblxuXHQgIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcblx0ICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcblx0ICAgIHJldHVybiByaWdodDtcblx0ICB9O1xuXG5cdCAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuXHQgICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuXHQgICAgcmV0dXJuIHJpZ2h0O1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcblx0ICAgICAgYmFzZSA9IDE2O1xuXHQgICAgfVxuXHQgICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG5cdCAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcblx0ICAgIHZhciBzdGFydCA9IDA7XG5cdCAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcblx0ICAgICAgc3RhcnQrKztcblx0ICAgIH1cblxuXHQgICAgaWYgKGJhc2UgPT09IDE2KSB7XG5cdCAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG5cdCAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIG51bWJlciA9IC1udW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcblx0ICAgICAgdGhpcy53b3JkcyA9IFtcblx0ICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcblx0ICAgICAgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAyO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcblx0ICAgICAgdGhpcy53b3JkcyA9IFtcblx0ICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgMVxuXHQgICAgICBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuXHQgICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcblx0ICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuXHQgICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzID0gWyAwIF07XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcblx0ICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaiwgdztcblx0ICAgIHZhciBvZmYgPSAwO1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuXHQgICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG5cdCAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuXHQgICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgICAgaisrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcblx0ICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcblx0ICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG9mZiArPSAyNDtcblx0ICAgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgICBqKys7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBwYXJzZUhleCAoc3RyLCBzdGFydCwgZW5kKSB7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuXHQgICAgICByIDw8PSA0O1xuXG5cdCAgICAgIC8vICdhJyAtICdmJ1xuXHQgICAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KSB7XG5cdCAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cblx0ICAgICAgLy8gJ0EnIC0gJ0YnXG5cdCAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKSB7XG5cdCAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cblx0ICAgICAgLy8gJzAnIC0gJzknXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgciB8PSBjICYgMHhmO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0KSB7XG5cdCAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuXHQgICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcblx0ICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaiwgdztcblx0ICAgIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuXHQgICAgdmFyIG9mZiA9IDA7XG5cdCAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuXHQgICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG5cdCAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcblx0ICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuXHQgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgIGlmIChvZmYgPj0gMjYpIHtcblx0ICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgaisrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG5cdCAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG5cdCAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuXHQgICAgICByICo9IG11bDtcblxuXHQgICAgICAvLyAnYSdcblx0ICAgICAgaWYgKGMgPj0gNDkpIHtcblx0ICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuXHQgICAgICAvLyAnQSdcblx0ICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG5cdCAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cblx0ICAgICAgLy8gJzAnIC0gJzknXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgciArPSBjO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcblx0ICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuXHQgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuXHQgICAgdGhpcy5sZW5ndGggPSAxO1xuXG5cdCAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2Vcblx0ICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuXHQgICAgICBsaW1iTGVuKys7XG5cdCAgICB9XG5cdCAgICBsaW1iTGVuLS07XG5cdCAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cblx0ICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcblx0ICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG5cdCAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG5cdCAgICB2YXIgd29yZCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuXHQgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG5cdCAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG5cdCAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAobW9kICE9PSAwKSB7XG5cdCAgICAgIHZhciBwb3cgPSAxO1xuXHQgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG5cdCAgICAgICAgcG93ICo9IGJhc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmltdWxuKHBvdyk7XG5cdCAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcblx0ICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgfVxuXHQgICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcblx0ICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuXHQgICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuXHQgICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG5cdCAgICB0aGlzLmNvcHkocik7XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG5cdCAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcblx0ICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgIHRoaXMubGVuZ3RoLS07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG5cdCAgICAvLyAtMCA9IDBcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG5cdCAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+Jztcblx0ICB9O1xuXG5cdCAgLypcblxuXHQgIHZhciB6ZXJvcyA9IFtdO1xuXHQgIHZhciBncm91cFNpemVzID0gW107XG5cdCAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuXHQgIHZhciBzID0gJyc7XG5cdCAgdmFyIGkgPSAtMTtcblx0ICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcblx0ICAgIHplcm9zW2ldID0gcztcblx0ICAgIHMgKz0gJzAnO1xuXHQgIH1cblx0ICBncm91cFNpemVzWzBdID0gMDtcblx0ICBncm91cFNpemVzWzFdID0gMDtcblx0ICBncm91cEJhc2VzWzBdID0gMDtcblx0ICBncm91cEJhc2VzWzFdID0gMDtcblx0ICB2YXIgYmFzZSA9IDIgLSAxO1xuXHQgIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcblx0ICAgIHZhciBncm91cFNpemUgPSAwO1xuXHQgICAgdmFyIGdyb3VwQmFzZSA9IDE7XG5cdCAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuXHQgICAgICBncm91cEJhc2UgKj0gYmFzZTtcblx0ICAgICAgZ3JvdXBTaXplICs9IDE7XG5cdCAgICB9XG5cdCAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuXHQgICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcblx0ICB9XG5cblx0ICAqL1xuXG5cdCAgdmFyIHplcm9zID0gW1xuXHQgICAgJycsXG5cdCAgICAnMCcsXG5cdCAgICAnMDAnLFxuXHQgICAgJzAwMCcsXG5cdCAgICAnMDAwMCcsXG5cdCAgICAnMDAwMDAnLFxuXHQgICAgJzAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcblx0ICBdO1xuXG5cdCAgdmFyIGdyb3VwU2l6ZXMgPSBbXG5cdCAgICAwLCAwLFxuXHQgICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuXHQgICAgOCwgNywgNywgNywgNywgNiwgNixcblx0ICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG5cdCAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuXHQgICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuXHQgIF07XG5cblx0ICB2YXIgZ3JvdXBCYXNlcyA9IFtcblx0ICAgIDAsIDAsXG5cdCAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcblx0ICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG5cdCAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG5cdCAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcblx0ICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG5cdCAgXTtcblxuXHQgIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG5cdCAgICBiYXNlID0gYmFzZSB8fCAxMDtcblx0ICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG5cdCAgICB2YXIgb3V0O1xuXHQgICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG5cdCAgICAgIG91dCA9ICcnO1xuXHQgICAgICB2YXIgb2ZmID0gMDtcblx0ICAgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuXHQgICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBvZmYgKz0gMjtcblx0ICAgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgICBpLS07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcblx0ICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcblx0ICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG5cdCAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuXHQgICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcblx0ICAgICAgb3V0ID0gJyc7XG5cdCAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgICBjLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG5cdCAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcblx0ICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG5cdCAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG5cdCAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBvdXQgPSByICsgb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuXHQgICAgICAgIG91dCA9ICcwJyArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH1cblxuXHQgICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG5cdCAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuXHQgICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG5cdCAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcblx0ICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcblx0ICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG5cdCAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG5cdCAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cdCAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuXHQgICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuXHQgICAgdmFyIGIsIGk7XG5cdCAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcblx0ICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG5cdCAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXNbaV0gPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuXHQgICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuXHQgICAgICAgIHEuaXVzaHJuKDgpO1xuXG5cdCAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcblx0ICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcblx0ICAgICAgICBxLml1c2hybig4KTtcblxuXHQgICAgICAgIHJlc1tpXSA9IGI7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzW2ldID0gMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBpZiAoTWF0aC5jbHozMikge1xuXHQgICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG5cdCAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcblx0ICAgICAgdmFyIHQgPSB3O1xuXHQgICAgICB2YXIgciA9IDA7XG5cdCAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuXHQgICAgICAgIHIgKz0gMTM7XG5cdCAgICAgICAgdCA+Pj49IDEzO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4NDApIHtcblx0ICAgICAgICByICs9IDc7XG5cdCAgICAgICAgdCA+Pj49IDc7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHQgPj0gMHg4KSB7XG5cdCAgICAgICAgciArPSA0O1xuXHQgICAgICAgIHQgPj4+PSA0O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4MDIpIHtcblx0ICAgICAgICByICs9IDI7XG5cdCAgICAgICAgdCA+Pj49IDI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHIgKyB0O1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG5cdCAgICAvLyBTaG9ydC1jdXRcblx0ICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cblx0ICAgIHZhciB0ID0gdztcblx0ICAgIHZhciByID0gMDtcblx0ICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcblx0ICAgICAgciArPSAxMztcblx0ICAgICAgdCA+Pj49IDEzO1xuXHQgICAgfVxuXHQgICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcblx0ICAgICAgciArPSA3O1xuXHQgICAgICB0ID4+Pj0gNztcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcblx0ICAgICAgciArPSA0O1xuXHQgICAgICB0ID4+Pj0gNDtcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcblx0ICAgICAgciArPSAyO1xuXHQgICAgICB0ID4+Pj0gMjtcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcblx0ICAgICAgcisrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cblx0ICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcblx0ICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuXHQgICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuXHQgICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG5cdCAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG5cdCAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcblx0ICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuXHQgICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG5cdCAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHc7XG5cdCAgfVxuXG5cdCAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuXHQgIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuXHQgICAgdmFyIHIgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG5cdCAgICAgIHIgKz0gYjtcblx0ICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuXHQgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcblx0ICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuXHQgICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcblx0ICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuXHQgIH07XG5cblx0ICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcblx0ICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcblx0ICAgIHZhciBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG5cdCAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG5cdCAgICB2YXIgYTtcblx0ICAgIHZhciBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcyAhPT0gYSkge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuXHQgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuXHQgIH07XG5cblx0ICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuXHQgIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cblx0ICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG5cdCAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG5cdCAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG5cdCAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG5cdCAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG5cdCAgICAgIGJ5dGVzTmVlZGVkLS07XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG5cdCAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG5cdCAgfTtcblxuXHQgIC8vIFNldCBgYml0YCBvZiBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG5cdCAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG5cdCAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG5cdCAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cblx0ICAgIGlmICh2YWwpIHtcblx0ICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuXHQgICAgdmFyIHI7XG5cblx0ICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG5cdCAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG5cdCAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcblx0ICAgIHZhciBhLCBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSByID4+PiAyNjtcblx0ICAgIH1cblx0ICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSByID4+PiAyNjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuXHQgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcblx0ICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuXHQgICAgdmFyIHJlcztcblx0ICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuXHQgICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuXHQgICAgICBudW0ubmVnYXRpdmUgXj0gMTtcblx0ICAgICAgcmV0dXJuIHJlcztcblx0ICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gcmVzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcblx0ICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG5cdCAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG5cdCAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5pYWRkKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG5cdCAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuXHQgICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuXHQgICAgaWYgKGNtcCA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgICB0aGlzLndvcmRzWzBdID0gMDtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIGEgPiBiXG5cdCAgICB2YXIgYSwgYjtcblx0ICAgIGlmIChjbXAgPiAwKSB7XG5cdCAgICAgIGEgPSB0aGlzO1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IG51bTtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gciA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cdCAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgY2FycnkgPSByID4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuXHQgICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG5cdCAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG5cdCAgICBpZiAoYSAhPT0gdGhpcykge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcblx0ICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG5cdCAgICBvdXQubGVuZ3RoID0gbGVuO1xuXHQgICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuXHQgICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG5cdCAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuXHQgICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuXHQgICAgdmFyIHIgPSBhICogYjtcblxuXHQgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG5cdCAgICBvdXQud29yZHNbMF0gPSBsbztcblxuXHQgICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuXHQgICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG5cdCAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG5cdCAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG5cdCAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuXHQgICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcblx0ICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuXHQgICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG5cdCAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuXHQgICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuXHQgICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuXHQgICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgfVxuXHQgICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG5cdCAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBvdXQubGVuZ3RoLS07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvdXQuc3RyaXAoKTtcblx0ICB9XG5cblx0ICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuXHQgIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcblx0ICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuXHQgIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuXHQgICAgdmFyIGIgPSBudW0ud29yZHM7XG5cdCAgICB2YXIgbyA9IG91dC53b3Jkcztcblx0ICAgIHZhciBjID0gMDtcblx0ICAgIHZhciBsbztcblx0ICAgIHZhciBtaWQ7XG5cdCAgICB2YXIgaGk7XG5cdCAgICB2YXIgYTAgPSBhWzBdIHwgMDtcblx0ICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG5cdCAgICB2YXIgYTEgPSBhWzFdIHwgMDtcblx0ICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG5cdCAgICB2YXIgYTIgPSBhWzJdIHwgMDtcblx0ICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG5cdCAgICB2YXIgYTMgPSBhWzNdIHwgMDtcblx0ICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG5cdCAgICB2YXIgYTQgPSBhWzRdIHwgMDtcblx0ICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG5cdCAgICB2YXIgYTUgPSBhWzVdIHwgMDtcblx0ICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG5cdCAgICB2YXIgYTYgPSBhWzZdIHwgMDtcblx0ICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG5cdCAgICB2YXIgYTcgPSBhWzddIHwgMDtcblx0ICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG5cdCAgICB2YXIgYTggPSBhWzhdIHwgMDtcblx0ICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG5cdCAgICB2YXIgYTkgPSBhWzldIHwgMDtcblx0ICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG5cdCAgICB2YXIgYjAgPSBiWzBdIHwgMDtcblx0ICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG5cdCAgICB2YXIgYjEgPSBiWzFdIHwgMDtcblx0ICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG5cdCAgICB2YXIgYjIgPSBiWzJdIHwgMDtcblx0ICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG5cdCAgICB2YXIgYjMgPSBiWzNdIHwgMDtcblx0ICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG5cdCAgICB2YXIgYjQgPSBiWzRdIHwgMDtcblx0ICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG5cdCAgICB2YXIgYjUgPSBiWzVdIHwgMDtcblx0ICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG5cdCAgICB2YXIgYjYgPSBiWzZdIHwgMDtcblx0ICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG5cdCAgICB2YXIgYjcgPSBiWzddIHwgMDtcblx0ICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG5cdCAgICB2YXIgYjggPSBiWzhdIHwgMDtcblx0ICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG5cdCAgICB2YXIgYjkgPSBiWzldIHwgMDtcblx0ICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cblx0ICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG5cdCAgICBvdXQubGVuZ3RoID0gMTk7XG5cdCAgICAvKiBrID0gMCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG5cdCAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzAgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuXHQgICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcblx0ICAgIHcxICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAyICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcblx0ICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMyAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG5cdCAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzMgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDQgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuXHQgICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcblx0ICAgIHc0ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA1ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcblx0ICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gNiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG5cdCAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzYgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDcgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuXHQgICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcblx0ICAgIHc3ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA4ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcblx0ICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3OCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gOSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzkgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEwICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTEgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzExICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTIgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEzICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTQgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE0ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxNSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTUgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE2ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTcgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE3ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxOCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG5cdCAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTggJj0gMHgzZmZmZmZmO1xuXHQgICAgb1swXSA9IHcwO1xuXHQgICAgb1sxXSA9IHcxO1xuXHQgICAgb1syXSA9IHcyO1xuXHQgICAgb1szXSA9IHczO1xuXHQgICAgb1s0XSA9IHc0O1xuXHQgICAgb1s1XSA9IHc1O1xuXHQgICAgb1s2XSA9IHc2O1xuXHQgICAgb1s3XSA9IHc3O1xuXHQgICAgb1s4XSA9IHc4O1xuXHQgICAgb1s5XSA9IHc5O1xuXHQgICAgb1sxMF0gPSB3MTA7XG5cdCAgICBvWzExXSA9IHcxMTtcblx0ICAgIG9bMTJdID0gdzEyO1xuXHQgICAgb1sxM10gPSB3MTM7XG5cdCAgICBvWzE0XSA9IHcxNDtcblx0ICAgIG9bMTVdID0gdzE1O1xuXHQgICAgb1sxNl0gPSB3MTY7XG5cdCAgICBvWzE3XSA9IHcxNztcblx0ICAgIG9bMThdID0gdzE4O1xuXHQgICAgaWYgKGMgIT09IDApIHtcblx0ICAgICAgb1sxOV0gPSBjO1xuXHQgICAgICBvdXQubGVuZ3RoKys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb3V0O1xuXHQgIH07XG5cblx0ICAvLyBQb2x5ZmlsbCBjb21iXG5cdCAgaWYgKCFNYXRoLmltdWwpIHtcblx0ICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG5cdCAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgdmFyIGhuY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG5cdCAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcblx0ICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcblx0ICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG5cdCAgICAgIGhuY2FycnkgPSAwO1xuXHQgICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG5cdCAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcblx0ICAgICAgICB2YXIgaSA9IGsgLSBqO1xuXHQgICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG5cdCAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuXHQgICAgICAgIHZhciByID0gYSAqIGI7XG5cblx0ICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcblx0ICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG5cdCAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuXHQgICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcblx0ICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuXHQgICAgICB9XG5cdCAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuXHQgICAgICBjYXJyeSA9IG5jYXJyeTtcblx0ICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG91dC5sZW5ndGgtLTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG5cdCAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG5cdCAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcblx0ICAgIHZhciByZXM7XG5cdCAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuXHQgICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG5cdCAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG5cdCAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcblx0ICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cblx0ICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG5cdCAgICB0aGlzLnggPSB4O1xuXHQgICAgdGhpcy55ID0geTtcblx0ICB9XG5cblx0ICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuXHQgICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHQ7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuXHQgIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuXHQgICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG5cdCAgICB2YXIgcmIgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcblx0ICAgICAgeCA+Pj0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJiO1xuXHQgIH07XG5cblx0ICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcblx0ICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cblx0ICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuXHQgICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuXHQgICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG5cdCAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcblx0ICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cblx0ICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcblx0ICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuXHQgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuXHQgICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcblx0ICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuXHQgICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG5cdCAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuXHQgICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuXHQgICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG5cdCAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG5cdCAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG5cdCAgICAgICAgICBybyA9IHJ4O1xuXG5cdCAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG5cdCAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cblx0ICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG5cdCAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG5cdCAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuXHQgICAgICAgICAgaWYgKGogIT09IGwpIHtcblx0ICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG5cdCAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG5cdCAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG5cdCAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcblx0ICAgIHZhciBvZGQgPSBOICYgMTtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcblx0ICAgICAgaSsrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuXHQgICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcblx0ICAgICAgdmFyIHQgPSByd3NbaV07XG5cblx0ICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG5cdCAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuXHQgICAgICB0ID0gaXdzW2ldO1xuXG5cdCAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcblx0ICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuXHQgICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcblx0ICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcblx0ICAgICAgICBjYXJyeTtcblxuXHQgICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cblx0ICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcblx0ICAgICAgICBjYXJyeSA9IDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd3M7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuXHQgICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuXHQgICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcblx0ICAgIH1cblxuXHQgICAgLy8gUGFkIHdpdGggemVyb2VzXG5cdCAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG5cdCAgICAgIHJ3c1tpXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG5cdCAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuXHQgICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgcGhbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcGg7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcblx0ICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuXHQgICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuXHQgICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cblx0ICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG5cdCAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuXHQgICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG5cdCAgICBybXdzLmxlbmd0aCA9IE47XG5cblx0ICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcblx0ICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cblx0ICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcblx0ICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuXHQgICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuXHQgICAgICByd3N0W2ldID0gcng7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuXHQgICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcblx0ICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuXHQgICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cblx0ICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuXHQgICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG5cdCAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuXHQgICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcblx0ICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuXHQgICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuXHQgIH07XG5cblx0ICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG5cdCAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcblx0ICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG5cdCAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcblx0ICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICB9O1xuXG5cdCAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cblx0ICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cblx0ICAgIC8vIENhcnJ5XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcblx0ICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcblx0ICAgICAgY2FycnkgPj49IDI2O1xuXHQgICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG5cdCAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuXHQgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gYHRoaXNgICogYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG5cdCAgfTtcblxuXHQgIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG5cdCAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG5cdCAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcblx0ICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuXHQgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuXHQgICAgdmFyIHJlcyA9IHRoaXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuXHQgICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuXHQgICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcblx0ICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cblx0ICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG5cdCAgICB2YXIgciA9IGJpdHMgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXHQgICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcblx0ICAgIHZhciBpO1xuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICB2YXIgY2FycnkgPSAwO1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcblx0ICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcblx0ICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjYXJyeSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzICE9PSAwKSB7XG5cdCAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmxlbmd0aCArPSBzO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuXHQgICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG5cdCAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG5cdCAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG5cdCAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuXHQgIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG5cdCAgICB2YXIgaDtcblx0ICAgIGlmIChoaW50KSB7XG5cdCAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaCA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHZhciByID0gYml0cyAlIDI2O1xuXHQgICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcblx0ICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuXHQgICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cblx0ICAgIGggLT0gcztcblx0ICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuXHQgICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuXHQgICAgaWYgKG1hc2tlZFdvcmRzKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG5cdCAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzID09PSAwKSB7XG5cdCAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuXHQgICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcblx0ICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG5cdCAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG5cdCAgICB9XG5cblx0ICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuXHQgICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG5cdCAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LWxlZnRcblx0ICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gU2hpZnQtcmlnaHRcblx0ICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcblx0ICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXQgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG5cdCAgICB2YXIgcSA9IDEgPDwgcjtcblxuXHQgICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG5cdCAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cblx0ICAgIHJldHVybiAhISh3ICYgcSk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG5cdCAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXRzICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyICE9PSAwKSB7XG5cdCAgICAgIHMrKztcblx0ICAgIH1cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuXHQgIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cdCAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cblx0ICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuXHQgICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaXN1Ym4obnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBZGQgd2l0aG91dCBjaGVja3Ncblx0ICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcblx0ICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG5cdCAgICAvLyBDYXJyeVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuXHQgICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG5cdCAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblx0ICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaWFkZG4obnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBDYXJyeVxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG5cdCAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuXHQgICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcblx0ICAgIHZhciBpO1xuXG5cdCAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuXHQgICAgdmFyIHc7XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG5cdCAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcblx0ICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuXHQgICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXHQgICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcblx0ICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHcgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcblx0ICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuXHQgICAgY2FycnkgPSAwO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cdCAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuXHQgICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG5cdCAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcblx0ICAgIHZhciBiID0gbnVtO1xuXG5cdCAgICAvLyBOb3JtYWxpemVcblx0ICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuXHQgICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcblx0ICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuXHQgICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG5cdCAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcblx0ICAgICAgYS5pdXNobG4oc2hpZnQpO1xuXHQgICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG5cdCAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG5cdCAgICB2YXIgcTtcblxuXHQgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG5cdCAgICAgIHEubGVuZ3RoID0gbSArIDE7XG5cdCAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBxLndvcmRzW2ldID0gMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG5cdCAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICBhID0gZGlmZjtcblx0ICAgICAgaWYgKHEpIHtcblx0ICAgICAgICBxLndvcmRzW21dID0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdCAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG5cdCAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuXHQgICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuXHQgICAgICAvLyAoMHg3ZmZmZmZmKVxuXHQgICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG5cdCAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcblx0ICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBxai0tO1xuXHQgICAgICAgIGEubmVnYXRpdmUgPSAwO1xuXHQgICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuXHQgICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAocSkge1xuXHQgICAgICAgIHEud29yZHNbal0gPSBxajtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHEpIHtcblx0ICAgICAgcS5zdHJpcCgpO1xuXHQgICAgfVxuXHQgICAgYS5zdHJpcCgpO1xuXG5cdCAgICAvLyBEZW5vcm1hbGl6ZVxuXHQgICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG5cdCAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZGl2OiBxIHx8IG51bGwsXG5cdCAgICAgIG1vZDogYVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcblx0ICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cblx0ICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG5cdCAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcblx0ICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG5cdCAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBuZXcgQk4oMCksXG5cdCAgICAgICAgbW9kOiBuZXcgQk4oMClcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRpdiwgbW9kLCByZXM7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcblx0ICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG5cdCAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcblx0ICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgICBtb2QuaWFkZChudW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBkaXYsXG5cdCAgICAgICAgbW9kOiBtb2Rcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBkaXYsXG5cdCAgICAgICAgbW9kOiByZXMubW9kXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcblx0ICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcblx0ICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuXHQgICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IHJlcy5kaXYsXG5cdCAgICAgICAgbW9kOiBtb2Rcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cblx0ICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuXHQgICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogbmV3IEJOKDApLFxuXHQgICAgICAgIG1vZDogdGhpc1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuXHQgICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG5cdCAgICAgICAgICBtb2Q6IG51bGxcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIGRpdjogbnVsbCxcblx0ICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG5cdCAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG5cdCAgfTtcblxuXHQgIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcblx0ICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuXHQgIH07XG5cblx0ICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG5cdCAgfTtcblxuXHQgIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG5cdCAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuXHQgICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuXHQgICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cblx0ICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cblx0ICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG5cdCAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcblx0ICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcblx0ICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG5cdCAgICAvLyBSb3VuZCBkb3duXG5cdCAgICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApIHJldHVybiBkbS5kaXY7XG5cblx0ICAgIC8vIFJvdW5kIHVwXG5cdCAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuXHQgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXHQgICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cblx0ICAgIHZhciBhY2MgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGFjYztcblx0ICB9O1xuXG5cdCAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG5cdCAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuXHQgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuXHQgICAgICBjYXJyeSA9IHcgJSBudW07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuXHQgICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuXHQgICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuXHQgICAgdmFyIHggPSB0aGlzO1xuXHQgICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cblx0ICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHggPSB4LnVtb2QocCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB4ID0geC5jbG9uZSgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBICogeCArIEIgKiB5ID0geFxuXHQgICAgdmFyIEEgPSBuZXcgQk4oMSk7XG5cdCAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuXHQgICAgLy8gQyAqIHggKyBEICogeSA9IHlcblx0ICAgIHZhciBDID0gbmV3IEJOKDApO1xuXHQgICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cblx0ICAgIHZhciBnID0gMDtcblxuXHQgICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuXHQgICAgICB4Lml1c2hybigxKTtcblx0ICAgICAgeS5pdXNocm4oMSk7XG5cdCAgICAgICsrZztcblx0ICAgIH1cblxuXHQgICAgdmFyIHlwID0geS5jbG9uZSgpO1xuXHQgICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG5cdCAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcblx0ICAgICAgaWYgKGkgPiAwKSB7XG5cdCAgICAgICAgeC5pdXNocm4oaSk7XG5cdCAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcblx0ICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIEEuaWFkZCh5cCk7XG5cdCAgICAgICAgICAgIEIuaXN1Yih4cCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIEEuaXVzaHJuKDEpO1xuXHQgICAgICAgICAgQi5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcblx0ICAgICAgaWYgKGogPiAwKSB7XG5cdCAgICAgICAgeS5pdXNocm4oaik7XG5cdCAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcblx0ICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIEMuaWFkZCh5cCk7XG5cdCAgICAgICAgICAgIEQuaXN1Yih4cCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIEMuaXVzaHJuKDEpO1xuXHQgICAgICAgICAgRC5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHguY21wKHkpID49IDApIHtcblx0ICAgICAgICB4LmlzdWIoeSk7XG5cdCAgICAgICAgQS5pc3ViKEMpO1xuXHQgICAgICAgIEIuaXN1YihEKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB5LmlzdWIoeCk7XG5cdCAgICAgICAgQy5pc3ViKEEpO1xuXHQgICAgICAgIEQuaXN1YihCKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBhOiBDLFxuXHQgICAgICBiOiBELFxuXHQgICAgICBnY2Q6IHkuaXVzaGxuKGcpXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcblx0ICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcblx0ICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuXHQgIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcblx0ICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cblx0ICAgIHZhciBhID0gdGhpcztcblx0ICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG5cdCAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBhID0gYS51bW9kKHApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IGEuY2xvbmUoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuXHQgICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG5cdCAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cblx0ICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcblx0ICAgICAgaWYgKGkgPiAwKSB7XG5cdCAgICAgICAgYS5pdXNocm4oaSk7XG5cdCAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcblx0ICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB4MS5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcblx0ICAgICAgaWYgKGogPiAwKSB7XG5cdCAgICAgICAgYi5pdXNocm4oaik7XG5cdCAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcblx0ICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB4Mi5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcblx0ICAgICAgICBhLmlzdWIoYik7XG5cdCAgICAgICAgeDEuaXN1Yih4Mik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYi5pc3ViKGEpO1xuXHQgICAgICAgIHgyLmlzdWIoeDEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXM7XG5cdCAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG5cdCAgICAgIHJlcyA9IHgxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzID0geDI7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzLmlhZGQocCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuXHQgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG5cdCAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuXHQgICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG5cdCAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuXHQgICAgYS5uZWdhdGl2ZSA9IDA7XG5cdCAgICBiLm5lZ2F0aXZlID0gMDtcblxuXHQgICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG5cdCAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuXHQgICAgICBhLml1c2hybigxKTtcblx0ICAgICAgYi5pdXNocm4oMSk7XG5cdCAgICB9XG5cblx0ICAgIGRvIHtcblx0ICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcblx0ICAgICAgICBhLml1c2hybigxKTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuXHQgICAgICAgIGIuaXVzaHJuKDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHIgPSBhLmNtcChiKTtcblx0ICAgICAgaWYgKHIgPCAwKSB7XG5cdCAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG5cdCAgICAgICAgdmFyIHQgPSBhO1xuXHQgICAgICAgIGEgPSBiO1xuXHQgICAgICAgIGIgPSB0O1xuXHQgICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBhLmlzdWIoYik7XG5cdCAgICB9IHdoaWxlICh0cnVlKTtcblxuXHQgICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcblx0ICB9O1xuXG5cdCAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG5cdCAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG5cdCAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuXHQgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cblx0ICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcblx0ICB9O1xuXG5cdCAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuXHQgIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG5cdCAgICB2YXIgciA9IGJpdCAlIDI2O1xuXHQgICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcblx0ICAgIHZhciBxID0gMSA8PCByO1xuXG5cdCAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcblx0ICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcblx0ICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcblx0ICAgIHZhciBjYXJyeSA9IHE7XG5cdCAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdyArPSBjYXJyeTtcblx0ICAgICAgY2FycnkgPSB3ID4+PiAyNjtcblx0ICAgICAgdyAmPSAweDNmZmZmZmY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuXHQgICAgfVxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgdmFyIHJlcztcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgcmVzID0gMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIG51bSA9IC1udW07XG5cdCAgICAgIH1cblxuXHQgICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cblx0ICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcblx0ICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuXHQgIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuXHQgIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcblx0ICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cblx0ICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG5cdCAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcblx0ICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cblx0ICAgIHZhciByZXMgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG5cdCAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcblx0ICAgICAgaWYgKGEgPCBiKSB7XG5cdCAgICAgICAgcmVzID0gLTE7XG5cdCAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcblx0ICAgICAgICByZXMgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG5cdCAgfTtcblxuXHQgIC8vXG5cdCAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcblx0ICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cblx0ICAvL1xuXHQgIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG5cdCAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG5cdCAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuXHQgICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuXHQgICAgdGhpcy5yZWQgPSBjdHg7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuXHQgICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcblx0ICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFNxdWFyZSByb290IG92ZXIgcFxuXHQgIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG5cdCAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuXHQgIHZhciBwcmltZXMgPSB7XG5cdCAgICBrMjU2OiBudWxsLFxuXHQgICAgcDIyNDogbnVsbCxcblx0ICAgIHAxOTI6IG51bGwsXG5cdCAgICBwMjU1MTk6IG51bGxcblx0ICB9O1xuXG5cdCAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG5cdCAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG5cdCAgICAvLyBQID0gMiBeIE4gLSBLXG5cdCAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcblx0ICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcblx0ICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cblx0ICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG5cdCAgfVxuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG5cdCAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuXHQgICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuXHQgICAgcmV0dXJuIHRtcDtcblx0ICB9O1xuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG5cdCAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG5cdCAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG5cdCAgICB2YXIgciA9IG51bTtcblx0ICAgIHZhciBybGVuO1xuXG5cdCAgICBkbyB7XG5cdCAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuXHQgICAgICByID0gdGhpcy5pbXVsSyhyKTtcblx0ICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG5cdCAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuXHQgICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cblx0ICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcblx0ICAgIGlmIChjbXAgPT09IDApIHtcblx0ICAgICAgci53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHIubGVuZ3RoID0gMTtcblx0ICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuXHQgICAgICByLmlzdWIodGhpcy5wKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAvLyByIGlzIEJOIHY0IGluc3RhbmNlXG5cdCAgICAgICAgci5zdHJpcCgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIHIgaXMgQk4gdjUgaW5zdGFuY2Vcblx0ICAgICAgICByLl9zdHJpcCgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcblx0ICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG5cdCAgfTtcblxuXHQgIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG5cdCAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gSzI1NiAoKSB7XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJ2syNTYnLFxuXHQgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuXHQgIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcblx0ICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG5cdCAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG5cdCAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcblx0ICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG5cdCAgICB9XG5cdCAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG5cdCAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcblx0ICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuXHQgICAgICBpbnB1dC5sZW5ndGggPSAxO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcblx0ICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG5cdCAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG5cdCAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuXHQgICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuXHQgICAgICBwcmV2ID0gbmV4dDtcblx0ICAgIH1cblx0ICAgIHByZXYgPj4+PSAyMjtcblx0ICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuXHQgICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcblx0ICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuXHQgICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG5cdCAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuXHQgICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG5cdCAgICBudW0ubGVuZ3RoICs9IDI7XG5cblx0ICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG5cdCAgICB2YXIgbG8gPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuXHQgICAgICBsbyArPSB3ICogMHgzZDE7XG5cdCAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuXHQgICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcblx0ICAgIH1cblxuXHQgICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG5cdCAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuXHQgICAgICBudW0ubGVuZ3RoLS07XG5cdCAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgICAgbnVtLmxlbmd0aC0tO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVtO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBQMjI0ICgpIHtcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAncDIyNCcsXG5cdCAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG5cdCAgZnVuY3Rpb24gUDE5MiAoKSB7XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJ3AxOTInLFxuXHQgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuXHQgIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG5cdCAgICAvLyAyIF4gMjU1IC0gMTlcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAnMjU1MTknLFxuXHQgICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cblx0ICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuXHQgICAgLy8gSyA9IDB4MTNcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG5cdCAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuXHQgICAgICBoaSA+Pj49IDI2O1xuXG5cdCAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuXHQgICAgICBjYXJyeSA9IGhpO1xuXHQgICAgfVxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVtO1xuXHQgIH07XG5cblx0ICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcblx0ICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuXHQgICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcblx0ICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cblx0ICAgIHZhciBwcmltZTtcblx0ICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuXHQgICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuXHQgICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuXHQgICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuXHQgICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG5cdCAgICB9XG5cdCAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuXHQgICAgcmV0dXJuIHByaW1lO1xuXHQgIH07XG5cblx0ICAvL1xuXHQgIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuXHQgIC8vXG5cdCAgZnVuY3Rpb24gUmVkIChtKSB7XG5cdCAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcblx0ICAgICAgdGhpcy5tID0gcHJpbWUucDtcblx0ICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG5cdCAgICAgIHRoaXMubSA9IG07XG5cdCAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuXHQgICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuXHQgICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcblx0ICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcblx0ICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG5cdCAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcblx0ICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcblx0ICAgIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSkge1xuXHQgICAgICByZXR1cm4gYS5jbG9uZSgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5hZGQoYik7XG5cdCAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzLmlzdWIodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuXHQgICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuXHQgICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG5cdCAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkxKGEpO1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblx0ICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG5cdCAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcblx0ICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG5cdCAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcblx0ICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cblx0ICAgIC8vIEZhc3QgY2FzZVxuXHQgICAgaWYgKG1vZDMgPT09IDMpIHtcblx0ICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG5cdCAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG5cdCAgICAvL1xuXHQgICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcblx0ICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG5cdCAgICB2YXIgcyA9IDA7XG5cdCAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuXHQgICAgICBzKys7XG5cdCAgICAgIHEuaXVzaHJuKDEpO1xuXHQgICAgfVxuXHQgICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuXHQgICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcblx0ICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG5cdCAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuXHQgICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG5cdCAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcblx0ICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuXHQgICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG5cdCAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG5cdCAgICAgIHoucmVkSUFkZChuT25lKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcblx0ICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG5cdCAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuXHQgICAgdmFyIG0gPSBzO1xuXHQgICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcblx0ICAgICAgdmFyIHRtcCA9IHQ7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuXHQgICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcblx0ICAgICAgfVxuXHQgICAgICBhc3NlcnQoaSA8IG0pO1xuXHQgICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cblx0ICAgICAgciA9IHIucmVkTXVsKGIpO1xuXHQgICAgICBjID0gYi5yZWRTcXIoKTtcblx0ICAgICAgdCA9IHQucmVkTXVsKGMpO1xuXHQgICAgICBtID0gaTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcblx0ICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuXHQgICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBpbnYubmVnYXRpdmUgPSAwO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcblx0ICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG5cdCAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cblx0ICAgIHZhciB3aW5kb3dTaXplID0gNDtcblx0ICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcblx0ICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcblx0ICAgIHduZFsxXSA9IGE7XG5cdCAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHJlcyA9IHduZFswXTtcblx0ICAgIHZhciBjdXJyZW50ID0gMDtcblx0ICAgIHZhciBjdXJyZW50TGVuID0gMDtcblx0ICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuXHQgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG5cdCAgICAgIHN0YXJ0ID0gMjY7XG5cdCAgICB9XG5cblx0ICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcblx0ICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0ICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuXHQgICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuXHQgICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcblx0ICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3VycmVudCA8PD0gMTtcblx0ICAgICAgICBjdXJyZW50IHw9IGJpdDtcblx0ICAgICAgICBjdXJyZW50TGVuKys7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG5cdCAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuXHQgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuXHQgICAgICAgIGN1cnJlbnQgPSAwO1xuXHQgICAgICB9XG5cdCAgICAgIHN0YXJ0ID0gMjY7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcblx0ICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuXHQgICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG5cdCAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG5cdCAgICByZXMucmVkID0gbnVsbDtcblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vXG5cdCAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG5cdCAgLy9cblxuXHQgIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcblx0ICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBNb250IChtKSB7XG5cdCAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuXHQgICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcblx0ICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcblx0ICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuXHQgICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuXHQgICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG5cdCAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG5cdCAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuXHQgICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG5cdCAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG5cdCAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuXHQgICAgci5yZWQgPSBudWxsO1xuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG5cdCAgICAgIGEud29yZHNbMF0gPSAwO1xuXHQgICAgICBhLmxlbmd0aCA9IDE7XG5cdCAgICAgIHJldHVybiBhO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdCA9IGEuaW11bChiKTtcblx0ICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG5cdCAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG5cdCAgICB2YXIgcmVzID0gdTtcblxuXHQgICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcblx0ICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cblx0ICAgIHZhciB0ID0gYS5tdWwoYik7XG5cdCAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuXHQgICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuXHQgICAgdmFyIHJlcyA9IHU7XG5cdCAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuXHQgICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcblx0ICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcblx0ICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblx0fSkoJ29iamVjdCcgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgY29tbW9uanNHbG9iYWwpO1xuXHR9KTtcblx0dmFyIGJuXzEgPSBibi5CTjtcblxuXHR2YXIgX3ZlcnNpb24gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwibG9nZ2VyLzUuMC41XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDEgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uKTtcblx0dmFyIF92ZXJzaW9uXzEgPSBfdmVyc2lvbi52ZXJzaW9uO1xuXG5cdHZhciBsaWIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdHZhciBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5cdHZhciBfY2Vuc29yRXJyb3JzID0gZmFsc2U7XG5cdHZhciBMb2dMZXZlbHMgPSB7IGRlYnVnOiAxLCBcImRlZmF1bHRcIjogMiwgaW5mbzogMiwgd2FybmluZzogMywgZXJyb3I6IDQsIG9mZjogNSB9O1xuXHR2YXIgX2xvZ0xldmVsID0gTG9nTGV2ZWxzW1wiZGVmYXVsdFwiXTtcblxuXHR2YXIgX2dsb2JhbExvZ2dlciA9IG51bGw7XG5cdGZ1bmN0aW9uIF9jaGVja05vcm1hbGl6ZSgpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIG1pc3NpbmdfMSA9IFtdO1xuXHQgICAgICAgIC8vIE1ha2Ugc3VyZSBhbGwgZm9ybXMgb2Ygbm9ybWFsaXphdGlvbiBhcmUgc3VwcG9ydGVkXG5cdCAgICAgICAgW1wiTkZEXCIsIFwiTkZDXCIsIFwiTkZLRFwiLCBcIk5GS0NcIl0uZm9yRWFjaChmdW5jdGlvbiAoZm9ybSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidGVzdFwiLm5vcm1hbGl6ZShmb3JtKSAhPT0gXCJ0ZXN0XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgbm9ybWFsaXplXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgbWlzc2luZ18xLnB1c2goZm9ybSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICBpZiAobWlzc2luZ18xLmxlbmd0aCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtaXNzaW5nIFwiICsgbWlzc2luZ18xLmpvaW4oXCIsIFwiKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTkpLm5vcm1hbGl6ZShcIk5GRFwiKSAhPT0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDY1LCAweDAzMDEpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJyb2tlbiBpbXBsZW1lbnRhdGlvblwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdHZhciBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcblx0dmFyIExvZ0xldmVsO1xuXHQoZnVuY3Rpb24gKExvZ0xldmVsKSB7XG5cdCAgICBMb2dMZXZlbFtcIkRFQlVHXCJdID0gXCJERUJVR1wiO1xuXHQgICAgTG9nTGV2ZWxbXCJJTkZPXCJdID0gXCJJTkZPXCI7XG5cdCAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcblx0ICAgIExvZ0xldmVsW1wiRVJST1JcIl0gPSBcIkVSUk9SXCI7XG5cdCAgICBMb2dMZXZlbFtcIk9GRlwiXSA9IFwiT0ZGXCI7XG5cdH0pKExvZ0xldmVsID0gZXhwb3J0cy5Mb2dMZXZlbCB8fCAoZXhwb3J0cy5Mb2dMZXZlbCA9IHt9KSk7XG5cdHZhciBFcnJvckNvZGU7XG5cdChmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBHZW5lcmljIEVycm9yc1xuXHQgICAgLy8gVW5rbm93biBFcnJvclxuXHQgICAgRXJyb3JDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xuXHQgICAgLy8gTm90IEltcGxlbWVudGVkXG5cdCAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuXHQgICAgLy8gVW5zdXBwb3J0ZWQgT3BlcmF0aW9uXG5cdCAgICAvLyAgIC0gb3BlcmF0aW9uXG5cdCAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuXHQgICAgLy8gTmV0d29yayBFcnJvciAoaS5lLiBFdGhlcmV1bSBOZXR3b3JrLCBzdWNoIGFzIGFuIGludmFsaWQgY2hhaW4gSUQpXG5cdCAgICAvLyAgIC0gZXZlbnQgKFwibm9OZXR3b3JrXCIgaXMgbm90IHJlLXRocm93biBpbiBwcm92aWRlci5yZWFkeTsgb3RoZXJ3aXNlIHRocm93bilcblx0ICAgIEVycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSBcIk5FVFdPUktfRVJST1JcIjtcblx0ICAgIC8vIFNvbWUgc29ydCBvZiBiYWQgcmVzcG9uc2UgZnJvbSB0aGUgc2VydmVyXG5cdCAgICBFcnJvckNvZGVbXCJTRVJWRVJfRVJST1JcIl0gPSBcIlNFUlZFUl9FUlJPUlwiO1xuXHQgICAgLy8gVGltZW91dFxuXHQgICAgRXJyb3JDb2RlW1wiVElNRU9VVFwiXSA9IFwiVElNRU9VVFwiO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gT3BlcmF0aW9uYWwgIEVycm9yc1xuXHQgICAgLy8gQnVmZmVyIE92ZXJydW5cblx0ICAgIEVycm9yQ29kZVtcIkJVRkZFUl9PVkVSUlVOXCJdID0gXCJCVUZGRVJfT1ZFUlJVTlwiO1xuXHQgICAgLy8gTnVtZXJpYyBGYXVsdFxuXHQgICAgLy8gICAtIG9wZXJhdGlvbjogdGhlIG9wZXJhdGlvbiBiZWluZyBleGVjdXRlZFxuXHQgICAgLy8gICAtIGZhdWx0OiB0aGUgcmVhc29uIHRoaXMgZmF1bHRlZFxuXHQgICAgRXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXSA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gQXJndW1lbnQgRXJyb3JzXG5cdCAgICAvLyBNaXNzaW5nIG5ldyBvcGVyYXRvciB0byBhbiBvYmplY3Rcblx0ICAgIC8vICAtIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBjbGFzc1xuXHQgICAgRXJyb3JDb2RlW1wiTUlTU0lOR19ORVdcIl0gPSBcIk1JU1NJTkdfTkVXXCI7XG5cdCAgICAvLyBJbnZhbGlkIGFyZ3VtZW50IChlLmcuIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIHR5cGUpIHRvIGEgZnVuY3Rpb246XG5cdCAgICAvLyAgIC0gYXJndW1lbnQ6IFRoZSBhcmd1bWVudCBuYW1lIHRoYXQgd2FzIGludmFsaWRcblx0ICAgIC8vICAgLSB2YWx1ZTogVGhlIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuXHQgICAgRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuXHQgICAgLy8gTWlzc2luZyBhcmd1bWVudCB0byBhIGZ1bmN0aW9uOlxuXHQgICAgLy8gICAtIGNvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyByZWNlaXZlZFxuXHQgICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG5cdCAgICBFcnJvckNvZGVbXCJNSVNTSU5HX0FSR1VNRU5UXCJdID0gXCJNSVNTSU5HX0FSR1VNRU5UXCI7XG5cdCAgICAvLyBUb28gbWFueSBhcmd1bWVudHNcblx0ICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcblx0ICAgIC8vICAgLSBleHBlY3RlZENvdW50OiBUaGUgbnVtYmVyIG9mIGFyZ3VtZW50cyBleHBlY3RlZFxuXHQgICAgRXJyb3JDb2RlW1wiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiXSA9IFwiVU5FWFBFQ1RFRF9BUkdVTUVOVFwiO1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gQmxvY2tjaGFpbiBFcnJvcnNcblx0ICAgIC8vIENhbGwgZXhjZXB0aW9uXG5cdCAgICAvLyAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uXG5cdCAgICAvLyAgLSBhZGRyZXNzPzogdGhlIGNvbnRyYWN0IGFkZHJlc3Ncblx0ICAgIC8vICAtIGFyZ3M/OiBUaGUgYXJndW1lbnRzIHBhc3NlZCBpbnRvIHRoZSBmdW5jdGlvblxuXHQgICAgLy8gIC0gbWV0aG9kPzogVGhlIFNvbGlkaXR5IG1ldGhvZCBzaWduYXR1cmVcblx0ICAgIC8vICAtIGVycm9yU2lnbmF0dXJlPzogVGhlIEVJUDg0OCBlcnJvciBzaWduYXR1cmVcblx0ICAgIC8vICAtIGVycm9yQXJncz86IFRoZSBFSVA4NDggZXJyb3IgcGFyYW1ldGVyc1xuXHQgICAgLy8gIC0gcmVhc29uOiBUaGUgcmVhc29uIChvbmx5IGZvciBFSVA4NDggXCJFcnJvcihzdHJpbmcpXCIpXG5cdCAgICBFcnJvckNvZGVbXCJDQUxMX0VYQ0VQVElPTlwiXSA9IFwiQ0FMTF9FWENFUFRJT05cIjtcblx0ICAgIC8vIEluc3VmZmljaWVuIGZ1bmRzICg8IHZhbHVlICsgZ2FzTGltaXQgKiBnYXNQcmljZSlcblx0ICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuXHQgICAgRXJyb3JDb2RlW1wiSU5TVUZGSUNJRU5UX0ZVTkRTXCJdID0gXCJJTlNVRkZJQ0lFTlRfRlVORFNcIjtcblx0ICAgIC8vIE5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuXHQgICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG5cdCAgICBFcnJvckNvZGVbXCJOT05DRV9FWFBJUkVEXCJdID0gXCJOT05DRV9FWFBJUkVEXCI7XG5cdCAgICAvLyBUaGUgcmVwbGFjZW1lbnQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb24gaXMgdG9vIGxvd1xuXHQgICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gYXR0ZW1wdGVkXG5cdCAgICBFcnJvckNvZGVbXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiXSA9IFwiUkVQTEFDRU1FTlRfVU5ERVJQUklDRURcIjtcblx0ICAgIC8vIFRoZSBnYXMgbGltaXQgY291bGQgbm90IGJlIGVzdGltYXRlZFxuXHQgICAgLy8gICAtIHRyYW5zYWN0aW9uOiB0aGUgdHJhbnNhY3Rpb24gcGFzc2VkIHRvIGVzdGltYXRlR2FzXG5cdCAgICBFcnJvckNvZGVbXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiXSA9IFwiVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcIjtcblx0fSkoRXJyb3JDb2RlID0gZXhwb3J0cy5FcnJvckNvZGUgfHwgKGV4cG9ydHMuRXJyb3JDb2RlID0ge30pKTtcblx0O1xuXHR2YXIgTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gTG9nZ2VyKHZlcnNpb24pIHtcblx0ICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcblx0ICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgdmFsdWU6IHZlcnNpb24sXG5cdCAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5fbG9nID0gZnVuY3Rpb24gKGxvZ0xldmVsLCBhcmdzKSB7XG5cdCAgICAgICAgdmFyIGxldmVsID0gbG9nTGV2ZWwudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBpZiAoTG9nTGV2ZWxzW2xldmVsXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGxvZ0xldmVsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKF9sb2dMZXZlbCA+IExvZ0xldmVsc1tsZXZlbF0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5ERUJVRywgYXJncyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5pbmZvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBhcmdzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcblx0ICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9sb2coTG9nZ2VyLmxldmVscy5JTkZPLCBhcmdzKTtcblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLndhcm4gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLldBUk5JTkcsIGFyZ3MpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUubWFrZUVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuXHQgICAgICAgIC8vIEVycm9ycyBhcmUgYmVpbmcgY2Vuc29yZWRcblx0ICAgICAgICBpZiAoX2NlbnNvckVycm9ycykge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlRXJyb3IoXCJjZW5zb3JlZCBlcnJvclwiLCBjb2RlLCB7fSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY29kZSkge1xuXHQgICAgICAgICAgICBjb2RlID0gTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXBhcmFtcykge1xuXHQgICAgICAgICAgICBwYXJhbXMgPSB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1lc3NhZ2VEZXRhaWxzID0gW107XG5cdCAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goa2V5ICsgXCI9XCIgKyBKU09OLnN0cmluZ2lmeShwYXJhbXNba2V5XSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1cIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtc1trZXldLnRvU3RyaW5nKCkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goXCJjb2RlPVwiICsgY29kZSk7XG5cdCAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChcInZlcnNpb249XCIgKyB0aGlzLnZlcnNpb24pO1xuXHQgICAgICAgIHZhciByZWFzb24gPSBtZXNzYWdlO1xuXHQgICAgICAgIGlmIChtZXNzYWdlRGV0YWlscy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSArPSBcIiAoXCIgKyBtZXNzYWdlRGV0YWlscy5qb2luKFwiLCBcIikgKyBcIilcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQFRPRE86IEFueT8/XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuXHQgICAgICAgIGVycm9yLnJlYXNvbiA9IHJlYXNvbjtcblx0ICAgICAgICBlcnJvci5jb2RlID0gY29kZTtcblx0ICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBlcnJvcltrZXldID0gcGFyYW1zW2tleV07XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUudGhyb3dFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcblx0ICAgICAgICB0aHJvdyB0aGlzLm1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUudGhyb3dBcmd1bWVudEVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgYXJndW1lbnQ6IG5hbWUsXG5cdCAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuYXNzZXJ0ID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgbWVzc2FnZSwgY29kZSwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLnByb3RvdHlwZS5hc3NlcnRBcmd1bWVudCA9IGZ1bmN0aW9uIChjb25kaXRpb24sIG1lc3NhZ2UsIG5hbWUsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tOb3JtYWxpemUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwicGxhdGZvcm0gbWlzc2luZyBTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZVwiLCBmb3JtOiBfbm9ybWFsaXplRXJyb3Jcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tTYWZlVWludDUzID0gZnVuY3Rpb24gKHZhbHVlLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKG1lc3NhZ2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBtZXNzYWdlID0gXCJ2YWx1ZSBub3Qgc2FmZVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDB4MWZmZmZmZmZmZmZmZmYpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcblx0ICAgICAgICAgICAgICAgIGZhdWx0OiBcIm91dC1vZi1zYWZlLXJhbmdlXCIsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcblx0ICAgICAgICAgICAgICAgIGZhdWx0OiBcIm5vbi1pbnRlZ2VyXCIsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tBcmd1bWVudENvdW50ID0gZnVuY3Rpb24gKGNvdW50LCBleHBlY3RlZENvdW50LCBtZXNzYWdlKSB7XG5cdCAgICAgICAgaWYgKG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvdW50IDwgZXhwZWN0ZWRDb3VudCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcblx0ICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb3VudCA+IGV4cGVjdGVkQ291bnQpIHtcblx0ICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcblx0ICAgICAgICAgICAgICAgIGNvdW50OiBjb3VudCxcblx0ICAgICAgICAgICAgICAgIGV4cGVjdGVkQ291bnQ6IGV4cGVjdGVkQ291bnRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIExvZ2dlci5wcm90b3R5cGUuY2hlY2tOZXcgPSBmdW5jdGlvbiAodGFyZ2V0LCBraW5kKSB7XG5cdCAgICAgICAgaWYgKHRhcmdldCA9PT0gT2JqZWN0IHx8IHRhcmdldCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRoaXMudGhyb3dFcnJvcihcIm1pc3NpbmcgbmV3XCIsIExvZ2dlci5lcnJvcnMuTUlTU0lOR19ORVcsIHsgbmFtZToga2luZC5uYW1lIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBMb2dnZXIucHJvdG90eXBlLmNoZWNrQWJzdHJhY3QgPSBmdW5jdGlvbiAodGFyZ2V0LCBraW5kKSB7XG5cdCAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJjYW5ub3QgaW5zdGFudGlhdGUgYWJzdHJhY3QgY2xhc3MgXCIgKyBKU09OLnN0cmluZ2lmeShraW5kLm5hbWUpICsgXCIgZGlyZWN0bHk7IHVzZSBhIHN1Yi1jbGFzc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBuYW1lOiB0YXJnZXQubmFtZSwgb3BlcmF0aW9uOiBcIm5ld1wiIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIG5ld1wiLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfTkVXLCB7IG5hbWU6IGtpbmQubmFtZSB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLmdsb2JhbExvZ2dlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoIV9nbG9iYWxMb2dnZXIpIHtcblx0ICAgICAgICAgICAgX2dsb2JhbExvZ2dlciA9IG5ldyBMb2dnZXIoX3ZlcnNpb24udmVyc2lvbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfZ2xvYmFsTG9nZ2VyO1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5zZXRDZW5zb3JzaGlwID0gZnVuY3Rpb24gKGNlbnNvcnNoaXAsIHBlcm1hbmVudCkge1xuXHQgICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcblx0ICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiY2Fubm90IHBlcm1hbmVudGx5IGRpc2FibGUgY2Vuc29yc2hpcFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldENlbnNvcnNoaXBcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKF9wZXJtYW5lbnRDZW5zb3JFcnJvcnMpIHtcblx0ICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRDZW5zb3JzaGlwXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9jZW5zb3JFcnJvcnMgPSAhIWNlbnNvcnNoaXA7XG5cdCAgICAgICAgX3Blcm1hbmVudENlbnNvckVycm9ycyA9ICEhcGVybWFuZW50O1xuXHQgICAgfTtcblx0ICAgIExvZ2dlci5zZXRMb2dMZXZlbCA9IGZ1bmN0aW9uIChsb2dMZXZlbCkge1xuXHQgICAgICAgIHZhciBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcblx0ICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBMb2dnZXIuZ2xvYmFsTG9nZ2VyKCkud2FybihcImludmFsaWQgbG9nIGxldmVsIC0gXCIgKyBsb2dMZXZlbCk7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX2xvZ0xldmVsID0gbGV2ZWw7XG5cdCAgICB9O1xuXHQgICAgTG9nZ2VyLmVycm9ycyA9IEVycm9yQ29kZTtcblx0ICAgIExvZ2dlci5sZXZlbHMgPSBMb2dMZXZlbDtcblx0ICAgIHJldHVybiBMb2dnZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuTG9nZ2VyID0gTG9nZ2VyO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCA9IHVud3JhcEV4cG9ydHMobGliKTtcblx0dmFyIGxpYl8xID0gbGliLkxvZ0xldmVsO1xuXHR2YXIgbGliXzIgPSBsaWIuRXJyb3JDb2RlO1xuXHR2YXIgbGliXzMgPSBsaWIuTG9nZ2VyO1xuXG5cdHZhciBfdmVyc2lvbiQyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImJ5dGVzLzUuMC40XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDMgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJDIpO1xuXHR2YXIgX3ZlcnNpb25fMSQxID0gX3ZlcnNpb24kMi52ZXJzaW9uO1xuXG5cdHZhciBsaWIkMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQyLnZlcnNpb24pO1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdGZ1bmN0aW9uIGlzSGV4YWJsZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICEhKHZhbHVlLnRvSGV4U3RyaW5nKTtcblx0fVxuXHRmdW5jdGlvbiBhZGRTbGljZShhcnJheSkge1xuXHQgICAgaWYgKGFycmF5LnNsaWNlKSB7XG5cdCAgICAgICAgcmV0dXJuIGFycmF5O1xuXHQgICAgfVxuXHQgICAgYXJyYXkuc2xpY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXHQgICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYXJyYXksIGFyZ3MpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGFycmF5O1xuXHR9XG5cdGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKChpc0hleFN0cmluZyh2YWx1ZSkgJiYgISh2YWx1ZS5sZW5ndGggJSAyKSkgfHwgaXNCeXRlcyh2YWx1ZSkpO1xuXHR9XG5cdGV4cG9ydHMuaXNCeXRlc0xpa2UgPSBpc0J5dGVzTGlrZTtcblx0ZnVuY3Rpb24gaXNCeXRlcyh2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUuY29uc3RydWN0b3IgPT09IFVpbnQ4QXJyYXkpIHtcblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZS5sZW5ndGggPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgIH1cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgdiA9IHZhbHVlW2ldO1xuXHQgICAgICAgIGlmICh2IDwgMCB8fCB2ID49IDI1NiB8fCAodiAlIDEpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0fVxuXHRleHBvcnRzLmlzQnl0ZXMgPSBpc0J5dGVzO1xuXHRmdW5jdGlvbiBhcnJheWlmeSh2YWx1ZSwgb3B0aW9ucykge1xuXHQgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICB3aGlsZSAodmFsdWUpIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQodmFsdWUgJiAweGZmKTtcblx0ICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChTdHJpbmcodmFsdWUgLyAyNTYpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLmFsbG93TWlzc2luZ1ByZWZpeCAmJiB0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIZXhhYmxlKHZhbHVlKSkge1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUudG9IZXhTdHJpbmcoKTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcblx0ICAgICAgICB2YXIgaGV4ID0gdmFsdWUuc3Vic3RyaW5nKDIpO1xuXHQgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwibGVmdFwiKSB7XG5cdCAgICAgICAgICAgICAgICBoZXggPSBcIjB4MFwiICsgaGV4LnN1YnN0cmluZygyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG5cdCAgICAgICAgICAgICAgICBoZXggKz0gXCIwXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXgubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheShyZXN1bHQpKTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiBhZGRTbGljZShuZXcgVWludDhBcnJheSh2YWx1ZSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHR9XG5cdGV4cG9ydHMuYXJyYXlpZnkgPSBhcnJheWlmeTtcblx0ZnVuY3Rpb24gY29uY2F0KGl0ZW1zKSB7XG5cdCAgICB2YXIgb2JqZWN0cyA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gYXJyYXlpZnkoaXRlbSk7IH0pO1xuXHQgICAgdmFyIGxlbmd0aCA9IG9iamVjdHMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgaXRlbSkgeyByZXR1cm4gKGFjY3VtICsgaXRlbS5sZW5ndGgpOyB9LCAwKTtcblx0ICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgb2JqZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKG9mZnNldCwgb2JqZWN0KSB7XG5cdCAgICAgICAgcmVzdWx0LnNldChvYmplY3QsIG9mZnNldCk7XG5cdCAgICAgICAgcmV0dXJuIG9mZnNldCArIG9iamVjdC5sZW5ndGg7XG5cdCAgICB9LCAwKTtcblx0ICAgIHJldHVybiBhZGRTbGljZShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMuY29uY2F0ID0gY29uY2F0O1xuXHRmdW5jdGlvbiBzdHJpcFplcm9zKHZhbHVlKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHQgICAgLy8gRmluZCB0aGUgZmlyc3Qgbm9uLXplcm8gZW50cnlcblx0ICAgIHZhciBzdGFydCA9IDA7XG5cdCAgICB3aGlsZSAoc3RhcnQgPCByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzdGFydF0gPT09IDApIHtcblx0ICAgICAgICBzdGFydCsrO1xuXHQgICAgfVxuXHQgICAgLy8gSWYgd2Ugc3RhcnRlZCB3aXRoIHplcm9zLCBzdHJpcCB0aGVtXG5cdCAgICBpZiAoc3RhcnQpIHtcblx0ICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2Uoc3RhcnQpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLnN0cmlwWmVyb3MgPSBzdHJpcFplcm9zO1xuXHRmdW5jdGlvbiB6ZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcblx0ICAgIHZhbHVlID0gYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgaWYgKHZhbHVlLmxlbmd0aCA+IGxlbmd0aCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2VcIiwgXCJ2YWx1ZVwiLCBhcmd1bWVudHNbMF0pO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG5cdCAgICByZXN1bHQuc2V0KHZhbHVlLCBsZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuXHQgICAgcmV0dXJuIGFkZFNsaWNlKHJlc3VsdCk7XG5cdH1cblx0ZXhwb3J0cy56ZXJvUGFkID0gemVyb1BhZDtcblx0ZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXjB4WzAtOUEtRmEtZl0qJC8pKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKGxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggIT09IDIgKyAyICogbGVuZ3RoKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblx0ZXhwb3J0cy5pc0hleFN0cmluZyA9IGlzSGV4U3RyaW5nO1xuXHR2YXIgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuXHRmdW5jdGlvbiBoZXhsaWZ5KHZhbHVlLCBvcHRpb25zKSB7XG5cdCAgICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tTYWZlVWludDUzKHZhbHVlLCBcImludmFsaWQgaGV4bGlmeSB2YWx1ZVwiKTtcblx0ICAgICAgICB2YXIgaGV4ID0gXCJcIjtcblx0ICAgICAgICB3aGlsZSAodmFsdWUpIHtcblx0ICAgICAgICAgICAgaGV4ID0gSGV4Q2hhcmFjdGVyc1t2YWx1ZSAmIDB4MGZdICsgaGV4O1xuXHQgICAgICAgICAgICB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUgLyAxNik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChoZXgubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuXHQgICAgICAgICAgICAgICAgaGV4ID0gXCIwXCIgKyBoZXg7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGhleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKG9wdGlvbnMuYWxsb3dNaXNzaW5nUHJlZml4ICYmIHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIGlmIChpc0hleGFibGUodmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvSGV4U3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcInJpZ2h0XCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlICs9IFwiMFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImhleCBkYXRhIGlzIG9kZC1sZW5ndGhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gXCIweFwiO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHYgPSB2YWx1ZVtpXTtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IEhleENoYXJhY3RlcnNbKHYgJiAweGYwKSA+PiA0XSArIEhleENoYXJhY3RlcnNbdiAmIDB4MGZdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdH1cblx0ZXhwb3J0cy5oZXhsaWZ5ID0gaGV4bGlmeTtcblx0Lypcblx0ZnVuY3Rpb24gdW5vZGRpZnkodmFsdWU6IEJ5dGVzTGlrZSB8IEhleGFibGUgfCBudW1iZXIpOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyIHtcblx0ICAgIGlmICh0eXBlb2YodmFsdWUpID09PSBcInN0cmluZ1wiICYmIHZhbHVlLmxlbmd0aCAlIDIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpID09PSBcIjB4XCIpIHtcblx0ICAgICAgICByZXR1cm4gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHQqL1xuXHRmdW5jdGlvbiBoZXhEYXRhTGVuZ3RoKGRhdGEpIHtcblx0ICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcblx0ICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG5cdH1cblx0ZXhwb3J0cy5oZXhEYXRhTGVuZ3RoID0gaGV4RGF0YUxlbmd0aDtcblx0ZnVuY3Rpb24gaGV4RGF0YVNsaWNlKGRhdGEsIG9mZnNldCwgZW5kT2Zmc2V0KSB7XG5cdCAgICBpZiAodHlwZW9mIChkYXRhKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoIWlzSGV4U3RyaW5nKGRhdGEpIHx8IChkYXRhLmxlbmd0aCAlIDIpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4RGF0YVwiLCBcInZhbHVlXCIsIGRhdGEpO1xuXHQgICAgfVxuXHQgICAgb2Zmc2V0ID0gMiArIDIgKiBvZmZzZXQ7XG5cdCAgICBpZiAoZW5kT2Zmc2V0ICE9IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0LCAyICsgMiAqIGVuZE9mZnNldCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0KTtcblx0fVxuXHRleHBvcnRzLmhleERhdGFTbGljZSA9IGhleERhdGFTbGljZTtcblx0ZnVuY3Rpb24gaGV4Q29uY2F0KGl0ZW1zKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gXCIweFwiO1xuXHQgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuXHQgICAgICAgIHJlc3VsdCArPSBoZXhsaWZ5KGl0ZW0pLnN1YnN0cmluZygyKTtcblx0ICAgIH0pO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLmhleENvbmNhdCA9IGhleENvbmNhdDtcblx0ZnVuY3Rpb24gaGV4VmFsdWUodmFsdWUpIHtcblx0ICAgIHZhciB0cmltbWVkID0gaGV4U3RyaXBaZXJvcyhoZXhsaWZ5KHZhbHVlLCB7IGhleFBhZDogXCJsZWZ0XCIgfSkpO1xuXHQgICAgaWYgKHRyaW1tZWQgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBcIjB4MFwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRyaW1tZWQ7XG5cdH1cblx0ZXhwb3J0cy5oZXhWYWx1ZSA9IGhleFZhbHVlO1xuXHRmdW5jdGlvbiBoZXhTdHJpcFplcm9zKHZhbHVlKSB7XG5cdCAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG5cdCAgICB2YXIgb2Zmc2V0ID0gMDtcblx0ICAgIHdoaWxlIChvZmZzZXQgPCB2YWx1ZS5sZW5ndGggJiYgdmFsdWVbb2Zmc2V0XSA9PT0gXCIwXCIpIHtcblx0ICAgICAgICBvZmZzZXQrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcob2Zmc2V0KTtcblx0fVxuXHRleHBvcnRzLmhleFN0cmlwWmVyb3MgPSBoZXhTdHJpcFplcm9zO1xuXHRmdW5jdGlvbiBoZXhaZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcodmFsdWUpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmICh2YWx1ZS5sZW5ndGggPiAyICogbGVuZ3RoICsgMikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2VcIiwgXCJ2YWx1ZVwiLCBhcmd1bWVudHNbMV0pO1xuXHQgICAgfVxuXHQgICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA8IDIgKiBsZW5ndGggKyAyKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdGV4cG9ydHMuaGV4WmVyb1BhZCA9IGhleFplcm9QYWQ7XG5cdGZ1bmN0aW9uIHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICByOiBcIjB4XCIsXG5cdCAgICAgICAgczogXCIweFwiLFxuXHQgICAgICAgIF92czogXCIweFwiLFxuXHQgICAgICAgIHJlY292ZXJ5UGFyYW06IDAsXG5cdCAgICAgICAgdjogMFxuXHQgICAgfTtcblx0ICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gYXJyYXlpZnkoc2lnbmF0dXJlKTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA2NSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBzaWduYXR1cmUgc3RyaW5nOyBtdXN0IGJlIDY1IGJ5dGVzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEdldCB0aGUgciwgcyBhbmQgdlxuXHQgICAgICAgIHJlc3VsdC5yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCAzMikpO1xuXHQgICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcblx0ICAgICAgICByZXN1bHQudiA9IGJ5dGVzWzY0XTtcblx0ICAgICAgICAvLyBBbGxvdyBhIHJlY2lkIHRvIGJlIHVzZWQgYXMgdGhlIHZcblx0ICAgICAgICBpZiAocmVzdWx0LnYgPCAyNykge1xuXHQgICAgICAgICAgICBpZiAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC52ICs9IDI3O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBpbnZhbGlkIHYgYnl0ZVwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENvbXB1dGUgcmVjb3ZlcnlQYXJhbSBmcm9tIHZcblx0ICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcblx0ICAgICAgICAvLyBDb21wdXRlIF92cyBmcm9tIHJlY292ZXJ5UGFyYW0gYW5kIHNcblx0ICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0pIHtcblx0ICAgICAgICAgICAgYnl0ZXNbMzJdIHw9IDB4ODA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDMyLCA2NCkpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgcmVzdWx0LnIgPSBzaWduYXR1cmUucjtcblx0ICAgICAgICByZXN1bHQucyA9IHNpZ25hdHVyZS5zO1xuXHQgICAgICAgIHJlc3VsdC52ID0gc2lnbmF0dXJlLnY7XG5cdCAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSBzaWduYXR1cmUucmVjb3ZlcnlQYXJhbTtcblx0ICAgICAgICByZXN1bHQuX3ZzID0gc2lnbmF0dXJlLl92cztcblx0ICAgICAgICAvLyBJZiB0aGUgX3ZzIGlzIGF2YWlsYWJsZSwgdXNlIGl0IHRvIHBvcHVsYXRlIG1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuXHQgICAgICAgIC8vIGFuZCB2ZXJpZnkgbm9uLW1pc3NpbmcgcywgdiBhbmQgcmVjb3ZlcnlQYXJhbVxuXHQgICAgICAgIGlmIChyZXN1bHQuX3ZzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHZzXzEgPSB6ZXJvUGFkKGFycmF5aWZ5KHJlc3VsdC5fdnMpLCAzMik7XG5cdCAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhsaWZ5KHZzXzEpO1xuXHQgICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHJlY2lkXG5cdCAgICAgICAgICAgIHZhciByZWNvdmVyeVBhcmFtID0gKCh2c18xWzBdID49IDEyOCkgPyAxIDogMCk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHJlY292ZXJ5UGFyYW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcblx0ICAgICAgICAgICAgdnNfMVswXSAmPSAweDdmO1xuXHQgICAgICAgICAgICB2YXIgcyA9IGhleGxpZnkodnNfMSk7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQucyA9IHM7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnMgIT09IHMpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgdiBtaXNtYXRjaCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBVc2UgcmVjaWQgYW5kIHYgdG8gcG9wdWxhdGUgZWFjaCBvdGhlclxuXHQgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIG1pc3NpbmcgdiBhbmQgcmVjb3ZlcnlQYXJhbVwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSAxIC0gKHJlc3VsdC52ICUgMik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQudiA9IDI3ICsgcmVzdWx0LnJlY292ZXJ5UGFyYW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09ICgxIC0gKHJlc3VsdC52ICUgMikpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggdlwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgclwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnIgPSBoZXhaZXJvUGFkKHJlc3VsdC5yLCAzMik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBtaXNzaW5nIG9yIGludmFsaWQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5zLCAzMik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2cyA9IGFycmF5aWZ5KHJlc3VsdC5zKTtcblx0ICAgICAgICBpZiAodnNbMF0gPj0gMTI4KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcyBvdXQgb2YgcmFuZ2VcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG5cdCAgICAgICAgICAgIHZzWzBdIHw9IDB4ODA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBfdnMgPSBoZXhsaWZ5KHZzKTtcblx0ICAgICAgICBpZiAocmVzdWx0Ll92cykge1xuXHQgICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHJlc3VsdC5fdnMpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleFplcm9QYWQocmVzdWx0Ll92cywgMzIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIF92c1xuXHQgICAgICAgIGlmIChyZXN1bHQuX3ZzID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmVzdWx0Ll92cyA9IF92cztcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAocmVzdWx0Ll92cyAhPT0gX3ZzKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgX3ZzIG1pc21hdGNoIHYgYW5kIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuc3BsaXRTaWduYXR1cmUgPSBzcGxpdFNpZ25hdHVyZTtcblx0ZnVuY3Rpb24gam9pblNpZ25hdHVyZShzaWduYXR1cmUpIHtcblx0ICAgIHNpZ25hdHVyZSA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG5cdCAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuXHQgICAgICAgIHNpZ25hdHVyZS5yLFxuXHQgICAgICAgIHNpZ25hdHVyZS5zLFxuXHQgICAgICAgIChzaWduYXR1cmUucmVjb3ZlcnlQYXJhbSA/IFwiMHgxY1wiIDogXCIweDFiXCIpXG5cdCAgICBdKSk7XG5cdH1cblx0ZXhwb3J0cy5qb2luU2lnbmF0dXJlID0gam9pblNpZ25hdHVyZTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkMSA9IHVud3JhcEV4cG9ydHMobGliJDEpO1xuXHR2YXIgbGliXzEkMSA9IGxpYiQxLmlzQnl0ZXNMaWtlO1xuXHR2YXIgbGliXzIkMSA9IGxpYiQxLmlzQnl0ZXM7XG5cdHZhciBsaWJfMyQxID0gbGliJDEuYXJyYXlpZnk7XG5cdHZhciBsaWJfNCA9IGxpYiQxLmNvbmNhdDtcblx0dmFyIGxpYl81ID0gbGliJDEuc3RyaXBaZXJvcztcblx0dmFyIGxpYl82ID0gbGliJDEuemVyb1BhZDtcblx0dmFyIGxpYl83ID0gbGliJDEuaXNIZXhTdHJpbmc7XG5cdHZhciBsaWJfOCA9IGxpYiQxLmhleGxpZnk7XG5cdHZhciBsaWJfOSA9IGxpYiQxLmhleERhdGFMZW5ndGg7XG5cdHZhciBsaWJfMTAgPSBsaWIkMS5oZXhEYXRhU2xpY2U7XG5cdHZhciBsaWJfMTEgPSBsaWIkMS5oZXhDb25jYXQ7XG5cdHZhciBsaWJfMTIgPSBsaWIkMS5oZXhWYWx1ZTtcblx0dmFyIGxpYl8xMyA9IGxpYiQxLmhleFN0cmlwWmVyb3M7XG5cdHZhciBsaWJfMTQgPSBsaWIkMS5oZXhaZXJvUGFkO1xuXHR2YXIgbGliXzE1ID0gbGliJDEuc3BsaXRTaWduYXR1cmU7XG5cdHZhciBsaWJfMTYgPSBsaWIkMS5qb2luU2lnbmF0dXJlO1xuXG5cdHZhciBfdmVyc2lvbiQ0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImJpZ251bWJlci81LjAuN1wiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiQ1ID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiQ0KTtcblx0dmFyIF92ZXJzaW9uXzEkMiA9IF92ZXJzaW9uJDQudmVyc2lvbjtcblxuXHR2YXIgYmlnbnVtYmVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQvKipcblx0ICogIEJpZ051bWJlclxuXHQgKlxuXHQgKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcblx0ICogIGJlY2F1c2UgaXQgaXMgdXNlZCBieSBlbGxpcHRpYywgc28gaXQgaXMgcmVxdWlyZWQgcmVnYXJkbGVzLlxuXHQgKlxuXHQgKi9cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kNC52ZXJzaW9uKTtcblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5cdGZ1bmN0aW9uIGlzQmlnTnVtYmVyaXNoKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG5cdCAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiICYmICh2YWx1ZSAlIDEpID09PSAwKSB8fFxuXHQgICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiAhIXZhbHVlLm1hdGNoKC9eLT9bMC05XSskLykpIHx8XG5cdCAgICAgICAgbGliJDEuaXNIZXhTdHJpbmcodmFsdWUpIHx8XG5cdCAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcImJpZ2ludFwiKSB8fFxuXHQgICAgICAgIGxpYiQxLmlzQnl0ZXModmFsdWUpKTtcblx0fVxuXHRleHBvcnRzLmlzQmlnTnVtYmVyaXNoID0gaXNCaWdOdW1iZXJpc2g7XG5cdHZhciBCaWdOdW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBCaWdOdW1iZXIoY29uc3RydWN0b3JHdWFyZCwgaGV4KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBCaWdOdW1iZXIpO1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IChCaWdOdW1iZXIpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuX2hleCA9IGhleDtcblx0ICAgICAgICB0aGlzLl9pc0JpZ051bWJlciA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMuX2hleC5zdWJzdHJpbmcoMSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgbyA9IEJpZ051bWJlci5mcm9tKG90aGVyKTtcblx0ICAgICAgICBpZiAoby5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiZGl2aXNpb24gYnkgemVyb1wiLCBcImRpdlwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHZhciB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgbW9kdWxvIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm1vZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudW1vZCh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG5cdCAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCByYWlzZSB0byBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJwb3dcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdG9CTihvdGhlcik7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCAnYW5kJyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJhbmRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFuZCh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90ICdvcicgbmVnYXRpdmUgdmFsdWVzXCIsIFwib3JcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0b0JOKG90aGVyKTtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90ICd4b3InIG5lZ2F0aXZlIHZhbHVlc1wiLCBcInhvclwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5tYXNrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90IG1hc2sgbmVnYXRpdmUgdmFsdWVzXCIsIFwibWFza1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubWFza24odmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCBzaGlmdCBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJzaGxcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnNociA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcblx0ICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCBzaGlmdCBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJzaHJcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNocm4odmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZXEodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdCh0b0JOKG90aGVyKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdGUodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndCh0b0JOKG90aGVyKSk7XG5cdCAgICB9O1xuXHQgICAgQmlnTnVtYmVyLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndGUodG9CTihvdGhlcikpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuaXNOZWdhdGl2ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMuX2hleFswXSA9PT0gXCItXCIpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmlzWmVybygpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9OdW1iZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcInRvTnVtYmVyXCIsIHRoaXMudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gTG90cyBvZiBwZW9wbGUgZXhwZWN0IHRoaXMsIHdoaWNoIHdlIGRvIG5vdCBzdXBwb3J0LCBzbyBjaGVja1xuXHQgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAwKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBwYXJhbWV0ZXJzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9TdHJpbmcoMTApO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5wcm90b3R5cGUudG9IZXhTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcblx0ICAgIH07XG5cdCAgICBCaWdOdW1iZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICByZXR1cm4geyB0eXBlOiBcIkJpZ051bWJlclwiLCBoZXg6IHRoaXMudG9IZXhTdHJpbmcoKSB9O1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/MHhbMC05YS1mXSskL2kpKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihfY29uc3RydWN0b3JHdWFyZCwgdG9IZXgodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRvSGV4KG5ldyBibi5CTih2YWx1ZSkpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiKSB7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RmF1bHQoXCJ1bmRlcmZsb3dcIiwgXCJCaWdOdW1iZXIuZnJvbVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHZhbHVlID49IE1BWF9TQUZFIHx8IHZhbHVlIDw9IC1NQVhfU0FGRSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dGYXVsdChcIm92ZXJmbG93XCIsIFwiQmlnTnVtYmVyLmZyb21cIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShTdHJpbmcodmFsdWUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFueVZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYW55VmFsdWUpID09PSBcImJpZ2ludFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShhbnlWYWx1ZS50b1N0cmluZygpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxpYiQxLmlzQnl0ZXMoYW55VmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShsaWIkMS5oZXhsaWZ5KGFueVZhbHVlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChhbnlWYWx1ZSkge1xuXHQgICAgICAgICAgICAvLyBIZXhhYmxlIGludGVyZmFjZSAodGFrZXMgcGlvcml0eSlcblx0ICAgICAgICAgICAgaWYgKGFueVZhbHVlLnRvSGV4U3RyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaGV4ID0gYW55VmFsdWUudG9IZXhTdHJpbmcoKTtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGhleCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIEZvciBub3csIGhhbmRsZSBsZWdhY3kgSlNPTi1pZmllZCB2YWx1ZXMgKGdvZXMgYXdheSBpbiB2Nilcblx0ICAgICAgICAgICAgICAgIHZhciBoZXggPSBhbnlWYWx1ZS5faGV4O1xuXHQgICAgICAgICAgICAgICAgLy8gTmV3LWZvcm0gSlNPTlxuXHQgICAgICAgICAgICAgICAgaWYgKGhleCA9PSBudWxsICYmIGFueVZhbHVlLnR5cGUgPT09IFwiQmlnTnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBoZXggPSBhbnlWYWx1ZS5oZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChoZXgpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKGhleCkgfHwgKGhleFswXSA9PT0gXCItXCIgJiYgbGliJDEuaXNIZXhTdHJpbmcoaGV4LnN1YnN0cmluZygxKSkpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXgpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEJpZ051bWJlci5pc0JpZ051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNCaWdOdW1iZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBCaWdOdW1iZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gQmlnTnVtYmVyO1xuXHQvLyBOb3JtYWxpemUgdGhlIGhleCBzdHJpbmdcblx0ZnVuY3Rpb24gdG9IZXgodmFsdWUpIHtcblx0ICAgIC8vIEZvciBCTiwgY2FsbCBvbiB0aGUgaGV4IHN0cmluZ1xuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIHRvSGV4KHZhbHVlLnRvU3RyaW5nKDE2KSk7XG5cdCAgICB9XG5cdCAgICAvLyBJZiBuZWdhdGl2ZSwgcHJlcGVuZCB0aGUgbmVnYXRpdmUgc2lnbiB0byB0aGUgbm9ybWFsaXplZCBwb3NpdGl2ZSB2YWx1ZVxuXHQgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuXHQgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbmVnYXRpdmUgc2lnblxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuXHQgICAgICAgIC8vIENhbm5vdCBoYXZlIG11bGl0cGxlIG5lZ2F0aXZlIHNpZ25zIChlLmcuIFwiLS0weDA0XCIpXG5cdCAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENhbGwgdG9IZXggb24gdGhlIHBvc2l0aXZlIGNvbXBvbmVudFxuXHQgICAgICAgIHZhbHVlID0gdG9IZXgodmFsdWUpO1xuXHQgICAgICAgIC8vIERvIG5vdCBhbGxvdyBcIi0weDAwXCJcblx0ICAgICAgICBpZiAodmFsdWUgPT09IFwiMHgwMFwiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTmVnYXRlIHRoZSB2YWx1ZVxuXHQgICAgICAgIHJldHVybiBcIi1cIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgLy8gQWRkIGEgXCIweFwiIHByZWZpeCBpZiBtaXNzaW5nXG5cdCAgICBpZiAodmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgLy8gTm9ybWFsaXplIHplcm9cblx0ICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuXHQgICAgfVxuXHQgICAgLy8gTWFrZSB0aGUgc3RyaW5nIGV2ZW4gbGVuZ3RoXG5cdCAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuXHQgICAgICAgIHZhbHVlID0gXCIweDBcIiArIHZhbHVlLnN1YnN0cmluZygyKTtcblx0ICAgIH1cblx0ICAgIC8vIFRyaW0gdG8gc21hbGxlc3QgZXZlbi1sZW5ndGggc3RyaW5nXG5cdCAgICB3aGlsZSAodmFsdWUubGVuZ3RoID4gNCAmJiB2YWx1ZS5zdWJzdHJpbmcoMCwgNCkgPT09IFwiMHgwMFwiKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZS5zdWJzdHJpbmcoNCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0ZnVuY3Rpb24gdG9CaWdOdW1iZXIodmFsdWUpIHtcblx0ICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0b0hleCh2YWx1ZSkpO1xuXHR9XG5cdGZ1bmN0aW9uIHRvQk4odmFsdWUpIHtcblx0ICAgIHZhciBoZXggPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcblx0ICAgIGlmIChoZXhbMF0gPT09IFwiLVwiKSB7XG5cdCAgICAgICAgcmV0dXJuIChuZXcgYm4uQk4oXCItXCIgKyBoZXguc3Vic3RyaW5nKDMpLCAxNikpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBibi5CTihoZXguc3Vic3RyaW5nKDIpLCAxNik7XG5cdH1cblx0ZnVuY3Rpb24gdGhyb3dGYXVsdChmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuXHQgICAgdmFyIHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuXHQgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICBwYXJhbXMudmFsdWUgPSB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihmYXVsdCwgbGliLkxvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcblx0fVxuXG5cdH0pO1xuXG5cdHZhciBiaWdudW1iZXIkMSA9IHVud3JhcEV4cG9ydHMoYmlnbnVtYmVyKTtcblx0dmFyIGJpZ251bWJlcl8xID0gYmlnbnVtYmVyLmlzQmlnTnVtYmVyaXNoO1xuXHR2YXIgYmlnbnVtYmVyXzIgPSBiaWdudW1iZXIuQmlnTnVtYmVyO1xuXG5cdHZhciBmaXhlZG51bWJlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDQudmVyc2lvbik7XG5cblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBaZXJvID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKDApO1xuXHR2YXIgTmVnYXRpdmVPbmUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oLTEpO1xuXHRmdW5jdGlvbiB0aHJvd0ZhdWx0KG1lc3NhZ2UsIGZhdWx0LCBvcGVyYXRpb24sIHZhbHVlKSB7XG5cdCAgICB2YXIgcGFyYW1zID0geyBmYXVsdDogZmF1bHQsIG9wZXJhdGlvbjogb3BlcmF0aW9uIH07XG5cdCAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgIHBhcmFtcy52YWx1ZSA9IHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKG1lc3NhZ2UsIGxpYi5Mb2dnZXIuZXJyb3JzLk5VTUVSSUNfRkFVTFQsIHBhcmFtcyk7XG5cdH1cblx0Ly8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xuXHR2YXIgemVyb3MgPSBcIjBcIjtcblx0d2hpbGUgKHplcm9zLmxlbmd0aCA8IDI1Nikge1xuXHQgICAgemVyb3MgKz0gemVyb3M7XG5cdH1cblx0Ly8gUmV0dXJucyBhIHN0cmluZyBcIjFcIiBmb2xsb3dlZCBieSBkZWNpbWFsIFwiMFwic1xuXHRmdW5jdGlvbiBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKSB7XG5cdCAgICBpZiAodHlwZW9mIChkZWNpbWFscykgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBkZWNpbWFscyA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbShkZWNpbWFscykudG9OdW1iZXIoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGUpIHsgfVxuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpID09PSBcIm51bWJlclwiICYmIGRlY2ltYWxzID49IDAgJiYgZGVjaW1hbHMgPD0gMjU2ICYmICEoZGVjaW1hbHMgJSAxKSkge1xuXHQgICAgICAgIHJldHVybiAoXCIxXCIgKyB6ZXJvcy5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHNpemVcIiwgXCJkZWNpbWFsc1wiLCBkZWNpbWFscyk7XG5cdH1cblx0ZnVuY3Rpb24gZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG5cdCAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuXHQgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgIH1cblx0ICAgIHZhciBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG5cdCAgICAvLyBNYWtlIHN1cmUgd2VpIGlzIGEgYmlnIG51bWJlciAoY29udmVydCBhcyBuZWNlc3NhcnkpXG5cdCAgICB2YWx1ZSA9IGJpZ251bWJlci5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICB2YXIgbmVnYXRpdmUgPSB2YWx1ZS5sdChaZXJvKTtcblx0ICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUubXVsKE5lZ2F0aXZlT25lKTtcblx0ICAgIH1cblx0ICAgIHZhciBmcmFjdGlvbiA9IHZhbHVlLm1vZChtdWx0aXBsaWVyKS50b1N0cmluZygpO1xuXHQgICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIGZyYWN0aW9uID0gXCIwXCIgKyBmcmFjdGlvbjtcblx0ICAgIH1cblx0ICAgIC8vIFN0cmlwIHRyYWluaW5nIDBcblx0ICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ubWF0Y2goL14oWzAtOV0qWzEtOV18MCkoMCopLylbMV07XG5cdCAgICB2YXIgd2hvbGUgPSB2YWx1ZS5kaXYobXVsdGlwbGllcikudG9TdHJpbmcoKTtcblx0ICAgIHZhbHVlID0gd2hvbGUgKyBcIi5cIiArIGZyYWN0aW9uO1xuXHQgICAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICAgICAgdmFsdWUgPSBcIi1cIiArIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdGV4cG9ydHMuZm9ybWF0Rml4ZWQgPSBmb3JtYXRGaXhlZDtcblx0ZnVuY3Rpb24gcGFyc2VGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpIHtcblx0ICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG5cdCAgICAgICAgZGVjaW1hbHMgPSAwO1xuXHQgICAgfVxuXHQgICAgdmFyIG11bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcblx0ICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14tP1swLTkuLF0rJC8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZGVjaW1hbCB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmIChtdWx0aXBsaWVyLmxlbmd0aCAtIDEgPT09IDApIHtcblx0ICAgICAgICByZXR1cm4gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIElzIGl0IG5lZ2F0aXZlP1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gKHZhbHVlLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIpO1xuXHQgICAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG5cdCAgICB9XG5cdCAgICBpZiAodmFsdWUgPT09IFwiLlwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICAvLyBTcGxpdCBpdCBpbnRvIGEgd2hvbGUgYW5kIGZyYWN0aW9uYWwgcGFydFxuXHQgICAgdmFyIGNvbXBzID0gdmFsdWUuc3BsaXQoXCIuXCIpO1xuXHQgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidG9vIG1hbnkgZGVjaW1hbCBwb2ludHNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICB2YXIgd2hvbGUgPSBjb21wc1swXSwgZnJhY3Rpb24gPSBjb21wc1sxXTtcblx0ICAgIGlmICghd2hvbGUpIHtcblx0ICAgICAgICB3aG9sZSA9IFwiMFwiO1xuXHQgICAgfVxuXHQgICAgaWYgKCFmcmFjdGlvbikge1xuXHQgICAgICAgIGZyYWN0aW9uID0gXCIwXCI7XG5cdCAgICB9XG5cdCAgICAvLyBQcmV2ZW50IHVuZGVyZmxvd1xuXHQgICAgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIHRocm93RmF1bHQoXCJmcmFjdGlvbmFsIGNvbXBvbmVudCBleGNlZWRzIGRlY2ltYWxzXCIsIFwidW5kZXJmbG93XCIsIFwicGFyc2VGaXhlZFwiKTtcblx0ICAgIH1cblx0ICAgIC8vIEZ1bGx5IHBhZCB0aGUgc3RyaW5nIHdpdGggemVyb3MgdG8gZ2V0IHRvIHdlaVxuXHQgICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuXHQgICAgICAgIGZyYWN0aW9uICs9IFwiMFwiO1xuXHQgICAgfVxuXHQgICAgdmFyIHdob2xlVmFsdWUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20od2hvbGUpO1xuXHQgICAgdmFyIGZyYWN0aW9uVmFsdWUgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20oZnJhY3Rpb24pO1xuXHQgICAgdmFyIHdlaSA9ICh3aG9sZVZhbHVlLm11bChtdWx0aXBsaWVyKSkuYWRkKGZyYWN0aW9uVmFsdWUpO1xuXHQgICAgaWYgKG5lZ2F0aXZlKSB7XG5cdCAgICAgICAgd2VpID0gd2VpLm11bChOZWdhdGl2ZU9uZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gd2VpO1xuXHR9XG5cdGV4cG9ydHMucGFyc2VGaXhlZCA9IHBhcnNlRml4ZWQ7XG5cdHZhciBGaXhlZEZvcm1hdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEZpeGVkRm9ybWF0KGNvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKSB7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHVzZSBGaXhlZEZvcm1hdCBjb25zdHJ1Y3RvcjsgdXNlIEZpeGVkRm9ybWF0LmZyb21cIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IEZpeGVkRm9ybWF0XCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRoaXMuc2lnbmVkID0gc2lnbmVkO1xuXHQgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblx0ICAgICAgICB0aGlzLmRlY2ltYWxzID0gZGVjaW1hbHM7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gKHNpZ25lZCA/IFwiXCIgOiBcInVcIikgKyBcImZpeGVkXCIgKyBTdHJpbmcod2lkdGgpICsgXCJ4XCIgKyBTdHJpbmcoZGVjaW1hbHMpO1xuXHQgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcblx0ICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuXHQgICAgfVxuXHQgICAgRml4ZWRGb3JtYXQuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZpeGVkRm9ybWF0KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNpZ25lZCA9IHRydWU7XG5cdCAgICAgICAgdmFyIHdpZHRoID0gMTI4O1xuXHQgICAgICAgIHZhciBkZWNpbWFscyA9IDE4O1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgLy8gZGVmYXVsdHMuLi5cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgc2lnbmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2goL14odT8pZml4ZWQoWzAtOV0rKXgoWzAtOV0rKSQvKTtcblx0ICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXRcIiwgXCJmb3JtYXRcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG5cdCAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzJdKTtcblx0ICAgICAgICAgICAgICAgIGRlY2ltYWxzID0gcGFyc2VJbnQobWF0Y2hbM10pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGVjayA9IGZ1bmN0aW9uIChrZXksIHR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZVtrZXldKSAhPT0gdHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoXCIgKyBrZXkgKyBcIiBub3QgXCIgKyB0eXBlICsgXCIpXCIsIFwiZm9ybWF0LlwiICsga2V5LCB2YWx1ZVtrZXldKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBzaWduZWQgPSBjaGVjayhcInNpZ25lZFwiLCBcImJvb2xlYW5cIiwgc2lnbmVkKTtcblx0ICAgICAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcblx0ICAgICAgICAgICAgZGVjaW1hbHMgPSBjaGVjayhcImRlY2ltYWxzXCIsIFwibnVtYmVyXCIsIGRlY2ltYWxzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgd2lkdGggKG5vdCBieXRlIGFsaWduZWQpXCIsIFwiZm9ybWF0LndpZHRoXCIsIHdpZHRoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGRlY2ltYWxzID4gODApIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IChkZWNpbWFscyB0b28gbGFyZ2UpXCIsIFwiZm9ybWF0LmRlY2ltYWxzXCIsIGRlY2ltYWxzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEZvcm1hdChfY29uc3RydWN0b3JHdWFyZCwgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGaXhlZEZvcm1hdDtcblx0fSgpKTtcblx0ZXhwb3J0cy5GaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0O1xuXHR2YXIgRml4ZWROdW1iZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGaXhlZE51bWJlcihjb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZpeGVkTnVtYmVyKTtcblx0ICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkTnVtYmVyIGNvbnN0cnVjdG9yOyB1c2UgRml4ZWROdW1iZXIuZnJvbVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRml4ZWRGb3JtYXRcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG5cdCAgICAgICAgdGhpcy5faGV4ID0gaGV4O1xuXHQgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG5cdCAgICAgICAgdGhpcy5faXNGaXhlZE51bWJlciA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5fY2hlY2tGb3JtYXQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0ICAgICAgICBpZiAodGhpcy5mb3JtYXQubmFtZSAhPT0gb3RoZXIuZm9ybWF0Lm5hbWUpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImluY29tcGF0aWJsZSBmb3JtYXQ7IHVzZSBmaXhlZE51bWJlci50b0Zvcm1hdFwiLCBcIm90aGVyXCIsIG90aGVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmFkZFVuc2FmZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcblx0ICAgICAgICB2YXIgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICB2YXIgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5hZGQoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnN1YlVuc2FmZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcblx0ICAgICAgICB2YXIgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICB2YXIgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5zdWIoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLm11bFVuc2FmZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHQgICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcblx0ICAgICAgICB2YXIgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICB2YXIgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwoYikuZGl2KHRoaXMuZm9ybWF0Ll9tdWx0aXBsaWVyKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUuZGl2VW5zYWZlID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuXHQgICAgICAgIHZhciBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHZhciBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bCh0aGlzLmZvcm1hdC5fbXVsdGlwbGllcikuZGl2KGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBGaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLCB0aGlzLmZvcm1hdCk7XG5cdCAgICAgICAgdmFyIGhhc0ZyYWN0aW9uID0gIWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtcblx0ICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgJiYgaGFzRnJhY3Rpb24pIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YlVuc2FmZShPTkUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5jZWlsaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IEZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sIHRoaXMuZm9ybWF0KTtcblx0ICAgICAgICB2YXIgaGFzRnJhY3Rpb24gPSAhY29tcHNbMV0ubWF0Y2goL14oMCopJC8pO1xuXHQgICAgICAgIGlmICghdGhpcy5pc05lZ2F0aXZlKCkgJiYgaGFzRnJhY3Rpb24pIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZFVuc2FmZShPTkUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIEBUT0RPOiBTdXBwb3J0IG90aGVyIHJvdW5kaW5nIGFsZ29yaXRobXNcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5yb3VuZCA9IGZ1bmN0aW9uIChkZWNpbWFscykge1xuXHQgICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgd2UgYXJlIGFscmVhZHkgaW4gcmFuZ2UsIHdlJ3JlIGRvbmVcblx0ICAgICAgICB2YXIgY29tcHMgPSB0aGlzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpO1xuXHQgICAgICAgIGlmIChkZWNpbWFscyA8IDAgfHwgZGVjaW1hbHMgPiA4MCB8fCAoZGVjaW1hbHMgJSAxKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIGNvdW50XCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29tcHNbMV0ubGVuZ3RoIDw9IGRlY2ltYWxzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZmFjdG9yID0gRml4ZWROdW1iZXIuZnJvbShcIjFcIiArIHplcm9zLnN1YnN0cmluZygwLCBkZWNpbWFscykpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLm11bFVuc2FmZShmYWN0b3IpLmFkZFVuc2FmZShCVU1QKS5mbG9vcigpLmRpdlVuc2FmZShmYWN0b3IpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS5pc1plcm8gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZSA9PT0gXCIwLjBcIik7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZVswXSA9PT0gXCItXCIpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3ZhbHVlOyB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvSGV4U3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoKSB7XG5cdCAgICAgICAgaWYgKHdpZHRoID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlIHdpZHRoXCIsIFwid2lkdGhcIiwgd2lkdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaGV4ID0gYmlnbnVtYmVyLkJpZ051bWJlci5mcm9tKHRoaXMuX2hleCkuZnJvbVR3b3ModGhpcy5mb3JtYXQud2lkdGgpLnRvVHdvcyh3aWR0aCkudG9IZXhTdHJpbmcoKTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChoZXgsIHdpZHRoIC8gOCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIucHJvdG90eXBlLnRvVW5zYWZlRmxvYXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBwYXJzZUZsb2F0KHRoaXMudG9TdHJpbmcoKSk7IH07XG5cdCAgICBGaXhlZE51bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcodGhpcy5fdmFsdWUsIGZvcm1hdCk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWROdW1iZXIuZnJvbVZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFscywgZm9ybWF0KSB7XG5cdCAgICAgICAgLy8gSWYgZGVjaW1hbHMgbG9va3MgbW9yZSBsaWtlIGEgZm9ybWF0LCBhbmQgdGhlcmUgaXMgbm8gZm9ybWF0LCBzaGlmdCB0aGUgcGFyYW1ldGVyc1xuXHQgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCAmJiBkZWNpbWFscyAhPSBudWxsICYmICFiaWdudW1iZXIuaXNCaWdOdW1iZXJpc2goZGVjaW1hbHMpKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGRlY2ltYWxzO1xuXHQgICAgICAgICAgICBkZWNpbWFscyA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChkZWNpbWFscyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21TdHJpbmcoZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSwgRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpKTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZml4ZWRGb3JtYXQgPSBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCk7XG5cdCAgICAgICAgdmFyIG51bWVyaWMgPSBwYXJzZUZpeGVkKHZhbHVlLCBmaXhlZEZvcm1hdC5kZWNpbWFscyk7XG5cdCAgICAgICAgaWYgKCFmaXhlZEZvcm1hdC5zaWduZWQgJiYgbnVtZXJpYy5sdChaZXJvKSkge1xuXHQgICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwib3ZlcmZsb3dcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBoZXggPSBudWxsO1xuXHQgICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcblx0ICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b1R3b3MoZml4ZWRGb3JtYXQud2lkdGgpLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBoZXggPSBudW1lcmljLnRvSGV4U3RyaW5nKCk7XG5cdCAgICAgICAgICAgIGhleCA9IGxpYiQxLmhleFplcm9QYWQoaGV4LCBmaXhlZEZvcm1hdC53aWR0aCAvIDgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcblx0ICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIGRlY2ltYWwsIGZpeGVkRm9ybWF0KTtcblx0ICAgIH07XG5cdCAgICBGaXhlZE51bWJlci5mcm9tQnl0ZXMgPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXHQgICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBcImZpeGVkXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcblx0ICAgICAgICBpZiAobGliJDEuYXJyYXlpZnkodmFsdWUpLmxlbmd0aCA+IGZpeGVkRm9ybWF0LndpZHRoIC8gOCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdmVyZmxvd1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG51bWVyaWMgPSBiaWdudW1iZXIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcblx0ICAgICAgICAgICAgbnVtZXJpYyA9IG51bWVyaWMuZnJvbVR3b3MoZml4ZWRGb3JtYXQud2lkdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaGV4ID0gbnVtZXJpYy50b1R3b3MoKGZpeGVkRm9ybWF0LnNpZ25lZCA/IDAgOiAxKSArIGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuXHQgICAgICAgIHZhciBkZWNpbWFsID0gZm9ybWF0Rml4ZWQobnVtZXJpYywgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuXHQgICAgICAgIHJldHVybiBuZXcgRml4ZWROdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIGhleCwgZGVjaW1hbCwgZml4ZWRGb3JtYXQpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdCkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyh2YWx1ZSwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxpYiQxLmlzQnl0ZXModmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tQnl0ZXModmFsdWUsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUodmFsdWUsIDAsIGZvcm1hdCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAvLyBBbGxvdyBOVU1FUklDX0ZBVUxUIHRvIGJ1YmJsZSB1cFxuXHQgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZpeGVkTnVtYmVyLmlzRml4ZWROdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRml4ZWROdW1iZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGaXhlZE51bWJlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5GaXhlZE51bWJlciA9IEZpeGVkTnVtYmVyO1xuXHR2YXIgT05FID0gRml4ZWROdW1iZXIuZnJvbSgxKTtcblx0dmFyIEJVTVAgPSBGaXhlZE51bWJlci5mcm9tKFwiMC41XCIpO1xuXG5cdH0pO1xuXG5cdHZhciBmaXhlZG51bWJlciQxID0gdW53cmFwRXhwb3J0cyhmaXhlZG51bWJlcik7XG5cdHZhciBmaXhlZG51bWJlcl8xID0gZml4ZWRudW1iZXIuZm9ybWF0Rml4ZWQ7XG5cdHZhciBmaXhlZG51bWJlcl8yID0gZml4ZWRudW1iZXIucGFyc2VGaXhlZDtcblx0dmFyIGZpeGVkbnVtYmVyXzMgPSBmaXhlZG51bWJlci5GaXhlZEZvcm1hdDtcblx0dmFyIGZpeGVkbnVtYmVyXzQgPSBmaXhlZG51bWJlci5GaXhlZE51bWJlcjtcblxuXHR2YXIgbGliJDIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZXhwb3J0cy5CaWdOdW1iZXIgPSBiaWdudW1iZXIuQmlnTnVtYmVyO1xuXG5cdGV4cG9ydHMuZm9ybWF0Rml4ZWQgPSBmaXhlZG51bWJlci5mb3JtYXRGaXhlZDtcblx0ZXhwb3J0cy5GaXhlZEZvcm1hdCA9IGZpeGVkbnVtYmVyLkZpeGVkRm9ybWF0O1xuXHRleHBvcnRzLkZpeGVkTnVtYmVyID0gZml4ZWRudW1iZXIuRml4ZWROdW1iZXI7XG5cdGV4cG9ydHMucGFyc2VGaXhlZCA9IGZpeGVkbnVtYmVyLnBhcnNlRml4ZWQ7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDIgPSB1bndyYXBFeHBvcnRzKGxpYiQyKTtcblx0dmFyIGxpYl8xJDIgPSBsaWIkMi5CaWdOdW1iZXI7XG5cdHZhciBsaWJfMiQyID0gbGliJDIuZm9ybWF0Rml4ZWQ7XG5cdHZhciBsaWJfMyQyID0gbGliJDIuRml4ZWRGb3JtYXQ7XG5cdHZhciBsaWJfNCQxID0gbGliJDIuRml4ZWROdW1iZXI7XG5cdHZhciBsaWJfNSQxID0gbGliJDIucGFyc2VGaXhlZDtcblxuXHR2YXIgX3ZlcnNpb24kNiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJwcm9wZXJ0aWVzLzUuMC4zXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDcgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJDYpO1xuXHR2YXIgX3ZlcnNpb25fMSQzID0gX3ZlcnNpb24kNi52ZXJzaW9uO1xuXG5cdHZhciBsaWIkMyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDYudmVyc2lvbik7XG5cdGZ1bmN0aW9uIGRlZmluZVJlYWRPbmx5KG9iamVjdCwgbmFtZSwgdmFsdWUpIHtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHZhbHVlOiB2YWx1ZSxcblx0ICAgICAgICB3cml0YWJsZTogZmFsc2UsXG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlZmluZVJlYWRPbmx5ID0gZGVmaW5lUmVhZE9ubHk7XG5cdC8vIENyYXdsIHVwIHRoZSBjb25zdHJ1Y3RvciBjaGFpbiB0byBmaW5kIGEgc3RhdGljIG1ldGhvZFxuXHRmdW5jdGlvbiBnZXRTdGF0aWMoY3Rvciwga2V5KSB7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMyOyBpKyspIHtcblx0ICAgICAgICBpZiAoY3RvcltrZXldKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjdG9yW2tleV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY3Rvci5wcm90b3R5cGUgfHwgdHlwZW9mIChjdG9yLnByb3RvdHlwZSkgIT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3Rvci5wcm90b3R5cGUpLmNvbnN0cnVjdG9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZXhwb3J0cy5nZXRTdGF0aWMgPSBnZXRTdGF0aWM7XG5cdGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciBwcm9taXNlcywgcmVzdWx0cztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBwcm9taXNlcyA9IE9iamVjdC5rZXlzKG9iamVjdCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh7IGtleToga2V5LCB2YWx1ZTogdiB9KTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5hbGwocHJvbWlzZXMpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW1bKHJlc3VsdC5rZXkpXSA9IHJlc3VsdC52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwge30pXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5yZXNvbHZlUHJvcGVydGllcyA9IHJlc29sdmVQcm9wZXJ0aWVzO1xuXHRmdW5jdGlvbiBjaGVja1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG5cdCAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2YgKG9iamVjdCkgIT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBvYmplY3RcIiwgXCJvYmplY3RcIiwgb2JqZWN0KTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5rZXlzKG9iamVjdCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgaWYgKCFwcm9wZXJ0aWVzW2tleV0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiICsga2V5LCBcInRyYW5zYWN0aW9uOlwiICsga2V5LCBvYmplY3QpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuY2hlY2tQcm9wZXJ0aWVzID0gY2hlY2tQcm9wZXJ0aWVzO1xuXHRmdW5jdGlvbiBzaGFsbG93Q29weShvYmplY3QpIHtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcblx0ICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRleHBvcnRzLnNoYWxsb3dDb3B5ID0gc2hhbGxvd0NvcHk7XG5cdHZhciBvcGFxdWUgPSB7IGJpZ2ludDogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBudW1iZXI6IHRydWUsIHN0cmluZzogdHJ1ZSB9O1xuXHRmdW5jdGlvbiBfaXNGcm96ZW4ob2JqZWN0KSB7XG5cdCAgICAvLyBPcGFxdWUgb2JqZWN0cyBhcmUgbm90IG11dGFibGUsIHNvIHNhZmUgdG8gY29weSBieSBhc3NpZ25tZW50XG5cdCAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsIHx8IG9wYXF1ZVt0eXBlb2YgKG9iamVjdCldKSB7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIGlmICghT2JqZWN0LmlzRnJvemVuKG9iamVjdCkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmICghX2lzRnJvemVuKG9iamVjdFtrZXlzW2ldXSkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiQ2Fubm90IGRlZXBDb3B5IFwiICsgdHlwZW9mIChvYmplY3QpLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuXHR9XG5cdC8vIFJldHVybnMgYSBuZXcgY29weSBvZiBvYmplY3QsIHN1Y2ggdGhhdCBubyBwcm9wZXJ0aWVzIG1heSBiZSByZXBsYWNlZC5cblx0Ly8gTmV3IHByb3BlcnRpZXMgbWF5IGJlIGFkZGVkIG9ubHkgdG8gb2JqZWN0cy5cblx0ZnVuY3Rpb24gX2RlZXBDb3B5KG9iamVjdCkge1xuXHQgICAgaWYgKF9pc0Zyb3plbihvYmplY3QpKSB7XG5cdCAgICAgICAgcmV0dXJuIG9iamVjdDtcblx0ICAgIH1cblx0ICAgIC8vIEFycmF5cyBhcmUgbXV0YWJsZSwgc28gd2UgbmVlZCB0byBjcmVhdGUgYSBjb3B5XG5cdCAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0Lm1hcChmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gZGVlcENvcHkoaXRlbSk7IH0pKTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKG9iamVjdCkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3Rba2V5XTtcblx0ICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHJlc3VsdCwga2V5LCBkZWVwQ29weSh2YWx1ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJDYW5ub3QgZGVlcENvcHkgXCIgKyB0eXBlb2YgKG9iamVjdCksIFwib2JqZWN0XCIsIG9iamVjdCk7XG5cdH1cblx0ZnVuY3Rpb24gZGVlcENvcHkob2JqZWN0KSB7XG5cdCAgICByZXR1cm4gX2RlZXBDb3B5KG9iamVjdCk7XG5cdH1cblx0ZXhwb3J0cy5kZWVwQ29weSA9IGRlZXBDb3B5O1xuXHR2YXIgRGVzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBEZXNjcmlwdGlvbihpbmZvKSB7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGluZm8pIHtcblx0ICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENvcHkoaW5mb1trZXldKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gRGVzY3JpcHRpb247XG5cdH0oKSk7XG5cdGV4cG9ydHMuRGVzY3JpcHRpb24gPSBEZXNjcmlwdGlvbjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkMyA9IHVud3JhcEV4cG9ydHMobGliJDMpO1xuXHR2YXIgbGliXzEkMyA9IGxpYiQzLmRlZmluZVJlYWRPbmx5O1xuXHR2YXIgbGliXzIkMyA9IGxpYiQzLmdldFN0YXRpYztcblx0dmFyIGxpYl8zJDMgPSBsaWIkMy5yZXNvbHZlUHJvcGVydGllcztcblx0dmFyIGxpYl80JDIgPSBsaWIkMy5jaGVja1Byb3BlcnRpZXM7XG5cdHZhciBsaWJfNSQyID0gbGliJDMuc2hhbGxvd0NvcHk7XG5cdHZhciBsaWJfNiQxID0gbGliJDMuZGVlcENvcHk7XG5cdHZhciBsaWJfNyQxID0gbGliJDMuRGVzY3JpcHRpb247XG5cblx0dmFyIF92ZXJzaW9uJDggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiYWJpLzUuMC41XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJDkgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJDgpO1xuXHR2YXIgX3ZlcnNpb25fMSQ0ID0gX3ZlcnNpb24kOC52ZXJzaW9uO1xuXG5cdHZhciBmcmFnbWVudHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cdDtcblx0dmFyIF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5cdHZhciBNb2RpZmllcnNCeXRlcyA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSwgc3RvcmFnZTogdHJ1ZSB9O1xuXHR2YXIgTW9kaWZpZXJzTmVzdCA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSB9O1xuXHRmdW5jdGlvbiBjaGVja01vZGlmaWVyKHR5cGUsIG5hbWUpIHtcblx0ICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGlmIChNb2RpZmllcnNCeXRlc1tuYW1lXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlID09PSBcImFkZHJlc3NcIikge1xuXHQgICAgICAgIGlmIChuYW1lID09PSBcInBheWFibGVcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlLmluZGV4T2YoXCJbXCIpID49IDAgfHwgdHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG5cdCAgICAgICAgaWYgKE1vZGlmaWVyc05lc3RbbmFtZV0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKE1vZGlmaWVyc0J5dGVzW25hbWVdIHx8IG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbW9kaWZpZXJcIiwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhhdCBjaGlsZHJlbiBvZiBhbiBpbmRleGVkIHR1cGxlIGFyZSBtYXJrZWQgd2l0aCBhIG51bGwgaW5kZXhlZFxuXHRmdW5jdGlvbiBwYXJzZVBhcmFtVHlwZShwYXJhbSwgYWxsb3dJbmRleGVkKSB7XG5cdCAgICB2YXIgb3JpZ2luYWxQYXJhbSA9IHBhcmFtO1xuXHQgICAgZnVuY3Rpb24gdGhyb3dFcnJvcihpKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IHBvc2l0aW9uIFwiICsgaSwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICB9XG5cdCAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG5cdCAgICBmdW5jdGlvbiBuZXdOb2RlKHBhcmVudCkge1xuXHQgICAgICAgIHZhciBub2RlID0geyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IHBhcmVudCwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcblx0ICAgICAgICBpZiAoYWxsb3dJbmRleGVkKSB7XG5cdCAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbm9kZTtcblx0ICAgIH1cblx0ICAgIHZhciBwYXJlbnQgPSB7IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG5cdCAgICB2YXIgbm9kZSA9IHBhcmVudDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgYyA9IHBhcmFtW2ldO1xuXHQgICAgICAgIHN3aXRjaCAoYykge1xuXHQgICAgICAgICAgICBjYXNlIFwiKFwiOlxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlICYmIG5vZGUudHlwZSA9PT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidHVwbGVcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFub2RlLnN0YXRlLmFsbG93UGFyYW1zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dUeXBlID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG5cdCAgICAgICAgICAgICAgICBub2RlLmNvbXBvbmVudHMgPSBbbmV3Tm9kZShub2RlKV07XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5jb21wb25lbnRzWzBdO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCIpXCI6XG5cdCAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNoZWNrTW9kaWZpZXIobm9kZS50eXBlLCBub2RlLm5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcblx0ICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGU7XG5cdCAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIGNoaWxkLnBhcmVudDtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcIixcIjpcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXdOb2RlKG5vZGUucGFyZW50KTtcblx0ICAgICAgICAgICAgICAgIC8veyB0eXBlOiBcIlwiLCBuYW1lOiBcIlwiLCBwYXJlbnQ6IG5vZGUucGFyZW50LCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuXHQgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuY29tcG9uZW50cy5wdXNoKHNpYmxpbmcpO1xuXHQgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgbm9kZSA9IHNpYmxpbmc7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgLy8gSGl0IGEgc3BhY2UuLi5cblx0ICAgICAgICAgICAgY2FzZSBcIiBcIjpcblx0ICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgdHlwZSwgdGhlIHR5cGUgaXMgZG9uZSBhbmQgbWF5IHJlYWQgYSBwYXJhbSBvciBuYW1lXG5cdCAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlICE9PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vZGUuc3RhdGUuYWxsb3dUeXBlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgbmFtZSwgdGhlIG5hbWUgaXMgZG9uZVxuXHQgICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dOYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubmFtZSAhPT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbGxvd0luZGV4ZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcIltcIjpcblx0ICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdGF0ZS5hbGxvd0FycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJdXCI6XG5cdCAgICAgICAgICAgICAgICBpZiAoIW5vZGUuc3RhdGUucmVhZEFycmF5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93TmFtZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93VHlwZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dBcnJheSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93QXJyYXk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLnN0YXRlLnJlYWRBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAobm9kZS5wYXJlbnQpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5leHBlY3RlZCBlb2ZcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICB9XG5cdCAgICBkZWxldGUgcGFyZW50LnN0YXRlO1xuXHQgICAgaWYgKG5vZGUubmFtZSA9PT0gXCJpbmRleGVkXCIpIHtcblx0ICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgICAgICB0aHJvd0Vycm9yKG9yaWdpbmFsUGFyYW0ubGVuZ3RoIC0gNyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcblx0ICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuXHQgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuXHQgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG5cdCAgICB9XG5cdCAgICBwYXJlbnQudHlwZSA9IHZlcmlmeVR5cGUocGFyZW50LnR5cGUpO1xuXHQgICAgcmV0dXJuIHBhcmVudDtcblx0fVxuXHRmdW5jdGlvbiBwb3B1bGF0ZShvYmplY3QsIHBhcmFtcykge1xuXHQgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KG9iamVjdCwga2V5LCBwYXJhbXNba2V5XSk7XG5cdCAgICB9XG5cdH1cblx0ZXhwb3J0cy5Gb3JtYXRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuXHQgICAgLy8gQmFyZSBmb3JtYXR0aW5nLCBhcyBpcyBuZWVkZWQgZm9yIGNvbXB1dGluZyBhIHNpZ2hhc2ggb2YgYW4gZXZlbnQgb3IgZnVuY3Rpb25cblx0ICAgIHNpZ2hhc2g6IFwic2lnaGFzaFwiLFxuXHQgICAgLy8gSHVtYW4tUmVhZGFibGUgd2l0aCBNaW5pbWFsIHNwYWNpbmcgYW5kIHdpdGhvdXQgbmFtZXMgKGNvbXBhY3QgaHVtYW4tcmVhZGFibGUpXG5cdCAgICBtaW5pbWFsOiBcIm1pbmltYWxcIixcblx0ICAgIC8vIEh1bWFuLVJlYWRibGUgd2l0aCBuaWNlIHNwYWNpbmcsIGluY2x1ZGluZyBhbGwgbmFtZXNcblx0ICAgIGZ1bGw6IFwiZnVsbFwiLFxuXHQgICAgLy8gSlNPTi1mb3JtYXQgYSBsYSBTb2xpZGl0eVxuXHQgICAganNvbjogXCJqc29uXCJcblx0fSk7XG5cdHZhciBwYXJhbVR5cGVBcnJheSA9IG5ldyBSZWdFeHAoL14oLiopXFxbKFswLTldKilcXF0kLyk7XG5cdHZhciBQYXJhbVR5cGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBQYXJhbVR5cGUoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGZyb21TdHJpbmdcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFBhcmFtVHlwZSgpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG5cdCAgICAgICAgdmFyIG1hdGNoID0gdGhpcy50eXBlLm1hdGNoKHBhcmFtVHlwZUFycmF5KTtcblx0ICAgICAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuXHQgICAgICAgICAgICAgICAgYXJyYXlMZW5ndGg6IHBhcnNlSW50KG1hdGNoWzJdIHx8IFwiLTFcIiksXG5cdCAgICAgICAgICAgICAgICBhcnJheUNoaWxkcmVuOiBQYXJhbVR5cGUuZnJvbU9iamVjdCh7XG5cdCAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMV0sXG5cdCAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50czogdGhpcy5jb21wb25lbnRzXG5cdCAgICAgICAgICAgICAgICB9KSxcblx0ICAgICAgICAgICAgICAgIGJhc2VUeXBlOiBcImFycmF5XCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBwb3B1bGF0ZSh0aGlzLCB7XG5cdCAgICAgICAgICAgICAgICBhcnJheUxlbmd0aDogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IG51bGwsXG5cdCAgICAgICAgICAgICAgICBiYXNlVHlwZTogKCh0aGlzLmNvbXBvbmVudHMgIT0gbnVsbCkgPyBcInR1cGxlXCIgOiB0aGlzLnR5cGUpXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB0aGlzLl9pc1BhcmFtVHlwZSA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIC8vIEZvcm1hdCB0aGUgcGFyYW1ldGVyIGZyYWdtZW50XG5cdCAgICAvLyAgIC0gc2lnaGFzaDogXCIodWludDI1NixhZGRyZXNzKVwiXG5cdCAgICAvLyAgIC0gbWluaW1hbDogXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcIlxuXHQgICAgLy8gICAtIGZ1bGw6ICAgIFwidHVwbGUodWludDI1NiBmb28sIGFkZHJlcyBiYXIpIGluZGV4ZWQgYmF6XCJcblx0ICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuXHQgICAgICAgIGlmICghZm9ybWF0KSB7XG5cdCAgICAgICAgICAgIGZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKCFleHBvcnRzLkZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRfMSA9IHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6ICgodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSA/IFwidHVwbGVcIiA6IHRoaXMudHlwZSksXG5cdCAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lIHx8IHVuZGVmaW5lZClcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAodGhpcy5pbmRleGVkKSA9PT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdF8xLmluZGV4ZWQgPSB0aGlzLmluZGV4ZWQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cykge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0XzEuY29tcG9uZW50cyA9IHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGNvbXApIHsgcmV0dXJuIEpTT04ucGFyc2UoY29tcC5mb3JtYXQoZm9ybWF0KSk7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShyZXN1bHRfMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuXHQgICAgICAgIC8vIEFycmF5XG5cdCAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5hcnJheUNoaWxkcmVuLmZvcm1hdChmb3JtYXQpO1xuXHQgICAgICAgICAgICByZXN1bHQgKz0gXCJbXCIgKyAodGhpcy5hcnJheUxlbmd0aCA8IDAgPyBcIlwiIDogU3RyaW5nKHRoaXMuYXJyYXlMZW5ndGgpKSArIFwiXVwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwidHVwbGVcIikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIihcIiArIHRoaXMuY29tcG9uZW50cy5tYXAoZnVuY3Rpb24gKGNvbXApIHsgcmV0dXJuIGNvbXAuZm9ybWF0KGZvcm1hdCk7IH0pLmpvaW4oKGZvcm1hdCA9PT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5mdWxsKSA/IFwiLCBcIiA6IFwiLFwiKSArIFwiKVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudHlwZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ICE9PSBleHBvcnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXhlZCA9PT0gdHJ1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiIGluZGV4ZWRcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwgJiYgdGhpcy5uYW1lKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBQYXJhbVR5cGUuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgYWxsb3dJbmRleGVkKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbVN0cmluZyh2YWx1ZSwgYWxsb3dJbmRleGVkKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBQYXJhbVR5cGUuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChQYXJhbVR5cGUuaXNQYXJhbVR5cGUodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG5ldyBQYXJhbVR5cGUoX2NvbnN0cnVjdG9yR3VhcmQsIHtcblx0ICAgICAgICAgICAgbmFtZTogKHZhbHVlLm5hbWUgfHwgbnVsbCksXG5cdCAgICAgICAgICAgIHR5cGU6IHZlcmlmeVR5cGUodmFsdWUudHlwZSksXG5cdCAgICAgICAgICAgIGluZGV4ZWQ6ICgodmFsdWUuaW5kZXhlZCA9PSBudWxsKSA/IG51bGwgOiAhIXZhbHVlLmluZGV4ZWQpLFxuXHQgICAgICAgICAgICBjb21wb25lbnRzOiAodmFsdWUuY29tcG9uZW50cyA/IHZhbHVlLmNvbXBvbmVudHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IG51bGwpXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgUGFyYW1UeXBlLmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUsIGFsbG93SW5kZXhlZCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIFBhcmFtVHlwaWZ5KG5vZGUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcblx0ICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcblx0ICAgICAgICAgICAgICAgIGluZGV4ZWQ6IG5vZGUuaW5kZXhlZCxcblx0ICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IG5vZGUuY29tcG9uZW50c1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFBhcmFtVHlwaWZ5KHBhcnNlUGFyYW1UeXBlKHZhbHVlLCAhIWFsbG93SW5kZXhlZCkpO1xuXHQgICAgfTtcblx0ICAgIFBhcmFtVHlwZS5pc1BhcmFtVHlwZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9pc1BhcmFtVHlwZSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFBhcmFtVHlwZTtcblx0fSgpKTtcblx0ZXhwb3J0cy5QYXJhbVR5cGUgPSBQYXJhbVR5cGU7XG5cdDtcblx0ZnVuY3Rpb24gcGFyc2VQYXJhbXModmFsdWUsIGFsbG93SW5kZXgpIHtcblx0ICAgIHJldHVybiBzcGxpdE5lc3RpbmcodmFsdWUpLm1hcChmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIFBhcmFtVHlwZS5mcm9tU3RyaW5nKHBhcmFtLCBhbGxvd0luZGV4KTsgfSk7XG5cdH1cblx0dmFyIEZyYWdtZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gRnJhZ21lbnQoY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGEgc3RhdGljIGZyb20gbWV0aG9kXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBGcmFnbWVudCgpXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG5cdCAgICAgICAgdGhpcy5faXNGcmFnbWVudCA9IHRydWU7XG5cdCAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcblx0ICAgIH1cblx0ICAgIEZyYWdtZW50LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRnJhZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChGcmFnbWVudC5pc0ZyYWdtZW50KHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiZmFsbGJhY2tcIjpcblx0ICAgICAgICAgICAgY2FzZSBcInJlY2VpdmVcIjpcblx0ICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBTb21ldGhpbmc/IE1heWJlIHJldHVybiBhIEZ1bmN0aW9uRnJhZ21lbnQ/IEEgY3VzdG9tIERlZmF1bHRGdW5jdGlvbkZyYWdtZW50P1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmcmFnbWVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRnJhZ21lbnQuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgXCJyZXR1cm5zXCIgaXMgc3Vycm91bmRlZCBieSBhIHNwYWNlIGFuZCBhbGwgd2hpdGVzcGFjZSBpcyBleGFjdGx5IG9uZSBzcGFjZVxuXHQgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxzL2csIFwiIFwiKTtcblx0ICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xcKC9nLCBcIiAoXCIpLnJlcGxhY2UoL1xcKS9nLCBcIikgXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xuXHQgICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZXZlbnRcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnN1YnN0cmluZyg1KS50cmltKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIiBcIilbMF0gPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnN1YnN0cmluZyg4KS50cmltKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh2YWx1ZS5zcGxpdChcIihcIilbMF0udHJpbSgpID09PSBcImNvbnN0cnVjdG9yXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZS50cmltKCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGZyYWdtZW50XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZyYWdtZW50LmlzRnJhZ21lbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGcmFnbWVudDtcblx0fSgpKTtcblx0ZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuXHR2YXIgRXZlbnRGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhFdmVudEZyYWdtZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRXZlbnRGcmFnbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBFdmVudEZyYWdtZW50LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWV4cG9ydHMuRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcblx0ICAgICAgICAgICAgICAgIGFub255bW91czogdGhpcy5hbm9ueW1vdXMsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG5cdCAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpOyB9KVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cdCAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBcImV2ZW50IFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbigoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5hbm9ueW1vdXMpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcImFub255bW91cyBcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRXZlbnRGcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJldmVudFwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV2ZW50IG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHtcblx0ICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcblx0ICAgICAgICAgICAgYW5vbnltb3VzOiB2YWx1ZS5hbm9ueW1vdXMsXG5cdCAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiBuZXcgRXZlbnRGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcblx0ICAgICAgICBpZiAoIW1hdGNoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV2ZW50IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFub255bW91cyA9IGZhbHNlO1xuXHQgICAgICAgIG1hdGNoWzNdLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImFub255bW91c1wiOlxuXHQgICAgICAgICAgICAgICAgICAgIGFub255bW91cyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gRXZlbnRGcmFnbWVudC5mcm9tT2JqZWN0KHtcblx0ICAgICAgICAgICAgbmFtZTogbWF0Y2hbMV0udHJpbSgpLFxuXHQgICAgICAgICAgICBhbm9ueW1vdXM6IGFub255bW91cyxcblx0ICAgICAgICAgICAgaW5wdXRzOiBwYXJzZVBhcmFtcyhtYXRjaFsyXSwgdHJ1ZSksXG5cdCAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIlxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEV2ZW50RnJhZ21lbnQuaXNFdmVudEZyYWdtZW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICh2YWx1ZSAmJiB2YWx1ZS5faXNGcmFnbWVudCAmJiB2YWx1ZS50eXBlID09PSBcImV2ZW50XCIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBFdmVudEZyYWdtZW50O1xuXHR9KEZyYWdtZW50KSk7XG5cdGV4cG9ydHMuRXZlbnRGcmFnbWVudCA9IEV2ZW50RnJhZ21lbnQ7XG5cdGZ1bmN0aW9uIHBhcnNlR2FzKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgIHBhcmFtcy5nYXMgPSBudWxsO1xuXHQgICAgdmFyIGNvbXBzID0gdmFsdWUuc3BsaXQoXCJAXCIpO1xuXHQgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMSkge1xuXHQgICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAyKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICghY29tcHNbMV0ubWF0Y2goL15bMC05XSskLykpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZSBnYXNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtcy5nYXMgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjb21wc1sxXSk7XG5cdCAgICAgICAgcmV0dXJuIGNvbXBzWzBdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdGZ1bmN0aW9uIHBhcnNlTW9kaWZpZXJzKHZhbHVlLCBwYXJhbXMpIHtcblx0ICAgIHBhcmFtcy5jb25zdGFudCA9IGZhbHNlO1xuXHQgICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcblx0ICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcblx0ICAgIHZhbHVlLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuXHQgICAgICAgIHN3aXRjaCAobW9kaWZpZXIudHJpbSgpKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJjb25zdGFudFwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicGF5YWJsZVwiOlxuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnBheWFibGUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJub25wYXlhYmxlXCI6XG5cdCAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwibm9ucGF5YWJsZVwiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJwdXJlXCI6XG5cdCAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicHVyZVwiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJ2aWV3XCI6XG5cdCAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJleHRlcm5hbFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCJcIjpcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmtub3duIG1vZGlmaWVyOiBcIiArIG1vZGlmaWVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiB2ZXJpZnlTdGF0ZSh2YWx1ZSkge1xuXHQgICAgdmFyIHJlc3VsdCA9IHtcblx0ICAgICAgICBjb25zdGFudDogZmFsc2UsXG5cdCAgICAgICAgcGF5YWJsZTogdHJ1ZSxcblx0ICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiXG5cdCAgICB9O1xuXHQgICAgaWYgKHZhbHVlLnN0YXRlTXV0YWJpbGl0eSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IHZhbHVlLnN0YXRlTXV0YWJpbGl0eTtcblx0ICAgICAgICAvLyBTZXQgKGFuZCBjaGVjayB0aGluZ3MgYXJlIGNvbnNpc3RlbnQpIHRoZSBjb25zdGFudCBwcm9wZXJ0eVxuXHQgICAgICAgIHJlc3VsdC5jb25zdGFudCA9IChyZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID09PSBcInB1cmVcIik7XG5cdCAgICAgICAgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgaWYgKCghIXZhbHVlLmNvbnN0YW50KSAhPT0gcmVzdWx0LmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGhhdmUgY29uc3RhbnQgZnVuY3Rpb24gd2l0aCBtdXRhYmlsaXR5IFwiICsgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgcGF5YWJsZSBwcm9wZXJ0eVxuXHQgICAgICAgIHJlc3VsdC5wYXlhYmxlID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcblx0ICAgICAgICBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmICgoISF2YWx1ZS5wYXlhYmxlKSAhPT0gcmVzdWx0LnBheWFibGUpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBwYXlhYmxlIGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodmFsdWUucGF5YWJsZSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmVzdWx0LnBheWFibGUgPSAhIXZhbHVlLnBheWFibGU7XG5cdCAgICAgICAgLy8gSWYgcGF5YWJsZSB3ZSBjYW4gYXNzdW1lIG5vbi1jb25zdGFudDsgb3RoZXJ3aXNlIHdlIGNhbid0IGFzc3VtZVxuXHQgICAgICAgIGlmICh2YWx1ZS5jb25zdGFudCA9PSBudWxsICYmICFyZXN1bHQucGF5YWJsZSAmJiB2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuXHQgICAgICAgIGlmIChyZXN1bHQuY29uc3RhbnQpIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocmVzdWx0LnBheWFibGUgJiYgcmVzdWx0LmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBwYXlhYmxlIGZ1bmN0aW9uXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcblx0ICAgICAgICByZXN1bHQuY29uc3RhbnQgPSAhIXZhbHVlLmNvbnN0YW50O1xuXHQgICAgICAgIHJlc3VsdC5wYXlhYmxlID0gIXJlc3VsdC5jb25zdGFudDtcblx0ICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gKHJlc3VsdC5jb25zdGFudCA/IFwidmlld1wiIDogXCJwYXlhYmxlXCIpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHR2YXIgQ29uc3RydWN0b3JGcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhDb25zdHJ1Y3RvckZyYWdtZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQ29uc3RydWN0b3JGcmFnbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBDb25zdHJ1Y3RvckZyYWdtZW50LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWV4cG9ydHMuRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIixcblx0ICAgICAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogKCh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpID8gdGhpcy5zdGF0ZU11dGFiaWxpdHkgOiB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICAgICAgcGF5YmxlOiB0aGlzLnBheWFibGUsXG5cdCAgICAgICAgICAgICAgICBnYXM6ICh0aGlzLmdhcyA/IHRoaXMuZ2FzLnRvTnVtYmVyKCkgOiB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKTsgfSlcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBmb3JtYXQgYSBjb25zdHJ1Y3RvciBmb3Igc2lnaGFzaFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJmb3JtYXQoc2lnaGFzaClcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiY29uc3RydWN0b3IoXCIgKyB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbigoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuXHQgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAmJiB0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcblx0ICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuc3RhdGVNdXRhYmlsaXR5ICsgXCIgXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuXHQgICAgfTtcblx0ICAgIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29uc3RydWN0b3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3RhdGUgPSB2ZXJpZnlTdGF0ZSh2YWx1ZSk7XG5cdCAgICAgICAgaWYgKHN0YXRlLmNvbnN0YW50KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY29uc3RhbnRcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgIG5hbWU6IG51bGwsXG5cdCAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG5cdCAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuXHQgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IHN0YXRlLnN0YXRlTXV0YWJpbGl0eSxcblx0ICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHsgdHlwZTogXCJjb25zdHJ1Y3RvclwiIH07XG5cdCAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcblx0ICAgICAgICB2YXIgcGFyZW5zID0gdmFsdWUubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgaWYgKCFwYXJlbnMgfHwgcGFyZW5zWzFdLnRyaW0oKSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXS50cmltKCksIGZhbHNlKTtcblx0ICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuXHQgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBDb25zdHJ1Y3RvckZyYWdtZW50LmlzQ29uc3RydWN0b3JGcmFnbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudDtcblx0fShGcmFnbWVudCkpO1xuXHRleHBvcnRzLkNvbnN0cnVjdG9yRnJhZ21lbnQgPSBDb25zdHJ1Y3RvckZyYWdtZW50O1xuXHR2YXIgRnVuY3Rpb25GcmFnbWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhGdW5jdGlvbkZyYWdtZW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRnVuY3Rpb25GcmFnbWVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgaWYgKCFmb3JtYXQpIHtcblx0ICAgICAgICAgICAgZm9ybWF0ID0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWV4cG9ydHMuRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmpzb24pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcblx0ICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcblx0ICAgICAgICAgICAgICAgIGNvbnN0YW50OiB0aGlzLmNvbnN0YW50LFxuXHQgICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICBwYXlibGU6IHRoaXMucGF5YWJsZSxcblx0ICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpOyB9KSxcblx0ICAgICAgICAgICAgICAgIG91cHV0czogdGhpcy5vdXRwdXRzLm1hcChmdW5jdGlvbiAob3V0cHV0KSB7IHJldHVybiBKU09OLnBhcnNlKG91dHB1dC5mb3JtYXQoZm9ybWF0KSk7IH0pLFxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG5cdCAgICAgICAgaWYgKGZvcm1hdCAhPT0gZXhwb3J0cy5Gb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCArPSBcImZ1bmN0aW9uIFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXN1bHQgKz0gdGhpcy5uYW1lICsgXCIoXCIgKyB0aGlzLmlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiBpbnB1dC5mb3JtYXQoZm9ybWF0KTsgfSkuam9pbigoZm9ybWF0ID09PSBleHBvcnRzLkZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuXHQgICAgICAgIGlmIChmb3JtYXQgIT09IGV4cG9ydHMuRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICsgXCIgXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuY29uc3RhbnQpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInZpZXcgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMub3V0cHV0cyAmJiB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJyZXR1cm5zIChcIiArIHRoaXMub3V0cHV0cy5tYXAoZnVuY3Rpb24gKG91dHB1dCkgeyByZXR1cm4gb3V0cHV0LmZvcm1hdChmb3JtYXQpOyB9KS5qb2luKFwiLCBcIikgKyBcIikgXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHRoaXMuZ2FzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIkBcIiArIHRoaXMuZ2FzLnRvU3RyaW5nKCkgKyBcIiBcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcblx0ICAgIH07XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LmZyb20gPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZ1bmN0aW9uRnJhZ21lbnQuZnJvbU9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmIChGdW5jdGlvbkZyYWdtZW50LmlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0YXRlID0gdmVyaWZ5U3RhdGUodmFsdWUpO1xuXHQgICAgICAgIHZhciBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG5cdCAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG5cdCAgICAgICAgICAgIGNvbnN0YW50OiBzdGF0ZS5jb25zdGFudCxcblx0ICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG5cdCAgICAgICAgICAgIG91dHB1dHM6ICh2YWx1ZS5vdXRwdXRzID8gdmFsdWUub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuXHQgICAgICAgICAgICBwYXlhYmxlOiBzdGF0ZS5wYXlhYmxlLFxuXHQgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IHN0YXRlLnN0YXRlTXV0YWJpbGl0eSxcblx0ICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uRnJhZ21lbnQoX2NvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcyk7XG5cdCAgICB9O1xuXHQgICAgRnVuY3Rpb25GcmFnbWVudC5mcm9tU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHBhcmFtcyA9IHsgdHlwZTogXCJmdW5jdGlvblwiIH07XG5cdCAgICAgICAgdmFsdWUgPSBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKTtcblx0ICAgICAgICB2YXIgY29tcHMgPSB2YWx1ZS5zcGxpdChcIiByZXR1cm5zIFwiKTtcblx0ICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBwYXJlbnMgPSBjb21wc1swXS5tYXRjaChyZWdleFBhcmVuKTtcblx0ICAgICAgICBpZiAoIXBhcmVucykge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmdW5jdGlvbiBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtcy5uYW1lID0gcGFyZW5zWzFdLnRyaW0oKTtcblx0ICAgICAgICBpZiAocGFyYW1zLm5hbWUpIHtcblx0ICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHBhcmFtcy5pbnB1dHMgPSBwYXJzZVBhcmFtcyhwYXJlbnNbMl0sIGZhbHNlKTtcblx0ICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuXHQgICAgICAgIC8vIFdlIGhhdmUgb3V0cHV0c1xuXHQgICAgICAgIGlmIChjb21wcy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgIHZhciByZXR1cm5zID0gY29tcHNbMV0ubWF0Y2gocmVnZXhQYXJlbik7XG5cdCAgICAgICAgICAgIGlmIChyZXR1cm5zWzFdLnRyaW0oKSAhPSBcIlwiIHx8IHJldHVybnNbM10udHJpbSgpICE9IFwiXCIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIHRva2Vuc1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IHBhcnNlUGFyYW1zKHJldHVybnNbMl0sIGZhbHNlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHBhcmFtcy5vdXRwdXRzID0gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICBGdW5jdGlvbkZyYWdtZW50LmlzRnVuY3Rpb25GcmFnbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJmdW5jdGlvblwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRnVuY3Rpb25GcmFnbWVudDtcblx0fShDb25zdHJ1Y3RvckZyYWdtZW50KSk7XG5cdGV4cG9ydHMuRnVuY3Rpb25GcmFnbWVudCA9IEZ1bmN0aW9uRnJhZ21lbnQ7XG5cdC8vZXhwb3J0IGNsYXNzIEVycm9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG5cdC8vfVxuXHQvL2V4cG9ydCBjbGFzcyBTdHJ1Y3RGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcblx0Ly99XG5cdGZ1bmN0aW9uIHZlcmlmeVR5cGUodHlwZSkge1xuXHQgICAgLy8gVGhlc2UgbmVlZCB0byBiZSB0cmFuc2Zvcm1lZCB0byB0aGVpciBmdWxsIGRlc2NyaXB0aW9uXG5cdCAgICBpZiAodHlwZS5tYXRjaCgvXnVpbnQoJHxbXjEtOV0pLykpIHtcblx0ICAgICAgICB0eXBlID0gXCJ1aW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZyg0KTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykpIHtcblx0ICAgICAgICB0eXBlID0gXCJpbnQyNTZcIiArIHR5cGUuc3Vic3RyaW5nKDMpO1xuXHQgICAgfVxuXHQgICAgLy8gQFRPRE86IG1vcmUgdmVyaWZpY2F0aW9uXG5cdCAgICByZXR1cm4gdHlwZTtcblx0fVxuXHR2YXIgcmVnZXhJZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5bQS1aYS16X11bQS1aYS16MC05X10qJFwiKTtcblx0ZnVuY3Rpb24gdmVyaWZ5SWRlbnRpZmllcih2YWx1ZSkge1xuXHQgICAgaWYgKCF2YWx1ZSB8fCAhdmFsdWUubWF0Y2gocmVnZXhJZGVudGlmaWVyKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGlkZW50aWZpZXIgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdmFsdWU7XG5cdH1cblx0dmFyIHJlZ2V4UGFyZW4gPSBuZXcgUmVnRXhwKFwiXihbXikoXSopXFxcXCgoLiopXFxcXCkoW14pKF0qKSRcIik7XG5cdGZ1bmN0aW9uIHNwbGl0TmVzdGluZyh2YWx1ZSkge1xuXHQgICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB2YXIgYWNjdW0gPSBcIlwiO1xuXHQgICAgdmFyIGRlcHRoID0gMDtcblx0ICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IHZhbHVlLmxlbmd0aDsgb2Zmc2V0KyspIHtcblx0ICAgICAgICB2YXIgYyA9IHZhbHVlW29mZnNldF07XG5cdCAgICAgICAgaWYgKGMgPT09IFwiLFwiICYmIGRlcHRoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKGFjY3VtKTtcblx0ICAgICAgICAgICAgYWNjdW0gPSBcIlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgYWNjdW0gKz0gYztcblx0ICAgICAgICAgICAgaWYgKGMgPT09IFwiKFwiKSB7XG5cdCAgICAgICAgICAgICAgICBkZXB0aCsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG5cdCAgICAgICAgICAgICAgICBkZXB0aC0tO1xuXHQgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09PSAtMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhlc2lzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGFjY3VtKSB7XG5cdCAgICAgICAgcmVzdWx0LnB1c2goYWNjdW0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdH0pO1xuXG5cdHZhciBmcmFnbWVudHMkMSA9IHVud3JhcEV4cG9ydHMoZnJhZ21lbnRzKTtcblx0dmFyIGZyYWdtZW50c18xID0gZnJhZ21lbnRzLkZvcm1hdFR5cGVzO1xuXHR2YXIgZnJhZ21lbnRzXzIgPSBmcmFnbWVudHMuUGFyYW1UeXBlO1xuXHR2YXIgZnJhZ21lbnRzXzMgPSBmcmFnbWVudHMuRnJhZ21lbnQ7XG5cdHZhciBmcmFnbWVudHNfNCA9IGZyYWdtZW50cy5FdmVudEZyYWdtZW50O1xuXHR2YXIgZnJhZ21lbnRzXzUgPSBmcmFnbWVudHMuQ29uc3RydWN0b3JGcmFnbWVudDtcblx0dmFyIGZyYWdtZW50c182ID0gZnJhZ21lbnRzLkZ1bmN0aW9uRnJhZ21lbnQ7XG5cblx0dmFyIGFic3RyYWN0Q29kZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kOC52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG5cdCAgICAvLyBGaW5kIHRoZSBmaXJzdCBlcnJvciAoaWYgYW55KVxuXHQgICAgdmFyIGVycm9ycyA9IFtdO1xuXHQgICAgdmFyIGNoZWNrRXJyb3JzID0gZnVuY3Rpb24gKHBhdGgsIG9iamVjdCkge1xuXHQgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuXHQgICAgICAgICAgICB2YXIgY2hpbGRQYXRoID0gcGF0aC5zbGljZSgpO1xuXHQgICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgY2hlY2tFcnJvcnMoY2hpbGRQYXRoLCBvYmplY3Rba2V5XSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7IHBhdGg6IGNoaWxkUGF0aCwgZXJyb3I6IGVycm9yIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuXHQgICAgcmV0dXJuIGVycm9ycztcblx0fVxuXHRleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gY2hlY2tSZXN1bHRFcnJvcnM7XG5cdHZhciBDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvZGVyKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuXHQgICAgICAgIC8vIEBUT0RPOiBkZWZpbmVSZWFkT25seSB0aGVzZVxuXHQgICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblx0ICAgICAgICB0aGlzLmxvY2FsTmFtZSA9IGxvY2FsTmFtZTtcblx0ICAgICAgICB0aGlzLmR5bmFtaWMgPSBkeW5hbWljO1xuXHQgICAgfVxuXHQgICAgQ29kZXIucHJvdG90eXBlLl90aHJvd0Vycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIHZhbHVlKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihtZXNzYWdlLCB0aGlzLmxvY2FsTmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBDb2Rlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Db2RlciA9IENvZGVyO1xuXHR2YXIgV3JpdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgZnVuY3Rpb24gV3JpdGVyKHdvcmRTaXplKSB7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG5cdCAgICAgICAgdGhpcy5fZGF0YSA9IGxpYiQxLmFycmF5aWZ5KFtdKTtcblx0ICAgICAgICB0aGlzLl9wYWRkaW5nID0gbmV3IFVpbnQ4QXJyYXkod29yZFNpemUpO1xuXHQgICAgfVxuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRlci5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaWIkMS5oZXhsaWZ5KHRoaXMuX2RhdGEpOyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0ZXIucHJvdG90eXBlLCBcImxlbmd0aFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kYXRhLmxlbmd0aDsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXcml0ZXIucHJvdG90eXBlLl93cml0ZURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgIHRoaXMuX2RhdGEgPSBsaWIkMS5jb25jYXQoW3RoaXMuX2RhdGEsIGRhdGFdKTtcblx0ICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGg7XG5cdCAgICB9O1xuXHQgICAgLy8gQXJyYXlpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgcmlnaHQgdG8gd29yZFNpemVcblx0ICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVCeXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBieXRlcyA9IGxpYiQxLmFycmF5aWZ5KHZhbHVlKTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSkge1xuXHQgICAgICAgICAgICBieXRlcyA9IGxpYiQxLmNvbmNhdChbYnl0ZXMsIHRoaXMuX3BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSldKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YShieXRlcyk7XG5cdCAgICB9O1xuXHQgICAgV3JpdGVyLnByb3RvdHlwZS5fZ2V0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSkpO1xuXHQgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiB0aGlzLndvcmRTaXplKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuXHQgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLndvcmRTaXplLFxuXHQgICAgICAgICAgICAgICAgb2Zmc2V0OiBieXRlcy5sZW5ndGhcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChieXRlcy5sZW5ndGggJSB0aGlzLndvcmRTaXplKSB7XG5cdCAgICAgICAgICAgIGJ5dGVzID0gbGliJDEuY29uY2F0KFt0aGlzLl9wYWRkaW5nLnNsaWNlKGJ5dGVzLmxlbmd0aCAlIHRoaXMud29yZFNpemUpLCBieXRlc10pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYnl0ZXM7XG5cdCAgICB9O1xuXHQgICAgLy8gQmlnTnVtYmVyaXNoIGl0ZW1zOyBwYWRkZWQgb24gdGhlIGxlZnQgdG8gd29yZFNpemVcblx0ICAgIFdyaXRlci5wcm90b3R5cGUud3JpdGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEodGhpcy5fZ2V0VmFsdWUodmFsdWUpKTtcblx0ICAgIH07XG5cdCAgICBXcml0ZXIucHJvdG90eXBlLndyaXRlVXBkYXRhYmxlVmFsdWUgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5sZW5ndGg7XG5cdCAgICAgICAgdGhpcy53cml0ZVZhbHVlKDApO1xuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX2RhdGEuc2V0KF90aGlzLl9nZXRWYWx1ZSh2YWx1ZSksIG9mZnNldCk7XG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gV3JpdGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLldyaXRlciA9IFdyaXRlcjtcblx0dmFyIFJlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFJlYWRlcihkYXRhLCB3b3JkU2l6ZSwgY29lcmNlRnVuYywgYWxsb3dMb29zZSkge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2RhdGFcIiwgbGliJDEuYXJyYXlpZnkoZGF0YSkpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwid29yZFNpemVcIiwgd29yZFNpemUgfHwgMzIpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2NvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbGxvd0xvb3NlXCIsIGFsbG93TG9vc2UpO1xuXHQgICAgICAgIHRoaXMuX29mZnNldCA9IDA7XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGVyLnByb3RvdHlwZSwgXCJkYXRhXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpYiQxLmhleGxpZnkodGhpcy5fZGF0YSk7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRlci5wcm90b3R5cGUsIFwiY29uc3VtZWRcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fb2Zmc2V0OyB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIC8vIFRoZSBkZWZhdWx0IENvZXJjZSBmdW5jdGlvblxuXHQgICAgUmVhZGVyLmNvZXJjZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhciBtYXRjaCA9IG5hbWUubWF0Y2goXCJedT9pbnQoWzAtOV0rKSRcIik7XG5cdCAgICAgICAgaWYgKG1hdGNoICYmIHBhcnNlSW50KG1hdGNoWzFdKSA8PSA0OCkge1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLmNvZXJjZSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0aGlzLl9jb2VyY2VGdW5jKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2VyY2VGdW5jKG5hbWUsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFJlYWRlci5jb2VyY2UobmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIFJlYWRlci5wcm90b3R5cGUuX3BlZWtCeXRlcyA9IGZ1bmN0aW9uIChvZmZzZXQsIGxlbmd0aCwgbG9vc2UpIHtcblx0ICAgICAgICB2YXIgYWxpZ25lZExlbmd0aCA9IE1hdGguY2VpbChsZW5ndGggLyB0aGlzLndvcmRTaXplKSAqIHRoaXMud29yZFNpemU7XG5cdCAgICAgICAgaWYgKHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLl9kYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBpZiAodGhpcy5hbGxvd0xvb3NlICYmIGxvb3NlICYmIHRoaXMuX29mZnNldCArIGxlbmd0aCA8PSB0aGlzLl9kYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgYWxpZ25lZExlbmd0aCA9IGxlbmd0aDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBvdXQtb2YtYm91bmRzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLl9kYXRhLmxlbmd0aCxcblx0ICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGhcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9kYXRhLnNsaWNlKHRoaXMuX29mZnNldCwgdGhpcy5fb2Zmc2V0ICsgYWxpZ25lZExlbmd0aCk7XG5cdCAgICB9O1xuXHQgICAgUmVhZGVyLnByb3RvdHlwZS5zdWJSZWFkZXIgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQgKyBvZmZzZXQpLCB0aGlzLndvcmRTaXplLCB0aGlzLl9jb2VyY2VGdW5jLCB0aGlzLmFsbG93TG9vc2UpO1xuXHQgICAgfTtcblx0ICAgIFJlYWRlci5wcm90b3R5cGUucmVhZEJ5dGVzID0gZnVuY3Rpb24gKGxlbmd0aCwgbG9vc2UpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSB0aGlzLl9wZWVrQnl0ZXMoMCwgbGVuZ3RoLCAhIWxvb3NlKTtcblx0ICAgICAgICB0aGlzLl9vZmZzZXQgKz0gYnl0ZXMubGVuZ3RoO1xuXHQgICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cblx0ICAgICAgICByZXR1cm4gYnl0ZXMuc2xpY2UoMCwgbGVuZ3RoKTtcblx0ICAgIH07XG5cdCAgICBSZWFkZXIucHJvdG90eXBlLnJlYWRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odGhpcy5yZWFkQnl0ZXModGhpcy53b3JkU2l6ZSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZWFkZXI7XG5cdH0oKSk7XG5cdGV4cG9ydHMuUmVhZGVyID0gUmVhZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBhYnN0cmFjdENvZGVyJDEgPSB1bndyYXBFeHBvcnRzKGFic3RyYWN0Q29kZXIpO1xuXHR2YXIgYWJzdHJhY3RDb2Rlcl8xID0gYWJzdHJhY3RDb2Rlci5jaGVja1Jlc3VsdEVycm9ycztcblx0dmFyIGFic3RyYWN0Q29kZXJfMiA9IGFic3RyYWN0Q29kZXIuQ29kZXI7XG5cdHZhciBhYnN0cmFjdENvZGVyXzMgPSBhYnN0cmFjdENvZGVyLldyaXRlcjtcblx0dmFyIGFic3RyYWN0Q29kZXJfNCA9IGFic3RyYWN0Q29kZXIuUmVhZGVyO1xuXG5cdHZhciBzaGEzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQvKipcclxuXHQgKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxyXG5cdCAqXHJcblx0ICogQHZlcnNpb24gMC41LjdcclxuXHQgKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxyXG5cdCAqIEBjb3B5cmlnaHQgQ2hlbiwgWWktQ3l1YW4gMjAxNS0yMDE2XHJcblx0ICogQGxpY2Vuc2UgTUlUXHJcblx0ICovXHJcblx0Lypqc2xpbnQgYml0d2lzZTogdHJ1ZSAqL1xyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICAndXNlIHN0cmljdCc7XHJcblxyXG5cdCAgdmFyIHJvb3QgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyA/IHdpbmRvdyA6IHt9O1xyXG5cdCAgdmFyIE5PREVfSlMgPSAhcm9vdC5KU19TSEEzX05PX05PREVfSlMgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlO1xyXG5cdCAgaWYgKE5PREVfSlMpIHtcclxuXHQgICAgcm9vdCA9IGNvbW1vbmpzR2xvYmFsO1xyXG5cdCAgfVxyXG5cdCAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmICdvYmplY3QnID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cztcclxuXHQgIHZhciBIRVhfQ0hBUlMgPSAnMDEyMzQ1Njc4OWFiY2RlZicuc3BsaXQoJycpO1xyXG5cdCAgdmFyIFNIQUtFX1BBRERJTkcgPSBbMzEsIDc5MzYsIDIwMzE2MTYsIDUyMDA5MzY5Nl07XHJcblx0ICB2YXIgS0VDQ0FLX1BBRERJTkcgPSBbMSwgMjU2LCA2NTUzNiwgMTY3NzcyMTZdO1xyXG5cdCAgdmFyIFBBRERJTkcgPSBbNiwgMTUzNiwgMzkzMjE2LCAxMDA2NjMyOTZdO1xyXG5cdCAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XHJcblx0ICB2YXIgUkMgPSBbMSwgMCwgMzI4OTgsIDAsIDMyOTA2LCAyMTQ3NDgzNjQ4LCAyMTQ3NTE2NDE2LCAyMTQ3NDgzNjQ4LCAzMjkwNywgMCwgMjE0NzQ4MzY0OSxcclxuXHQgICAgICAgICAgICAwLCAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjc3NywgMjE0NzQ4MzY0OCwgMTM4LCAwLCAxMzYsIDAsIDIxNDc1MTY0MjUsIDAsXHJcblx0ICAgICAgICAgICAgMjE0NzQ4MzY1OCwgMCwgMjE0NzUxNjU1NSwgMCwgMTM5LCAyMTQ3NDgzNjQ4LCAzMjkwNSwgMjE0NzQ4MzY0OCwgMzI3NzEsXHJcblx0ICAgICAgICAgICAgMjE0NzQ4MzY0OCwgMzI3NzAsIDIxNDc0ODM2NDgsIDEyOCwgMjE0NzQ4MzY0OCwgMzI3NzgsIDAsIDIxNDc0ODM2NTgsIDIxNDc0ODM2NDgsXHJcblx0ICAgICAgICAgICAgMjE0NzUxNjU0NSwgMjE0NzQ4MzY0OCwgMzI4OTYsIDIxNDc0ODM2NDgsIDIxNDc0ODM2NDksIDAsIDIxNDc1MTY0MjQsIDIxNDc0ODM2NDhdO1xyXG5cdCAgdmFyIEJJVFMgPSBbMjI0LCAyNTYsIDM4NCwgNTEyXTtcclxuXHQgIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcclxuXHQgIHZhciBPVVRQVVRfVFlQRVMgPSBbJ2hleCcsICdidWZmZXInLCAnYXJyYXlCdWZmZXInLCAnYXJyYXknXTtcclxuXHJcblx0ICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcclxuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cykudXBkYXRlKG1lc3NhZ2UpW291dHB1dFR5cGVdKCk7XHJcblx0ICAgIH07XHJcblx0ICB9O1xyXG5cclxuXHQgIHZhciBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XHJcblx0ICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xyXG5cdCAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xyXG5cdCAgICB9O1xyXG5cdCAgfTtcclxuXHJcblx0ICB2YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcpIHtcclxuXHQgICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XHJcblx0ICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgYml0cyk7XHJcblx0ICAgIH07XHJcblx0ICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xyXG5cdCAgICAgIHJldHVybiBtZXRob2QuY3JlYXRlKCkudXBkYXRlKG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xyXG5cdCAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCB0eXBlKTtcclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gbWV0aG9kO1xyXG5cdCAgfTtcclxuXHJcblx0ICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xyXG5cdCAgICB2YXIgbWV0aG9kID0gY3JlYXRlU2hha2VPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xyXG5cdCAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMpIHtcclxuXHQgICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcclxuXHQgICAgfTtcclxuXHQgICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzKSB7XHJcblx0ICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xyXG5cdCAgICB9O1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xyXG5cdCAgICAgIHZhciB0eXBlID0gT1VUUFVUX1RZUEVTW2ldO1xyXG5cdCAgICAgIG1ldGhvZFt0eXBlXSA9IGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsIHR5cGUpO1xyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBtZXRob2Q7XHJcblx0ICB9O1xyXG5cclxuXHQgIHZhciBhbGdvcml0aG1zID0gW1xyXG5cdCAgICB7bmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZH0sXHJcblx0ICAgIHtuYW1lOiAnc2hhMycsIHBhZGRpbmc6IFBBRERJTkcsIGJpdHM6IEJJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlTWV0aG9kfSxcclxuXHQgICAge25hbWU6ICdzaGFrZScsIHBhZGRpbmc6IFNIQUtFX1BBRERJTkcsIGJpdHM6IFNIQUtFX0JJVFMsIGNyZWF0ZU1ldGhvZDogY3JlYXRlU2hha2VNZXRob2R9XHJcblx0ICBdO1xyXG5cclxuXHQgIHZhciBtZXRob2RzID0ge30sIG1ldGhvZE5hbWVzID0gW107XHJcblxyXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGdvcml0aG1zLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xyXG5cdCAgICB2YXIgYml0cyAgPSBhbGdvcml0aG0uYml0cztcclxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XHJcblx0ICAgICAgdmFyIG1ldGhvZE5hbWUgPSBhbGdvcml0aG0ubmFtZSArJ18nICsgYml0c1tqXTtcclxuXHQgICAgICBtZXRob2ROYW1lcy5wdXNoKG1ldGhvZE5hbWUpO1xyXG5cdCAgICAgIG1ldGhvZHNbbWV0aG9kTmFtZV0gPSBhbGdvcml0aG0uY3JlYXRlTWV0aG9kKGJpdHNbal0sIGFsZ29yaXRobS5wYWRkaW5nKTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cclxuXHQgIGZ1bmN0aW9uIEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XHJcblx0ICAgIHRoaXMuYmxvY2tzID0gW107XHJcblx0ICAgIHRoaXMucyA9IFtdO1xyXG5cdCAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nO1xyXG5cdCAgICB0aGlzLm91dHB1dEJpdHMgPSBvdXRwdXRCaXRzO1xyXG5cdCAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcclxuXHQgICAgdGhpcy5ibG9jayA9IDA7XHJcblx0ICAgIHRoaXMuc3RhcnQgPSAwO1xyXG5cdCAgICB0aGlzLmJsb2NrQ291bnQgPSAoMTYwMCAtIChiaXRzIDw8IDEpKSA+PiA1O1xyXG5cdCAgICB0aGlzLmJ5dGVDb3VudCA9IHRoaXMuYmxvY2tDb3VudCA8PCAyO1xyXG5cdCAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcclxuXHQgICAgdGhpcy5leHRyYUJ5dGVzID0gKG91dHB1dEJpdHMgJiAzMSkgPj4gMztcclxuXHJcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNTA7ICsraSkge1xyXG5cdCAgICAgIHRoaXMuc1tpXSA9IDA7XHJcblx0ICAgIH1cclxuXHQgIH1cclxuXHJcblx0ICBLZWNjYWsucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcblx0ICAgIHZhciBub3RTdHJpbmcgPSB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZyc7XHJcblx0ICAgIGlmIChub3RTdHJpbmcgJiYgbWVzc2FnZS5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXIpIHtcclxuXHQgICAgICBtZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkobWVzc2FnZSk7XHJcblx0ICAgIH1cclxuXHQgICAgdmFyIGxlbmd0aCA9IG1lc3NhZ2UubGVuZ3RoLCBibG9ja3MgPSB0aGlzLmJsb2NrcywgYnl0ZUNvdW50ID0gdGhpcy5ieXRlQ291bnQsXHJcblx0ICAgICAgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgaW5kZXggPSAwLCBzID0gdGhpcy5zLCBpLCBjb2RlO1xyXG5cclxuXHQgICAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XHJcblx0ICAgICAgaWYgKHRoaXMucmVzZXQpIHtcclxuXHQgICAgICAgIHRoaXMucmVzZXQgPSBmYWxzZTtcclxuXHQgICAgICAgIGJsb2Nrc1swXSA9IHRoaXMuYmxvY2s7XHJcblx0ICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG5cdCAgICAgICAgICBibG9ja3NbaV0gPSAwO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAobm90U3RyaW5nKSB7XHJcblx0ICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XHJcblx0ICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XHJcblx0ICAgICAgICAgIGNvZGUgPSBtZXNzYWdlLmNoYXJDb2RlQXQoaW5kZXgpO1xyXG5cdCAgICAgICAgICBpZiAoY29kZSA8IDB4ODApIHtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPCAweDgwMCkge1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGMwIHwgKGNvZGUgPj4gNikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ZDgwMCB8fCBjb2RlID49IDB4ZTAwMCkge1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGUwIHwgKGNvZGUgPj4gMTIpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8IChjb2RlICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcclxuXHQgICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhmMCB8IChjb2RlID4+IDE4KSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoKGNvZGUgPj4gMTIpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xyXG5cdCAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XHJcblx0ICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgICB9XHJcblx0ICAgICAgdGhpcy5sYXN0Qnl0ZUluZGV4ID0gaTtcclxuXHQgICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnQgPSBpIC0gYnl0ZUNvdW50O1xyXG5cdCAgICAgICAgdGhpcy5ibG9jayA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcclxuXHQgICAgICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcblx0ICAgICAgICB9XHJcblx0ICAgICAgICBmKHMpO1xyXG5cdCAgICAgICAgdGhpcy5yZXNldCA9IHRydWU7XHJcblx0ICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgIHRoaXMuc3RhcnQgPSBpO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gdGhpcztcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdmFyIGJsb2NrcyA9IHRoaXMuYmxvY2tzLCBpID0gdGhpcy5sYXN0Qnl0ZUluZGV4LCBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zO1xyXG5cdCAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xyXG5cdCAgICBpZiAodGhpcy5sYXN0Qnl0ZUluZGV4ID09PSB0aGlzLmJ5dGVDb3VudCkge1xyXG5cdCAgICAgIGJsb2Nrc1swXSA9IGJsb2Nrc1tibG9ja0NvdW50XTtcclxuXHQgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xyXG5cdCAgICAgICAgYmxvY2tzW2ldID0gMDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgYmxvY2tzW2Jsb2NrQ291bnQgLSAxXSB8PSAweDgwMDAwMDAwO1xyXG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudDsgKytpKSB7XHJcblx0ICAgICAgc1tpXSBePSBibG9ja3NbaV07XHJcblx0ICAgIH1cclxuXHQgICAgZihzKTtcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcblx0ICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcblx0ICAgIHZhciBoZXggPSAnJywgYmxvY2s7XHJcblx0ICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XHJcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcclxuXHQgICAgICAgIGJsb2NrID0gc1tpXTtcclxuXHQgICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXHJcblx0ICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXHJcblx0ICAgICAgICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xyXG5cdCAgICAgICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgICBpID0gMDtcclxuXHQgICAgICB9XHJcblx0ICAgIH1cclxuXHQgICAgaWYgKGV4dHJhQnl0ZXMpIHtcclxuXHQgICAgICBibG9jayA9IHNbaV07XHJcblx0ICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAwKSB7XHJcblx0ICAgICAgICBoZXggKz0gSEVYX0NIQVJTWyhibG9jayA+PiA0KSAmIDB4MEZdICsgSEVYX0NIQVJTW2Jsb2NrICYgMHgwRl07XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMTIpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDgpICYgMHgwRl07XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xyXG5cdCAgICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gMjApICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDE2KSAmIDB4MEZdO1xyXG5cdCAgICAgIH1cclxuXHQgICAgfVxyXG5cdCAgICByZXR1cm4gaGV4O1xyXG5cdCAgfTtcclxuXHJcblx0ICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICB0aGlzLmZpbmFsaXplKCk7XHJcblxyXG5cdCAgICB2YXIgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucywgb3V0cHV0QmxvY2tzID0gdGhpcy5vdXRwdXRCbG9ja3MsXHJcblx0ICAgICAgICBleHRyYUJ5dGVzID0gdGhpcy5leHRyYUJ5dGVzLCBpID0gMCwgaiA9IDA7XHJcblx0ICAgIHZhciBieXRlcyA9IHRoaXMub3V0cHV0Qml0cyA+PiAzO1xyXG5cdCAgICB2YXIgYnVmZmVyO1xyXG5cdCAgICBpZiAoZXh0cmFCeXRlcykge1xyXG5cdCAgICAgIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcigob3V0cHV0QmxvY2tzICsgMSkgPDwgMik7XHJcblx0ICAgIH0gZWxzZSB7XHJcblx0ICAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ5dGVzKTtcclxuXHQgICAgfVxyXG5cdCAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcclxuXHQgICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG5cdCAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcblx0ICAgICAgYXJyYXlbaV0gPSBzW2ldO1xyXG5cdCAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zbGljZSgwLCBieXRlcyk7XHJcblx0ICAgIH1cclxuXHQgICAgcmV0dXJuIGJ1ZmZlcjtcclxuXHQgIH07XHJcblxyXG5cdCAgS2VjY2FrLnByb3RvdHlwZS5idWZmZXIgPSBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyO1xyXG5cclxuXHQgIEtlY2Nhay5wcm90b3R5cGUuZGlnZXN0ID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgdGhpcy5maW5hbGl6ZSgpO1xyXG5cclxuXHQgICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxyXG5cdCAgICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xyXG5cdCAgICB2YXIgYXJyYXkgPSBbXSwgb2Zmc2V0LCBibG9jaztcclxuXHQgICAgd2hpbGUgKGogPCBvdXRwdXRCbG9ja3MpIHtcclxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xyXG5cdCAgICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG5cdCAgICAgICAgYmxvY2sgPSBzW2ldO1xyXG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XHJcblx0ICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoaiAlIGJsb2NrQ291bnQgPT09IDApIHtcclxuXHQgICAgICAgIGYocyk7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIGlmIChleHRyYUJ5dGVzKSB7XHJcblx0ICAgICAgb2Zmc2V0ID0gaiA8PCAyO1xyXG5cdCAgICAgIGJsb2NrID0gc1tpXTtcclxuXHQgICAgICBpZiAoZXh0cmFCeXRlcyA+IDApIHtcclxuXHQgICAgICAgIGFycmF5W29mZnNldF0gPSBibG9jayAmIDB4RkY7XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIGlmIChleHRyYUJ5dGVzID4gMSkge1xyXG5cdCAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xyXG5cdCAgICAgIH1cclxuXHQgICAgICBpZiAoZXh0cmFCeXRlcyA+IDIpIHtcclxuXHQgICAgICAgIGFycmF5W29mZnNldCArIDJdID0gKGJsb2NrID4+IDE2KSAmIDB4RkY7XHJcblx0ICAgICAgfVxyXG5cdCAgICB9XHJcblx0ICAgIHJldHVybiBhcnJheTtcclxuXHQgIH07XHJcblxyXG5cdCAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xyXG5cdCAgICB2YXIgaCwgbCwgbiwgYzAsIGMxLCBjMiwgYzMsIGM0LCBjNSwgYzYsIGM3LCBjOCwgYzksXHJcblx0ICAgICAgICBiMCwgYjEsIGIyLCBiMywgYjQsIGI1LCBiNiwgYjcsIGI4LCBiOSwgYjEwLCBiMTEsIGIxMiwgYjEzLCBiMTQsIGIxNSwgYjE2LCBiMTcsXHJcblx0ICAgICAgICBiMTgsIGIxOSwgYjIwLCBiMjEsIGIyMiwgYjIzLCBiMjQsIGIyNSwgYjI2LCBiMjcsIGIyOCwgYjI5LCBiMzAsIGIzMSwgYjMyLCBiMzMsXHJcblx0ICAgICAgICBiMzQsIGIzNSwgYjM2LCBiMzcsIGIzOCwgYjM5LCBiNDAsIGI0MSwgYjQyLCBiNDMsIGI0NCwgYjQ1LCBiNDYsIGI0NywgYjQ4LCBiNDk7XHJcblx0ICAgIGZvciAobiA9IDA7IG4gPCA0ODsgbiArPSAyKSB7XHJcblx0ICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XHJcblx0ICAgICAgYzEgPSBzWzFdIF4gc1sxMV0gXiBzWzIxXSBeIHNbMzFdIF4gc1s0MV07XHJcblx0ICAgICAgYzIgPSBzWzJdIF4gc1sxMl0gXiBzWzIyXSBeIHNbMzJdIF4gc1s0Ml07XHJcblx0ICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XHJcblx0ICAgICAgYzQgPSBzWzRdIF4gc1sxNF0gXiBzWzI0XSBeIHNbMzRdIF4gc1s0NF07XHJcblx0ICAgICAgYzUgPSBzWzVdIF4gc1sxNV0gXiBzWzI1XSBeIHNbMzVdIF4gc1s0NV07XHJcblx0ICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XHJcblx0ICAgICAgYzcgPSBzWzddIF4gc1sxN10gXiBzWzI3XSBeIHNbMzddIF4gc1s0N107XHJcblx0ICAgICAgYzggPSBzWzhdIF4gc1sxOF0gXiBzWzI4XSBeIHNbMzhdIF4gc1s0OF07XHJcblx0ICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XHJcblxyXG5cdCAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XHJcblx0ICAgICAgbCA9IGM5IF4gKChjMyA8PCAxKSB8IChjMiA+Pj4gMzEpKTtcclxuXHQgICAgICBzWzBdIF49IGg7XHJcblx0ICAgICAgc1sxXSBePSBsO1xyXG5cdCAgICAgIHNbMTBdIF49IGg7XHJcblx0ICAgICAgc1sxMV0gXj0gbDtcclxuXHQgICAgICBzWzIwXSBePSBoO1xyXG5cdCAgICAgIHNbMjFdIF49IGw7XHJcblx0ICAgICAgc1szMF0gXj0gaDtcclxuXHQgICAgICBzWzMxXSBePSBsO1xyXG5cdCAgICAgIHNbNDBdIF49IGg7XHJcblx0ICAgICAgc1s0MV0gXj0gbDtcclxuXHQgICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xyXG5cdCAgICAgIGwgPSBjMSBeICgoYzUgPDwgMSkgfCAoYzQgPj4+IDMxKSk7XHJcblx0ICAgICAgc1syXSBePSBoO1xyXG5cdCAgICAgIHNbM10gXj0gbDtcclxuXHQgICAgICBzWzEyXSBePSBoO1xyXG5cdCAgICAgIHNbMTNdIF49IGw7XHJcblx0ICAgICAgc1syMl0gXj0gaDtcclxuXHQgICAgICBzWzIzXSBePSBsO1xyXG5cdCAgICAgIHNbMzJdIF49IGg7XHJcblx0ICAgICAgc1szM10gXj0gbDtcclxuXHQgICAgICBzWzQyXSBePSBoO1xyXG5cdCAgICAgIHNbNDNdIF49IGw7XHJcblx0ICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcclxuXHQgICAgICBsID0gYzMgXiAoKGM3IDw8IDEpIHwgKGM2ID4+PiAzMSkpO1xyXG5cdCAgICAgIHNbNF0gXj0gaDtcclxuXHQgICAgICBzWzVdIF49IGw7XHJcblx0ICAgICAgc1sxNF0gXj0gaDtcclxuXHQgICAgICBzWzE1XSBePSBsO1xyXG5cdCAgICAgIHNbMjRdIF49IGg7XHJcblx0ICAgICAgc1syNV0gXj0gbDtcclxuXHQgICAgICBzWzM0XSBePSBoO1xyXG5cdCAgICAgIHNbMzVdIF49IGw7XHJcblx0ICAgICAgc1s0NF0gXj0gaDtcclxuXHQgICAgICBzWzQ1XSBePSBsO1xyXG5cdCAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XHJcblx0ICAgICAgbCA9IGM1IF4gKChjOSA8PCAxKSB8IChjOCA+Pj4gMzEpKTtcclxuXHQgICAgICBzWzZdIF49IGg7XHJcblx0ICAgICAgc1s3XSBePSBsO1xyXG5cdCAgICAgIHNbMTZdIF49IGg7XHJcblx0ICAgICAgc1sxN10gXj0gbDtcclxuXHQgICAgICBzWzI2XSBePSBoO1xyXG5cdCAgICAgIHNbMjddIF49IGw7XHJcblx0ICAgICAgc1szNl0gXj0gaDtcclxuXHQgICAgICBzWzM3XSBePSBsO1xyXG5cdCAgICAgIHNbNDZdIF49IGg7XHJcblx0ICAgICAgc1s0N10gXj0gbDtcclxuXHQgICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xyXG5cdCAgICAgIGwgPSBjNyBeICgoYzEgPDwgMSkgfCAoYzAgPj4+IDMxKSk7XHJcblx0ICAgICAgc1s4XSBePSBoO1xyXG5cdCAgICAgIHNbOV0gXj0gbDtcclxuXHQgICAgICBzWzE4XSBePSBoO1xyXG5cdCAgICAgIHNbMTldIF49IGw7XHJcblx0ICAgICAgc1syOF0gXj0gaDtcclxuXHQgICAgICBzWzI5XSBePSBsO1xyXG5cdCAgICAgIHNbMzhdIF49IGg7XHJcblx0ICAgICAgc1szOV0gXj0gbDtcclxuXHQgICAgICBzWzQ4XSBePSBoO1xyXG5cdCAgICAgIHNbNDldIF49IGw7XHJcblxyXG5cdCAgICAgIGIwID0gc1swXTtcclxuXHQgICAgICBiMSA9IHNbMV07XHJcblx0ICAgICAgYjMyID0gKHNbMTFdIDw8IDQpIHwgKHNbMTBdID4+PiAyOCk7XHJcblx0ICAgICAgYjMzID0gKHNbMTBdIDw8IDQpIHwgKHNbMTFdID4+PiAyOCk7XHJcblx0ICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XHJcblx0ICAgICAgYjE1ID0gKHNbMjFdIDw8IDMpIHwgKHNbMjBdID4+PiAyOSk7XHJcblx0ICAgICAgYjQ2ID0gKHNbMzFdIDw8IDkpIHwgKHNbMzBdID4+PiAyMyk7XHJcblx0ICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XHJcblx0ICAgICAgYjI4ID0gKHNbNDBdIDw8IDE4KSB8IChzWzQxXSA+Pj4gMTQpO1xyXG5cdCAgICAgIGIyOSA9IChzWzQxXSA8PCAxOCkgfCAoc1s0MF0gPj4+IDE0KTtcclxuXHQgICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XHJcblx0ICAgICAgYjIxID0gKHNbM10gPDwgMSkgfCAoc1syXSA+Pj4gMzEpO1xyXG5cdCAgICAgIGIyID0gKHNbMTNdIDw8IDEyKSB8IChzWzEyXSA+Pj4gMjApO1xyXG5cdCAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xyXG5cdCAgICAgIGIzNCA9IChzWzIyXSA8PCAxMCkgfCAoc1syM10gPj4+IDIyKTtcclxuXHQgICAgICBiMzUgPSAoc1syM10gPDwgMTApIHwgKHNbMjJdID4+PiAyMik7XHJcblx0ICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xyXG5cdCAgICAgIGIxNyA9IChzWzMyXSA8PCAxMykgfCAoc1szM10gPj4+IDE5KTtcclxuXHQgICAgICBiNDggPSAoc1s0Ml0gPDwgMikgfCAoc1s0M10gPj4+IDMwKTtcclxuXHQgICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcclxuXHQgICAgICBiNDAgPSAoc1s1XSA8PCAzMCkgfCAoc1s0XSA+Pj4gMik7XHJcblx0ICAgICAgYjQxID0gKHNbNF0gPDwgMzApIHwgKHNbNV0gPj4+IDIpO1xyXG5cdCAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xyXG5cdCAgICAgIGIyMyA9IChzWzE1XSA8PCA2KSB8IChzWzE0XSA+Pj4gMjYpO1xyXG5cdCAgICAgIGI0ID0gKHNbMjVdIDw8IDExKSB8IChzWzI0XSA+Pj4gMjEpO1xyXG5cdCAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xyXG5cdCAgICAgIGIzNiA9IChzWzM0XSA8PCAxNSkgfCAoc1szNV0gPj4+IDE3KTtcclxuXHQgICAgICBiMzcgPSAoc1szNV0gPDwgMTUpIHwgKHNbMzRdID4+PiAxNyk7XHJcblx0ICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XHJcblx0ICAgICAgYjE5ID0gKHNbNDRdIDw8IDI5KSB8IChzWzQ1XSA+Pj4gMyk7XHJcblx0ICAgICAgYjEwID0gKHNbNl0gPDwgMjgpIHwgKHNbN10gPj4+IDQpO1xyXG5cdCAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcclxuXHQgICAgICBiNDIgPSAoc1sxN10gPDwgMjMpIHwgKHNbMTZdID4+PiA5KTtcclxuXHQgICAgICBiNDMgPSAoc1sxNl0gPDwgMjMpIHwgKHNbMTddID4+PiA5KTtcclxuXHQgICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcclxuXHQgICAgICBiMjUgPSAoc1syN10gPDwgMjUpIHwgKHNbMjZdID4+PiA3KTtcclxuXHQgICAgICBiNiA9IChzWzM2XSA8PCAyMSkgfCAoc1szN10gPj4+IDExKTtcclxuXHQgICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcclxuXHQgICAgICBiMzggPSAoc1s0N10gPDwgMjQpIHwgKHNbNDZdID4+PiA4KTtcclxuXHQgICAgICBiMzkgPSAoc1s0Nl0gPDwgMjQpIHwgKHNbNDddID4+PiA4KTtcclxuXHQgICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XHJcblx0ICAgICAgYjMxID0gKHNbOV0gPDwgMjcpIHwgKHNbOF0gPj4+IDUpO1xyXG5cdCAgICAgIGIxMiA9IChzWzE4XSA8PCAyMCkgfCAoc1sxOV0gPj4+IDEyKTtcclxuXHQgICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XHJcblx0ICAgICAgYjQ0ID0gKHNbMjldIDw8IDcpIHwgKHNbMjhdID4+PiAyNSk7XHJcblx0ICAgICAgYjQ1ID0gKHNbMjhdIDw8IDcpIHwgKHNbMjldID4+PiAyNSk7XHJcblx0ICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XHJcblx0ICAgICAgYjI3ID0gKHNbMzldIDw8IDgpIHwgKHNbMzhdID4+PiAyNCk7XHJcblx0ICAgICAgYjggPSAoc1s0OF0gPDwgMTQpIHwgKHNbNDldID4+PiAxOCk7XHJcblx0ICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XHJcblxyXG5cdCAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XHJcblx0ICAgICAgc1sxXSA9IGIxIF4gKH5iMyAmIGI1KTtcclxuXHQgICAgICBzWzEwXSA9IGIxMCBeICh+YjEyICYgYjE0KTtcclxuXHQgICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcclxuXHQgICAgICBzWzIwXSA9IGIyMCBeICh+YjIyICYgYjI0KTtcclxuXHQgICAgICBzWzIxXSA9IGIyMSBeICh+YjIzICYgYjI1KTtcclxuXHQgICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcclxuXHQgICAgICBzWzMxXSA9IGIzMSBeICh+YjMzICYgYjM1KTtcclxuXHQgICAgICBzWzQwXSA9IGI0MCBeICh+YjQyICYgYjQ0KTtcclxuXHQgICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcclxuXHQgICAgICBzWzJdID0gYjIgXiAofmI0ICYgYjYpO1xyXG5cdCAgICAgIHNbM10gPSBiMyBeICh+YjUgJiBiNyk7XHJcblx0ICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XHJcblx0ICAgICAgc1sxM10gPSBiMTMgXiAofmIxNSAmIGIxNyk7XHJcblx0ICAgICAgc1syMl0gPSBiMjIgXiAofmIyNCAmIGIyNik7XHJcblx0ICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XHJcblx0ICAgICAgc1szMl0gPSBiMzIgXiAofmIzNCAmIGIzNik7XHJcblx0ICAgICAgc1szM10gPSBiMzMgXiAofmIzNSAmIGIzNyk7XHJcblx0ICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XHJcblx0ICAgICAgc1s0M10gPSBiNDMgXiAofmI0NSAmIGI0Nyk7XHJcblx0ICAgICAgc1s0XSA9IGI0IF4gKH5iNiAmIGI4KTtcclxuXHQgICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xyXG5cdCAgICAgIHNbMTRdID0gYjE0IF4gKH5iMTYgJiBiMTgpO1xyXG5cdCAgICAgIHNbMTVdID0gYjE1IF4gKH5iMTcgJiBiMTkpO1xyXG5cdCAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xyXG5cdCAgICAgIHNbMjVdID0gYjI1IF4gKH5iMjcgJiBiMjkpO1xyXG5cdCAgICAgIHNbMzRdID0gYjM0IF4gKH5iMzYgJiBiMzgpO1xyXG5cdCAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xyXG5cdCAgICAgIHNbNDRdID0gYjQ0IF4gKH5iNDYgJiBiNDgpO1xyXG5cdCAgICAgIHNbNDVdID0gYjQ1IF4gKH5iNDcgJiBiNDkpO1xyXG5cdCAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XHJcblx0ICAgICAgc1s3XSA9IGI3IF4gKH5iOSAmIGIxKTtcclxuXHQgICAgICBzWzE2XSA9IGIxNiBeICh+YjE4ICYgYjEwKTtcclxuXHQgICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcclxuXHQgICAgICBzWzI2XSA9IGIyNiBeICh+YjI4ICYgYjIwKTtcclxuXHQgICAgICBzWzI3XSA9IGIyNyBeICh+YjI5ICYgYjIxKTtcclxuXHQgICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcclxuXHQgICAgICBzWzM3XSA9IGIzNyBeICh+YjM5ICYgYjMxKTtcclxuXHQgICAgICBzWzQ2XSA9IGI0NiBeICh+YjQ4ICYgYjQwKTtcclxuXHQgICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcclxuXHQgICAgICBzWzhdID0gYjggXiAofmIwICYgYjIpO1xyXG5cdCAgICAgIHNbOV0gPSBiOSBeICh+YjEgJiBiMyk7XHJcblx0ICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XHJcblx0ICAgICAgc1sxOV0gPSBiMTkgXiAofmIxMSAmIGIxMyk7XHJcblx0ICAgICAgc1syOF0gPSBiMjggXiAofmIyMCAmIGIyMik7XHJcblx0ICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XHJcblx0ICAgICAgc1szOF0gPSBiMzggXiAofmIzMCAmIGIzMik7XHJcblx0ICAgICAgc1szOV0gPSBiMzkgXiAofmIzMSAmIGIzMyk7XHJcblx0ICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XHJcblx0ICAgICAgc1s0OV0gPSBiNDkgXiAofmI0MSAmIGI0Myk7XHJcblxyXG5cdCAgICAgIHNbMF0gXj0gUkNbbl07XHJcblx0ICAgICAgc1sxXSBePSBSQ1tuICsgMV07XHJcblx0ICAgIH1cclxuXHQgIH07XHJcblxyXG5cdCAgaWYgKENPTU1PTl9KUykge1xyXG5cdCAgICBtb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XHJcblx0ICB9IGVsc2Uge1xyXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1ldGhvZE5hbWVzLmxlbmd0aDsgKytpKSB7XHJcblx0ICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcclxuXHQgICAgfVxyXG5cdCAgfVxyXG5cdH0pKCk7XG5cdH0pO1xuXG5cdHZhciBsaWIkNCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIganNfc2hhM18xID0gX19pbXBvcnREZWZhdWx0KHNoYTMpO1xuXG5cdGZ1bmN0aW9uIGtlY2NhazI1NihkYXRhKSB7XG5cdCAgICByZXR1cm4gJzB4JyArIGpzX3NoYTNfMS5kZWZhdWx0LmtlY2Nha18yNTYobGliJDEuYXJyYXlpZnkoZGF0YSkpO1xuXHR9XG5cdGV4cG9ydHMua2VjY2FrMjU2ID0ga2VjY2FrMjU2O1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQ0ID0gdW53cmFwRXhwb3J0cyhsaWIkNCk7XG5cdHZhciBsaWJfMSQ0ID0gbGliJDQua2VjY2FrMjU2O1xuXG5cdHZhciBfdmVyc2lvbiRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInJscC81LjAuM1wiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRiID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRhKTtcblx0dmFyIF92ZXJzaW9uXzEkNSA9IF92ZXJzaW9uJGEudmVyc2lvbjtcblxuXHR2YXIgbGliJDUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdC8vU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1JMUFxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kYS52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICB3aGlsZSAodmFsdWUpIHtcblx0ICAgICAgICByZXN1bHQudW5zaGlmdCh2YWx1ZSAmIDB4ZmYpO1xuXHQgICAgICAgIHZhbHVlID4+PSA4O1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiB1bmFycmF5aWZ5SW50ZWdlcihkYXRhLCBvZmZzZXQsIGxlbmd0aCkge1xuXHQgICAgdmFyIHJlc3VsdCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzdWx0ID0gKHJlc3VsdCAqIDI1NikgKyBkYXRhW29mZnNldCArIGldO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBfZW5jb2RlKG9iamVjdCkge1xuXHQgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuXHQgICAgICAgIHZhciBwYXlsb2FkXzEgPSBbXTtcblx0ICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcblx0ICAgICAgICAgICAgcGF5bG9hZF8xID0gcGF5bG9hZF8xLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgaWYgKHBheWxvYWRfMS5sZW5ndGggPD0gNTUpIHtcblx0ICAgICAgICAgICAgcGF5bG9hZF8xLnVuc2hpZnQoMHhjMCArIHBheWxvYWRfMS5sZW5ndGgpO1xuXHQgICAgICAgICAgICByZXR1cm4gcGF5bG9hZF8xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbGVuZ3RoXzEgPSBhcnJheWlmeUludGVnZXIocGF5bG9hZF8xLmxlbmd0aCk7XG5cdCAgICAgICAgbGVuZ3RoXzEudW5zaGlmdCgweGY3ICsgbGVuZ3RoXzEubGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gbGVuZ3RoXzEuY29uY2F0KHBheWxvYWRfMSk7XG5cdCAgICB9XG5cdCAgICBpZiAoIWxpYiQxLmlzQnl0ZXNMaWtlKG9iamVjdCkpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiUkxQIG9iamVjdCBtdXN0IGJlIEJ5dGVzTGlrZVwiLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuXHQgICAgfVxuXHQgICAgdmFyIGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaWIkMS5hcnJheWlmeShvYmplY3QpKTtcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMSAmJiBkYXRhWzBdIDw9IDB4N2YpIHtcblx0ICAgICAgICByZXR1cm4gZGF0YTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRhdGEubGVuZ3RoIDw9IDU1KSB7XG5cdCAgICAgICAgZGF0YS51bnNoaWZ0KDB4ODAgKyBkYXRhLmxlbmd0aCk7XG5cdCAgICAgICAgcmV0dXJuIGRhdGE7XG5cdCAgICB9XG5cdCAgICB2YXIgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKGRhdGEubGVuZ3RoKTtcblx0ICAgIGxlbmd0aC51bnNoaWZ0KDB4YjcgKyBsZW5ndGgubGVuZ3RoKTtcblx0ICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xuXHR9XG5cdGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcblx0ICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KF9lbmNvZGUob2JqZWN0KSk7XG5cdH1cblx0ZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5cdGZ1bmN0aW9uIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIGNoaWxkT2Zmc2V0LCBsZW5ndGgpIHtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcblx0ICAgICAgICB2YXIgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuXHQgICAgICAgIHJlc3VsdC5wdXNoKGRlY29kZWQucmVzdWx0KTtcblx0ICAgICAgICBjaGlsZE9mZnNldCArPSBkZWNvZGVkLmNvbnN1bWVkO1xuXHQgICAgICAgIGlmIChjaGlsZE9mZnNldCA+IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjaGlsZCBkYXRhIHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG5cdH1cblx0Ly8gcmV0dXJucyB7IGNvbnN1bWVkOiBudW1iZXIsIHJlc3VsdDogT2JqZWN0IH1cblx0ZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcblx0ICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgIH1cblx0ICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuXHQgICAgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGY4KSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Zjc7XG5cdCAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGxlbmd0aF8yID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aF8yID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGxvbmcgc2VnbWVudCB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIGxlbmd0aExlbmd0aCArIGxlbmd0aF8yKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGMwKSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aF8zID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aF8zID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSwgbGVuZ3RoXzMpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YjgpIHtcblx0ICAgICAgICB2YXIgbGVuZ3RoTGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhiNztcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGxlbmd0aF80ID0gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0ICsgMSwgbGVuZ3RoTGVuZ3RoKTtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aF80ID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gbGliJDEuaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGgsIG9mZnNldCArIDEgKyBsZW5ndGhMZW5ndGggKyBsZW5ndGhfNCkpO1xuXHQgICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aF80KSwgcmVzdWx0OiByZXN1bHQgfTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG5cdCAgICAgICAgdmFyIGxlbmd0aF81ID0gZGF0YVtvZmZzZXRdIC0gMHg4MDtcblx0ICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aF81ID4gZGF0YS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gbGliJDEuaGV4bGlmeShkYXRhLnNsaWNlKG9mZnNldCArIDEsIG9mZnNldCArIDEgKyBsZW5ndGhfNSkpO1xuXHQgICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aF81KSwgcmVzdWx0OiByZXN1bHQgfTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGxpYiQxLmhleGxpZnkoZGF0YVtvZmZzZXRdKSB9O1xuXHR9XG5cdGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShkYXRhKTtcblx0ICAgIHZhciBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG5cdCAgICBpZiAoZGVjb2RlZC5jb25zdW1lZCAhPT0gYnl0ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmxwIGRhdGFcIiwgXCJkYXRhXCIsIGRhdGEpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGRlY29kZWQucmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCQ1ID0gdW53cmFwRXhwb3J0cyhsaWIkNSk7XG5cdHZhciBsaWJfMSQ1ID0gbGliJDUuZW5jb2RlO1xuXHR2YXIgbGliXzIkNCA9IGxpYiQ1LmRlY29kZTtcblxuXHR2YXIgX3ZlcnNpb24kYyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJhZGRyZXNzLzUuMC40XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGQgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGMpO1xuXHR2YXIgX3ZlcnNpb25fMSQ2ID0gX3ZlcnNpb24kYy52ZXJzaW9uO1xuXG5cdHZhciBsaWIkNiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gV2UgdXNlIHRoaXMgZm9yIGJhc2UgMzYgbWF0aHNcblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kYy52ZXJzaW9uKTtcblx0ZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcblx0ICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoYWRkcmVzcywgMjApKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICB9XG5cdCAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgdmFyIGNoYXJzID0gYWRkcmVzcy5zdWJzdHJpbmcoMikuc3BsaXQoXCJcIik7XG5cdCAgICB2YXIgZXhwYW5kZWQgPSBuZXcgVWludDhBcnJheSg0MCk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQwOyBpKyspIHtcblx0ICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG5cdCAgICB9XG5cdCAgICB2YXIgaGFzaGVkID0gbGliJDEuYXJyYXlpZnkobGliJDQua2VjY2FrMjU2KGV4cGFuZGVkKSk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQwOyBpICs9IDIpIHtcblx0ICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcblx0ICAgICAgICAgICAgY2hhcnNbaV0gPSBjaGFyc1tpXS50b1VwcGVyQ2FzZSgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuXHQgICAgICAgICAgICBjaGFyc1tpICsgMV0gPSBjaGFyc1tpICsgMV0udG9VcHBlckNhc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gXCIweFwiICsgY2hhcnMuam9pbihcIlwiKTtcblx0fVxuXHQvLyBTaGltcyBmb3IgZW52aXJvbm1lbnRzIHRoYXQgYXJlIG1pc3Npbmcgc29tZSByZXF1aXJlZCBjb25zdGFudHMgYW5kIGZ1bmN0aW9uc1xuXHR2YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmY7XG5cdGZ1bmN0aW9uIGxvZzEwKHgpIHtcblx0ICAgIGlmIChNYXRoLmxvZzEwKSB7XG5cdCAgICAgICAgcmV0dXJuIE1hdGgubG9nMTAoeCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTWF0aC5sb2coeCkgLyBNYXRoLkxOMTA7XG5cdH1cblx0Ly8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXJcblx0Ly8gQ3JlYXRlIGxvb2t1cCB0YWJsZVxuXHR2YXIgaWJhbkxvb2t1cCA9IHt9O1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0ICAgIGliYW5Mb29rdXBbU3RyaW5nKGkpXSA9IFN0cmluZyhpKTtcblx0fVxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDI2OyBpKyspIHtcblx0ICAgIGliYW5Mb29rdXBbU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIGkpXSA9IFN0cmluZygxMCArIGkpO1xuXHR9XG5cdC8vIEhvdyBtYW55IGRlY2ltYWwgZGlnaXRzIGNhbiB3ZSBwcm9jZXNzPyAoZm9yIDY0LWJpdCBmbG9hdCwgdGhpcyBpcyAxNSlcblx0dmFyIHNhZmVEaWdpdHMgPSBNYXRoLmZsb29yKGxvZzEwKE1BWF9TQUZFX0lOVEVHRVIpKTtcblx0ZnVuY3Rpb24gaWJhbkNoZWNrc3VtKGFkZHJlc3MpIHtcblx0ICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvVXBwZXJDYXNlKCk7XG5cdCAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcblx0ICAgIHZhciBleHBhbmRlZCA9IGFkZHJlc3Muc3BsaXQoXCJcIikubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBpYmFuTG9va3VwW2NdOyB9KS5qb2luKFwiXCIpO1xuXHQgICAgLy8gSmF2YXNjcmlwdCBjYW4gaGFuZGxlIGludGVnZXJzIHNhZmVseSB1cCB0byAxNSAoZGVjaW1hbCkgZGlnaXRzXG5cdCAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcblx0ICAgICAgICB2YXIgYmxvY2sgPSBleHBhbmRlZC5zdWJzdHJpbmcoMCwgc2FmZURpZ2l0cyk7XG5cdCAgICAgICAgZXhwYW5kZWQgPSBwYXJzZUludChibG9jaywgMTApICUgOTcgKyBleHBhbmRlZC5zdWJzdHJpbmcoYmxvY2subGVuZ3RoKTtcblx0ICAgIH1cblx0ICAgIHZhciBjaGVja3N1bSA9IFN0cmluZyg5OCAtIChwYXJzZUludChleHBhbmRlZCwgMTApICUgOTcpKTtcblx0ICAgIHdoaWxlIChjaGVja3N1bS5sZW5ndGggPCAyKSB7XG5cdCAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNoZWNrc3VtO1xuXHR9XG5cdDtcblx0ZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG5cdCAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblx0ICAgIGlmICh0eXBlb2YgKGFkZHJlc3MpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICB9XG5cdCAgICBpZiAoYWRkcmVzcy5tYXRjaCgvXigweCk/WzAtOWEtZkEtRl17NDB9JC8pKSB7XG5cdCAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG5cdCAgICAgICAgaWYgKGFkZHJlc3Muc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgYWRkcmVzcyA9IFwiMHhcIiArIGFkZHJlc3M7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKTtcblx0ICAgICAgICAvLyBJdCBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuXHQgICAgICAgIGlmIChhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pICYmIHJlc3VsdCAhPT0gYWRkcmVzcykge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYmFkIGFkZHJlc3MgY2hlY2tzdW1cIiwgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoYWRkcmVzcy5tYXRjaCgvXlhFWzAtOV17Mn1bMC05QS1aYS16XXszMCwzMX0kLykpIHtcblx0ICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuXHQgICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygyLCA0KSAhPT0gaWJhbkNoZWNrc3VtKGFkZHJlc3MpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJiYWQgaWNhcCBjaGVja3N1bVwiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCA9IChuZXcgYm4uQk4oYWRkcmVzcy5zdWJzdHJpbmcoNCksIDM2KSkudG9TdHJpbmcoMTYpO1xuXHQgICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcblx0ICAgICAgICAgICAgcmVzdWx0ID0gXCIwXCIgKyByZXN1bHQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGV4cG9ydHMuZ2V0QWRkcmVzcyA9IGdldEFkZHJlc3M7XG5cdGZ1bmN0aW9uIGlzQWRkcmVzcyhhZGRyZXNzKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGdldEFkZHJlc3MoYWRkcmVzcyk7XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdGV4cG9ydHMuaXNBZGRyZXNzID0gaXNBZGRyZXNzO1xuXHRmdW5jdGlvbiBnZXRJY2FwQWRkcmVzcyhhZGRyZXNzKSB7XG5cdCAgICB2YXIgYmFzZTM2ID0gKG5ldyBibi5CTihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSwgMTYpKS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKTtcblx0ICAgIHdoaWxlIChiYXNlMzYubGVuZ3RoIDwgMzApIHtcblx0ICAgICAgICBiYXNlMzYgPSBcIjBcIiArIGJhc2UzNjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBcIlhFXCIgKyBpYmFuQ2hlY2tzdW0oXCJYRTAwXCIgKyBiYXNlMzYpICsgYmFzZTM2O1xuXHR9XG5cdGV4cG9ydHMuZ2V0SWNhcEFkZHJlc3MgPSBnZXRJY2FwQWRkcmVzcztcblx0Ly8gaHR0cDovL2V0aGVyZXVtLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NjAvaG93LWlzLXRoZS1hZGRyZXNzLW9mLWFuLWV0aGVyZXVtLWNvbnRyYWN0LWNvbXB1dGVkXG5cdGZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuXHQgICAgdmFyIGZyb20gPSBudWxsO1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBmcm9tID0gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgIH1cblx0ICAgIHZhciBub25jZSA9IGxpYiQxLnN0cmlwWmVyb3MobGliJDEuYXJyYXlpZnkobGliJDIuQmlnTnVtYmVyLmZyb20odHJhbnNhY3Rpb24ubm9uY2UpLnRvSGV4U3RyaW5nKCkpKTtcblx0ICAgIHJldHVybiBnZXRBZGRyZXNzKGxpYiQxLmhleERhdGFTbGljZShsaWIkNC5rZWNjYWsyNTYobGliJDUuZW5jb2RlKFtmcm9tLCBub25jZV0pKSwgMTIpKTtcblx0fVxuXHRleHBvcnRzLmdldENvbnRyYWN0QWRkcmVzcyA9IGdldENvbnRyYWN0QWRkcmVzcztcblx0ZnVuY3Rpb24gZ2V0Q3JlYXRlMkFkZHJlc3MoZnJvbSwgc2FsdCwgaW5pdENvZGVIYXNoKSB7XG5cdCAgICBpZiAobGliJDEuaGV4RGF0YUxlbmd0aChzYWx0KSAhPT0gMzIpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBzYWx0KTtcblx0ICAgIH1cblx0ICAgIGlmIChsaWIkMS5oZXhEYXRhTGVuZ3RoKGluaXRDb2RlSGFzaCkgIT09IDMyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIGluaXRDb2RlSGFzaCk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gZ2V0QWRkcmVzcyhsaWIkMS5oZXhEYXRhU2xpY2UobGliJDQua2VjY2FrMjU2KGxpYiQxLmNvbmNhdChbXCIweGZmXCIsIGdldEFkZHJlc3MoZnJvbSksIHNhbHQsIGluaXRDb2RlSGFzaF0pKSwgMTIpKTtcblx0fVxuXHRleHBvcnRzLmdldENyZWF0ZTJBZGRyZXNzID0gZ2V0Q3JlYXRlMkFkZHJlc3M7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDYgPSB1bndyYXBFeHBvcnRzKGxpYiQ2KTtcblx0dmFyIGxpYl8xJDYgPSBsaWIkNi5nZXRBZGRyZXNzO1xuXHR2YXIgbGliXzIkNSA9IGxpYiQ2LmlzQWRkcmVzcztcblx0dmFyIGxpYl8zJDQgPSBsaWIkNi5nZXRJY2FwQWRkcmVzcztcblx0dmFyIGxpYl80JDMgPSBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3M7XG5cdHZhciBsaWJfNSQzID0gbGliJDYuZ2V0Q3JlYXRlMkFkZHJlc3M7XG5cblx0dmFyIGFkZHJlc3MgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBBZGRyZXNzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQWRkcmVzc0NvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQWRkcmVzc0NvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImFkZHJlc3NcIiwgXCJhZGRyZXNzXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBBZGRyZXNzQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgbGliJDYuZ2V0QWRkcmVzcyh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBBZGRyZXNzQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhsaWIkMS5oZXhaZXJvUGFkKHJlYWRlci5yZWFkVmFsdWUoKS50b0hleFN0cmluZygpLCAyMCkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBZGRyZXNzQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkFkZHJlc3NDb2RlciA9IEFkZHJlc3NDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgYWRkcmVzcyQxID0gdW53cmFwRXhwb3J0cyhhZGRyZXNzKTtcblx0dmFyIGFkZHJlc3NfMiA9IGFkZHJlc3MuQWRkcmVzc0NvZGVyO1xuXG5cdHZhciBhbm9ueW1vdXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0Ly8gQ2xvbmVzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGFuIGV4aXN0aW5nIENvZGVyLCBidXQgd2l0aG91dCBhIGxvY2FsTmFtZVxuXHR2YXIgQW5vbnltb3VzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQW5vbnltb3VzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBBbm9ueW1vdXNDb2Rlcihjb2Rlcikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvZGVyLm5hbWUsIGNvZGVyLnR5cGUsIHVuZGVmaW5lZCwgY29kZXIuZHluYW1pYykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5jb2RlciA9IGNvZGVyO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIEFub255bW91c0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBBbm9ueW1vdXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmRlY29kZShyZWFkZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBbm9ueW1vdXNDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQW5vbnltb3VzQ29kZXIgPSBBbm9ueW1vdXNDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgYW5vbnltb3VzJDEgPSB1bndyYXBFeHBvcnRzKGFub255bW91cyk7XG5cdHZhciBhbm9ueW1vdXNfMSA9IGFub255bW91cy5Bbm9ueW1vdXNDb2RlcjtcblxuXHR2YXIgYXJyYXkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kOC52ZXJzaW9uKTtcblxuXG5cdGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuXHQgICAgdmFyIGFycmF5VmFsdWVzID0gbnVsbDtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcblx0ICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHZhbHVlcyAmJiB0eXBlb2YgKHZhbHVlcykgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICB2YXIgdW5pcXVlXzEgPSB7fTtcblx0ICAgICAgICBhcnJheVZhbHVlcyA9IGNvZGVycy5tYXAoZnVuY3Rpb24gKGNvZGVyKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuXHQgICAgICAgICAgICBpZiAoIW5hbWUpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIG1pc3NpbmcgbmFtZXNcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50OiBcInZhbHVlc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIGNvZGVyOiBjb2Rlcixcblx0ICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodW5pcXVlXzFbbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVuY29kZSBvYmplY3QgZm9yIHNpZ25hdHVyZSB3aXRoIGR1cGxpY2F0ZSBuYW1lc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgY29kZXI6IGNvZGVyLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHVuaXF1ZV8xW25hbWVdID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHR1cGxlIHZhbHVlXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcblx0ICAgIH1cblx0ICAgIGlmIChjb2RlcnMubGVuZ3RoICE9PSBhcnJheVZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHlwZXMvdmFsdWUgbGVuZ3RoIG1pc21hdGNoXCIsIFwidHVwbGVcIiwgdmFsdWVzKTtcblx0ICAgIH1cblx0ICAgIHZhciBzdGF0aWNXcml0ZXIgPSBuZXcgYWJzdHJhY3RDb2Rlci5Xcml0ZXIod3JpdGVyLndvcmRTaXplKTtcblx0ICAgIHZhciBkeW5hbWljV3JpdGVyID0gbmV3IGFic3RyYWN0Q29kZXIuV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7XG5cdCAgICB2YXIgdXBkYXRlRnVuY3MgPSBbXTtcblx0ICAgIGNvZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlciwgaW5kZXgpIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG5cdCAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgZHluYW1pYyBvZmZzZXQgKGZvciB0aGUgZnV0dXJlIHBvaW50ZXIpXG5cdCAgICAgICAgICAgIHZhciBkeW5hbWljT2Zmc2V0XzEgPSBkeW5hbWljV3JpdGVyLmxlbmd0aDtcblx0ICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSBkeW5hbWljIHZhbHVlIGludG8gdGhlIGR5bmFtaWNXcml0ZXJcblx0ICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgLy8gUHJlcGFyZSB0byBwb3B1bGF0ZSB0aGUgY29ycmVjdCBvZmZzZXQgb25jZSB3ZSBhcmUgZG9uZVxuXHQgICAgICAgICAgICB2YXIgdXBkYXRlRnVuY18xID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcblx0ICAgICAgICAgICAgdXBkYXRlRnVuY3MucHVzaChmdW5jdGlvbiAoYmFzZU9mZnNldCkge1xuXHQgICAgICAgICAgICAgICAgdXBkYXRlRnVuY18xKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0XzEpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGNvZGVyLmVuY29kZShzdGF0aWNXcml0ZXIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vIEJhY2tmaWxsIGFsbCB0aGUgZHluYW1pYyBvZmZzZXRzLCBub3cgdGhhdCB3ZSBrbm93IHRoZSBzdGF0aWMgbGVuZ3RoXG5cdCAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKGZ1bmN0aW9uIChmdW5jKSB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuXHQgICAgdmFyIGxlbmd0aCA9IHdyaXRlci53cml0ZUJ5dGVzKHN0YXRpY1dyaXRlci5kYXRhKTtcblx0ICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyhkeW5hbWljV3JpdGVyLmRhdGEpO1xuXHQgICAgcmV0dXJuIGxlbmd0aDtcblx0fVxuXHRleHBvcnRzLnBhY2sgPSBwYWNrO1xuXHRmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcblx0ICAgIHZhciB2YWx1ZXMgPSBbXTtcblx0ICAgIC8vIEEgcmVhZGVyIGFuY2hvcmVkIHRvIHRoaXMgYmFzZVxuXHQgICAgdmFyIGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuXHQgICAgY29kZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblx0ICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcmVhZGVyLnJlYWRWYWx1ZSgpO1xuXHQgICAgICAgICAgICB2YXIgb2Zmc2V0UmVhZGVyID0gYmFzZVJlYWRlci5zdWJSZWFkZXIob2Zmc2V0LnRvTnVtYmVyKCkpO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUob2Zmc2V0UmVhZGVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUuYmFzZVR5cGUgPSBjb2Rlci5uYW1lO1xuXHQgICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcblx0ICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHQgICAgLy8gV2Ugb25seSBvdXRwdXQgbmFtZWQgcHJvcGVydGllcyBmb3IgdW5pcXVlbHkgbmFtZWQgY29kZXJzXG5cdCAgICB2YXIgdW5pcXVlTmFtZXMgPSBjb2RlcnMucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgY29kZXIpIHtcblx0ICAgICAgICB2YXIgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcblx0ICAgICAgICBpZiAobmFtZSkge1xuXHQgICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG5cdCAgICAgICAgICAgICAgICBhY2N1bVtuYW1lXSA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFjY3VtO1xuXHQgICAgfSwge30pO1xuXHQgICAgLy8gQWRkIGFueSBuYW1lZCBwYXJhbWV0ZXJzIChpLmUuIHR1cGxlcylcblx0ICAgIGNvZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb2RlciwgaW5kZXgpIHtcblx0ICAgICAgICB2YXIgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcblx0ICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuXHQgICAgICAgICAgICBuYW1lID0gXCJfbGVuZ3RoXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG5cdCAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlcywgbmFtZSwge1xuXHQgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHRocm93IHZhbHVlOyB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuXHQgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIGksIHtcblx0ICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB2YWx1ZTsgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBfbG9vcF8xKGkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcblx0fVxuXHRleHBvcnRzLnVucGFjayA9IHVucGFjaztcblx0dmFyIEFycmF5Q29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQXJyYXlDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEFycmF5Q29kZXIoY29kZXIsIGxlbmd0aCwgbG9jYWxOYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgdHlwZSA9IChjb2Rlci50eXBlICsgXCJbXCIgKyAobGVuZ3RoID49IDAgPyBsZW5ndGggOiBcIlwiKSArIFwiXVwiKTtcblx0ICAgICAgICB2YXIgZHluYW1pYyA9IChsZW5ndGggPT09IC0xIHx8IGNvZGVyLmR5bmFtaWMpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJhcnJheVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuY29kZXIgPSBjb2Rlcjtcblx0ICAgICAgICBfdGhpcy5sZW5ndGggPSBsZW5ndGg7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgQXJyYXlDb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHdyaXRlciwgdmFsdWUpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJleHBlY3RlZCBhcnJheSB2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjb3VudCA9IHRoaXMubGVuZ3RoO1xuXHQgICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG5cdCAgICAgICAgICAgIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xuXHQgICAgICAgIHZhciBjb2RlcnMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIGNvZGVycywgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEFycmF5Q29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICB2YXIgY291bnQgPSB0aGlzLmxlbmd0aDtcblx0ICAgICAgICBpZiAoY291bnQgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIGNvdW50ID0gcmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjb2RlcnMgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0ICAgICAgICAgICAgY29kZXJzLnB1c2gobmV3IGFub255bW91cy5Bbm9ueW1vdXNDb2Rlcih0aGlzLmNvZGVyKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgdW5wYWNrKHJlYWRlciwgY29kZXJzKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEFycmF5Q29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkFycmF5Q29kZXIgPSBBcnJheUNvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBhcnJheSQxID0gdW53cmFwRXhwb3J0cyhhcnJheSk7XG5cdHZhciBhcnJheV8xID0gYXJyYXkucGFjaztcblx0dmFyIGFycmF5XzIgPSBhcnJheS51bnBhY2s7XG5cdHZhciBhcnJheV8zID0gYXJyYXkuQXJyYXlDb2RlcjtcblxuXHR2YXIgYm9vbGVhbl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdHZhciBCb29sZWFuQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQm9vbGVhbkNvZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQm9vbGVhbkNvZGVyKGxvY2FsTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBcImJvb2xcIiwgXCJib29sXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBCb29sZWFuQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHZhbHVlID8gMSA6IDApO1xuXHQgICAgfTtcblx0ICAgIEJvb2xlYW5Db2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMudHlwZSwgIXJlYWRlci5yZWFkVmFsdWUoKS5pc1plcm8oKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEJvb2xlYW5Db2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuQm9vbGVhbkNvZGVyID0gQm9vbGVhbkNvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBib29sZWFuID0gdW53cmFwRXhwb3J0cyhib29sZWFuXzEpO1xuXHR2YXIgYm9vbGVhbl8yID0gYm9vbGVhbl8xLkJvb2xlYW5Db2RlcjtcblxuXHR2YXIgYnl0ZXMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgRHluYW1pY0J5dGVzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRHluYW1pY0J5dGVzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBEeW5hbWljQnl0ZXNDb2Rlcih0eXBlLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgdHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgRHluYW1pY0J5dGVzQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgdmFsdWUgPSBsaWIkMS5hcnJheWlmeSh2YWx1ZSk7XG5cdCAgICAgICAgdmFyIGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG5cdCAgICAgICAgbGVuZ3RoICs9IHdyaXRlci53cml0ZUJ5dGVzKHZhbHVlKTtcblx0ICAgICAgICByZXR1cm4gbGVuZ3RoO1xuXHQgICAgfTtcblx0ICAgIER5bmFtaWNCeXRlc0NvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksIHRydWUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBEeW5hbWljQnl0ZXNDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuRHluYW1pY0J5dGVzQ29kZXIgPSBEeW5hbWljQnl0ZXNDb2Rlcjtcblx0dmFyIEJ5dGVzQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQnl0ZXNDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEJ5dGVzQ29kZXIobG9jYWxOYW1lKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiYnl0ZXNcIiwgbG9jYWxOYW1lKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQnl0ZXNDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHJlYWRlcikge1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgbGliJDEuaGV4bGlmeShfc3VwZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIHJlYWRlcikpKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQnl0ZXNDb2Rlcjtcblx0fShEeW5hbWljQnl0ZXNDb2RlcikpO1xuXHRleHBvcnRzLkJ5dGVzQ29kZXIgPSBCeXRlc0NvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBieXRlcyQxID0gdW53cmFwRXhwb3J0cyhieXRlcyk7XG5cdHZhciBieXRlc18yID0gYnl0ZXMuRHluYW1pY0J5dGVzQ29kZXI7XG5cdHZhciBieXRlc18zID0gYnl0ZXMuQnl0ZXNDb2RlcjtcblxuXHR2YXIgZml4ZWRCeXRlcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdC8vIEBUT0RPOiBNZXJnZSB0aGlzIHdpdGggYnl0ZXNcblx0dmFyIEZpeGVkQnl0ZXNDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhGaXhlZEJ5dGVzQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGaXhlZEJ5dGVzQ29kZXIoc2l6ZSwgbG9jYWxOYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgbmFtZSA9IFwiYnl0ZXNcIiArIFN0cmluZyhzaXplKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICAgICAgX3RoaXMuc2l6ZSA9IHNpemU7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRml4ZWRCeXRlc0NvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHZhciBkYXRhID0gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJpbmNvcnJlY3QgZGF0YSBsZW5ndGhcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSk7XG5cdCAgICB9O1xuXHQgICAgRml4ZWRCeXRlc0NvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBsaWIkMS5oZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBGaXhlZEJ5dGVzQ29kZXI7XG5cdH0oYWJzdHJhY3RDb2Rlci5Db2RlcikpO1xuXHRleHBvcnRzLkZpeGVkQnl0ZXNDb2RlciA9IEZpeGVkQnl0ZXNDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgZml4ZWRCeXRlcyQxID0gdW53cmFwRXhwb3J0cyhmaXhlZEJ5dGVzKTtcblx0dmFyIGZpeGVkQnl0ZXNfMSA9IGZpeGVkQnl0ZXMuRml4ZWRCeXRlc0NvZGVyO1xuXG5cdHZhciBfbnVsbCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHR2YXIgTnVsbENvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE51bGxDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIE51bGxDb2Rlcihsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJudWxsXCIsIFwiXCIsIGxvY2FsTmFtZSwgZmFsc2UpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBOdWxsQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIm5vdCBudWxsXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZUJ5dGVzKFtdKTtcblx0ICAgIH07XG5cdCAgICBOdWxsQ29kZXIucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChyZWFkZXIpIHtcblx0ICAgICAgICByZWFkZXIucmVhZEJ5dGVzKDApO1xuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgbnVsbCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE51bGxDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuTnVsbENvZGVyID0gTnVsbENvZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBfbnVsbCQxID0gdW53cmFwRXhwb3J0cyhfbnVsbCk7XG5cdHZhciBfbnVsbF8xID0gX251bGwuTnVsbENvZGVyO1xuXG5cdHZhciBsaWIkNyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHR2YXIgQWRkcmVzc1plcm8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuXHRleHBvcnRzLkFkZHJlc3NaZXJvID0gQWRkcmVzc1plcm87XG5cdHZhciBIYXNoWmVybyA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5cdGV4cG9ydHMuSGFzaFplcm8gPSBIYXNoWmVybztcblx0Ly8gTkZLQyAoY29tcG9zZWQpICAgICAgICAgICAgIC8vIChkZWNvbXBvc2VkKVxuXHR2YXIgRXRoZXJTeW1ib2wgPSBcIlxcdTAzOWVcIjsgLy8gXCJcXHVEODM1XFx1REY2M1wiO1xuXHRleHBvcnRzLkV0aGVyU3ltYm9sID0gRXRoZXJTeW1ib2w7XG5cdHZhciBOZWdhdGl2ZU9uZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKC0xKTtcblx0ZXhwb3J0cy5OZWdhdGl2ZU9uZSA9IE5lZ2F0aXZlT25lO1xuXHR2YXIgWmVybyA9IGxpYiQyLkJpZ051bWJlci5mcm9tKDApO1xuXHRleHBvcnRzLlplcm8gPSBaZXJvO1xuXHR2YXIgT25lID0gbGliJDIuQmlnTnVtYmVyLmZyb20oMSk7XG5cdGV4cG9ydHMuT25lID0gT25lO1xuXHR2YXIgVHdvID0gbGliJDIuQmlnTnVtYmVyLmZyb20oMik7XG5cdGV4cG9ydHMuVHdvID0gVHdvO1xuXHR2YXIgV2VpUGVyRXRoZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShcIjEwMDAwMDAwMDAwMDAwMDAwMDBcIik7XG5cdGV4cG9ydHMuV2VpUGVyRXRoZXIgPSBXZWlQZXJFdGhlcjtcblx0dmFyIE1heFVpbnQyNTYgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlwiKTtcblx0ZXhwb3J0cy5NYXhVaW50MjU2ID0gTWF4VWludDI1NjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkNyA9IHVud3JhcEV4cG9ydHMobGliJDcpO1xuXHR2YXIgbGliXzEkNyA9IGxpYiQ3LkFkZHJlc3NaZXJvO1xuXHR2YXIgbGliXzIkNiA9IGxpYiQ3Lkhhc2haZXJvO1xuXHR2YXIgbGliXzMkNSA9IGxpYiQ3LkV0aGVyU3ltYm9sO1xuXHR2YXIgbGliXzQkNCA9IGxpYiQ3Lk5lZ2F0aXZlT25lO1xuXHR2YXIgbGliXzUkNCA9IGxpYiQ3Llplcm87XG5cdHZhciBsaWJfNiQyID0gbGliJDcuT25lO1xuXHR2YXIgbGliXzckMiA9IGxpYiQ3LlR3bztcblx0dmFyIGxpYl84JDEgPSBsaWIkNy5XZWlQZXJFdGhlcjtcblx0dmFyIGxpYl85JDEgPSBsaWIkNy5NYXhVaW50MjU2O1xuXG5cdHZhciBudW1iZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBOdW1iZXJDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhOdW1iZXJDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIE51bWJlckNvZGVyKHNpemUsIHNpZ25lZCwgbG9jYWxOYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgbmFtZSwgbG9jYWxOYW1lLCBmYWxzZSkgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5zaXplID0gc2l6ZTtcblx0ICAgICAgICBfdGhpcy5zaWduZWQgPSBzaWduZWQ7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgTnVtYmVyQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHYgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdCAgICAgICAgLy8gQ2hlY2sgYm91bmRzIGFyZSBzYWZlIGZvciBlbmNvZGluZ1xuXHQgICAgICAgIHZhciBtYXhVaW50VmFsdWUgPSBsaWIkNy5NYXhVaW50MjU2Lm1hc2sod3JpdGVyLndvcmRTaXplICogOCk7XG5cdCAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG5cdCAgICAgICAgICAgIHZhciBib3VuZHMgPSBtYXhVaW50VmFsdWUubWFzayh0aGlzLnNpemUgKiA4IC0gMSk7XG5cdCAgICAgICAgICAgIGlmICh2Lmd0KGJvdW5kcykgfHwgdi5sdChib3VuZHMuYWRkKGxpYiQ3Lk9uZSkubXVsKGxpYiQ3Lk5lZ2F0aXZlT25lKSkpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIHZhbHVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh2Lmx0KGxpYiQ3Llplcm8pIHx8IHYuZ3QobWF4VWludFZhbHVlLm1hc2sodGhpcy5zaXplICogOCkpKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX3Rocm93RXJyb3IoXCJ2YWx1ZSBvdXQtb2YtYm91bmRzXCIsIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdiA9IHYudG9Ud29zKHRoaXMuc2l6ZSAqIDgpLm1hc2sodGhpcy5zaXplICogOCk7XG5cdCAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG5cdCAgICAgICAgICAgIHYgPSB2LmZyb21Ud29zKHRoaXMuc2l6ZSAqIDgpLnRvVHdvcyg4ICogd3JpdGVyLndvcmRTaXplKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZhbHVlKHYpO1xuXHQgICAgfTtcblx0ICAgIE51bWJlckNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgdmFyIHZhbHVlID0gcmVhZGVyLnJlYWRWYWx1ZSgpLm1hc2sodGhpcy5zaXplICogOCk7XG5cdCAgICAgICAgaWYgKHRoaXMuc2lnbmVkKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuZnJvbVR3b3ModGhpcy5zaXplICogOCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBOdW1iZXJDb2Rlcjtcblx0fShhYnN0cmFjdENvZGVyLkNvZGVyKSk7XG5cdGV4cG9ydHMuTnVtYmVyQ29kZXIgPSBOdW1iZXJDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgbnVtYmVyJDEgPSB1bndyYXBFeHBvcnRzKG51bWJlcik7XG5cdHZhciBudW1iZXJfMSA9IG51bWJlci5OdW1iZXJDb2RlcjtcblxuXHR2YXIgX3ZlcnNpb24kZSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJzdHJpbmdzLzUuMC40XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGYgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGUpO1xuXHR2YXIgX3ZlcnNpb25fMSQ3ID0gX3ZlcnNpb24kZS52ZXJzaW9uO1xuXG5cdHZhciB1dGY4ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kZS52ZXJzaW9uKTtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHR2YXIgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtO1xuXHQoZnVuY3Rpb24gKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSkge1xuXHQgICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiY3VycmVudFwiXSA9IFwiXCI7XG5cdCAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkNcIl0gPSBcIk5GQ1wiO1xuXHQgICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZEXCJdID0gXCJORkRcIjtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0NcIl0gPSBcIk5GS0NcIjtcblx0ICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0RcIl0gPSBcIk5GS0RcIjtcblx0fSkoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0gZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfHwgKGV4cG9ydHMuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtID0ge30pKTtcblx0O1xuXHR2YXIgVXRmOEVycm9yUmVhc29uO1xuXHQoZnVuY3Rpb24gKFV0ZjhFcnJvclJlYXNvbikge1xuXHQgICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuXHQgICAgLy8gLSBvZmZzZXQgPSB0aGUgaW5kZXggdGhlIGNvZGVwb2ludCBiZWdhbiBpblxuXHQgICAgVXRmOEVycm9yUmVhc29uW1wiVU5FWFBFQ1RFRF9DT05USU5VRVwiXSA9IFwidW5leHBlY3RlZCBjb250aW51YXRpb24gYnl0ZVwiO1xuXHQgICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcblx0ICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIkJBRF9QUkVGSVhcIl0gPSBcImJhZCBjb2RlcG9pbnQgcHJlZml4XCI7XG5cdCAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcblx0ICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJSVU5cIl0gPSBcInN0cmluZyBvdmVycnVuXCI7XG5cdCAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcblx0ICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb250aW51YXRpb24gYnl0ZSB3YXMgZXhwZWN0ZWQgYXRcblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIk1JU1NJTkdfQ09OVElOVUVcIl0gPSBcIm1pc3NpbmcgY29udGludWF0aW9uIGJ5dGVcIjtcblx0ICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuXHQgICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuXHQgICAgLy8gLSBiYWRDb2RlcG9pbnQgPSB0aGUgY29tcHV0ZWQgY29kZXBvaW50OyBvdXRzaWRlIHRoZSBVVEYtOCByYW5nZVxuXHQgICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcblx0ICAgIC8vIFVURi04IHN0cmluZ3MgbWF5IG5vdCBjb250YWluIFVURi0xNiBzdXJyb2dhdGUgcGFpcnNcblx0ICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcblx0ICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG5cdCAgICBVdGY4RXJyb3JSZWFzb25bXCJVVEYxNl9TVVJST0dBVEVcIl0gPSBcIlVURi0xNiBzdXJyb2dhdGVcIjtcblx0ICAgIC8vIFRoZSBzdHJpbmcgaXMgYW4gb3ZlcmxvbmcgcmVwZXJlc2VudGF0aW9uXG5cdCAgICAvLyAtIG9mZnNldCAgICAgICA9IHN0YXJ0IG9mIHRoaXMgY29kZXBvaW50XG5cdCAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcblx0ICAgIFV0ZjhFcnJvclJlYXNvbltcIk9WRVJMT05HXCJdID0gXCJvdmVybG9uZyByZXByZXNlbnRhdGlvblwiO1xuXHR9KShVdGY4RXJyb3JSZWFzb24gPSBleHBvcnRzLlV0ZjhFcnJvclJlYXNvbiB8fCAoZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSB7fSkpO1xuXHQ7XG5cdGZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCBcIiArIG9mZnNldCArIFwiOyBcIiArIHJlYXNvbiwgXCJieXRlc1wiLCBieXRlcyk7XG5cdH1cblx0ZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG5cdCAgICAvLyBJZiB0aGVyZSBpcyBhbiBpbnZhbGlkIHByZWZpeCAoaW5jbHVkaW5nIHN0cmF5IGNvbnRpbnVhdGlvbiksIHNraXAgYW55IGFkZGl0aW9uYWwgY29udGludWF0aW9uIGJ5dGVzXG5cdCAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCB8fCByZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5VTkVYUEVDVEVEX0NPTlRJTlVFKSB7XG5cdCAgICAgICAgdmFyIGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIG8gPSBvZmZzZXQgKyAxOyBvIDwgYnl0ZXMubGVuZ3RoOyBvKyspIHtcblx0ICAgICAgICAgICAgaWYgKGJ5dGVzW29dID4+IDYgIT09IDB4MDIpIHtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGkrKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGk7XG5cdCAgICB9XG5cdCAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcblx0ICAgIC8vIChidXQgdGhlIGZpcnN0IGJ5dGUgd2FzIHJlYWQgYWxyZWFkeSByZWFkIGFuZCB0aGVyZWZvcmUgc2tpcHBlZClcblx0ICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOKSB7XG5cdCAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG5cdCAgICB9XG5cdCAgICAvLyBOb3RoaW5nIHRvIHNraXBcblx0ICAgIHJldHVybiAwO1xuXHR9XG5cdGZ1bmN0aW9uIHJlcGxhY2VGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpIHtcblx0ICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcblx0ICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5PVkVSTE9ORykge1xuXHQgICAgICAgIG91dHB1dC5wdXNoKGJhZENvZGVwb2ludCk7XG5cdCAgICAgICAgcmV0dXJuIDA7XG5cdCAgICB9XG5cdCAgICAvLyBQdXQgdGhlIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpbnRvIHRoZSBvdXRwdXRcblx0ICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG5cdCAgICAvLyBPdGhlcndpc2UsIHByb2Nlc3MgYXMgaWYgaWdub3JpbmcgZXJyb3JzXG5cdCAgICByZXR1cm4gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KTtcblx0fVxuXHQvLyBDb21tb24gZXJyb3IgaGFuZGluZyBzdHJhdGVnaWVzXG5cdGV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSBPYmplY3QuZnJlZXplKHtcblx0ICAgIGVycm9yOiBlcnJvckZ1bmMsXG5cdCAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG5cdCAgICByZXBsYWNlOiByZXBsYWNlRnVuY1xuXHR9KTtcblx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5cdGZ1bmN0aW9uIGdldFV0ZjhDb2RlUG9pbnRzKGJ5dGVzLCBvbkVycm9yKSB7XG5cdCAgICBpZiAob25FcnJvciA9PSBudWxsKSB7XG5cdCAgICAgICAgb25FcnJvciA9IGV4cG9ydHMuVXRmOEVycm9yRnVuY3MuZXJyb3I7XG5cdCAgICB9XG5cdCAgICBieXRlcyA9IGxpYiQxLmFycmF5aWZ5KGJ5dGVzKTtcblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIC8vIEludmFsaWQgYnl0ZXMgYXJlIGlnbm9yZWRcblx0ICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIGMgPSBieXRlc1tpKytdO1xuXHQgICAgICAgIC8vIDB4eHggeHh4eFxuXHQgICAgICAgIGlmIChjID4+IDcgPT09IDApIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuXHQgICAgICAgIHZhciBleHRyYUxlbmd0aCA9IG51bGw7XG5cdCAgICAgICAgdmFyIG92ZXJsb25nTWFzayA9IG51bGw7XG5cdCAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuXHQgICAgICAgIGlmICgoYyAmIDB4ZTApID09PSAweGMwKSB7XG5cdCAgICAgICAgICAgIGV4dHJhTGVuZ3RoID0gMTtcblx0ICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3Zjtcblx0ICAgICAgICAgICAgLy8gMTExMCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuXHQgICAgICAgICAgICBleHRyYUxlbmd0aCA9IDI7XG5cdCAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4N2ZmO1xuXHQgICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoKGMgJiAweGY4KSA9PT0gMHhmMCkge1xuXHQgICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG5cdCAgICAgICAgICAgIG92ZXJsb25nTWFzayA9IDB4ZmZmZjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmICgoYyAmIDB4YzApID09PSAweDgwKSB7XG5cdCAgICAgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUsIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uQkFEX1BSRUZJWCwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cblx0ICAgICAgICBpZiAoaSAtIDEgKyBleHRyYUxlbmd0aCA+PSBieXRlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVkVSUlVOLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBSZW1vdmUgdGhlIGxlbmd0aCBwcmVmaXggZnJvbSB0aGUgY2hhclxuXHQgICAgICAgIHZhciByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGV4dHJhTGVuZ3RoOyBqKyspIHtcblx0ICAgICAgICAgICAgdmFyIG5leHRDaGFyID0gYnl0ZXNbaV07XG5cdCAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcblx0ICAgICAgICAgICAgaWYgKChuZXh0Q2hhciAmIDB4YzApICE9IDB4ODApIHtcblx0ICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uTUlTU0lOR19DT05USU5VRSwgaSwgYnl0ZXMsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgO1xuXHQgICAgICAgICAgICByZXMgPSAocmVzIDw8IDYpIHwgKG5leHRDaGFyICYgMHgzZik7XG5cdCAgICAgICAgICAgIGkrKztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU2VlIGFib3ZlIGxvb3AgZm9yIGludmFsaWQgY29udGltdWF0aW9uIGJ5dGVcblx0ICAgICAgICBpZiAocmVzID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNYXhpbXVtIGNvZGUgcG9pbnRcblx0ICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcblx0ICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5PVVRfT0ZfUkFOR0UsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG5cdCAgICAgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBSZXNlcnZlZCBmb3IgVVRGLTE2IHN1cnJvZ2F0ZSBoYWx2ZXNcblx0ICAgICAgICBpZiAocmVzID49IDB4ZDgwMCAmJiByZXMgPD0gMHhkZmZmKSB7XG5cdCAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVVRGMTZfU1VSUk9HQVRFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcblx0ICAgICAgICBpZiAocmVzIDw9IG92ZXJsb25nTWFzaykge1xuXHQgICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJMT05HLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG5cdGZ1bmN0aW9uIHRvVXRmOEJ5dGVzKHN0ciwgZm9ybSkge1xuXHQgICAgaWYgKGZvcm0gPT09IHZvaWQgMCkgeyBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQ7IH1cblx0ICAgIGlmIChmb3JtICE9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50KSB7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTm9ybWFsaXplKCk7XG5cdCAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICBpZiAoYyA8IDB4ODApIHtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGMgPCAweDgwMCkge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiA2KSB8IDB4YzApO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKChjICYgMHhmYzAwKSA9PSAweGQ4MDApIHtcblx0ICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICB2YXIgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcblx0ICAgICAgICAgICAgaWYgKGkgPj0gc3RyLmxlbmd0aCB8fCAoYzIgJiAweGZjMDApICE9PSAweGRjMDApIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdXRmLTggc3RyaW5nXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIFN1cnJvZ2F0ZSBQYWlyXG5cdCAgICAgICAgICAgIHZhciBwYWlyID0gMHgxMDAwMCArICgoYyAmIDB4MDNmZikgPDwgMTApICsgKGMyICYgMHgwM2ZmKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKHBhaXIgPj4gMTgpIHwgMHhmMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoKHBhaXIgPj4gNikgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciAmIDB4M2YpIHwgMHg4MCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICByZXN1bHQucHVzaCgoYyA+PiAxMikgfCAweGUwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcblx0ICAgICAgICAgICAgcmVzdWx0LnB1c2goKGMgJiAweDNmKSB8IDB4ODApO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWIkMS5hcnJheWlmeShyZXN1bHQpO1xuXHR9XG5cdGV4cG9ydHMudG9VdGY4Qnl0ZXMgPSB0b1V0ZjhCeXRlcztcblx0O1xuXHRmdW5jdGlvbiBlc2NhcGVDaGFyKHZhbHVlKSB7XG5cdCAgICB2YXIgaGV4ID0gKFwiMDAwMFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcblx0ICAgIHJldHVybiBcIlxcXFx1XCIgKyBoZXguc3Vic3RyaW5nKGhleC5sZW5ndGggLSA0KTtcblx0fVxuXHRmdW5jdGlvbiBfdG9Fc2NhcGVkVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuXHQgICAgcmV0dXJuICdcIicgKyBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikubWFwKGZ1bmN0aW9uIChjb2RlUG9pbnQpIHtcblx0ICAgICAgICBpZiAoY29kZVBvaW50IDwgMjU2KSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoY29kZVBvaW50KSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBcIlxcXFxiXCI7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDk6IHJldHVybiBcIlxcXFx0XCI7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gXCJcXFxcblwiO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFwiXFxcXHJcIjtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMzQ6IHJldHVybiBcIlxcXFxcXFwiXCI7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDkyOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMzIgJiYgY29kZVBvaW50IDwgMTI3KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBlc2NhcGVDaGFyKGNvZGVQb2ludCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuXHQgICAgICAgIHJldHVybiBlc2NhcGVDaGFyKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCkgKyBlc2NhcGVDaGFyKChjb2RlUG9pbnQgJiAweDNmZikgKyAweGRjMDApO1xuXHQgICAgfSkuam9pbihcIlwiKSArICdcIic7XG5cdH1cblx0ZXhwb3J0cy5fdG9Fc2NhcGVkVXRmOFN0cmluZyA9IF90b0VzY2FwZWRVdGY4U3RyaW5nO1xuXHRmdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcblx0ICAgIHJldHVybiBjb2RlUG9pbnRzLm1hcChmdW5jdGlvbiAoY29kZVBvaW50KSB7XG5cdCAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XG5cdCAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG5cdCAgICB9KS5qb2luKFwiXCIpO1xuXHR9XG5cdGV4cG9ydHMuX3RvVXRmOFN0cmluZyA9IF90b1V0ZjhTdHJpbmc7XG5cdGZ1bmN0aW9uIHRvVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuXHQgICAgcmV0dXJuIF90b1V0ZjhTdHJpbmcoZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpKTtcblx0fVxuXHRleHBvcnRzLnRvVXRmOFN0cmluZyA9IHRvVXRmOFN0cmluZztcblx0ZnVuY3Rpb24gdG9VdGY4Q29kZVBvaW50cyhzdHIsIGZvcm0pIHtcblx0ICAgIGlmIChmb3JtID09PSB2b2lkIDApIHsgZm9ybSA9IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5jdXJyZW50OyB9XG5cdCAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG5cdH1cblx0ZXhwb3J0cy50b1V0ZjhDb2RlUG9pbnRzID0gdG9VdGY4Q29kZVBvaW50cztcblxuXHR9KTtcblxuXHR2YXIgdXRmOCQxID0gdW53cmFwRXhwb3J0cyh1dGY4KTtcblx0dmFyIHV0ZjhfMSA9IHV0ZjguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtO1xuXHR2YXIgdXRmOF8yID0gdXRmOC5VdGY4RXJyb3JSZWFzb247XG5cdHZhciB1dGY4XzMgPSB1dGY4LlV0ZjhFcnJvckZ1bmNzO1xuXHR2YXIgdXRmOF80ID0gdXRmOC50b1V0ZjhCeXRlcztcblx0dmFyIHV0ZjhfNSA9IHV0ZjguX3RvRXNjYXBlZFV0ZjhTdHJpbmc7XG5cdHZhciB1dGY4XzYgPSB1dGY4Ll90b1V0ZjhTdHJpbmc7XG5cdHZhciB1dGY4XzcgPSB1dGY4LnRvVXRmOFN0cmluZztcblx0dmFyIHV0ZjhfOCA9IHV0ZjgudG9VdGY4Q29kZVBvaW50cztcblxuXHR2YXIgYnl0ZXMzMiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0ZnVuY3Rpb24gZm9ybWF0Qnl0ZXMzMlN0cmluZyh0ZXh0KSB7XG5cdCAgICAvLyBHZXQgdGhlIGJ5dGVzXG5cdCAgICB2YXIgYnl0ZXMgPSB1dGY4LnRvVXRmOEJ5dGVzKHRleHQpO1xuXHQgICAgLy8gQ2hlY2sgd2UgaGF2ZSByb29tIGZvciBudWxsLXRlcm1pbmF0aW9uXG5cdCAgICBpZiAoYnl0ZXMubGVuZ3RoID4gMzEpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJieXRlczMyIHN0cmluZyBtdXN0IGJlIGxlc3MgdGhhbiAzMiBieXRlc1wiKTtcblx0ICAgIH1cblx0ICAgIC8vIFplcm8tcGFkIChpbXBsaWNpdGx5IG51bGwtdGVybWluYXRlcylcblx0ICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KGxpYiQxLmNvbmNhdChbYnl0ZXMsIGxpYiQ3Lkhhc2haZXJvXSkuc2xpY2UoMCwgMzIpKTtcblx0fVxuXHRleHBvcnRzLmZvcm1hdEJ5dGVzMzJTdHJpbmcgPSBmb3JtYXRCeXRlczMyU3RyaW5nO1xuXHRmdW5jdGlvbiBwYXJzZUJ5dGVzMzJTdHJpbmcoYnl0ZXMpIHtcblx0ICAgIHZhciBkYXRhID0gbGliJDEuYXJyYXlpZnkoYnl0ZXMpO1xuXHQgICAgLy8gTXVzdCBiZSAzMiBieXRlcyB3aXRoIGEgbnVsbC10ZXJtaW5hdGlvblxuXHQgICAgaWYgKGRhdGEubGVuZ3RoICE9PSAzMikge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMzMiAtIG5vdCAzMiBieXRlcyBsb25nXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKGRhdGFbMzFdICE9PSAwKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIHN0cmluZyAtIG5vIG51bGwgdGVybWluYXRvclwiKTtcblx0ICAgIH1cblx0ICAgIC8vIEZpbmQgdGhlIG51bGwgdGVybWluYXRpb25cblx0ICAgIHZhciBsZW5ndGggPSAzMTtcblx0ICAgIHdoaWxlIChkYXRhW2xlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgICAgbGVuZ3RoLS07XG5cdCAgICB9XG5cdCAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmluZyB2YWx1ZVxuXHQgICAgcmV0dXJuIHV0ZjgudG9VdGY4U3RyaW5nKGRhdGEuc2xpY2UoMCwgbGVuZ3RoKSk7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZUJ5dGVzMzJTdHJpbmcgPSBwYXJzZUJ5dGVzMzJTdHJpbmc7XG5cblx0fSk7XG5cblx0dmFyIGJ5dGVzMzIkMSA9IHVud3JhcEV4cG9ydHMoYnl0ZXMzMik7XG5cdHZhciBieXRlczMyXzEgPSBieXRlczMyLmZvcm1hdEJ5dGVzMzJTdHJpbmc7XG5cdHZhciBieXRlczMyXzIgPSBieXRlczMyLnBhcnNlQnl0ZXMzMlN0cmluZztcblxuXHR2YXIgaWRuYSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRmdW5jdGlvbiBieXRlczIoZGF0YSkge1xuXHQgICAgaWYgKChkYXRhLmxlbmd0aCAlIDQpICE9PSAwKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGRhdGFcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcblx0ICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChkYXRhLnN1YnN0cmluZyhpLCBpICsgNCksIDE2KSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGZ1bmN0aW9uIGNyZWF0ZVRhYmxlKGRhdGEsIGZ1bmMpIHtcblx0ICAgIGlmICghZnVuYykge1xuXHQgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFtwYXJzZUludCh2YWx1ZSwgMTYpXTsgfTtcblx0ICAgIH1cblx0ICAgIHZhciBsbyA9IDA7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBkYXRhLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uIChwYWlyKSB7XG5cdCAgICAgICAgdmFyIGNvbXBzID0gcGFpci5zcGxpdChcIjpcIik7XG5cdCAgICAgICAgbG8gKz0gcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcblx0ICAgICAgICByZXN1bHRbbG9dID0gZnVuYyhjb21wc1sxXSk7XG5cdCAgICB9KTtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gY3JlYXRlUmFuZ2VUYWJsZShkYXRhKSB7XG5cdCAgICB2YXIgaGkgPSAwO1xuXHQgICAgcmV0dXJuIGRhdGEuc3BsaXQoXCIsXCIpLm1hcChmdW5jdGlvbiAodikge1xuXHQgICAgICAgIHZhciBjb21wcyA9IHYuc3BsaXQoXCItXCIpO1xuXHQgICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgICAgICAgY29tcHNbMV0gPSBcIjBcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoY29tcHNbMV0gPT09IFwiXCIpIHtcblx0ICAgICAgICAgICAgY29tcHNbMV0gPSBcIjFcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGxvID0gaGkgKyBwYXJzZUludChjb21wc1swXSwgMTYpO1xuXHQgICAgICAgIGhpID0gcGFyc2VJbnQoY29tcHNbMV0sIDE2KTtcblx0ICAgICAgICByZXR1cm4geyBsOiBsbywgaDogaGkgfTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIG1hdGNoTWFwKHZhbHVlLCByYW5nZXMpIHtcblx0ICAgIHZhciBsbyA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciByYW5nZSA9IHJhbmdlc1tpXTtcblx0ICAgICAgICBsbyArPSByYW5nZS5sO1xuXHQgICAgICAgIGlmICh2YWx1ZSA+PSBsbyAmJiB2YWx1ZSA8PSBsbyArIHJhbmdlLmggJiYgKCh2YWx1ZSAtIGxvKSAlIChyYW5nZS5kIHx8IDEpKSA9PT0gMCkge1xuXHQgICAgICAgICAgICBpZiAocmFuZ2UuZSAmJiByYW5nZS5lLmluZGV4T2YodmFsdWUgLSBsbykgIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0dmFyIFRhYmxlX0FfMV9yYW5nZXMgPSBjcmVhdGVSYW5nZVRhYmxlKFwiMjIxLDEzLTFiLDVmLSw0MC0xMCw1MS1mLDExLTMsMy0zLDItMiwyLTQsOCwyLDE1LDJkLDI4LTgsODgsNDgsMjctLDMtNSwxMS0yMCwyNy0sOCwyOCwzLTUsMTIsMTgsYi1hLDFjLTQsNi0xNiwyLWQsMi0yLDIsMWItNCwxNy05LDhmLSwxMCxmLDFmLTIsMWMtMzQsMzMtMTRlLDQsMzYtLDEzLSw2LTIsMWEtZiw0LDktLDMtLDE3LDgsMi0yLDUtLDIsOC0sMy0sNC04LDItMywzLDYtLDE2LTYsMi0sNy0zLDMtLDE3LDgsMywzLDMtLDIsNi0zLDMtLDQtYSw1LDItNiwxMC1iLDQsOCwyLDQsMTcsOCwzLDYtLGIsNCw0LSwyLWUsMi00LGItMTAsNCw5LSwzLSwxNyw4LDMtLDUtLDktMiwzLSw0LTcsMy0zLDMsNC0zLGMtMTAsMyw3LTIsNCw1LTIsMywyLDMtMiwzLTIsNC0yLDksNC0zLDYtMiw0LDUtOCwyLWUsZC1kLDQsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy04LDMtMyxiLTExLDMsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy02LDIsMy0zLGItMTEsMyw5LDQsMTgsMTEtMyw3LSw0LDUtOCwyLTcsMy0zLGItMTEsMywxMy0yLDE5LGEsMi0sOC0yLDItMyw3LDIsOS0xMSw0LWIsM2ItMywxZS0yNCwzLDItLDMsMi0sMi01LDUsOCw0LDIsMi0sMyxlLDQtLDYsMiw3LSxiLSwzLTIxLDQ5LDIzLTUsMWMtMyw5LDI1LDEwLSwyLTJmLDIzLDYsMyw4LTIsNS01LDFiLTQ1LDI3LTksMmEtLDItMyw1Yi00LDQ1LTQsNTMtNSw4LDQwLDIsNS0sOCwyLDUtLDI4LDIsNS0sMjAsMiw1LSw4LDIsNS0sOCw4LDE4LDIwLDIsNS0sOCwyOCwxNC01LDFkLTIyLDU2LWIsMjc3LTgsMWUtMiw1Mi1lLGUsOC1hLDE4LTgsMTUtYixlLDQsMy1iLDVlLTIsYi0xNSwxMCxiLTUsNTktNywyYi01NTUsOWQtMyw1Yi01LDE3LSw3LSwyNy0sNy0sOSwyLDIsMiwyMC0sMzYsMTAsZi0sNywxNC0sNCxhLDU0LTMsMi02LDYtNSw5LSwxYy0xMCwxMy0xZCwxYy0xNCwzYy0sMTAtNiwzMi1iLDI0MC0zMCwyOC0xOCxjLTE0LGEwLDExNS0sMyw2Ni0sYi03Niw1LDUtLDFkLDI0LDIsNS0yLDIsOC0sMzUtMiwxOSxmLTEwLDFkLTMsMzExLTM3ZiwxYiw1YS1iLGQ3LTE5LGQtMyw0MSw1Ny0sNjgtNCwyOS0zLDVmLDI5LTM3LDJlLTIsMjUtYywyYy0yLDRlLTMsMzAsNzgtMyw2NC0sMjAsMTliNy00OSw1MWE3LTU5LDQ4ZS0yLDM4LTczOCwyYmE1LTViLDIyMmYtLDNjLTk0LDgtYiw2LTQsMWIsNiwyLDMsMyw2ZC0yMCwxNmUtZiw0MS0sMzctNywyZS0yLDExLWYsNS1iLDE4LSxiLDE0LDUtMyw2LDg4LSwyLGJmLTIsNy0sNy0sNy0sNC0yLDgsOC05LDgtMmZmLDIwLDUtYiwxYy1iNCwyNy0sMjctY2JiMSxmNy05LDI4LTIsYjUtMjIxLDU2LDQ4LDMtLDItLDMtLDUsZCwyLDUsMyw0Miw1LSw5LDgsMWQsNSw2LDItMiw4LDE1My0zLDEyMy0zLDMzLTI3ZmQsYTZkYS01MTI4LDIxZi01ZGYsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLDItMWQsNjEtZmY3ZFwiKTtcblx0Ly8gQFRPRE86IE1ha2UgdGhpcyByZWxhdGl2ZS4uLlxuXHR2YXIgVGFibGVfQl8xX2ZsYWdzID0gXCJhZCwzNGYsMTgwNiwxODBiLDE4MGMsMTgwZCwyMDBiLDIwMGMsMjAwZCwyMDYwLGZlZmZcIi5zcGxpdChcIixcIikubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBwYXJzZUludCh2LCAxNik7IH0pO1xuXHR2YXIgVGFibGVfQl8yX3JhbmdlcyA9IFtcblx0ICAgIHsgaDogMjUsIHM6IDMyLCBsOiA2NSB9LFxuXHQgICAgeyBoOiAzMCwgczogMzIsIGU6IFsyM10sIGw6IDEyNyB9LFxuXHQgICAgeyBoOiA1NCwgczogMSwgZTogWzQ4XSwgbDogNjQsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTQsIHM6IDEsIGw6IDU3LCBkOiAyIH0sXG5cdCAgICB7IGg6IDQ0LCBzOiAxLCBsOiAxNywgZDogMiB9LFxuXHQgICAgeyBoOiAxMCwgczogMSwgZTogWzIsIDYsIDhdLCBsOiA2MSwgZDogMiB9LFxuXHQgICAgeyBoOiAxNiwgczogMSwgbDogNjgsIGQ6IDIgfSxcblx0ICAgIHsgaDogODQsIHM6IDEsIGU6IFsxOCwgMjQsIDY2XSwgbDogMTksIGQ6IDIgfSxcblx0ICAgIHsgaDogMjYsIHM6IDMyLCBlOiBbMTddLCBsOiA0MzUgfSxcblx0ICAgIHsgaDogMjIsIHM6IDEsIGw6IDcxLCBkOiAyIH0sXG5cdCAgICB7IGg6IDE1LCBzOiA4MCwgbDogNDAgfSxcblx0ICAgIHsgaDogMzEsIHM6IDMyLCBsOiAxNiB9LFxuXHQgICAgeyBoOiAzMiwgczogMSwgbDogODAsIGQ6IDIgfSxcblx0ICAgIHsgaDogNTIsIHM6IDEsIGw6IDQyLCBkOiAyIH0sXG5cdCAgICB7IGg6IDEyLCBzOiAxLCBsOiA1NSwgZDogMiB9LFxuXHQgICAgeyBoOiA0MCwgczogMSwgZTogWzM4XSwgbDogMTUsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTQsIHM6IDEsIGw6IDQ4LCBkOiAyIH0sXG5cdCAgICB7IGg6IDM3LCBzOiA0OCwgbDogNDkgfSxcblx0ICAgIHsgaDogMTQ4LCBzOiAxLCBsOiA2MzUxLCBkOiAyIH0sXG5cdCAgICB7IGg6IDg4LCBzOiAxLCBsOiAxNjAsIGQ6IDIgfSxcblx0ICAgIHsgaDogMTUsIHM6IDE2LCBsOiA3MDQgfSxcblx0ICAgIHsgaDogMjUsIHM6IDI2LCBsOiA4NTQgfSxcblx0ICAgIHsgaDogMjUsIHM6IDMyLCBsOiA1NTkxNSB9LFxuXHQgICAgeyBoOiAzNywgczogNDAsIGw6IDEyNDcgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk3MTEsIGw6IDUzMjQ4IH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTE5NzYzLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTExOTgxNSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk4NjcsIGU6IFsxLCA0LCA1LCA3LCA4LCAxMSwgMTIsIDE3XSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMTk5MTksIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5OTcxLCBlOiBbMiwgNywgOCwgMTddLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNCwgczogLTEyMDAyMywgZTogWzIsIDcsIDEzLCAxNSwgMTYsIDE3XSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAwNzUsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMTI3LCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDE3OSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjUsIHM6IC0xMjAyMzEsIGw6IDUyIH0sXG5cdCAgICB7IGg6IDI1LCBzOiAtMTIwMjgzLCBsOiA1MiB9LFxuXHQgICAgeyBoOiAyNSwgczogLTEyMDMzNSwgbDogNTIgfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMTk1NDMsIGU6IFsxN10sIGw6IDU2IH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5NjAxLCBlOiBbMTddLCBsOiA1OCB9LFxuXHQgICAgeyBoOiAyNCwgczogLTExOTY1OSwgZTogWzE3XSwgbDogNTggfSxcblx0ICAgIHsgaDogMjQsIHM6IC0xMTk3MTcsIGU6IFsxN10sIGw6IDU4IH0sXG5cdCAgICB7IGg6IDI0LCBzOiAtMTE5Nzc1LCBlOiBbMTddLCBsOiA1OCB9XG5cdF07XG5cdHZhciBUYWJsZV9CXzJfbHV0X2FicyA9IGNyZWF0ZVRhYmxlKFwiYjU6M2JjLGMzOmZmLDc6NzMsMjoyNTMsNToyNTQsMzoyNTYsMToyNTcsNToyNTksMToyNWIsMzoyNjAsMToyNjMsMjoyNjksMToyNjgsNToyNmYsMToyNzIsMjoyNzUsNzoyODAsMzoyODMsNToyODgsMzoyOGEsMToyOGIsNToyOTIsM2Y6MTk1LDE6MWJmLDI5OjE5ZSwxMjU6M2I5LDhiOjNiMiwxOjNiOCwxOjNjNSwzOjNjNiwxOjNjMCwxYTozYmEsMTozYzEsMTozYzMsMjozYjgsMTozYjUsMWJjOTozYjksMWM6MWY3NiwxOjFmNzcsZjoxZjdhLDE6MWY3YixkOjFmNzgsMToxZjc5LDE6MWY3YywxOjFmN2QsMTA3OjYzLDU6MjViLDQ6NjgsMTo2OCwxOjY4LDM6NjksMTo2OSwxOjZjLDM6NmUsNDo3MCwxOjcxLDE6NzIsMTo3MiwxOjcyLDc6N2EsMjozYzksMjo3YSwyOjZiLDE6ZTUsMTo2MiwxOjYzLDM6NjUsMTo2NiwyOjZkLGI6M2IzLDE6M2MwLDY6NjQsMWI1NzQ6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzXCIpO1xuXHR2YXIgVGFibGVfQl8yX2x1dF9yZWwgPSBjcmVhdGVUYWJsZShcIjE3OToxLDI6MSwyOjEsNToxLDI6MSxhOjRmLGE6MSw4OjEsMjoxLDI6MSwzOjEsNToxLDM6MSw0OjEsMjoxLDM6MSw0OjEsODoyLDE6MSwyOjIsMToxLDI6MiwyNzoyLDE5NToyNiwyOjI1LDE6MjUsMToyNSwyOjQwLDI6M2YsMTozZiwzMzoxLDExOi02LDE6LTksMWFjNzotM2EsNmQ6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCxiOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LGM6LTgsMjotOCwyOi04LDI6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDQ5Oi04LDE6LTgsMTotNGEsMTotNGEsZDotNTYsMTotNTYsMTotNTYsMTotNTYsZDotOCwxOi04LGY6LTgsMTotOCwzOi03XCIpO1xuXHR2YXIgVGFibGVfQl8yX2NvbXBsZXggPSBjcmVhdGVUYWJsZShcImRmOjAwNzMwMDczLDUxOjAwNjkwMzA3LDE5OjAyQkMwMDZFLGE3OjAwNkEwMzBDLDE4YTowMDIwMDNCOSwxNjowM0I5MDMwODAzMDEsMjA6MDNDNTAzMDgwMzAxLDFkNzowNTY1MDU4MiwxOTBmOjAwNjgwMzMxLDE6MDA3NDAzMDgsMTowMDc3MDMwQSwxOjAwNzkwMzBBLDE6MDA2MTAyQkUsYjY6MDNDNTAzMTMsMjowM0M1MDMxMzAzMDAsMjowM0M1MDMxMzAzMDEsMjowM0M1MDMxMzAzNDIsMmE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMDAwM0I5LDE6MUYwMTAzQjksMToxRjAyMDNCOSwxOjFGMDMwM0I5LDE6MUYwNDAzQjksMToxRjA1MDNCOSwxOjFGMDYwM0I5LDE6MUYwNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUYyMDAzQjksMToxRjIxMDNCOSwxOjFGMjIwM0I5LDE6MUYyMzAzQjksMToxRjI0MDNCOSwxOjFGMjUwM0I5LDE6MUYyNjAzQjksMToxRjI3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMToxRjYwMDNCOSwxOjFGNjEwM0I5LDE6MUY2MjAzQjksMToxRjYzMDNCOSwxOjFGNjQwM0I5LDE6MUY2NTAzQjksMToxRjY2MDNCOSwxOjFGNjcwM0I5LDM6MUY3MDAzQjksMTowM0IxMDNCOSwxOjAzQUMwM0I5LDI6MDNCMTAzNDIsMTowM0IxMDM0MjAzQjksNTowM0IxMDNCOSw2OjFGNzQwM0I5LDE6MDNCNzAzQjksMTowM0FFMDNCOSwyOjAzQjcwMzQyLDE6MDNCNzAzNDIwM0I5LDU6MDNCNzAzQjksNjowM0I5MDMwODAzMDAsMTowM0I5MDMwODAzMDEsMzowM0I5MDM0MiwxOjAzQjkwMzA4MDM0MixiOjAzQzUwMzA4MDMwMCwxOjAzQzUwMzA4MDMwMSwxOjAzQzEwMzEzLDI6MDNDNTAzNDIsMTowM0M1MDMwODAzNDIsYjoxRjdDMDNCOSwxOjAzQzkwM0I5LDE6MDNDRTAzQjksMjowM0M5MDM0MiwxOjAzQzkwMzQyMDNCOSw1OjAzQzkwM0I5LGFjOjAwNzIwMDczLDViOjAwQjAwMDYzLDY6MDBCMDAwNjYsZDowMDZFMDA2RixhOjAwNzMwMDZELDE6MDA3NDAwNjUwMDZDLDE6MDA3NDAwNkQsMTI0ZjowMDY4MDA3MDAwNjEsMjowMDYxMDA3NSwyOjAwNkYwMDc2LGI6MDA3MDAwNjEsMTowMDZFMDA2MSwxOjAzQkMwMDYxLDE6MDA2RDAwNjEsMTowMDZCMDA2MSwxOjAwNkIwMDYyLDE6MDA2RDAwNjIsMTowMDY3MDA2MiwzOjAwNzAwMDY2LDE6MDA2RTAwNjYsMTowM0JDMDA2Niw0OjAwNjgwMDdBLDE6MDA2QjAwNjgwMDdBLDE6MDA2RDAwNjgwMDdBLDE6MDA2NzAwNjgwMDdBLDE6MDA3NDAwNjgwMDdBLDE1OjAwNzAwMDYxLDE6MDA2QjAwNzAwMDYxLDE6MDA2RDAwNzAwMDYxLDE6MDA2NzAwNzAwMDYxLDg6MDA3MDAwNzYsMTowMDZFMDA3NiwxOjAzQkMwMDc2LDE6MDA2RDAwNzYsMTowMDZCMDA3NiwxOjAwNkQwMDc2LDE6MDA3MDAwNzcsMTowMDZFMDA3NywxOjAzQkMwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDA3NywxOjAwNkQwMDc3LDE6MDA2QjAzQzksMTowMDZEMDNDOSwyOjAwNjIwMDcxLDM6MDA2MzIyMTUwMDZCMDA2NywxOjAwNjMwMDZGMDAyRSwxOjAwNjQwMDYyLDE6MDA2NzAwNzksMjowMDY4MDA3MCwyOjAwNkIwMDZCLDE6MDA2QjAwNkQsOTowMDcwMDA2OCwyOjAwNzAwMDcwMDA2RCwxOjAwNzAwMDcyLDI6MDA3MzAwNzYsMTowMDc3MDA2MixjNzIzOjAwNjYwMDY2LDE6MDA2NjAwNjksMTowMDY2MDA2QywxOjAwNjYwMDY2MDA2OSwxOjAwNjYwMDY2MDA2QywxOjAwNzMwMDc0LDE6MDA3MzAwNzQsZDowNTc0MDU3NiwxOjA1NzQwNTY1LDE6MDU3NDA1NkIsMTowNTdFMDU3NiwxOjA1NzQwNTZEXCIsIGJ5dGVzMik7XG5cdHZhciBUYWJsZV9DX3JhbmdlcyA9IGNyZWF0ZVJhbmdlVGFibGUoXCI4MC0yMCwyYTAtLDM5YywzMixmNzEsMThlLDdmMi1mLDE5LTcsMzAtNCw3LTUsZjgxLWIsNSxhODAwLTIwZmYsNGQxLTFmLDExMCxmYS02LGQxNzQtNywyZTg0LSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSxmZmZmLSwyLDFmLTVmLGZmN2YtMjAwMDFcIik7XG5cdGZ1bmN0aW9uIGZsYXR0ZW4odmFsdWVzKSB7XG5cdCAgICByZXR1cm4gdmFsdWVzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHZhbHVlKSB7XG5cdCAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHsgYWNjdW0ucHVzaCh2YWx1ZSk7IH0pO1xuXHQgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgIH0sIFtdKTtcblx0fVxuXHRmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUExKGNvZGVwb2ludCkge1xuXHQgICAgcmV0dXJuICEhbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9BXzFfcmFuZ2VzKTtcblx0fVxuXHRleHBvcnRzLl9uYW1lcHJlcFRhYmxlQTEgPSBfbmFtZXByZXBUYWJsZUExO1xuXHRmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUIyKGNvZGVwb2ludCkge1xuXHQgICAgdmFyIHJhbmdlID0gbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9CXzJfcmFuZ2VzKTtcblx0ICAgIGlmIChyYW5nZSkge1xuXHQgICAgICAgIHJldHVybiBbY29kZXBvaW50ICsgcmFuZ2Uuc107XG5cdCAgICB9XG5cdCAgICB2YXIgY29kZXMgPSBUYWJsZV9CXzJfbHV0X2Fic1tjb2RlcG9pbnRdO1xuXHQgICAgaWYgKGNvZGVzKSB7XG5cdCAgICAgICAgcmV0dXJuIGNvZGVzO1xuXHQgICAgfVxuXHQgICAgdmFyIHNoaWZ0ID0gVGFibGVfQl8yX2x1dF9yZWxbY29kZXBvaW50XTtcblx0ICAgIGlmIChzaGlmdCkge1xuXHQgICAgICAgIHJldHVybiBbY29kZXBvaW50ICsgc2hpZnRbMF1dO1xuXHQgICAgfVxuXHQgICAgdmFyIGNvbXBsZXggPSBUYWJsZV9CXzJfY29tcGxleFtjb2RlcG9pbnRdO1xuXHQgICAgaWYgKGNvbXBsZXgpIHtcblx0ICAgICAgICByZXR1cm4gY29tcGxleDtcblx0ICAgIH1cblx0ICAgIHJldHVybiBudWxsO1xuXHR9XG5cdGV4cG9ydHMuX25hbWVwcmVwVGFibGVCMiA9IF9uYW1lcHJlcFRhYmxlQjI7XG5cdGZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQyhjb2RlcG9pbnQpIHtcblx0ICAgIHJldHVybiAhIW1hdGNoTWFwKGNvZGVwb2ludCwgVGFibGVfQ19yYW5nZXMpO1xuXHR9XG5cdGV4cG9ydHMuX25hbWVwcmVwVGFibGVDID0gX25hbWVwcmVwVGFibGVDO1xuXHRmdW5jdGlvbiBuYW1lcHJlcCh2YWx1ZSkge1xuXHQgICAgLy8gVGhpcyBhbGxvd3MgcGxhdGZvcm1zIHdpdGggaW5jb21wbGV0ZSBub3JtYWxpemUgdG8gYnlwYXNzXG5cdCAgICAvLyBpdCBmb3IgdmVyeSBiYXNpYyBuYW1lcyB3aGljaCB0aGUgYnVpbHQtaW4gdG9Mb3dlckNhc2Vcblx0ICAgIC8vIHdpbGwgY2VydGFpbmx5IGhhbmRsZSBjb3JyZWN0bHlcblx0ICAgIGlmICh2YWx1ZS5tYXRjaCgvXlthLXowLTktXSokL2kpICYmIHZhbHVlLmxlbmd0aCA8PSA1OSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXHQgICAgLy8gR2V0IHRoZSBjb2RlIHBvaW50cyAoa2VlcGluZyB0aGUgY3VycmVudCBub3JtYWxpemF0aW9uKVxuXHQgICAgdmFyIGNvZGVzID0gdXRmOC50b1V0ZjhDb2RlUG9pbnRzKHZhbHVlKTtcblx0ICAgIGNvZGVzID0gZmxhdHRlbihjb2Rlcy5tYXAoZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICAvLyBTdWJzdGl0dXRlIFRhYmxlIEIuMSAoTWFwcyB0byBOb3RoaW5nKVxuXHQgICAgICAgIGlmIChUYWJsZV9CXzFfZmxhZ3MuaW5kZXhPZihjb2RlKSA+PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvZGUgPj0gMHhmZTAwICYmIGNvZGUgPD0gMHhmZTBmKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU3Vic3RpdHV0ZSBUYWJsZSBCLjIgKENhc2UgRm9sZGluZylcblx0ICAgICAgICB2YXIgY29kZXNUYWJsZUIyID0gX25hbWVwcmVwVGFibGVCMihjb2RlKTtcblx0ICAgICAgICBpZiAoY29kZXNUYWJsZUIyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjb2Rlc1RhYmxlQjI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vIFN1YnN0aXR1dGlvblxuXHQgICAgICAgIHJldHVybiBbY29kZV07XG5cdCAgICB9KSk7XG5cdCAgICAvLyBOb3JtYWxpemUgdXNpbmcgZm9ybSBLQ1xuXHQgICAgY29kZXMgPSB1dGY4LnRvVXRmOENvZGVQb2ludHModXRmOC5fdG9VdGY4U3RyaW5nKGNvZGVzKSwgdXRmOC5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uTkZLQyk7XG5cdCAgICAvLyBQcm9oaWJpdCBUYWJsZXMgQy4xLjIsIEMuMi4yLCBDLjMsIEMuNCwgQy41LCBDLjYsIEMuNywgQy44LCBDLjlcblx0ICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICBpZiAoX25hbWVwcmVwVGFibGVDKGNvZGUpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNUUklOR1BSRVBfQ09OVEFJTlNfUFJPSElCSVRFRFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0ICAgIC8vIFByb2hpYml0IFVuYXNzaWduZWQgQ29kZSBQb2ludHMgKFRhYmxlIEEuMSlcblx0ICAgIGNvZGVzLmZvckVhY2goZnVuY3Rpb24gKGNvZGUpIHtcblx0ICAgICAgICBpZiAoX25hbWVwcmVwVGFibGVBMShjb2RlKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTVFJJTkdQUkVQX0NPTlRBSU5TX1VOQVNTSUdORURcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdCAgICAvLyBJRE5BIGV4dHJhc1xuXHQgICAgdmFyIG5hbWUgPSB1dGY4Ll90b1V0ZjhTdHJpbmcoY29kZXMpO1xuXHQgICAgLy8gSUROQTogNC4yLjMuMVxuXHQgICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIiB8fCBuYW1lLnN1YnN0cmluZygyLCA0KSA9PT0gXCItLVwiIHx8IG5hbWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoIC0gMSkgPT09IFwiLVwiKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBoeXBoZW5cIik7XG5cdCAgICB9XG5cdCAgICAvLyBJRE5BOiA0LjIuNFxuXHQgICAgaWYgKG5hbWUubGVuZ3RoID4gNjMpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbG9uZ1wiKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBuYW1lO1xuXHR9XG5cdGV4cG9ydHMubmFtZXByZXAgPSBuYW1lcHJlcDtcblxuXHR9KTtcblxuXHR2YXIgaWRuYSQxID0gdW53cmFwRXhwb3J0cyhpZG5hKTtcblx0dmFyIGlkbmFfMSA9IGlkbmEuX25hbWVwcmVwVGFibGVBMTtcblx0dmFyIGlkbmFfMiA9IGlkbmEuX25hbWVwcmVwVGFibGVCMjtcblx0dmFyIGlkbmFfMyA9IGlkbmEuX25hbWVwcmVwVGFibGVDO1xuXHR2YXIgaWRuYV80ID0gaWRuYS5uYW1lcHJlcDtcblxuXHR2YXIgbGliJDggPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZXhwb3J0cy5mb3JtYXRCeXRlczMyU3RyaW5nID0gYnl0ZXMzMi5mb3JtYXRCeXRlczMyU3RyaW5nO1xuXHRleHBvcnRzLnBhcnNlQnl0ZXMzMlN0cmluZyA9IGJ5dGVzMzIucGFyc2VCeXRlczMyU3RyaW5nO1xuXG5cdGV4cG9ydHMubmFtZXByZXAgPSBpZG5hLm5hbWVwcmVwO1xuXG5cdGV4cG9ydHMuX3RvRXNjYXBlZFV0ZjhTdHJpbmcgPSB1dGY4Ll90b0VzY2FwZWRVdGY4U3RyaW5nO1xuXHRleHBvcnRzLnRvVXRmOEJ5dGVzID0gdXRmOC50b1V0ZjhCeXRlcztcblx0ZXhwb3J0cy50b1V0ZjhDb2RlUG9pbnRzID0gdXRmOC50b1V0ZjhDb2RlUG9pbnRzO1xuXHRleHBvcnRzLnRvVXRmOFN0cmluZyA9IHV0ZjgudG9VdGY4U3RyaW5nO1xuXHRleHBvcnRzLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHV0ZjguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtO1xuXHRleHBvcnRzLlV0ZjhFcnJvckZ1bmNzID0gdXRmOC5VdGY4RXJyb3JGdW5jcztcblx0ZXhwb3J0cy5VdGY4RXJyb3JSZWFzb24gPSB1dGY4LlV0ZjhFcnJvclJlYXNvbjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkOCA9IHVud3JhcEV4cG9ydHMobGliJDgpO1xuXHR2YXIgbGliXzEkOCA9IGxpYiQ4LmZvcm1hdEJ5dGVzMzJTdHJpbmc7XG5cdHZhciBsaWJfMiQ3ID0gbGliJDgucGFyc2VCeXRlczMyU3RyaW5nO1xuXHR2YXIgbGliXzMkNiA9IGxpYiQ4Lm5hbWVwcmVwO1xuXHR2YXIgbGliXzQkNSA9IGxpYiQ4Ll90b0VzY2FwZWRVdGY4U3RyaW5nO1xuXHR2YXIgbGliXzUkNSA9IGxpYiQ4LnRvVXRmOEJ5dGVzO1xuXHR2YXIgbGliXzYkMyA9IGxpYiQ4LnRvVXRmOENvZGVQb2ludHM7XG5cdHZhciBsaWJfNyQzID0gbGliJDgudG9VdGY4U3RyaW5nO1xuXHR2YXIgbGliXzgkMiA9IGxpYiQ4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0dmFyIGxpYl85JDIgPSBsaWIkOC5VdGY4RXJyb3JGdW5jcztcblx0dmFyIGxpYl8xMCQxID0gbGliJDguVXRmOEVycm9yUmVhc29uO1xuXG5cdHZhciBzdHJpbmcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgU3RyaW5nQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoU3RyaW5nQ29kZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBTdHJpbmdDb2Rlcihsb2NhbE5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJzdHJpbmdcIiwgbG9jYWxOYW1lKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgU3RyaW5nQ29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh3cml0ZXIsIHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZW5jb2RlLmNhbGwodGhpcywgd3JpdGVyLCBsaWIkOC50b1V0ZjhCeXRlcyh2YWx1ZSkpO1xuXHQgICAgfTtcblx0ICAgIFN0cmluZ0NvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ4LnRvVXRmOFN0cmluZyhfc3VwZXIucHJvdG90eXBlLmRlY29kZS5jYWxsKHRoaXMsIHJlYWRlcikpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTdHJpbmdDb2Rlcjtcblx0fShieXRlcy5EeW5hbWljQnl0ZXNDb2RlcikpO1xuXHRleHBvcnRzLlN0cmluZ0NvZGVyID0gU3RyaW5nQ29kZXI7XG5cblx0fSk7XG5cblx0dmFyIHN0cmluZyQxID0gdW53cmFwRXhwb3J0cyhzdHJpbmcpO1xuXHR2YXIgc3RyaW5nXzEgPSBzdHJpbmcuU3RyaW5nQ29kZXI7XG5cblx0dmFyIHR1cGxlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0dmFyIFR1cGxlQ29kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVHVwbGVDb2RlciwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFR1cGxlQ29kZXIoY29kZXJzLCBsb2NhbE5hbWUpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBkeW5hbWljID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHR5cGVzID0gW107XG5cdCAgICAgICAgY29kZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvZGVyKSB7XG5cdCAgICAgICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG5cdCAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0eXBlcy5wdXNoKGNvZGVyLnR5cGUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwidHVwbGVcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKSB8fCB0aGlzO1xuXHQgICAgICAgIF90aGlzLmNvZGVycyA9IGNvZGVycztcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBUdXBsZUNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAod3JpdGVyLCB2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBhcnJheS5wYWNrKHdyaXRlciwgdGhpcy5jb2RlcnMsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBUdXBsZUNvZGVyLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAocmVhZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBhcnJheS51bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycykpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBUdXBsZUNvZGVyO1xuXHR9KGFic3RyYWN0Q29kZXIuQ29kZXIpKTtcblx0ZXhwb3J0cy5UdXBsZUNvZGVyID0gVHVwbGVDb2RlcjtcblxuXHR9KTtcblxuXHR2YXIgdHVwbGUkMSA9IHVud3JhcEV4cG9ydHModHVwbGUpO1xuXHR2YXIgdHVwbGVfMSA9IHR1cGxlLlR1cGxlQ29kZXI7XG5cblx0dmFyIGFiaUNvZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJDgudmVyc2lvbik7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcblx0dmFyIHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5cdHZhciBBYmlDb2RlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEFiaUNvZGVyKGNvZXJjZUZ1bmMpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEFiaUNvZGVyKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImNvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyB8fCBudWxsKTtcblx0ICAgIH1cblx0ICAgIEFiaUNvZGVyLnByb3RvdHlwZS5fZ2V0Q29kZXIgPSBmdW5jdGlvbiAocGFyYW0pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHN3aXRjaCAocGFyYW0uYmFzZVR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImFkZHJlc3NcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYWRkcmVzcy5BZGRyZXNzQ29kZXIocGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJib29sXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGJvb2xlYW5fMS5Cb29sZWFuQ29kZXIocGFyYW0ubmFtZSk7XG5cdCAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgc3RyaW5nLlN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgYnl0ZXMuQnl0ZXNDb2RlcihwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGFycmF5LkFycmF5Q29kZXIodGhpcy5fZ2V0Q29kZXIocGFyYW0uYXJyYXlDaGlsZHJlbiksIHBhcmFtLmFycmF5TGVuZ3RoLCBwYXJhbS5uYW1lKTtcblx0ICAgICAgICAgICAgY2FzZSBcInR1cGxlXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHR1cGxlLlR1cGxlQ29kZXIoKHBhcmFtLmNvbXBvbmVudHMgfHwgW10pLm1hcChmdW5jdGlvbiAoY29tcG9uZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9nZXRDb2Rlcihjb21wb25lbnQpO1xuXHQgICAgICAgICAgICAgICAgfSksIHBhcmFtLm5hbWUpO1xuXHQgICAgICAgICAgICBjYXNlIFwiXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IF9udWxsLk51bGxDb2RlcihwYXJhbS5uYW1lKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gdT9pbnRbMC05XSpcblx0ICAgICAgICB2YXIgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG5cdCAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG5cdCAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAyNTYgfHwgKHNpemUgJSA4KSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgXCIgKyBtYXRjaFsxXSArIFwiIGJpdCBsZW5ndGhcIiwgXCJwYXJhbVwiLCBwYXJhbSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBudW1iZXIuTnVtYmVyQ29kZXIoc2l6ZSAvIDgsIChtYXRjaFsxXSA9PT0gXCJpbnRcIiksIHBhcmFtLm5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBieXRlc1swLTldK1xuXHQgICAgICAgIG1hdGNoID0gcGFyYW0udHlwZS5tYXRjaChwYXJhbVR5cGVCeXRlcyk7XG5cdCAgICAgICAgaWYgKG1hdGNoKSB7XG5cdCAgICAgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuXHQgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gMCB8fCBzaXplID4gMzIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IGZpeGVkQnl0ZXMuRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgcGFyYW0udHlwZSk7XG5cdCAgICB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLl9nZXRXb3JkU2l6ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMyOyB9O1xuXHQgICAgQWJpQ29kZXIucHJvdG90eXBlLl9nZXRSZWFkZXIgPSBmdW5jdGlvbiAoZGF0YSwgYWxsb3dMb29zZSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgYWJzdHJhY3RDb2Rlci5SZWFkZXIoZGF0YSwgdGhpcy5fZ2V0V29yZFNpemUoKSwgdGhpcy5jb2VyY2VGdW5jLCBhbGxvd0xvb3NlKTtcblx0ICAgIH07XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuX2dldFdyaXRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IGFic3RyYWN0Q29kZXIuV3JpdGVyKHRoaXMuX2dldFdvcmRTaXplKCkpO1xuXHQgICAgfTtcblx0ICAgIEFiaUNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodHlwZXMsIHZhbHVlcykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInR5cGVzL3ZhbHVlcyBsZW5ndGggbWlzbWF0Y2hcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuXHQgICAgICAgICAgICAgICAgY291bnQ6IHsgdHlwZXM6IHR5cGVzLmxlbmd0aCwgdmFsdWVzOiB2YWx1ZXMubGVuZ3RoIH0sXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogeyB0eXBlczogdHlwZXMsIHZhbHVlczogdmFsdWVzIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBjb2RlcnMgPSB0eXBlcy5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLl9nZXRDb2RlcihmcmFnbWVudHMuUGFyYW1UeXBlLmZyb20odHlwZSkpOyB9KTtcblx0ICAgICAgICB2YXIgY29kZXIgPSAobmV3IHR1cGxlLlR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIikpO1xuXHQgICAgICAgIHZhciB3cml0ZXIgPSB0aGlzLl9nZXRXcml0ZXIoKTtcblx0ICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuXHQgICAgICAgIHJldHVybiB3cml0ZXIuZGF0YTtcblx0ICAgIH07XG5cdCAgICBBYmlDb2Rlci5wcm90b3R5cGUuZGVjb2RlID0gZnVuY3Rpb24gKHR5cGVzLCBkYXRhLCBsb29zZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGNvZGVycyA9IHR5cGVzLm1hcChmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gX3RoaXMuX2dldENvZGVyKGZyYWdtZW50cy5QYXJhbVR5cGUuZnJvbSh0eXBlKSk7IH0pO1xuXHQgICAgICAgIHZhciBjb2RlciA9IG5ldyB0dXBsZS5UdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuXHQgICAgICAgIHJldHVybiBjb2Rlci5kZWNvZGUodGhpcy5fZ2V0UmVhZGVyKGxpYiQxLmFycmF5aWZ5KGRhdGEpLCBsb29zZSkpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBYmlDb2Rlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5BYmlDb2RlciA9IEFiaUNvZGVyO1xuXHRleHBvcnRzLmRlZmF1bHRBYmlDb2RlciA9IG5ldyBBYmlDb2RlcigpO1xuXG5cdH0pO1xuXG5cdHZhciBhYmlDb2RlciQxID0gdW53cmFwRXhwb3J0cyhhYmlDb2Rlcik7XG5cdHZhciBhYmlDb2Rlcl8xID0gYWJpQ29kZXIuQWJpQ29kZXI7XG5cdHZhciBhYmlDb2Rlcl8yID0gYWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyO1xuXG5cdHZhciBfdmVyc2lvbiRnID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImhhc2gvNS4wLjRcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kaCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kZyk7XG5cdHZhciBfdmVyc2lvbl8xJDggPSBfdmVyc2lvbiRnLnZlcnNpb247XG5cblx0dmFyIGxpYiQ5ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJGcudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0dmFyIFplcm9zID0gbmV3IFVpbnQ4QXJyYXkoWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdKTtcblx0dmFyIFBhcnRpdGlvbiA9IG5ldyBSZWdFeHAoXCJeKCguKilcXFxcLik/KFteLl0rKSRcIik7XG5cdGZ1bmN0aW9uIGlzVmFsaWROYW1lKG5hbWUpIHtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgdmFyIGNvbXBzID0gbmFtZS5zcGxpdChcIi5cIik7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAobGliJDgubmFtZXByZXAoY29tcHNbaV0pLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW1wdHlcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHR9XG5cdGV4cG9ydHMuaXNWYWxpZE5hbWUgPSBpc1ZhbGlkTmFtZTtcblx0ZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuXHQgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICBpZiAodHlwZW9mIChuYW1lKSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFkZHJlc3MgLSBcIiArIFN0cmluZyhuYW1lKSwgXCJuYW1lXCIsIG5hbWUpO1xuXHQgICAgfVxuXHQgICAgdmFyIHJlc3VsdCA9IFplcm9zO1xuXHQgICAgd2hpbGUgKG5hbWUubGVuZ3RoKSB7XG5cdCAgICAgICAgdmFyIHBhcnRpdGlvbiA9IG5hbWUubWF0Y2goUGFydGl0aW9uKTtcblx0ICAgICAgICB2YXIgbGFiZWwgPSBsaWIkOC50b1V0ZjhCeXRlcyhsaWIkOC5uYW1lcHJlcChwYXJ0aXRpb25bM10pKTtcblx0ICAgICAgICByZXN1bHQgPSBsaWIkNC5rZWNjYWsyNTYobGliJDEuY29uY2F0KFtyZXN1bHQsIGxpYiQ0LmtlY2NhazI1NihsYWJlbCldKSk7XG5cdCAgICAgICAgbmFtZSA9IHBhcnRpdGlvblsyXSB8fCBcIlwiO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkocmVzdWx0KTtcblx0fVxuXHRleHBvcnRzLm5hbWVoYXNoID0gbmFtZWhhc2g7XG5cdGZ1bmN0aW9uIGlkKHRleHQpIHtcblx0ICAgIHJldHVybiBsaWIkNC5rZWNjYWsyNTYobGliJDgudG9VdGY4Qnl0ZXModGV4dCkpO1xuXHR9XG5cdGV4cG9ydHMuaWQgPSBpZDtcblx0ZXhwb3J0cy5tZXNzYWdlUHJlZml4ID0gXCJcXHgxOUV0aGVyZXVtIFNpZ25lZCBNZXNzYWdlOlxcblwiO1xuXHRmdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlKSB7XG5cdCAgICBpZiAodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIG1lc3NhZ2UgPSBsaWIkOC50b1V0ZjhCeXRlcyhtZXNzYWdlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWIkNC5rZWNjYWsyNTYobGliJDEuY29uY2F0KFtcblx0ICAgICAgICBsaWIkOC50b1V0ZjhCeXRlcyhleHBvcnRzLm1lc3NhZ2VQcmVmaXgpLFxuXHQgICAgICAgIGxpYiQ4LnRvVXRmOEJ5dGVzKFN0cmluZyhtZXNzYWdlLmxlbmd0aCkpLFxuXHQgICAgICAgIG1lc3NhZ2Vcblx0ICAgIF0pKTtcblx0fVxuXHRleHBvcnRzLmhhc2hNZXNzYWdlID0gaGFzaE1lc3NhZ2U7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JDkgPSB1bndyYXBFeHBvcnRzKGxpYiQ5KTtcblx0dmFyIGxpYl8xJDkgPSBsaWIkOS5pc1ZhbGlkTmFtZTtcblx0dmFyIGxpYl8yJDggPSBsaWIkOS5uYW1laGFzaDtcblx0dmFyIGxpYl8zJDcgPSBsaWIkOS5pZDtcblx0dmFyIGxpYl80JDYgPSBsaWIkOS5tZXNzYWdlUHJlZml4O1xuXHR2YXIgbGliXzUkNiA9IGxpYiQ5Lmhhc2hNZXNzYWdlO1xuXG5cdHZhciBfaW50ZXJmYWNlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblx0ZXhwb3J0cy5jaGVja1Jlc3VsdEVycm9ycyA9IGFic3RyYWN0Q29kZXIuY2hlY2tSZXN1bHRFcnJvcnM7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiQ4LnZlcnNpb24pO1xuXHR2YXIgTG9nRGVzY3JpcHRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoTG9nRGVzY3JpcHRpb24sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBMb2dEZXNjcmlwdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gTG9nRGVzY3JpcHRpb247XG5cdH0obGliJDMuRGVzY3JpcHRpb24pKTtcblx0ZXhwb3J0cy5Mb2dEZXNjcmlwdGlvbiA9IExvZ0Rlc2NyaXB0aW9uO1xuXHR2YXIgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhUcmFuc2FjdGlvbkRlc2NyaXB0aW9uLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVHJhbnNhY3Rpb25EZXNjcmlwdGlvbigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVHJhbnNhY3Rpb25EZXNjcmlwdGlvbjtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR2YXIgSW5kZXhlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhJbmRleGVkLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSW5kZXhlZCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBJbmRleGVkLmlzSW5kZXhlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSW5kZXhlZDtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLkluZGV4ZWQgPSBJbmRleGVkO1xuXHRmdW5jdGlvbiB3cmFwQWNjZXNzRXJyb3IocHJvcGVydHksIGVycm9yKSB7XG5cdCAgICB2YXIgd3JhcCA9IG5ldyBFcnJvcihcImRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyBcIiArIHByb3BlcnR5KTtcblx0ICAgIHdyYXAuZXJyb3IgPSBlcnJvcjtcblx0ICAgIHJldHVybiB3cmFwO1xuXHR9XG5cdC8qXG5cdGZ1bmN0aW9uIGNoZWNrTmFtZXMoZnJhZ21lbnQ6IEZyYWdtZW50LCB0eXBlOiBcImlucHV0XCIgfCBcIm91dHB1dFwiLCBwYXJhbXM6IEFycmF5PFBhcmFtVHlwZT4pOiB2b2lkIHtcblx0ICAgIHBhcmFtcy5yZWR1Y2UoKGFjY3VtLCBwYXJhbSkgPT4ge1xuXHQgICAgICAgIGlmIChwYXJhbS5uYW1lKSB7XG5cdCAgICAgICAgICAgIGlmIChhY2N1bVtwYXJhbS5uYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZHVwbGljYXRlICR7IHR5cGUgfSBwYXJhbWV0ZXIgJHsgSlNPTi5zdHJpbmdpZnkocGFyYW0ubmFtZSkgfSBpbiAkeyBmcmFnbWVudC5mb3JtYXQoXCJmdWxsXCIpIH1gLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBhY2N1bVtwYXJhbS5uYW1lXSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhY2N1bTtcblx0ICAgIH0sIDx7IFsgbmFtZTogc3RyaW5nIF06IGJvb2xlYW4gfT57IH0pO1xuXHR9XG5cdCovXG5cdHZhciBJbnRlcmZhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBJbnRlcmZhY2UoZnJhZ21lbnRzJDEpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSW50ZXJmYWNlKTtcblx0ICAgICAgICB2YXIgYWJpID0gW107XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzJDEpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGFiaSA9IEpTT04ucGFyc2UoZnJhZ21lbnRzJDEpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzJDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnJhZ21lbnRzXCIsIGFiaS5tYXAoZnVuY3Rpb24gKGZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHMuRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG5cdCAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uIChmcmFnbWVudCkgeyByZXR1cm4gKGZyYWdtZW50ICE9IG51bGwpOyB9KSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfYWJpQ29kZXJcIiwgbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXRBYmlDb2RlclwiKSgpKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJlcnJvcnNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXZlbnRzXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInN0cnVjdHNcIiwge30pO1xuXHQgICAgICAgIC8vIEFkZCBhbGwgZnJhZ21lbnRzIGJ5IHRoZWlyIHNpZ25hdHVyZVxuXHQgICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKGZyYWdtZW50KSB7XG5cdCAgICAgICAgICAgIHZhciBidWNrZXQgPSBudWxsO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKGZyYWdtZW50LnR5cGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5kZXBsb3kpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJkdXBsaWNhdGUgZGVmaW5pdGlvbiAtIGNvbnN0cnVjdG9yXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImRlcGxveVwiLCBmcmFnbWVudCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcIm91dHB1dFwiLCAoPEZ1bmN0aW9uRnJhZ21lbnQ+ZnJhZ21lbnQpLm91dHB1dHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IF90aGlzLmZ1bmN0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJldmVudFwiOlxuXHQgICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IF90aGlzLmV2ZW50cztcblx0ICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcblx0ICAgICAgICAgICAgaWYgKGJ1Y2tldFtzaWduYXR1cmVdKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcImR1cGxpY2F0ZSBkZWZpbml0aW9uIC0gXCIgKyBzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJ1Y2tldFtzaWduYXR1cmVdID0gZnJhZ21lbnQ7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgLy8gSWYgd2UgZG8gbm90IGhhdmUgYSBjb25zdHJ1Y3RvciBhZGQgYSBkZWZhdWx0XG5cdCAgICAgICAgaWYgKCF0aGlzLmRlcGxveSkge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBmcmFnbWVudHMuQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tKHtcblx0ICAgICAgICAgICAgICAgIHBheWFibGU6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgdHlwZTogXCJjb25zdHJ1Y3RvclwiXG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNJbnRlcmZhY2VcIiwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcblx0ICAgICAgICBpZiAoIWZvcm1hdCkge1xuXHQgICAgICAgICAgICBmb3JtYXQgPSBmcmFnbWVudHMuRm9ybWF0VHlwZXMuZnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGZvcm1hdCA9PT0gZnJhZ21lbnRzLkZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludGVyZmFjZSBkb2VzIG5vdCBzdXBwb3J0IGZvcm1hdHRpbmcgc2lnaGFzaFwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYWJpID0gdGhpcy5mcmFnbWVudHMubWFwKGZ1bmN0aW9uIChmcmFnbWVudCkgeyByZXR1cm4gZnJhZ21lbnQuZm9ybWF0KGZvcm1hdCk7IH0pO1xuXHQgICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuXHQgICAgICAgIGlmIChmb3JtYXQgPT09IGZyYWdtZW50cy5Gb3JtYXRUeXBlcy5qc29uKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhYmkubWFwKGZ1bmN0aW9uIChqKSB7IHJldHVybiBKU09OLnBhcnNlKGopOyB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBhYmk7XG5cdCAgICB9O1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoZXNlIHRvIGhhbmRsZSBvdGhlciBibG9ja2NoYWluc1xuXHQgICAgSW50ZXJmYWNlLmdldEFiaUNvZGVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBhYmlDb2Rlci5kZWZhdWx0QWJpQ29kZXI7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRBZGRyZXNzKGFkZHJlc3MpO1xuXHQgICAgfTtcblx0ICAgIEludGVyZmFjZS5nZXRTaWdoYXNoID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4RGF0YVNsaWNlKGxpYiQ5LmlkKGZ1bmN0aW9uRnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcblx0ICAgIH07XG5cdCAgICBJbnRlcmZhY2UuZ2V0RXZlbnRUb3BpYyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50KSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ5LmlkKGV2ZW50RnJhZ21lbnQuZm9ybWF0KCkpO1xuXHQgICAgfTtcblx0ICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmdldEZ1bmN0aW9uID0gZnVuY3Rpb24gKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCkge1xuXHQgICAgICAgIGlmIChsaWIkMS5pc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB0aGlzLmZ1bmN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCA9PT0gdGhpcy5nZXRTaWdoYXNoKG5hbWVfMSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbmFtZV8xXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJzaWdoYXNoXCIsIG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG5cdCAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC5pbmRleE9mKFwiKFwiKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgdmFyIG5hbWVfMiA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG5cdCAgICAgICAgICAgIHZhciBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoZnVuY3Rpb24gKGYpIHsgcmV0dXJuIChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZV8yKTsgfSk7XG5cdCAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcIm5hbWVcIiwgbmFtZV8yKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibXVsdGlwbGUgbWF0Y2hpbmcgZnVuY3Rpb25zXCIsIFwibmFtZVwiLCBuYW1lXzIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmZ1bmN0aW9uc1ttYXRjaGluZ1swXV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE5vcm1saXplIHRoZSBzaWduYXR1cmUgYW5kIGxvb2t1cCB0aGUgZnVuY3Rpb25cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5mdW5jdGlvbnNbZnJhZ21lbnRzLkZ1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcblx0ICAgICAgICBpZiAoIXJlc3VsdCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZnVuY3Rpb25cIiwgXCJzaWduYXR1cmVcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICAvLyBGaW5kIGFuIGV2ZW50IGRlZmluaXRpb24gYnkgYW55IG1lYW5zIG5lY2Vzc2FyeSAodW5sZXNzIGl0IGlzIGFtYmlndW91cylcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0RXZlbnQgPSBmdW5jdGlvbiAobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykge1xuXHQgICAgICAgIGlmIChsaWIkMS5pc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclRvcGljKSkge1xuXHQgICAgICAgICAgICB2YXIgdG9waWNoYXNoID0gbmFtZU9yU2lnbmF0dXJlT3JUb3BpYy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBuYW1lXzMgaW4gdGhpcy5ldmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0b3BpY2hhc2ggPT09IHRoaXMuZ2V0RXZlbnRUb3BpYyhuYW1lXzMpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW25hbWVfM107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwidG9waWNoYXNoXCIsIHRvcGljaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG5cdCAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yVG9waWMuaW5kZXhPZihcIihcIikgPT09IC0xKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lXzQgPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRyaW0oKTtcblx0ICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gT2JqZWN0LmtleXModGhpcy5ldmVudHMpLmZpbHRlcihmdW5jdGlvbiAoZikgeyByZXR1cm4gKGYuc3BsaXQoXCIoXCIgLyogZml4OikgKi8pWzBdID09PSBuYW1lXzQpOyB9KTtcblx0ICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwibmFtZVwiLCBuYW1lXzQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoaW5nLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBldmVudHNcIiwgXCJuYW1lXCIsIG5hbWVfNCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTm9ybWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuXHQgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmV2ZW50c1tmcmFnbWVudHMuRXZlbnRGcmFnbWVudC5mcm9tU3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpLmZvcm1hdCgpXTtcblx0ICAgICAgICBpZiAoIXJlc3VsdCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJzaWduYXR1cmVcIiwgbmFtZU9yU2lnbmF0dXJlT3JUb3BpYyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gR2V0IHRoZSBzaWdoYXNoICh0aGUgYnl0ZXM0IHNlbGVjdG9yKSB1c2VkIGJ5IFNvbGlkaXR5IHRvIGlkZW50aWZ5IGEgZnVuY3Rpb25cblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0U2lnaGFzaCA9IGZ1bmN0aW9uIChmdW5jdGlvbkZyYWdtZW50KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRTaWdoYXNoXCIpKGZ1bmN0aW9uRnJhZ21lbnQpO1xuXHQgICAgfTtcblx0ICAgIC8vIEdldCB0aGUgdG9waWMgKHRoZSBieXRlczMyIGhhc2gpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZ2V0RXZlbnRUb3BpYyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50KSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRFdmVudFRvcGljXCIpKGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgfTtcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuX2RlY29kZVBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMsIGRhdGEpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5fZW5jb2RlUGFyYW1zID0gZnVuY3Rpb24gKHBhcmFtcywgdmFsdWVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVEZXBsb3kgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG5cdCAgICB9O1xuXHQgICAgLy8gRGVjb2RlIHRoZSBkYXRhIGZvciBhIGZ1bmN0aW9uIGNhbGwgKGUuZy4gdHguZGF0YSlcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZGVjb2RlRnVuY3Rpb25EYXRhID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gbGliJDEuYXJyYXlpZnkoZGF0YSk7XG5cdCAgICAgICAgaWYgKGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpICE9PSB0aGlzLmdldFNpZ2hhc2goZnVuY3Rpb25GcmFnbWVudCkpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGZ1bmN0aW9uIFwiICsgZnVuY3Rpb25GcmFnbWVudC5uYW1lICsgXCIuXCIsIFwiZGF0YVwiLCBsaWIkMS5oZXhsaWZ5KGJ5dGVzKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLl9kZWNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcblx0ICAgIH07XG5cdCAgICAvLyBFbmNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVGdW5jdGlvbkRhdGEgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgdmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KGxpYiQxLmNvbmNhdChbXG5cdCAgICAgICAgICAgIHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSxcblx0ICAgICAgICAgICAgdGhpcy5fZW5jb2RlUGFyYW1zKGZ1bmN0aW9uRnJhZ21lbnQuaW5wdXRzLCB2YWx1ZXMgfHwgW10pXG5cdCAgICAgICAgXSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIERlY29kZSB0aGUgcmVzdWx0IGZyb20gYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZyb20gZXRoX2NhbGwpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmRlY29kZUZ1bmN0aW9uUmVzdWx0ID0gZnVuY3Rpb24gKGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChmdW5jdGlvbkZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gbGliJDEuYXJyYXlpZnkoZGF0YSk7XG5cdCAgICAgICAgdmFyIHJlYXNvbiA9IG51bGw7XG5cdCAgICAgICAgdmFyIGVycm9yU2lnbmF0dXJlID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKGJ5dGVzLmxlbmd0aCAlIHRoaXMuX2FiaUNvZGVyLl9nZXRXb3JkU2l6ZSgpKSB7XG5cdCAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmRlY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIGJ5dGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgaWYgKGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpID09PSBcIjB4MDhjMzc5YTBcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yU2lnbmF0dXJlID0gXCJFcnJvcihzdHJpbmcpXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKFtcInN0cmluZ1wiXSwgYnl0ZXMuc2xpY2UoNCkpWzBdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbGwgcmV2ZXJ0IGV4Y2VwdGlvblwiLCBsaWIuTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuXHQgICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uRnJhZ21lbnQuZm9ybWF0KCksXG5cdCAgICAgICAgICAgIGVycm9yU2lnbmF0dXJlOiBlcnJvclNpZ25hdHVyZSxcblx0ICAgICAgICAgICAgZXJyb3JBcmdzOiBbcmVhc29uXSxcblx0ICAgICAgICAgICAgcmVhc29uOiByZWFzb25cblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBFbmNvZGUgdGhlIHJlc3VsdCBmb3IgYSBmdW5jdGlvbiBjYWxsIChlLmcuIGZvciBldGhfY2FsbClcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUuZW5jb2RlRnVuY3Rpb25SZXN1bHQgPSBmdW5jdGlvbiAoZnVuY3Rpb25GcmFnbWVudCwgdmFsdWVzKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb25GcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24oZnVuY3Rpb25GcmFnbWVudCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KHRoaXMuX2FiaUNvZGVyLmVuY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIHZhbHVlcyB8fCBbXSkpO1xuXHQgICAgfTtcblx0ICAgIC8vIENyZWF0ZSB0aGUgZmlsdGVyIGZvciB0aGUgZXZlbnQgd2l0aCBzZWFyY2ggY3JpdGVyaWEgKGUuZy4gZm9yIGV0aF9maWx0ZXJMb2cpXG5cdCAgICBJbnRlcmZhY2UucHJvdG90eXBlLmVuY29kZUZpbHRlclRvcGljcyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IGV2ZW50RnJhZ21lbnQuaW5wdXRzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInRvbyBtYW55IGFyZ3VtZW50cyBmb3IgXCIgKyBldmVudEZyYWdtZW50LmZvcm1hdCgpLCBsaWIuTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0b3BpY3MgPSBbXTtcblx0ICAgICAgICBpZiAoIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG5cdCAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBlbmNvZGVUb3BpYyA9IGZ1bmN0aW9uIChwYXJhbSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaWIkOS5pZCh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbGliJDQua2VjY2FrMjU2KGxpYiQxLmhleGxpZnkodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG5cdCAgICAgICAgICAgIGlmIChwYXJhbS50eXBlID09PSBcImFkZHJlc3NcIikge1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuX2FiaUNvZGVyLmVuY29kZShbXCJhZGRyZXNzXCJdLCBbdmFsdWVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChsaWIkMS5oZXhsaWZ5KHZhbHVlKSwgMzIpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW0gPSBldmVudEZyYWdtZW50LmlucHV0c1tpbmRleF07XG5cdCAgICAgICAgICAgIGlmICghcGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChudWxsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmaWx0ZXJpbmcgd2l0aCB0dXBsZXMgb3IgYXJyYXlzIG5vdCBzdXBwb3J0ZWRcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaCh2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpOyB9KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChlbmNvZGVUb3BpYyhwYXJhbSwgdmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFRyaW0gb2ZmIHRyYWlsaW5nIG51bGxzXG5cdCAgICAgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0b3BpY3MucG9wKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b3BpY3M7XG5cdCAgICB9O1xuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5lbmNvZGVFdmVudExvZyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50LCB2YWx1ZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdG9waWNzID0gW107XG5cdCAgICAgICAgdmFyIGRhdGFUeXBlcyA9IFtdO1xuXHQgICAgICAgIHZhciBkYXRhVmFsdWVzID0gW107XG5cdCAgICAgICAgaWYgKCFldmVudEZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCAhPT0gZXZlbnRGcmFnbWVudC5pbnB1dHMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJldmVudCBhcmd1bWVudHMvdmFsdWVzIG1pc21hdGNoXCIsIFwidmFsdWVzXCIsIHZhbHVlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuXHQgICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0b3BpY3MucHVzaChsaWIkOS5pZCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2gobGliJDQua2VjY2FrMjU2KHZhbHVlKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBAVE9PRFxuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKF90aGlzLl9hYmlDb2Rlci5lbmNvZGUoW3BhcmFtLnR5cGVdLCBbdmFsdWVdKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhVHlwZXMucHVzaChwYXJhbSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgZGF0YTogdGhpcy5fYWJpQ29kZXIuZW5jb2RlKGRhdGFUeXBlcywgZGF0YVZhbHVlcyksXG5cdCAgICAgICAgICAgIHRvcGljczogdG9waWNzXG5cdCAgICAgICAgfTtcblx0ICAgIH07XG5cdCAgICAvLyBEZWNvZGUgYSBmaWx0ZXIgZm9yIHRoZSBldmVudCBhbmQgdGhlIHNlYXJjaCBjcml0ZXJpYVxuXHQgICAgSW50ZXJmYWNlLnByb3RvdHlwZS5kZWNvZGVFdmVudExvZyA9IGZ1bmN0aW9uIChldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHRvcGljcyAhPSBudWxsICYmICFldmVudEZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICB2YXIgdG9waWNIYXNoID0gdGhpcy5nZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpO1xuXHQgICAgICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpIHx8IHRvcGljc1swXS50b0xvd2VyQ2FzZSgpICE9PSB0b3BpY0hhc2gpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZnJhZ21lbnQvdG9waWMgbWlzbWF0Y2hcIiwgbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ0b3BpY3NbMF1cIiwgZXhwZWN0ZWQ6IHRvcGljSGFzaCwgdmFsdWU6IHRvcGljc1swXSB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBpbmRleGVkID0gW107XG5cdCAgICAgICAgdmFyIG5vbkluZGV4ZWQgPSBbXTtcblx0ICAgICAgICB2YXIgZHluYW1pYyA9IFtdO1xuXHQgICAgICAgIGV2ZW50RnJhZ21lbnQuaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtLCBpbmRleCkge1xuXHQgICAgICAgICAgICBpZiAocGFyYW0uaW5kZXhlZCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChmcmFnbWVudHMuUGFyYW1UeXBlLmZyb21PYmplY3QoeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogcGFyYW0ubmFtZSB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgZHluYW1pYy5wdXNoKHRydWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaW5kZXhlZC5wdXNoKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgbm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtcblx0ICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgcmVzdWx0SW5kZXhlZCA9ICh0b3BpY3MgIT0gbnVsbCkgPyB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoaW5kZXhlZCwgbGliJDEuY29uY2F0KHRvcGljcykpIDogbnVsbDtcblx0ICAgICAgICB2YXIgcmVzdWx0Tm9uSW5kZXhlZCA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShub25JbmRleGVkLCBkYXRhLCB0cnVlKTtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgdmFyIG5vbkluZGV4ZWRJbmRleCA9IDAsIGluZGV4ZWRJbmRleCA9IDA7XG5cdCAgICAgICAgZXZlbnRGcmFnbWVudC5pbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0sIGluZGV4KSB7XG5cdCAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0SW5kZXhlZCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogbnVsbCB9KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKGR5bmFtaWNbaW5kZXhdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZGV4XSA9IG5ldyBJbmRleGVkKHsgX2lzSW5kZXhlZDogdHJ1ZSwgaGFzaDogcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK10gfSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gQWRkIHRoZSBrZXl3b3JkIGFyZ3VtZW50IGlmIG5hbWVkIGFuZCBzYWZlXG5cdCAgICAgICAgICAgIGlmIChwYXJhbS5uYW1lICYmIHJlc3VsdFtwYXJhbS5uYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVfMSA9IHJlc3VsdFtpbmRleF07XG5cdCAgICAgICAgICAgICAgICAvLyBNYWtlIGVycm9yIG5hbWVkIHZhbHVlcyB0aHJvdyBvbiBhY2Nlc3Ncblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZV8xIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBwYXJhbS5uYW1lLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB3cmFwQWNjZXNzRXJyb3IoXCJwcm9wZXJ0eSBcIiArIEpTT04uc3RyaW5naWZ5KHBhcmFtLm5hbWUpLCB2YWx1ZV8xKTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3BhcmFtLm5hbWVdID0gdmFsdWVfMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0W2ldO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuXHQgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwgaSwge1xuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyB3cmFwQWNjZXNzRXJyb3IoXCJpbmRleCBcIiArIGksIHZhbHVlKTsgfVxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgICAgIC8vIE1ha2UgYWxsIGVycm9yIGluZGV4ZWQgdmFsdWVzIHRocm93IG9uIGFjY2Vzc1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIF9sb29wXzEoaSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHJlc3VsdCk7XG5cdCAgICB9O1xuXHQgICAgLy8gR2l2ZW4gYSB0cmFuc2FjdGlvbiwgZmluZCB0aGUgbWF0Y2hpbmcgZnVuY3Rpb24gZnJhZ21lbnQgKGlmIGFueSkgYW5kXG5cdCAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCBjYWxsIHBhcmFtZXRlcnNcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUucGFyc2VUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0eCkge1xuXHQgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24odHguZGF0YS5zdWJzdHJpbmcoMCwgMTApLnRvTG93ZXJDYXNlKCkpO1xuXHQgICAgICAgIGlmICghZnJhZ21lbnQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25EZXNjcmlwdGlvbih7XG5cdCAgICAgICAgICAgIGFyZ3M6IHRoaXMuX2FiaUNvZGVyLmRlY29kZShmcmFnbWVudC5pbnB1dHMsIFwiMHhcIiArIHR4LmRhdGEuc3Vic3RyaW5nKDEwKSksXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQ6IGZyYWdtZW50LFxuXHQgICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuXHQgICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuXHQgICAgICAgICAgICBzaWdoYXNoOiB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuXHQgICAgICAgICAgICB2YWx1ZTogbGliJDIuQmlnTnVtYmVyLmZyb20odHgudmFsdWUgfHwgXCIwXCIpLFxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIEdpdmVuIGFuIGV2ZW50IGxvZywgZmluZCB0aGUgbWF0Y2hpbmcgZXZlbnQgZnJhZ21lbnQgKGlmIGFueSkgYW5kXG5cdCAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcblx0ICAgIEludGVyZmFjZS5wcm90b3R5cGUucGFyc2VMb2cgPSBmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChsb2cudG9waWNzWzBdKTtcblx0ICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XG5cdCAgICAgICAgLy8gICAgICAgIFByb2JhYmx5IG5vdCwgYmVjYXVzZSBqdXN0IGJlY2F1c2UgaXQgaXMgdGhlIG9ubHkgZXZlbnQgaW4gdGhlIEFCSSBkb2VzXG5cdCAgICAgICAgLy8gICAgICAgIG5vdCBtZWFuIHdlIGhhdmUgdGhlIGZ1bGwgQUJJOyBtYXliZSBqc3V0IGEgZnJhZ21lbnQ/XG5cdCAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbih7XG5cdCAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQ6IGZyYWdtZW50LFxuXHQgICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuXHQgICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuXHQgICAgICAgICAgICB0b3BpYzogdGhpcy5nZXRFdmVudFRvcGljKGZyYWdtZW50KSxcblx0ICAgICAgICAgICAgYXJnczogdGhpcy5kZWNvZGVFdmVudExvZyhmcmFnbWVudCwgbG9nLmRhdGEsIGxvZy50b3BpY3MpXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLypcblx0ICAgIHN0YXRpYyBmcm9tKHZhbHVlOiBBcnJheTxGcmFnbWVudCB8IHN0cmluZyB8IEpzb25BYmk+IHwgc3RyaW5nIHwgSW50ZXJmYWNlKSB7XG5cdCAgICAgICAgaWYgKEludGVyZmFjZS5pc0ludGVyZmFjZSh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZShKU09OLnBhcnNlKHZhbHVlKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKHZhbHVlKTtcblx0ICAgIH1cblx0ICAgICovXG5cdCAgICBJbnRlcmZhY2UuaXNJbnRlcmZhY2UgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzSW50ZXJmYWNlKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSW50ZXJmYWNlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkludGVyZmFjZSA9IEludGVyZmFjZTtcblxuXHR9KTtcblxuXHR2YXIgX2ludGVyZmFjZSQxID0gdW53cmFwRXhwb3J0cyhfaW50ZXJmYWNlKTtcblx0dmFyIF9pbnRlcmZhY2VfMSA9IF9pbnRlcmZhY2UuY2hlY2tSZXN1bHRFcnJvcnM7XG5cdHZhciBfaW50ZXJmYWNlXzIgPSBfaW50ZXJmYWNlLkxvZ0Rlc2NyaXB0aW9uO1xuXHR2YXIgX2ludGVyZmFjZV8zID0gX2ludGVyZmFjZS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR2YXIgX2ludGVyZmFjZV80ID0gX2ludGVyZmFjZS5JbmRleGVkO1xuXHR2YXIgX2ludGVyZmFjZV81ID0gX2ludGVyZmFjZS5JbnRlcmZhY2U7XG5cblx0dmFyIGxpYiRhID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGV4cG9ydHMuQ29uc3RydWN0b3JGcmFnbWVudCA9IGZyYWdtZW50cy5Db25zdHJ1Y3RvckZyYWdtZW50O1xuXHRleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBmcmFnbWVudHMuRXZlbnRGcmFnbWVudDtcblx0ZXhwb3J0cy5Gb3JtYXRUeXBlcyA9IGZyYWdtZW50cy5Gb3JtYXRUeXBlcztcblx0ZXhwb3J0cy5GcmFnbWVudCA9IGZyYWdtZW50cy5GcmFnbWVudDtcblx0ZXhwb3J0cy5GdW5jdGlvbkZyYWdtZW50ID0gZnJhZ21lbnRzLkZ1bmN0aW9uRnJhZ21lbnQ7XG5cdGV4cG9ydHMuUGFyYW1UeXBlID0gZnJhZ21lbnRzLlBhcmFtVHlwZTtcblxuXHRleHBvcnRzLkFiaUNvZGVyID0gYWJpQ29kZXIuQWJpQ29kZXI7XG5cdGV4cG9ydHMuZGVmYXVsdEFiaUNvZGVyID0gYWJpQ29kZXIuZGVmYXVsdEFiaUNvZGVyO1xuXG5cdGV4cG9ydHMuY2hlY2tSZXN1bHRFcnJvcnMgPSBfaW50ZXJmYWNlLmNoZWNrUmVzdWx0RXJyb3JzO1xuXHRleHBvcnRzLkluZGV4ZWQgPSBfaW50ZXJmYWNlLkluZGV4ZWQ7XG5cdGV4cG9ydHMuSW50ZXJmYWNlID0gX2ludGVyZmFjZS5JbnRlcmZhY2U7XG5cdGV4cG9ydHMuTG9nRGVzY3JpcHRpb24gPSBfaW50ZXJmYWNlLkxvZ0Rlc2NyaXB0aW9uO1xuXHRleHBvcnRzLlRyYW5zYWN0aW9uRGVzY3JpcHRpb24gPSBfaW50ZXJmYWNlLlRyYW5zYWN0aW9uRGVzY3JpcHRpb247XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGEgPSB1bndyYXBFeHBvcnRzKGxpYiRhKTtcblx0dmFyIGxpYl8xJGEgPSBsaWIkYS5Db25zdHJ1Y3RvckZyYWdtZW50O1xuXHR2YXIgbGliXzIkOSA9IGxpYiRhLkV2ZW50RnJhZ21lbnQ7XG5cdHZhciBsaWJfMyQ4ID0gbGliJGEuRm9ybWF0VHlwZXM7XG5cdHZhciBsaWJfNCQ3ID0gbGliJGEuRnJhZ21lbnQ7XG5cdHZhciBsaWJfNSQ3ID0gbGliJGEuRnVuY3Rpb25GcmFnbWVudDtcblx0dmFyIGxpYl82JDQgPSBsaWIkYS5QYXJhbVR5cGU7XG5cdHZhciBsaWJfNyQ0ID0gbGliJGEuQWJpQ29kZXI7XG5cdHZhciBsaWJfOCQzID0gbGliJGEuZGVmYXVsdEFiaUNvZGVyO1xuXHR2YXIgbGliXzkkMyA9IGxpYiRhLmNoZWNrUmVzdWx0RXJyb3JzO1xuXHR2YXIgbGliXzEwJDIgPSBsaWIkYS5JbmRleGVkO1xuXHR2YXIgbGliXzExJDEgPSBsaWIkYS5JbnRlcmZhY2U7XG5cdHZhciBsaWJfMTIkMSA9IGxpYiRhLkxvZ0Rlc2NyaXB0aW9uO1xuXHR2YXIgbGliXzEzJDEgPSBsaWIkYS5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXG5cdHZhciBfdmVyc2lvbiRpID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcImFic3RyYWN0LXByb3ZpZGVyLzUuMC40XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGogPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGkpO1xuXHR2YXIgX3ZlcnNpb25fMSQ5ID0gX3ZlcnNpb24kaS52ZXJzaW9uO1xuXG5cdHZhciBsaWIkYiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kaS52ZXJzaW9uKTtcblx0O1xuXHQ7XG5cdC8vZXhwb3J0IHR5cGUgQ2FsbFRyYW5zYWN0aW9uYWJsZSA9IHtcblx0Ly8gICAgY2FsbCh0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb25SZXF1ZXN0KTogUHJvbWlzZTxUcmFuc2FjdGlvblJlc3BvbnNlPjtcblx0Ly99O1xuXHR2YXIgRm9ya0V2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEZvcmtFdmVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBGb3JrRXZlbnQuaXNGb3JrRXZlbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRm9ya0V2ZW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRm9ya0V2ZW50O1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuRm9ya0V2ZW50ID0gRm9ya0V2ZW50O1xuXHR2YXIgQmxvY2tGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQmxvY2tGb3JrRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBCbG9ja0ZvcmtFdmVudChibG9ja0hhc2gsIGV4cGlyeSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhibG9ja0hhc2gsIDMyKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIiwgXCJibG9ja0hhc2hcIiwgYmxvY2tIYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG5cdCAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgX2lzQmxvY2tGb3JrRXZlbnQ6IHRydWUsXG5cdCAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcblx0ICAgICAgICAgICAgYmxvY2tIYXNoOiBibG9ja0hhc2hcblx0ICAgICAgICB9KSB8fCB0aGlzO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIHJldHVybiBCbG9ja0ZvcmtFdmVudDtcblx0fShGb3JrRXZlbnQpKTtcblx0ZXhwb3J0cy5CbG9ja0ZvcmtFdmVudCA9IEJsb2NrRm9ya0V2ZW50O1xuXHR2YXIgVHJhbnNhY3Rpb25Gb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVHJhbnNhY3Rpb25Gb3JrRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBUcmFuc2FjdGlvbkZvcmtFdmVudChoYXNoLCBleHBpcnkpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoaGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJoYXNoXCIsIGhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHtcblx0ICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuXHQgICAgICAgICAgICBfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuXHQgICAgICAgICAgICBoYXNoOiBoYXNoXG5cdCAgICAgICAgfSkgfHwgdGhpcztcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gVHJhbnNhY3Rpb25Gb3JrRXZlbnQ7XG5cdH0oRm9ya0V2ZW50KSk7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25Gb3JrRXZlbnQgPSBUcmFuc2FjdGlvbkZvcmtFdmVudDtcblx0dmFyIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQoYmVmb3JlSGFzaCwgYWZ0ZXJIYXNoLCBleHBpcnkpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoYmVmb3JlSGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJiZWZvcmVIYXNoXCIsIGJlZm9yZUhhc2gpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKGFmdGVySGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uIGhhc2hcIiwgXCJhZnRlckhhc2hcIiwgYWZ0ZXJIYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB7XG5cdCAgICAgICAgICAgIF9pc0ZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgX2lzVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDogdHJ1ZSxcblx0ICAgICAgICAgICAgZXhwaXJ5OiAoZXhwaXJ5IHx8IDApLFxuXHQgICAgICAgICAgICBiZWZvcmVIYXNoOiBiZWZvcmVIYXNoLFxuXHQgICAgICAgICAgICBhZnRlckhhc2g6IGFmdGVySGFzaFxuXHQgICAgICAgIH0pIHx8IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ7XG5cdH0oRm9ya0V2ZW50KSk7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudCA9IFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gRXhwb3J0ZWQgQWJzdHJhY3RzXG5cdHZhciBQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFByb3ZpZGVyKCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChfbmV3VGFyZ2V0LCBQcm92aWRlcik7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNQcm92aWRlclwiLCB0cnVlKTtcblx0ICAgIH1cblx0ICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcblx0ICAgIFByb3ZpZGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub24oZXZlbnROYW1lLCBsaXN0ZW5lcik7XG5cdCAgICB9O1xuXHQgICAgLy8gQWxpYXMgZm9yIFwib2ZmXCJcblx0ICAgIFByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuXHQgICAgfTtcblx0ICAgIFByb3ZpZGVyLmlzUHJvdmlkZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzUHJvdmlkZXIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBQcm92aWRlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5Qcm92aWRlciA9IFByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRiID0gdW53cmFwRXhwb3J0cyhsaWIkYik7XG5cdHZhciBsaWJfMSRiID0gbGliJGIuRm9ya0V2ZW50O1xuXHR2YXIgbGliXzIkYSA9IGxpYiRiLkJsb2NrRm9ya0V2ZW50O1xuXHR2YXIgbGliXzMkOSA9IGxpYiRiLlRyYW5zYWN0aW9uRm9ya0V2ZW50O1xuXHR2YXIgbGliXzQkOCA9IGxpYiRiLlRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQ7XG5cdHZhciBsaWJfNSQ4ID0gbGliJGIuUHJvdmlkZXI7XG5cblx0dmFyIF92ZXJzaW9uJGsgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiYWJzdHJhY3Qtc2lnbmVyLzUuMC41XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJGwgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJGspO1xuXHR2YXIgX3ZlcnNpb25fMSRhID0gX3ZlcnNpb24kay52ZXJzaW9uO1xuXG5cdHZhciBsaWIkYyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kay52ZXJzaW9uKTtcblx0dmFyIGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSBbXG5cdCAgICBcImNoYWluSWRcIiwgXCJkYXRhXCIsIFwiZnJvbVwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJub25jZVwiLCBcInRvXCIsIFwidmFsdWVcIlxuXHRdO1xuXHR2YXIgZm9yd2FyZEVycm9ycyA9IFtcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUyxcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsXG5cdCAgICBsaWIuTG9nZ2VyLmVycm9ycy5SRVBMQUNFTUVOVF9VTkRFUlBSSUNFRCxcblx0XTtcblx0Ly8gU3ViLUNsYXNzIE5vdGVzOlxuXHQvLyAgLSBBIFNpZ25lciBNVVNUIGFsd2F5cyBtYWtlIHN1cmUsIHRoYXQgaWYgcHJlc2VudCwgdGhlIFwiZnJvbVwiIGZpZWxkXG5cdC8vICAgIG1hdGNoZXMgdGhlIFNpZ25lciwgYmVmb3JlIHNlbmRpbmcgb3Igc2lnbmluZyBhIHRyYW5zYWN0aW9uXG5cdC8vICAtIEEgU2lnbmVyIFNIT1VMRCBhbHdheXMgd3JhcCBwcml2YXRlIGluZm9ybWF0aW9uIChzdWNoIGFzIGEgcHJpdmF0ZVxuXHQvLyAgICBrZXkgb3IgbW5lbW9uaWMpIGluIGEgZnVuY3Rpb24sIHNvIHRoYXQgY29uc29sZS5sb2cgZG9lcyBub3QgbGVha1xuXHQvLyAgICB0aGUgZGF0YVxuXHR2YXIgU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgTVVTVCBjYWxsIHN1cGVyXG5cdCAgICBmdW5jdGlvbiBTaWduZXIoKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KF9uZXdUYXJnZXQsIFNpZ25lcik7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNTaWduZXJcIiwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBTdWItY2xhc3NlcyBNQVkgb3ZlcnJpZGUgdGhlc2Vcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuZ2V0QmFsYW5jZSA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEJhbGFuY2VcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuZ2V0QmFsYW5jZSh0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uQ291bnQodGhpcy5nZXRBZGRyZXNzKCksIGJsb2NrVGFnKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUG9wdWxhdGVzIFwiZnJvbVwiIGlmIHVuc3BlY2lmaWVkLCBhbmQgZXN0aW1hdGVzIHRoZSBnYXMgZm9yIHRoZSB0cmFuc2F0aW9uXG5cdCAgICBTaWduZXIucHJvdG90eXBlLmVzdGltYXRlR2FzID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHg7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJlc3RpbWF0ZUdhc1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXModHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBjYWxscyB3aXRoIHRoZSB0cmFuc2F0aW9uXG5cdCAgICBTaWduZXIucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHg7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJjYWxsXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIFBvcHVsYXRlcyBhbGwgZmllbGRzIGluIGEgdHJhbnNhY3Rpb24sIHNpZ25zIGl0IGFuZCBzZW5kcyBpdCB0byB0aGUgbmV0d29ya1xuXHQgICAgU2lnbmVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJzZW5kVHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNpZ25UcmFuc2FjdGlvbih0eCkudGhlbihmdW5jdGlvbiAoc2lnbmVkVHgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5zZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduZXIucHJvdG90eXBlLmdldENoYWluSWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbmV0d29yaztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldENoYWluSWRcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXR3b3JrLmNoYWluSWRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBTaWduZXIucHJvdG90eXBlLmdldEdhc1ByaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldEdhc1ByaWNlXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmdldEdhc1ByaWNlKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFNpZ25lci5wcm90b3R5cGUucmVzb2x2ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInJlc29sdmVOYW1lXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLnJlc29sdmVOYW1lKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBDaGVja3MgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBjb250YWluIGludmFsaWQga2V5cyBhbmQgaWZcblx0ICAgIC8vIG5vIFwiZnJvbVwiIGlzIHByb3ZpZGVkLCBwb3B1bGF0ZXMgaXQuXG5cdCAgICAvLyAtIGRvZXMgTk9UIHJlcXVpcmUgYSBwcm92aWRlclxuXHQgICAgLy8gLSBhZGRzIFwiZnJvbVwiIGlzIG5vdCBwcmVzZW50XG5cdCAgICAvLyAtIHJldHVybnMgYSBDT1BZIChzYWZlIHRvIG11dGF0ZSB0aGUgcmVzdWx0KVxuXHQgICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG5cdCAgICAvLyAgIC0gY2FsbFxuXHQgICAgLy8gICAtIGVzdGltYXRlR2FzXG5cdCAgICAvLyAgIC0gcG9wdWxhdGVUcmFuc2FjdGlvbiAoYW5kIHRoZXJlZm9yIHNlbmRUcmFuc2FjdGlvbilcblx0ICAgIFNpZ25lci5wcm90b3R5cGUuY2hlY2tUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIGZvciAodmFyIGtleSBpbiB0cmFuc2FjdGlvbikge1xuXHQgICAgICAgICAgICBpZiAoYWxsb3dlZFRyYW5zYWN0aW9uS2V5cy5pbmRleE9mKGtleSkgPT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBrZXk6IFwiICsga2V5LCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdHggPSBsaWIkMy5zaGFsbG93Q29weSh0cmFuc2FjdGlvbik7XG5cdCAgICAgICAgaWYgKHR4LmZyb20gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0eC5mcm9tID0gdGhpcy5nZXRBZGRyZXNzKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgYW55IHByb3ZpZGVkIGFkZHJlc3MgbWF0Y2hlcyB0aGlzIHNpZ25lclxuXHQgICAgICAgICAgICB0eC5mcm9tID0gUHJvbWlzZS5hbGwoW1xuXHQgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmZyb20pLFxuXHQgICAgICAgICAgICAgICAgdGhpcy5nZXRBZGRyZXNzKClcblx0ICAgICAgICAgICAgXSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdICE9PSByZXN1bHRbMV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFswXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0eDtcblx0ICAgIH07XG5cdCAgICAvLyBQb3B1bGF0ZXMgQUxMIGtleXMgZm9yIGEgdHJhbnNhY3Rpb24gYW5kIGNoZWNrcyB0aGF0IFwiZnJvbVwiIG1hdGNoZXNcblx0ICAgIC8vIHRoaXMgU2lnbmVyLiBTaG91bGQgYmUgdXNlZCBieSBzZW5kVHJhbnNhY3Rpb24gYnV0IE5PVCBieSBzaWduVHJhbnNhY3Rpb24uXG5cdCAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcblx0ICAgIC8vICAgLSBzZW5kVHJhbnNhY3Rpb25cblx0ICAgIFNpZ25lci5wcm90b3R5cGUucG9wdWxhdGVUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh0aGlzLmNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LnRvID0gUHJvbWlzZS5yZXNvbHZlKHR4LnRvKS50aGVuKGZ1bmN0aW9uICh0bykgeyByZXR1cm4gX3RoaXMucmVzb2x2ZU5hbWUodG8pOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzUHJpY2UgPSB0aGlzLmdldEdhc1ByaWNlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm5vbmNlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm5vbmNlID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvdW50KFwicGVuZGluZ1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSB0aGlzLmVzdGltYXRlR2FzKHR4KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZEVycm9ycy5pbmRleE9mKGVycm9yLmNvZGUpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVQsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eDogdHhcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5jaGFpbklkID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSBQcm9taXNlLmFsbChbXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmNoYWluSWQpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2hhaW5JZCgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbMV0gIT09IDAgJiYgcmVzdWx0c1swXSAhPT0gcmVzdWx0c1sxXSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2hhaW5JZCBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gU3ViLWNsYXNzZXMgU0hPVUxEIGxlYXZlIHRoZXNlIGFsb25lXG5cdCAgICBTaWduZXIucHJvdG90eXBlLl9jaGVja1Byb3ZpZGVyID0gZnVuY3Rpb24gKG9wZXJhdGlvbikge1xuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IChvcGVyYXRpb24gfHwgXCJfY2hlY2tQcm92aWRlclwiKVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgU2lnbmVyLmlzU2lnbmVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25lcik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFNpZ25lcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5TaWduZXIgPSBTaWduZXI7XG5cdHZhciBWb2lkU2lnbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFZvaWRTaWduZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBWb2lkU2lnbmVyKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIFZvaWRTaWduZXIpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyIHx8IG51bGwpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIFZvaWRTaWduZXIucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFkZHJlc3MpO1xuXHQgICAgfTtcblx0ICAgIFZvaWRTaWduZXIucHJvdG90eXBlLl9mYWlsID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wZXJhdGlvbikge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWVzc2FnZSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogb3BlcmF0aW9uIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFZvaWRTaWduZXIucHJvdG90eXBlLnNpZ25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gbWVzc2FnZXNcIiwgXCJzaWduTWVzc2FnZVwiKTtcblx0ICAgIH07XG5cdCAgICBWb2lkU2lnbmVyLnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuXHQgICAgfTtcblx0ICAgIFZvaWRTaWduZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFZvaWRTaWduZXIodGhpcy5hZGRyZXNzLCBwcm92aWRlcik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFZvaWRTaWduZXI7XG5cdH0oU2lnbmVyKSk7XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IFZvaWRTaWduZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGMgPSB1bndyYXBFeHBvcnRzKGxpYiRjKTtcblx0dmFyIGxpYl8xJGMgPSBsaWIkYy5TaWduZXI7XG5cdHZhciBsaWJfMiRiID0gbGliJGMuVm9pZFNpZ25lcjtcblxuXHR2YXIgX3ZlcnNpb24kbSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJjb250cmFjdHMvNS4wLjRcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kbiA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kbSk7XG5cdHZhciBfdmVyc2lvbl8xJGIgPSBfdmVyc2lvbiRtLnZlcnNpb247XG5cblx0dmFyIGxpYiRkID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHR2YXIgX19zcHJlYWRBcnJheXMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcblx0ICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuXHQgICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuXHQgICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuXHQgICAgICAgICAgICByW2tdID0gYVtqXTtcblx0ICAgIHJldHVybiByO1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXG5cdC8vaW1wb3J0IHsgQWRkcmVzc1plcm8gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCI7XG5cblx0Ly8gQFRPT0QgcmVtb3ZlIGRlcGVuZGVuY2VzIHRyYW5zYWN0aW9uc1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJG0udmVyc2lvbik7XG5cdDtcblx0O1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdHZhciBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuXHQgICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZnJvbTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlXG5cdH07XG5cdGZ1bmN0aW9uIHJlc29sdmVOYW1lKHJlc29sdmVyLCBuYW1lT3JQcm9taXNlKSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG5hbWU7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5hbWVPclByb21pc2VdO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgYWxyZWFkeSBhbiBhZGRyZXNzLCBqdXN0IHVzZSBpdCAoYWZ0ZXIgYWRkaW5nIGNoZWNrc3VtKVxuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsaWIkNi5nZXRBZGRyZXNzKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYSBwcm92aWRlciBvciBzaWduZXIgaXMgbmVlZGVkIHRvIHJlc29sdmUgRU5TIG5hbWVzXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc29sdmVOYW1lXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVyLnJlc29sdmVOYW1lKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdC8vIFJlY3Vyc2l2ZWx5IHJlcGxhY2VzIEVOUyBuYW1lcyB3aXRoIHByb21pc2VzIHRvIHJlc29sdmUgdGhlIG5hbWUgYW5kIHJlc29sdmVzIGFsbCBwcm9wZXJ0aWVzXG5cdGZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUpIHtcblx0ICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtVHlwZSkpIHtcblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocGFyYW1UeXBlLm1hcChmdW5jdGlvbiAocGFyYW1UeXBlLCBpbmRleCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgKChBcnJheS5pc0FycmF5KHZhbHVlKSkgPyB2YWx1ZVtpbmRleF0gOiB2YWx1ZVtwYXJhbVR5cGUubmFtZV0pLCBwYXJhbVR5cGUpO1xuXHQgICAgICAgIH0pKTtcblx0ICAgIH1cblx0ICAgIGlmIChwYXJhbVR5cGUudHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcblx0ICAgICAgICByZXR1cm4gcmVzb2x2ZU5hbWUocmVzb2x2ZXIsIHZhbHVlKTtcblx0ICAgIH1cblx0ICAgIGlmIChwYXJhbVR5cGUudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG5cdCAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUuY29tcG9uZW50cyk7XG5cdCAgICB9XG5cdCAgICBpZiAocGFyYW1UeXBlLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcblx0ICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFsdWUgZm9yIGFycmF5XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsdWUubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2LCBwYXJhbVR5cGUuYXJyYXlDaGlsZHJlbik7IH0pKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpO1xuXHR9XG5cdGZ1bmN0aW9uIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIG92ZXJyaWRlcywgcmVzb2x2ZWQsIHR4LCBybywgcm9WYWx1ZSwgbGVmdG92ZXJzO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSBmcmFnbWVudC5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzID0gbGliJDMuc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcGFyYW1ldGVyIGNvdW50IG1hdGNoZXNcblx0ICAgICAgICAgICAgICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcInBhc3NlZCB0byBjb250cmFjdFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBcImZyb21cIiBvdmVycmlkZSAoYWxsb3cgcHJvbWlzZXMpXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyYWN0LnNpZ25lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnRyYWN0cyB3aXRoIGEgU2lnbmVyIGFyZSBmcm9tIHRoZSBTaWduZXIncyBmcmFtZS1vZi1yZWZlcmVuY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2UgYWxsb3cgb3ZlcnJpZGluZyBcImZyb21cIiBpZiBpdCBtYXRjaGVzIHRoZSBzaWduZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlOiByZXNvbHZlTmFtZShjb250cmFjdC5zaWduZXIsIG92ZXJyaWRlcy5mcm9tKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduZXI6IGNvbnRyYWN0LnNpZ25lci5nZXRBZGRyZXNzKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGNoZWNrKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGliJDYuZ2V0QWRkcmVzcyhjaGVjay5zaWduZXIpICE9PSBjaGVjay5vdmVycmlkZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJDb250cmFjdCB3aXRoIGEgU2lnbmVyIGNhbm5vdCBvdmVycmlkZSBmcm9tXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJvdmVycmlkZXMuZnJvbVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hlY2sub3ZlcnJpZGVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSBjb250cmFjdC5zaWduZXIuZ2V0QWRkcmVzcygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG92ZXJyaWRlcy5mcm9tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gcmVzb2x2ZU5hbWUoY29udHJhY3QucHJvdmlkZXIsIG92ZXJyaWRlcy5mcm9tKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy99IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb250cmFjdHMgd2l0aG91dCBhIHNpZ25lciBjYW4gb3ZlcnJpZGUgXCJmcm9tXCIsIGFuZCBpZlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bnNwZWNpZmllZCB0aGUgemVybyBhZGRyZXNzIGlzIHVzZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9vdmVycmlkZXMuZnJvbSA9IEFkZHJlc3NaZXJvO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiByZXNvbHZlQWRkcmVzc2VzKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlciwgYXJncywgZnJhZ21lbnQuaW5wdXRzKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGNvbnRyYWN0LnJlc29sdmVkQWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlczogKGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKG92ZXJyaWRlcykgfHwge30pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICB0eCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY29udHJhY3QuaW50ZXJmYWNlLmVuY29kZUZ1bmN0aW9uRGF0YShmcmFnbWVudCwgcmVzb2x2ZWQuYXJncyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlZC5hZGRyZXNzXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICBybyA9IHJlc29sdmVkLm92ZXJyaWRlcztcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBzaW1wbGUgb3ZlcnJpZGVzXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLm5vbmNlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHgubm9uY2UgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyby5ub25jZSkudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLmdhc0xpbWl0ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHguZ2FzTGltaXQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyby5nYXNMaW1pdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyby5nYXNQcmljZSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gbGliJDIuQmlnTnVtYmVyLmZyb20ocm8uZ2FzUHJpY2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAocm8uZnJvbSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4LmZyb20gPSByby5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSB3YXMgbm8gXCJnYXNMaW1pdFwiIG92ZXJyaWRlLCBidXQgdGhlIEFCSSBzcGVjaWZpZXMgYSBkZWZhdWx0LCB1c2UgaXRcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCAmJiBmcmFnbWVudC5nYXMgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKGZyYWdtZW50LmdhcykuYWRkKDIxMDAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUG9wdWxhdGUgXCJ2YWx1ZVwiIG92ZXJyaWRlXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJvLnZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJvVmFsdWUgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShyby52YWx1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcm9WYWx1ZS5pc1plcm8oKSAmJiAhZnJhZ21lbnQucGF5YWJsZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBtZXRob2QgY2Fubm90IG92ZXJyaWRlIHZhbHVlXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJvdmVycmlkZXMudmFsdWVcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3ZlcnJpZGVzLnZhbHVlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC52YWx1ZSA9IHJvVmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJlbXZvZSB0aGUgb3ZlcnJpZGVzXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5ub25jZTtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLmdhc0xpbWl0O1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuZ2FzUHJpY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMudmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgbGVmdG92ZXJzID0gT2JqZWN0LmtleXMob3ZlcnJpZGVzKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKG92ZXJyaWRlc1trZXldICE9IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAobGVmdG92ZXJzLmxlbmd0aCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGxlZnRvdmVycy5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGwpOyB9KS5qb2luKFwiLFwiKSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVycmlkZXM6IGxlZnRvdmVyc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHR4XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGRQb3B1bGF0ZShjb250cmFjdCwgZnJhZ21lbnQpIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKV07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZEVzdGltYXRlKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuXHQgICAgdmFyIHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHR4O1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNpZ25lck9yUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXN0aW1hdGUgcmVxdWlyZSBhIHByb3ZpZGVyIG9yIHNpZ25lclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZXN0aW1hdGVHYXNcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzaWduZXJPclByb3ZpZGVyLmVzdGltYXRlR2FzKHR4KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHR9XG5cdGZ1bmN0aW9uIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKSB7XG5cdCAgICB2YXIgc2lnbmVyT3JQcm92aWRlciA9IChjb250cmFjdC5zaWduZXIgfHwgY29udHJhY3QucHJvdmlkZXIpO1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tUYWcsIG92ZXJyaWRlcywgdHgsIHJlc3VsdCwgdmFsdWU7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnID0gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhcmdzLmxlbmd0aCA9PT0gZnJhZ21lbnQuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyA9IGxpYiQzLnNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvdmVycmlkZXMuYmxvY2tUYWcgIT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBvdmVycmlkZXMuYmxvY2tUYWddO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWcgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChvdmVycmlkZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDM7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb250cmFjdC5kZXBsb3lUcmFuc2FjdGlvbiAhPSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbnRyYWN0Ll9kZXBsb3llZChibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzQgLyp5aWVsZCovLCBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNpZ25lck9yUHJvdmlkZXIuY2FsbCh0eCwgYmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29udHJhY3QuaW50ZXJmYWNlLmRlY29kZUZ1bmN0aW9uUmVzdWx0KGZyYWdtZW50LCByZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxhcHNlU2ltcGxlICYmIGZyYWdtZW50Lm91dHB1dHMubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB2YWx1ZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRyZXNzID0gY29udHJhY3QuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci5hcmdzID0gYXJncztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbiA9IHR4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGRTZW5kKGNvbnRyYWN0LCBmcmFnbWVudCkge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgYXJncyA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG5cdCAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHhSZXF1ZXN0LCB0eCwgd2FpdDtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjb250cmFjdC5zaWduZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9uIHJlcXVpcmVzIGEgc2lnbmVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24gIT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjb250cmFjdC5fZGVwbG95ZWQoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eFJlcXVlc3QgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbnRyYWN0LnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHhSZXF1ZXN0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2FpdCA9IHR4LndhaXQuYmluZCh0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4LndhaXQgPSBmdW5jdGlvbiAoY29uZmlybWF0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhaXQoY29uZmlybWF0aW9ucykudGhlbihmdW5jdGlvbiAocmVjZWlwdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuZXZlbnRzID0gcmVjZWlwdC5sb2dzLm1hcChmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudCA9IGxpYiQzLmRlZXBDb3B5KGxvZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJzZWQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gY29udHJhY3QuaW50ZXJmYWNlLnBhcnNlTG9nKGxvZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgcGFyc2VkIHRoZSBldmVudCBsb2c7IGluY2x1ZGUgaXRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuYXJncyA9IHBhcnNlZC5hcmdzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEsIHRvcGljcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2cocGFyc2VkLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZXZlbnQgPSBwYXJzZWQubmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkLnNpZ25hdHVyZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVc2VmdWwgb3BlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZXRCbG9jayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5wcm92aWRlci5nZXRCbG9jayhyZWNlaXB0LmJsb2NrSGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0eF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBidWlsZERlZmF1bHQoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSkge1xuXHQgICAgaWYgKGZyYWdtZW50LmNvbnN0YW50KSB7XG5cdCAgICAgICAgcmV0dXJuIGJ1aWxkQ2FsbChjb250cmFjdCwgZnJhZ21lbnQsIGNvbGxhcHNlU2ltcGxlKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBidWlsZFNlbmQoY29udHJhY3QsIGZyYWdtZW50KTtcblx0fVxuXHRmdW5jdGlvbiBnZXRFdmVudFRhZyhmaWx0ZXIpIHtcblx0ICAgIGlmIChmaWx0ZXIuYWRkcmVzcyAmJiAoZmlsdGVyLnRvcGljcyA9PSBudWxsIHx8IGZpbHRlci50b3BpY3MubGVuZ3RoID09PSAwKSkge1xuXHQgICAgICAgIHJldHVybiBcIipcIjtcblx0ICAgIH1cblx0ICAgIHJldHVybiAoZmlsdGVyLmFkZHJlc3MgfHwgXCIqXCIpICsgXCJAXCIgKyAoZmlsdGVyLnRvcGljcyA/IGZpbHRlci50b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdG9waWMuam9pbihcInxcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0b3BpYztcblx0ICAgIH0pLmpvaW4oXCI6XCIpIDogXCJcIik7XG5cdH1cblx0dmFyIFJ1bm5pbmdFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFJ1bm5pbmdFdmVudCh0YWcsIGZpbHRlcikge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwidGFnXCIsIHRhZyk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmaWx0ZXJcIiwgZmlsdGVyKTtcblx0ICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcblx0ICAgIH1cblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiAobGlzdGVuZXIsIG9uY2UpIHtcblx0ICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyOiBsaXN0ZW5lciwgb25jZTogb25jZSB9KTtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcblx0ICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgICAgIGlmIChkb25lIHx8IGl0ZW0ubGlzdGVuZXIgIT09IGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuXHQgICAgfTtcblx0ICAgIFJ1bm5pbmdFdmVudC5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubWFwKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpLmxpc3RlbmVyOyB9KTtcblx0ICAgIH07XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoYXJncykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGxpc3RlbmVyQ291bnQgPSB0aGlzLmxpc3RlbmVyQ291bnQoKTtcblx0ICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgICAgICAgIHZhciBhcmdzQ29weSA9IGFyZ3Muc2xpY2UoKTtcblx0ICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgaW4gdGhlIG5leHQgZXZlbnQgbG9vcFxuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGl0ZW0ubGlzdGVuZXIuYXBwbHkoX3RoaXMsIGFyZ3NDb3B5KTtcblx0ICAgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgICAgIC8vIFJlc2NoZWR1bGUgaXQgaWYgaXQgbm90IFwib25jZVwiXG5cdCAgICAgICAgICAgIHJldHVybiAhKGl0ZW0ub25jZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQ7XG5cdCAgICB9O1xuXHQgICAgUnVubmluZ0V2ZW50LnByb3RvdHlwZS5wcmVwYXJlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgIH07XG5cdCAgICAvLyBSZXR1cm5zIHRoZSBhcnJheSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhbiBlbWl0XG5cdCAgICBSdW5uaW5nRXZlbnQucHJvdG90eXBlLmdldEVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICByZXR1cm4gW2V2ZW50XTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gUnVubmluZ0V2ZW50O1xuXHR9KCkpO1xuXHR2YXIgRXJyb3JSdW5uaW5nRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoRXJyb3JSdW5uaW5nRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBFcnJvclJ1bm5pbmdFdmVudCgpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgXCJlcnJvclwiLCBudWxsKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIEVycm9yUnVubmluZ0V2ZW50O1xuXHR9KFJ1bm5pbmdFdmVudCkpO1xuXHQvLyBAVE9ETyBGcmFnbWVudCBzaG91bGQgaW5oZXJpdCBXaWxkY2FyZD8gYW5kIGp1c3Qgb3ZlcnJpZGUgZ2V0RW1pdD9cblx0Ly8gICAgICAgb3IgaGF2ZSBhIGNvbW1vbiBhYnN0cmFjdCBzdXBlciBjbGFzcywgd2l0aCBlbm91Z2ggY29uc3RydWN0b3Jcblx0Ly8gICAgICAgb3B0aW9ucyB0byBjb25maWd1cmUgYm90aC5cblx0Ly8gQSBGcmFnbWVudCBFdmVudCB3aWxsIHBvcHVsYXRlIGFsbCB0aGUgcHJvcGVydGllcyB0aGF0IFdpbGRjYXJkXG5cdC8vIHdpbGwsIGFuZCBhZGRpdGlvYW5sbHkgZGVyZWZlcmVuY2UgdGhlIGFyZ3VtZW50cyB3aGVuIGVtaXR0aW5nXG5cdHZhciBGcmFnbWVudFJ1bm5pbmdFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhGcmFnbWVudFJ1bm5pbmdFdmVudCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIEZyYWdtZW50UnVubmluZ0V2ZW50KGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBmcmFnbWVudCwgdG9waWNzKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZmlsdGVyID0ge1xuXHQgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG5cdCAgICAgICAgfTtcblx0ICAgICAgICB2YXIgdG9waWMgPSBjb250cmFjdEludGVyZmFjZS5nZXRFdmVudFRvcGljKGZyYWdtZW50KTtcblx0ICAgICAgICBpZiAodG9waWNzKSB7XG5cdCAgICAgICAgICAgIGlmICh0b3BpYyAhPT0gdG9waWNzWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidG9waWMgbWlzbWF0Y2hcIiwgXCJ0b3BpY3NcIiwgdG9waWNzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzLnNsaWNlKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gW3RvcGljXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBnZXRFdmVudFRhZyhmaWx0ZXIpLCBmaWx0ZXIpIHx8IHRoaXM7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJpbnRlcmZhY2VcIiwgY29udHJhY3RJbnRlcmZhY2UpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImZyYWdtZW50XCIsIGZyYWdtZW50KTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBGcmFnbWVudFJ1bm5pbmdFdmVudC5wcm90b3R5cGUucHJlcGFyZUV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBfc3VwZXIucHJvdG90eXBlLnByZXBhcmVFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0ICAgICAgICBldmVudC5ldmVudCA9IHRoaXMuZnJhZ21lbnQubmFtZTtcblx0ICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHRoaXMuZnJhZ21lbnQuZm9ybWF0KCk7XG5cdCAgICAgICAgZXZlbnQuZGVjb2RlID0gZnVuY3Rpb24gKGRhdGEsIHRvcGljcykge1xuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKF90aGlzLmZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgZXZlbnQuYXJncyA9IHRoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHRoaXMuZnJhZ21lbnQsIGV2ZW50LmRhdGEsIGV2ZW50LnRvcGljcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICBldmVudC5hcmdzID0gbnVsbDtcblx0ICAgICAgICAgICAgZXZlbnQuZGVjb2RlRXJyb3IgPSBlcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgRnJhZ21lbnRSdW5uaW5nRXZlbnQucHJvdG90eXBlLmdldEVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICB2YXIgZXJyb3JzID0gbGliJGEuY2hlY2tSZXN1bHRFcnJvcnMoZXZlbnQuYXJncyk7XG5cdCAgICAgICAgaWYgKGVycm9ycy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdLmVycm9yO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYXJncyA9IChldmVudC5hcmdzIHx8IFtdKS5zbGljZSgpO1xuXHQgICAgICAgIGFyZ3MucHVzaChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIGFyZ3M7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEZyYWdtZW50UnVubmluZ0V2ZW50O1xuXHR9KFJ1bm5pbmdFdmVudCkpO1xuXHQvLyBBIFdpbGRhcmQgRXZlbnQgd2lsbCBhdHRlbXB0IHRvIHBvcHVsYXRlOlxuXHQvLyAgLSBldmVudCAgICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCBuYW1lXG5cdC8vICAtIGV2ZW50U2lnbmF0dXJlICAgVGhlIGZ1bGwgc2lnbmF0dXJlIG9mIHRoZSBldmVudFxuXHQvLyAgLSBkZWNvZGUgICAgICAgICAgIEEgZnVuY3Rpb24gdG8gZGVjb2RlIGRhdGEgYW5kIHRvcGljc1xuXHQvLyAgLSBhcmdzICAgICAgICAgICAgIFRoZSBkZWNvZGVkIGRhdGEgYW5kIHRvcGljc1xuXHR2YXIgV2lsZGNhcmRSdW5uaW5nRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoV2lsZGNhcmRSdW5uaW5nRXZlbnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBXaWxkY2FyZFJ1bm5pbmdFdmVudChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFwiKlwiLCB7IGFkZHJlc3M6IGFkZHJlc3MgfSkgfHwgdGhpcztcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImludGVyZmFjZVwiLCBjb250cmFjdEludGVyZmFjZSk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgV2lsZGNhcmRSdW5uaW5nRXZlbnQucHJvdG90eXBlLnByZXBhcmVFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5wcmVwYXJlRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgdmFyIHBhcnNlZF8xID0gdGhpcy5pbnRlcmZhY2UucGFyc2VMb2coZXZlbnQpO1xuXHQgICAgICAgICAgICBldmVudC5ldmVudCA9IHBhcnNlZF8xLm5hbWU7XG5cdCAgICAgICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gcGFyc2VkXzEuc2lnbmF0dXJlO1xuXHQgICAgICAgICAgICBldmVudC5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSwgdG9waWNzKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHBhcnNlZF8xLmV2ZW50RnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSBwYXJzZWRfMS5hcmdzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgLy8gTm8gbWF0Y2hpbmcgZXZlbnRcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdpbGRjYXJkUnVubmluZ0V2ZW50O1xuXHR9KFJ1bm5pbmdFdmVudCkpO1xuXHR2YXIgQ29udHJhY3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBDb250cmFjdChhZGRyZXNzT3JOYW1lLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyT3JQcm92aWRlcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBDb250cmFjdCk7XG5cdCAgICAgICAgLy8gQFRPRE86IE1heWJlIHN0aWxsIGNoZWNrIHRoZSBhZGRyZXNzT3JOYW1lIGxvb2tzIGxpa2UgYSB2YWxpZCBhZGRyZXNzIG9yIG5hbWU/XG5cdCAgICAgICAgLy9hZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBsaWIkMy5nZXRTdGF0aWMoKF9uZXdUYXJnZXQpLCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuXHQgICAgICAgIGlmIChzaWduZXJPclByb3ZpZGVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBudWxsKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKGxpYiRjLlNpZ25lci5pc1NpZ25lcihzaWduZXJPclByb3ZpZGVyKSkge1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHNpZ25lck9yUHJvdmlkZXIucHJvdmlkZXIgfHwgbnVsbCk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChsaWIkYi5Qcm92aWRlci5pc1Byb3ZpZGVyKHNpZ25lck9yUHJvdmlkZXIpKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyIG9yIHByb3ZpZGVyXCIsIFwic2lnbmVyT3JQcm92aWRlclwiLCBzaWduZXJPclByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjYWxsU3RhdGljXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImVzdGltYXRlR2FzXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImZ1bmN0aW9uc1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbHRlcnNcIiwge30pO1xuXHQgICAgICAgIHtcblx0ICAgICAgICAgICAgdmFyIHVuaXF1ZUZpbHRlcnNfMSA9IHt9O1xuXHQgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmludGVyZmFjZS5ldmVudHMpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U2lnbmF0dXJlKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZXZlbnQgPSBfdGhpcy5pbnRlcmZhY2UuZXZlbnRzW2V2ZW50U2lnbmF0dXJlXTtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmZpbHRlcnMsIGV2ZW50U2lnbmF0dXJlLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IF90aGlzLmFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRvcGljczogX3RoaXMuaW50ZXJmYWNlLmVuY29kZUZpbHRlclRvcGljcyhldmVudCwgYXJncylcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXVuaXF1ZUZpbHRlcnNfMVtldmVudC5uYW1lXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcnNfMVtldmVudC5uYW1lXSA9IFtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyc18xW2V2ZW50Lm5hbWVdLnB1c2goZXZlbnRTaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgT2JqZWN0LmtleXModW5pcXVlRmlsdGVyc18xKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZmlsdGVycyA9IHVuaXF1ZUZpbHRlcnNfMVtuYW1lXTtcblx0ICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmZpbHRlcnMsIG5hbWUsIF90aGlzLmZpbHRlcnNbZmlsdGVyc1swXV0pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJEdXBsaWNhdGUgZGVmaW5pdGlvbiBvZiBcIiArIG5hbWUgKyBcIiAoXCIgKyBmaWx0ZXJzLmpvaW4oXCIsIFwiKSArIFwiKVwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3J1bm5pbmdFdmVudHNcIiwge30pO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3dyYXBwZWRFbWl0c1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3NPck5hbWUpO1xuXHQgICAgICAgIGlmICh0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicmVzb2x2ZWRBZGRyZXNzXCIsIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSkudGhlbihmdW5jdGlvbiAoYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5hbWUgbm90IGZvdW5kXCIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG5cdCAgICAgICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJFUlJPUjogQ2Fubm90IGZpbmQgQ29udHJhY3QgLSBcIiArIGFkZHJlc3NPck5hbWUpO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInJlc29sdmVkQWRkcmVzc1wiLCBQcm9taXNlLnJlc29sdmUobGliJDYuZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgLy8gV2l0aG91dCBhIHByb3ZpZGVyLCB3ZSBjYW5ub3QgdXNlIEVOUyBuYW1lc1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm92aWRlciBpcyByZXF1aXJlZCB0byB1c2UgRU5TIG5hbWUgYXMgY29udHJhY3QgYWRkcmVzc1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IENvbnRyYWN0XCJcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB1bmlxdWVOYW1lcyA9IHt9O1xuXHQgICAgICAgIHZhciB1bmlxdWVTaWduYXR1cmVzID0ge307XG5cdCAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcblx0ICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gX3RoaXMuaW50ZXJmYWNlLmZ1bmN0aW9uc1tzaWduYXR1cmVdO1xuXHQgICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduYXR1cmUgaXMgdW5pcXVlOyBpZiBub3QgdGhlIEFCSSBnZW5lcmF0aW9uIGhhc1xuXHQgICAgICAgICAgICAvLyBub3QgYmVlbiBjbGVhbmVkIG9yIG1heSBiZSBpbmNvcnJlY3RseSBnZW5lcmF0ZWRcblx0ICAgICAgICAgICAgaWYgKHVuaXF1ZVNpZ25hdHVyZXNbc2lnbmF0dXJlXSkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJEdXBsaWNhdGUgQUJJIGVudHJ5IGZvciBcIiArIEpTT04uc3RyaW5naWZ5KG5hbWUpKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0gPSB0cnVlO1xuXHQgICAgICAgICAgICAvLyBUcmFjayB1bmlxdWUgbmFtZXM7IHdlIG9ubHkgZXhwb3NlIGJhcmUgbmFtZWQgZnVuY3Rpb25zIGlmIHRoZXlcblx0ICAgICAgICAgICAgLy8gYXJlIGFtYmlndW91c1xuXHQgICAgICAgICAgICB7XG5cdCAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gZnJhZ21lbnQubmFtZTtcblx0ICAgICAgICAgICAgICAgIGlmICghdW5pcXVlTmFtZXNbbmFtZV8xXSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW25hbWVfMV0gPSBbXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW25hbWVfMV0ucHVzaChzaWduYXR1cmUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpc1tzaWduYXR1cmVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdChfdGhpcywgZnJhZ21lbnQsIHRydWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBXZSBkbyBub3QgY29sbGFwc2Ugc2ltcGxlIGNhbGxzIG9uIHRoaXMgYnVja2V0LCB3aGljaCBhbGxvd3Ncblx0ICAgICAgICAgICAgLy8gZnJhbWV3b3JrcyB0byBzYWZlbHkgdXNlIHRoaXMgd2l0aG91dCBpbnRyb3NwZWN0aW9uIGFzIHdlbGwgYXNcblx0ICAgICAgICAgICAgLy8gYWxsb3dzIGRlY29kaW5nIGVycm9yIHJlY292ZXJ5LlxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdChfdGhpcywgZnJhZ21lbnQsIGZhbHNlKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIGJ1aWxkQ2FsbChfdGhpcywgZnJhZ21lbnQsIHRydWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgYnVpbGRQb3B1bGF0ZShfdGhpcywgZnJhZ21lbnQpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5lc3RpbWF0ZUdhcywgc2lnbmF0dXJlLCBidWlsZEVzdGltYXRlKF90aGlzLCBmcmFnbWVudCkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgT2JqZWN0LmtleXModW5pcXVlTmFtZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICAgICAgLy8gQW1iaWd1b3VzIG5hbWVzIHRvIG5vdCBnZXQgYXR0YWNoZWQgYXMgYmFyZSBuYW1lc1xuXHQgICAgICAgICAgICB2YXIgc2lnbmF0dXJlcyA9IHVuaXF1ZU5hbWVzW25hbWVdO1xuXHQgICAgICAgICAgICBpZiAoc2lnbmF0dXJlcy5sZW5ndGggPiAxKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHNpZ25hdHVyZXNbMF07XG5cdCAgICAgICAgICAgIGlmIChfdGhpc1tuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgbmFtZSwgX3RoaXNbc2lnbmF0dXJlXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmZ1bmN0aW9uc1tuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5mdW5jdGlvbnMsIG5hbWUsIF90aGlzLmZ1bmN0aW9uc1tzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoX3RoaXMuY2FsbFN0YXRpY1tuYW1lXSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcy5jYWxsU3RhdGljLCBuYW1lLCBfdGhpcy5jYWxsU3RhdGljW3NpZ25hdHVyZV0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChfdGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW25hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIG5hbWUsIF90aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb25bc2lnbmF0dXJlXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKF90aGlzLmVzdGltYXRlR2FzW25hbWVdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLmVzdGltYXRlR2FzLCBuYW1lLCBfdGhpcy5lc3RpbWF0ZUdhc1tzaWduYXR1cmVdKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgQ29udHJhY3QuZ2V0Q29udHJhY3RBZGRyZXNzID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ2LmdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbik7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QuZ2V0SW50ZXJmYWNlID0gZnVuY3Rpb24gKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG5cdCAgICAgICAgaWYgKGxpYiRhLkludGVyZmFjZS5pc0ludGVyZmFjZShjb250cmFjdEludGVyZmFjZSkpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW50ZXJmYWNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IGxpYiRhLkludGVyZmFjZShjb250cmFjdEludGVyZmFjZSk7XG5cdCAgICB9O1xuXHQgICAgLy8gQFRPRE86IEFsbG93IHRpbWVvdXQ/XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuZGVwbG95ZWQgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkKCk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLl9kZXBsb3llZCA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKCF0aGlzLl9kZXBsb3llZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgLy8gSWYgd2Ugd2VyZSBqdXN0IGRlcGxveWVkLCB3ZSBrbm93IHRoZSB0cmFuc2FjdGlvbiB3ZSBzaG91bGQgb2NjdXIgaW5cblx0ICAgICAgICAgICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2RlcGxveWVkUHJvbWlzZSA9IHRoaXMuZGVwbG95VHJhbnNhY3Rpb24ud2FpdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQFRPRE86IE9uY2Ugd2UgYWxsb3cgYSB0aW1lb3V0IHRvIGJlIHBhc3NlZCBpbiwgd2Ugd2lsbCB3YWl0XG5cdCAgICAgICAgICAgICAgICAvLyB1cCB0byB0aGF0IG1hbnkgYmxvY2tzIGZvciBnZXRDb2RlXG5cdCAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHBvbGwgZm9yIG91ciBjb2RlIHRvIGJlIGRlcGxveWVkXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9kZXBsb3llZFByb21pc2UgPSB0aGlzLnByb3ZpZGVyLmdldENvZGUodGhpcy5hZGRyZXNzLCBibG9ja1RhZykudGhlbihmdW5jdGlvbiAoY29kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlID09PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IF90aGlzLmFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkUHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzpcblx0ICAgIC8vIGVzdGltYXRlRmFsbGJhY2sob3ZlcnJpZGVzPzogVHJhbnNhY3Rpb25SZXF1ZXN0KTogUHJvbWlzZTxCaWdOdW1iZXI+XG5cdCAgICAvLyBAVE9ETzpcblx0ICAgIC8vIGVzdGltYXRlRGVwbG95KGJ5dGVjb2RlOiBzdHJpbmcsIC4uLmFyZ3MpOiBQcm9taXNlPEJpZ051bWJlcj5cblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5mYWxsYmFjayA9IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghdGhpcy5zaWduZXIpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJzZW5kaW5nIGEgdHJhbnNhY3Rpb25zIHJlcXVpcmUgYSBzaWduZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb24oZmFsbGJhY2spXCIgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0eCA9IGxpYiQzLnNoYWxsb3dDb3B5KG92ZXJyaWRlcyB8fCB7fSk7XG5cdCAgICAgICAgW1wiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IGtleSB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICB0eC50byA9IHRoaXMucmVzb2x2ZWRBZGRyZXNzO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmRlcGxveWVkKCkudGhlbihmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHR4KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBSZWNvbm5lY3QgdG8gYSBkaWZmZXJlbnQgc2lnbmVyIG9yIHByb3ZpZGVyXG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChzaWduZXJPclByb3ZpZGVyKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoc2lnbmVyT3JQcm92aWRlcikgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgc2lnbmVyT3JQcm92aWRlciA9IG5ldyBsaWIkYy5Wb2lkU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIsIHRoaXMucHJvdmlkZXIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29udHJhY3QgPSBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHNpZ25lck9yUHJvdmlkZXIpO1xuXHQgICAgICAgIGlmICh0aGlzLmRlcGxveVRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29udHJhY3Q7XG5cdCAgICB9O1xuXHQgICAgLy8gUmUtYXR0YWNoIHRvIGEgZGlmZmVyZW50IG9uLWNoYWluIGluc3RhbmNlIG9mIHRoaXMgY29udHJhY3Rcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKGFkZHJlc3NPck5hbWUsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lciB8fCB0aGlzLnByb3ZpZGVyKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5pc0luZGV4ZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gbGliJGEuSW5kZXhlZC5pc0luZGV4ZWQodmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5fbm9ybWFsaXplUnVubmluZ0V2ZW50ID0gZnVuY3Rpb24gKHJ1bm5pbmdFdmVudCkge1xuXHQgICAgICAgIC8vIEFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGV2ZW50IHJ1bm5pbmc7IHdlIGNhbiByZS11c2UgaXRcblx0ICAgICAgICBpZiAodGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJ1bm5pbmdFdmVudDtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUuX2dldFJ1bm5pbmdFdmVudCA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIC8vIExpc3RlbiBmb3IgXCJlcnJvclwiIGV2ZW50cyAoaWYgeW91ciBjb250cmFjdCBoYXMgYW4gZXJyb3IgZXZlbnQsIGluY2x1ZGVcblx0ICAgICAgICAgICAgLy8gdGhlIGZ1bGwgc2lnbmF0dXJlIHRvIGJ5cGFzcyB0aGlzIHNwZWNpYWwgZXZlbnQga2V5d29yZClcblx0ICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJlcnJvclwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBFcnJvclJ1bm5pbmdFdmVudCgpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudCB0aGF0IGlzIHJlZ2lzdGVyZWRcblx0ICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJldmVudFwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoXCJldmVudFwiLCBudWxsKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnRcblx0ICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCIqXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBHZXQgdGhlIGV2ZW50IEZyYWdtZW50ICh0aHJvd3MgaWYgYW1iaWd1b3VzL3Vua25vd24gZXZlbnQpXG5cdCAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50TmFtZSk7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIGZyYWdtZW50KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFdlIGhhdmUgdG9waWNzIHRvIGZpbHRlciBieS4uLlxuXHQgICAgICAgIGlmIChldmVudE5hbWUudG9waWNzICYmIGV2ZW50TmFtZS50b3BpY3MubGVuZ3RoID4gMCkge1xuXHQgICAgICAgICAgICAvLyBJcyBpdCBhIGtub3duIHRvcGljaGFzaD8gKHRocm93cyBpZiBubyBtYXRjaGluZyB0b3BpY2hhc2gpXG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdG9waWMgPSBldmVudE5hbWUudG9waWNzWzBdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodG9waWMpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB0b3BpY1wiKTsgLy8gQFRPRE86IE1heSBoYXBwZW4gZm9yIGFub255bW91cyBldmVudHNcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KHRvcGljKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEZyYWdtZW50UnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIGZyYWdtZW50LCBldmVudE5hbWUudG9waWNzKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHRoZSB1bmtub3duIHRvcGljaGFzaFxuXHQgICAgICAgICAgICB2YXIgZmlsdGVyID0ge1xuXHQgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgdG9waWNzOiBldmVudE5hbWUudG9waWNzXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFJ1bm5pbmdFdmVudChnZXRFdmVudFRhZyhmaWx0ZXIpLCBmaWx0ZXIpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgV2lsZGNhcmRSdW5uaW5nRXZlbnQodGhpcy5hZGRyZXNzLCB0aGlzLmludGVyZmFjZSkpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5fY2hlY2tSdW5uaW5nRXZlbnRzID0gZnVuY3Rpb24gKHJ1bm5pbmdFdmVudCkge1xuXHQgICAgICAgIGlmIChydW5uaW5nRXZlbnQubGlzdGVuZXJDb3VudCgpID09PSAwKSB7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddO1xuXHQgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9sbGVyIGZvciB0aGlzLCByZW1vdmUgaXRcblx0ICAgICAgICAgICAgdmFyIGVtaXQgPSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG5cdCAgICAgICAgICAgIGlmIChlbWl0KSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyLm9mZihydW5uaW5nRXZlbnQuZmlsdGVyLCBlbWl0KTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBncmFjZWZ1bGx5IHJlY292ZXJcblx0ICAgIC8vIGZyb20gcGFyc2UgZXJyb3JzIGlmIHRoZXkgd2lzaFxuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLl93cmFwRXZlbnQgPSBmdW5jdGlvbiAocnVubmluZ0V2ZW50LCBsb2csIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZXZlbnQgPSBsaWIkMy5kZWVwQ29weShsb2cpO1xuXHQgICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAoIWxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgX3RoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci5nZXRCbG9jayhsb2cuYmxvY2tIYXNoKTsgfTtcblx0ICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGxvZy50cmFuc2FjdGlvbkhhc2gpOyB9O1xuXHQgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uUmVjZWlwdChsb2cudHJhbnNhY3Rpb25IYXNoKTsgfTtcblx0ICAgICAgICAvLyBUaGlzIG1heSB0aHJvdyBpZiB0aGUgdG9waWNzIGFuZCBkYXRhIG1pc21hdGNoIHRoZSBzaWduYXR1cmVcblx0ICAgICAgICBydW5uaW5nRXZlbnQucHJlcGFyZUV2ZW50KGV2ZW50KTtcblx0ICAgICAgICByZXR1cm4gZXZlbnQ7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLl9hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJ1bm5pbmdFdmVudCwgbGlzdGVuZXIsIG9uY2UpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImV2ZW50cyByZXF1aXJlIGEgcHJvdmlkZXIgb3IgYSBzaWduZXIgd2l0aCBhIHByb3ZpZGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwib25jZVwiIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBydW5uaW5nRXZlbnQuYWRkTGlzdGVuZXIobGlzdGVuZXIsIG9uY2UpO1xuXHQgICAgICAgIC8vIFRyYWNrIHRoaXMgcnVubmluZyBldmVudCBhbmQgaXRzIGxpc3RlbmVycyAobWF5IGFscmVhZHkgYmUgdGhlcmU7IGJ1dCBubyBoYXJkIGluIHVwZGF0aW5nKVxuXHQgICAgICAgIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ10gPSBydW5uaW5nRXZlbnQ7XG5cdCAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBwb2xsaW5nIHRoZSBwcm92aWRlciwgc3RhcnQgcG9sbGluZ1xuXHQgICAgICAgIGlmICghdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddKSB7XG5cdCAgICAgICAgICAgIHZhciB3cmFwcGVkRW1pdCA9IGZ1bmN0aW9uIChsb2cpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBldmVudCA9IF90aGlzLl93cmFwRXZlbnQocnVubmluZ0V2ZW50LCBsb2csIGxpc3RlbmVyKTtcblx0ICAgICAgICAgICAgICAgIC8vIFRyeSB0byBlbWl0IHRoZSByZXN1bHQgZm9yIHRoZSBwYXJhbWV0ZXJpemVkIGV2ZW50Li4uXG5cdCAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhcmdzID0gcnVubmluZ0V2ZW50LmdldEVtaXQoZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0LmFwcGx5KF90aGlzLCBfX3NwcmVhZEFycmF5cyhbcnVubmluZ0V2ZW50LmZpbHRlcl0sIGFyZ3MpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3IuZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gQWx3YXlzIGVtaXQgXCJldmVudFwiIGZvciBmcmFnbWVudC1iYXNlIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJldmVudFwiLCBldmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAvLyBFbWl0IFwiZXJyb3JcIiBpZiB0aGVyZSB3YXMgYW4gZXJyb3Jcblx0ICAgICAgICAgICAgICAgIGlmIChldmVudC5kZWNvZGVFcnJvciAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcImVycm9yXCIsIGV2ZW50LmRlY29kZUVycm9yLCBldmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSA9IHdyYXBwZWRFbWl0O1xuXHQgICAgICAgICAgICAvLyBTcGVjaWFsIGV2ZW50cywgbGlrZSBcImVycm9yXCIgZG8gbm90IGhhdmUgYSBmaWx0ZXJcblx0ICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlci5vbihydW5uaW5nRXZlbnQuZmlsdGVyLCB3cmFwcGVkRW1pdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLnF1ZXJ5RmlsdGVyID0gZnVuY3Rpb24gKGV2ZW50LCBmcm9tQmxvY2tPckJsb2NraGFzaCwgdG9CbG9jaykge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHJ1bm5pbmdFdmVudCA9IHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCk7XG5cdCAgICAgICAgdmFyIGZpbHRlciA9IGxpYiQzLnNoYWxsb3dDb3B5KHJ1bm5pbmdFdmVudC5maWx0ZXIpO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGZyb21CbG9ja09yQmxvY2toYXNoKSA9PT0gXCJzdHJpbmdcIiAmJiBsaWIkMS5pc0hleFN0cmluZyhmcm9tQmxvY2tPckJsb2NraGFzaCwgMzIpKSB7XG5cdCAgICAgICAgICAgIGlmICh0b0Jsb2NrICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3Qgc3BlY2lmeSB0b0Jsb2NrIHdpdGggYmxvY2toYXNoXCIsIFwidG9CbG9ja1wiLCB0b0Jsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gZnJvbUJsb2NrT3JCbG9ja2hhc2g7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gKChmcm9tQmxvY2tPckJsb2NraGFzaCAhPSBudWxsKSA/IGZyb21CbG9ja09yQmxvY2toYXNoIDogMCk7XG5cdCAgICAgICAgICAgIGZpbHRlci50b0Jsb2NrID0gKCh0b0Jsb2NrICE9IG51bGwpID8gdG9CbG9jayA6IFwibGF0ZXN0XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRMb2dzKGZpbHRlcikudGhlbihmdW5jdGlvbiAobG9ncykge1xuXHQgICAgICAgICAgICByZXR1cm4gbG9ncy5tYXAoZnVuY3Rpb24gKGxvZykgeyByZXR1cm4gX3RoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsIGxvZywgbnVsbCk7IH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgbGlzdGVuZXIpIHtcblx0ICAgICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVyKHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudCksIGxpc3RlbmVyLCBmYWxzZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiAoZXZlbnQsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpLCBsaXN0ZW5lciwgdHJ1ZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IChydW5uaW5nRXZlbnQucnVuKGFyZ3MpID4gMCk7XG5cdCAgICAgICAgLy8gTWF5IGhhdmUgZHJhaW5lZCBhbGwgdGhlIFwib25jZVwiIGV2ZW50czsgY2hlY2sgZm9yIGxpdmluZyBldmVudHNcblx0ICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0LnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpLmxpc3RlbmVyQ291bnQoKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gW107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgdGFnIGluIHRoaXMuX3J1bm5pbmdFdmVudHMpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXS5saXN0ZW5lcnMoKS5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdF8xLnB1c2gobGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdF8xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkubGlzdGVuZXJzKCk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJ1bm5pbmdFdmVudF8xID0gdGhpcy5fcnVubmluZ0V2ZW50c1t0YWddO1xuXHQgICAgICAgICAgICAgICAgcnVubmluZ0V2ZW50XzEucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50XzEpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEZWxldGUgYW55IGxpc3RlbmVyc1xuXHQgICAgICAgIHZhciBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcblx0ICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cdCAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3QucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG5cdCAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUxpc3RlbmVyKGxpc3RlbmVyKTtcblx0ICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICBDb250cmFjdC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuXHQgICAgICAgIHJldHVybiB0aGlzLm9mZihldmVudE5hbWUsIGxpc3RlbmVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ29udHJhY3Q7XG5cdH0oKSk7XG5cdGV4cG9ydHMuQ29udHJhY3QgPSBDb250cmFjdDtcblx0dmFyIENvbnRyYWN0RmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIENvbnRyYWN0RmFjdG9yeShjb250cmFjdEludGVyZmFjZSwgYnl0ZWNvZGUsIHNpZ25lcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgYnl0ZWNvZGVIZXggPSBudWxsO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBieXRlY29kZUhleCA9IGJ5dGVjb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChsaWIkMS5pc0J5dGVzKGJ5dGVjb2RlKSkge1xuXHQgICAgICAgICAgICBieXRlY29kZUhleCA9IGxpYiQxLmhleGxpZnkoYnl0ZWNvZGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChieXRlY29kZSAmJiB0eXBlb2YgKGJ5dGVjb2RlLm9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgLy8gQWxsb3cgdGhlIGJ5dGVjb2RlIG9iamVjdCBmcm9tIHRoZSBTb2xpZGl0eSBjb21waWxlclxuXHQgICAgICAgICAgICBieXRlY29kZUhleCA9IGJ5dGVjb2RlLm9iamVjdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIC8vIENyYXNoIGluIHRoZSBuZXh0IHZlcmlmaWNhdGlvbiBzdGVwXG5cdCAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gXCIhXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIE1ha2Ugc3VyZSBpdCBpcyAweCBwcmVmaXhlZFxuXHQgICAgICAgIGlmIChieXRlY29kZUhleC5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuXHQgICAgICAgICAgICBieXRlY29kZUhleCA9IFwiMHhcIiArIGJ5dGVjb2RlSGV4O1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbmFsIHJlc3VsdCBpcyB2YWxpZCBieXRlY29kZVxuXHQgICAgICAgIGlmICghbGliJDEuaXNIZXhTdHJpbmcoYnl0ZWNvZGVIZXgpIHx8IChieXRlY29kZUhleC5sZW5ndGggJSAyKSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlY29kZVwiLCBcImJ5dGVjb2RlXCIsIGJ5dGVjb2RlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHNpZ25lciwgbWFrZSBzdXJlIGl0IGlzIHZhbGlkXG5cdCAgICAgICAgaWYgKHNpZ25lciAmJiAhbGliJGMuU2lnbmVyLmlzU2lnbmVyKHNpZ25lcikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyXCIsIFwic2lnbmVyXCIsIHNpZ25lcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYnl0ZWNvZGVcIiwgYnl0ZWNvZGVIZXgpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGxpYiQzLmdldFN0YXRpYygoX25ld1RhcmdldCksIFwiZ2V0SW50ZXJmYWNlXCIpKGNvbnRyYWN0SW50ZXJmYWNlKSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzaWduZXJcIiwgc2lnbmVyIHx8IG51bGwpO1xuXHQgICAgfVxuXHQgICAgLy8gQFRPRE86IEZ1dHVyZTsgcmVuYW1lIHRvIHBvcHVsdGVUcmFuc2FjdGlvbj9cblx0ICAgIENvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuZ2V0RGVwbG95VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB0eCA9IHt9O1xuXHQgICAgICAgIC8vIElmIHdlIGhhdmUgMSBhZGRpdGlvbmFsIGFyZ3VtZW50LCB3ZSBhbGxvdyB0cmFuc2FjdGlvbiBvdmVycmlkZXNcblx0ICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoICsgMSAmJiB0eXBlb2YgKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICAgICAgdHggPSBsaWIkMy5zaGFsbG93Q29weShhcmdzLnBvcCgpKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHR4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWRUcmFuc2FjdGlvbktleXNba2V5XSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gdHJhbnNhY3Rpb24gb3ZlcnJpZGUgXCIgKyBrZXkpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIERvIG5vdCBhbGxvdyB0aGVzZSB0byBiZSBvdmVycmlkZGVuIGluIGEgZGVwbG95bWVudCB0cmFuc2FjdGlvblxuXHQgICAgICAgIFtcImRhdGFcIiwgXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIGlmICh0eFtrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBvdmVycmlkZSBcIiArIGtleSwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2FsbCBtYXRjaGVzIHRoZSBjb25zdHJ1Y3RvciBzaWduYXR1cmVcblx0ICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCwgXCIgaW4gQ29udHJhY3QgY29uc3RydWN0b3JcIik7XG5cdCAgICAgICAgLy8gU2V0IHRoZSBkYXRhIHRvIHRoZSBieXRlY29kZSArIHRoZSBlbmNvZGVkIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuXHQgICAgICAgIHR4LmRhdGEgPSBsaWIkMS5oZXhsaWZ5KGxpYiQxLmNvbmNhdChbXG5cdCAgICAgICAgICAgIHRoaXMuYnl0ZWNvZGUsXG5cdCAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShhcmdzKVxuXHQgICAgICAgIF0pKTtcblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LnByb3RvdHlwZS5kZXBsb3kgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG92ZXJyaWRlcywgcGFyYW1zLCB1bnNpZ25lZFR4LCB0eCwgYWRkcmVzcywgY29udHJhY3Q7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiAxIGV4dHJhIHBhcmFtZXRlciB3YXMgcGFzc2VkIGluLCBpdCBjb250YWlucyBvdmVycmlkZXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlcyA9IGFyZ3MucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYWxsIG1hdGNoZXMgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCwgXCIgaW4gQ29udHJhY3QgY29uc3RydWN0b3JcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc29sdmVBZGRyZXNzZXModGhpcy5zaWduZXIsIGFyZ3MsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnB1c2gob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdW5zaWduZWRUeCA9IHRoaXMuZ2V0RGVwbG95VHJhbnNhY3Rpb24uYXBwbHkodGhpcywgcGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHVuc2lnbmVkVHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gbGliJDMuZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RBZGRyZXNzXCIpKHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udHJhY3QgPSBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRDb250cmFjdFwiKShhZGRyZXNzLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShjb250cmFjdCwgXCJkZXBsb3lUcmFuc2FjdGlvblwiLCB0eCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjb250cmFjdF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMuY29uc3RydWN0b3IpLmdldENvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lcik7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHNpZ25lcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBzaWduZXIpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5mcm9tU29saWRpdHkgPSBmdW5jdGlvbiAoY29tcGlsZXJPdXRwdXQsIHNpZ25lcikge1xuXHQgICAgICAgIGlmIChjb21waWxlck91dHB1dCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBjb21waWxlciBvdXRwdXRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTUlTU0lOR19BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJjb21waWxlck91dHB1dFwiIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIChjb21waWxlck91dHB1dCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgY29tcGlsZXJPdXRwdXQgPSBKU09OLnBhcnNlKGNvbXBpbGVyT3V0cHV0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGFiaSA9IGNvbXBpbGVyT3V0cHV0LmFiaTtcblx0ICAgICAgICB2YXIgYnl0ZWNvZGUgPSBudWxsO1xuXHQgICAgICAgIGlmIChjb21waWxlck91dHB1dC5ieXRlY29kZSkge1xuXHQgICAgICAgICAgICBieXRlY29kZSA9IGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChjb21waWxlck91dHB1dC5ldm0gJiYgY29tcGlsZXJPdXRwdXQuZXZtLmJ5dGVjb2RlKSB7XG5cdCAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuZXZtLmJ5dGVjb2RlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IHRoaXMoYWJpLCBieXRlY29kZSwgc2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICBDb250cmFjdEZhY3RvcnkuZ2V0SW50ZXJmYWNlID0gZnVuY3Rpb24gKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG5cdCAgICAgICAgcmV0dXJuIENvbnRyYWN0LmdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSk7XG5cdCAgICB9O1xuXHQgICAgQ29udHJhY3RGYWN0b3J5LmdldENvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh0eCkge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3ModHgpO1xuXHQgICAgfTtcblx0ICAgIENvbnRyYWN0RmFjdG9yeS5nZXRDb250cmFjdCA9IGZ1bmN0aW9uIChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdChhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ29udHJhY3RGYWN0b3J5O1xuXHR9KCkpO1xuXHRleHBvcnRzLkNvbnRyYWN0RmFjdG9yeSA9IENvbnRyYWN0RmFjdG9yeTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkZCA9IHVud3JhcEV4cG9ydHMobGliJGQpO1xuXHR2YXIgbGliXzEkZCA9IGxpYiRkLkNvbnRyYWN0O1xuXHR2YXIgbGliXzIkYyA9IGxpYiRkLkNvbnRyYWN0RmFjdG9yeTtcblxuXHR2YXIgbGliJGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHQvKipcblx0ICogdmFyIGJhc2V4ID0gcmVxdWlyZShcImJhc2UteFwiKTtcblx0ICpcblx0ICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBoZWF2aWx5IGJhc2VkIG9uIGJhc2UteC4gVGhlIG1haW4gcmVhc29uIHRvXG5cdCAqIGRldmlhdGUgd2FzIHRvIHByZXZlbnQgdGhlIGRlcGVuZGVuY3kgb2YgQnVmZmVyLlxuXHQgKlxuXHQgKiBDb250cmlidXRvcnM6XG5cdCAqXG5cdCAqIGJhc2UteCBlbmNvZGluZ1xuXHQgKiBGb3JrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL2JzNThcblx0ICogT3JpZ2luYWxseSB3cml0dGVuIGJ5IE1pa2UgSGVhcm4gZm9yIEJpdGNvaW5KXG5cdCAqIENvcHlyaWdodCAoYykgMjAxMSBHb29nbGUgSW5jXG5cdCAqIFBvcnRlZCB0byBKYXZhU2NyaXB0IGJ5IFN0ZWZhbiBUaG9tYXNcblx0ICogTWVyZ2VkIEJ1ZmZlciByZWZhY3RvcmluZ3MgZnJvbSBiYXNlNTgtbmF0aXZlIGJ5IFN0ZXBoZW4gUGFpclxuXHQgKiBDb3B5cmlnaHQgKGMpIDIwMTMgQml0UGF5IEluY1xuXHQgKlxuXHQgKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblx0ICpcblx0ICogQ29weXJpZ2h0IGJhc2UteCBjb250cmlidXRvcnMgKGMpIDIwMTZcblx0ICpcblx0ICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcblx0ICogY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLFxuXHQgKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG5cdCAqIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLFxuXHQgKiBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcblx0ICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblx0ICpcblx0ICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cblx0ICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblx0ICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuXHQgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcblx0ICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5cdCAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcblx0ICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcblx0ICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuXHQgKiBJTiBUSEUgU09GVFdBUkUuXG5cdCAqXG5cdCAqL1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXHR2YXIgQmFzZVggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBCYXNlWChhbHBoYWJldCkge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxwaGFiZXRcIiwgYWxwaGFiZXQpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYmFzZVwiLCBhbHBoYWJldC5sZW5ndGgpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2FscGhhYmV0TWFwXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9sZWFkZXJcIiwgYWxwaGFiZXQuY2hhckF0KDApKTtcblx0ICAgICAgICAvLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2FscGhhYmV0TWFwW2FscGhhYmV0LmNoYXJBdChpKV0gPSBpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIEJhc2VYLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICB2YXIgc291cmNlID0gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIlwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGlnaXRzID0gWzBdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgKytpKSB7XG5cdCAgICAgICAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtpXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ICs9IGRpZ2l0c1tqXSA8PCA4O1xuXHQgICAgICAgICAgICAgICAgZGlnaXRzW2pdID0gY2FycnkgJSB0aGlzLmJhc2U7XG5cdCAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgdGhpcy5iYXNlKTtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gdGhpcy5iYXNlKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHN0cmluZyA9IFwiXCI7XG5cdCAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3Ncblx0ICAgICAgICBmb3IgKHZhciBrID0gMDsgc291cmNlW2tdID09PSAwICYmIGsgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytrKSB7XG5cdCAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLl9sZWFkZXI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG5cdCAgICAgICAgZm9yICh2YXIgcSA9IGRpZ2l0cy5sZW5ndGggLSAxOyBxID49IDA7IC0tcSkge1xuXHQgICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5hbHBoYWJldFtkaWdpdHNbcV1dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gc3RyaW5nO1xuXHQgICAgfTtcblx0ICAgIEJhc2VYLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGJ5dGVzID0gW107XG5cdCAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBieXRlcy5wdXNoKDApO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGJ5dGUgPSB0aGlzLl9hbHBoYWJldE1hcFt2YWx1ZVtpXV07XG5cdCAgICAgICAgICAgIGlmIChieXRlID09PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vbi1iYXNlXCIgKyB0aGlzLmJhc2UgKyBcIiBjaGFyYWN0ZXJcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGNhcnJ5ID0gYnl0ZTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBieXRlcy5sZW5ndGg7ICsraikge1xuXHQgICAgICAgICAgICAgICAgY2FycnkgKz0gYnl0ZXNbal0gKiB0aGlzLmJhc2U7XG5cdCAgICAgICAgICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcblx0ICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goY2FycnkgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgIGNhcnJ5ID4+PSA4O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIGRlYWwgd2l0aCBsZWFkaW5nIHplcm9zXG5cdCAgICAgICAgZm9yICh2YXIgayA9IDA7IHZhbHVlW2tdID09PSB0aGlzLl9sZWFkZXIgJiYgayA8IHZhbHVlLmxlbmd0aCAtIDE7ICsraykge1xuXHQgICAgICAgICAgICBieXRlcy5wdXNoKDApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoYnl0ZXMucmV2ZXJzZSgpKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEJhc2VYO1xuXHR9KCkpO1xuXHRleHBvcnRzLkJhc2VYID0gQmFzZVg7XG5cdHZhciBCYXNlMzIgPSBuZXcgQmFzZVgoXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejIzNDU2N1wiKTtcblx0ZXhwb3J0cy5CYXNlMzIgPSBCYXNlMzI7XG5cdHZhciBCYXNlNTggPSBuZXcgQmFzZVgoXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIpO1xuXHRleHBvcnRzLkJhc2U1OCA9IEJhc2U1ODtcblx0Ly9jb25zb2xlLmxvZyhCYXNlNTguZGVjb2RlKFwiUW1kMlY3NzdvNVh2SmJZTWVNYjhrMm5VNWY4ZDNjaVVRNVlwWXVXaHp2OGlEalwiKSlcblx0Ly9jb25zb2xlLmxvZyhCYXNlNTguZW5jb2RlKEJhc2U1OC5kZWNvZGUoXCJRbWQyVjc3N281WHZKYllNZU1iOGsyblU1ZjhkM2NpVVE1WXBZdVdoenY4aURqXCIpKSlcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkZSA9IHVud3JhcEV4cG9ydHMobGliJGUpO1xuXHR2YXIgbGliXzEkZSA9IGxpYiRlLkJhc2VYO1xuXHR2YXIgbGliXzIkZCA9IGxpYiRlLkJhc2UzMjtcblx0dmFyIGxpYl8zJGEgPSBsaWIkZS5CYXNlNTg7XG5cblx0dmFyIG1pbmltYWxpc3RpY0Fzc2VydCA9IGFzc2VydDtcblxuXHRmdW5jdGlvbiBhc3NlcnQodmFsLCBtc2cpIHtcblx0ICBpZiAoIXZhbClcblx0ICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcblx0fVxuXG5cdGFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuXHQgIGlmIChsICE9IHIpXG5cdCAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICgnQXNzZXJ0aW9uIGZhaWxlZDogJyArIGwgKyAnICE9ICcgKyByKSk7XG5cdH07XG5cblx0dmFyIGluaGVyaXRzX2Jyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5cdGlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG5cdCAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcblx0ICAgIGlmIChzdXBlckN0b3IpIHtcblx0ICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG5cdCAgICAgICAgY29uc3RydWN0b3I6IHtcblx0ICAgICAgICAgIHZhbHVlOiBjdG9yLFxuXHQgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG5cdCAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcblx0ICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgICAgIH1cblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfTtcblx0fSBlbHNlIHtcblx0ICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuXHQgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG5cdCAgICBpZiAoc3VwZXJDdG9yKSB7XG5cdCAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuXHQgICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZTtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcblx0ICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuXHQgICAgfVxuXHQgIH07XG5cdH1cblx0fSk7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdHZhciBpbmhlcml0c18xID0gaW5oZXJpdHNfYnJvd3NlcjtcblxuXHRmdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG5cdCAgaWYgKEFycmF5LmlzQXJyYXkobXNnKSlcblx0ICAgIHJldHVybiBtc2cuc2xpY2UoKTtcblx0ICBpZiAoIW1zZylcblx0ICAgIHJldHVybiBbXTtcblx0ICB2YXIgcmVzID0gW107XG5cdCAgaWYgKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG5cdCAgICBpZiAoIWVuYykge1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgICAgdmFyIGhpID0gYyA+PiA4O1xuXHQgICAgICAgIHZhciBsbyA9IGMgJiAweGZmO1xuXHQgICAgICAgIGlmIChoaSlcblx0ICAgICAgICAgIHJlcy5wdXNoKGhpLCBsbyk7XG5cdCAgICAgICAgZWxzZVxuXHQgICAgICAgICAgcmVzLnB1c2gobG8pO1xuXHQgICAgICB9XG5cdCAgICB9IGVsc2UgaWYgKGVuYyA9PT0gJ2hleCcpIHtcblx0ICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcblx0ICAgICAgaWYgKG1zZy5sZW5ndGggJSAyICE9PSAwKVxuXHQgICAgICAgIG1zZyA9ICcwJyArIG1zZztcblx0ICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcblx0ICAgICAgICByZXMucHVzaChwYXJzZUludChtc2dbaV0gKyBtc2dbaSArIDFdLCAxNikpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBmb3IgKGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuXHQgICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciB0b0FycmF5XzEgPSB0b0FycmF5O1xuXG5cdGZ1bmN0aW9uIHRvSGV4KG1zZykge1xuXHQgIHZhciByZXMgPSAnJztcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcblx0ICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciB0b0hleF8xID0gdG9IZXg7XG5cblx0ZnVuY3Rpb24gaHRvbmwodykge1xuXHQgIHZhciByZXMgPSAodyA+Pj4gMjQpIHxcblx0ICAgICAgICAgICAgKCh3ID4+PiA4KSAmIDB4ZmYwMCkgfFxuXHQgICAgICAgICAgICAoKHcgPDwgOCkgJiAweGZmMDAwMCkgfFxuXHQgICAgICAgICAgICAoKHcgJiAweGZmKSA8PCAyNCk7XG5cdCAgcmV0dXJuIHJlcyA+Pj4gMDtcblx0fVxuXHR2YXIgaHRvbmxfMSA9IGh0b25sO1xuXG5cdGZ1bmN0aW9uIHRvSGV4MzIobXNnLCBlbmRpYW4pIHtcblx0ICB2YXIgcmVzID0gJyc7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciB3ID0gbXNnW2ldO1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2xpdHRsZScpXG5cdCAgICAgIHcgPSBodG9ubCh3KTtcblx0ICAgIHJlcyArPSB6ZXJvOCh3LnRvU3RyaW5nKDE2KSk7XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dmFyIHRvSGV4MzJfMSA9IHRvSGV4MzI7XG5cblx0ZnVuY3Rpb24gemVybzIod29yZCkge1xuXHQgIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcblx0ICAgIHJldHVybiAnMCcgKyB3b3JkO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB3b3JkO1xuXHR9XG5cdHZhciB6ZXJvMl8xID0gemVybzI7XG5cblx0ZnVuY3Rpb24gemVybzgod29yZCkge1xuXHQgIGlmICh3b3JkLmxlbmd0aCA9PT0gNylcblx0ICAgIHJldHVybiAnMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA2KVxuXHQgICAgcmV0dXJuICcwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSA1KVxuXHQgICAgcmV0dXJuICcwMDAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNClcblx0ICAgIHJldHVybiAnMDAwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAzKVxuXHQgICAgcmV0dXJuICcwMDAwMCcgKyB3b3JkO1xuXHQgIGVsc2UgaWYgKHdvcmQubGVuZ3RoID09PSAyKVxuXHQgICAgcmV0dXJuICcwMDAwMDAnICsgd29yZDtcblx0ICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcblx0ICAgIHJldHVybiAnMDAwMDAwMCcgKyB3b3JkO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB3b3JkO1xuXHR9XG5cdHZhciB6ZXJvOF8xID0gemVybzg7XG5cblx0ZnVuY3Rpb24gam9pbjMyKG1zZywgc3RhcnQsIGVuZCwgZW5kaWFuKSB7XG5cdCAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuXHQgIG1pbmltYWxpc3RpY0Fzc2VydChsZW4gJSA0ID09PSAwKTtcblx0ICB2YXIgcmVzID0gbmV3IEFycmF5KGxlbiAvIDQpO1xuXHQgIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuXHQgICAgdmFyIHc7XG5cdCAgICBpZiAoZW5kaWFuID09PSAnYmlnJylcblx0ICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuXHQgICAgZWxzZVxuXHQgICAgICB3ID0gKG1zZ1trICsgM10gPDwgMjQpIHwgKG1zZ1trICsgMl0gPDwgMTYpIHwgKG1zZ1trICsgMV0gPDwgOCkgfCBtc2dba107XG5cdCAgICByZXNbaV0gPSB3ID4+PiAwO1xuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHZhciBqb2luMzJfMSA9IGpvaW4zMjtcblxuXHRmdW5jdGlvbiBzcGxpdDMyKG1zZywgZW5kaWFuKSB7XG5cdCAgdmFyIHJlcyA9IG5ldyBBcnJheShtc2cubGVuZ3RoICogNCk7XG5cdCAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcblx0ICAgIHZhciBtID0gbXNnW2ldO1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2JpZycpIHtcblx0ICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG5cdCAgICAgIHJlc1trICsgMV0gPSAobSA+Pj4gMTYpICYgMHhmZjtcblx0ICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiA4KSAmIDB4ZmY7XG5cdCAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlc1trICsgM10gPSBtID4+PiAyNDtcblx0ICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuXHQgICAgICByZXNbayArIDFdID0gKG0gPj4+IDgpICYgMHhmZjtcblx0ICAgICAgcmVzW2tdID0gbSAmIDB4ZmY7XG5cdCAgICB9XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH1cblx0dmFyIHNwbGl0MzJfMSA9IHNwbGl0MzI7XG5cblx0ZnVuY3Rpb24gcm90cjMyKHcsIGIpIHtcblx0ICByZXR1cm4gKHcgPj4+IGIpIHwgKHcgPDwgKDMyIC0gYikpO1xuXHR9XG5cdHZhciByb3RyMzJfMSA9IHJvdHIzMjtcblxuXHRmdW5jdGlvbiByb3RsMzIodywgYikge1xuXHQgIHJldHVybiAodyA8PCBiKSB8ICh3ID4+PiAoMzIgLSBiKSk7XG5cdH1cblx0dmFyIHJvdGwzMl8xID0gcm90bDMyO1xuXG5cdGZ1bmN0aW9uIHN1bTMyKGEsIGIpIHtcblx0ICByZXR1cm4gKGEgKyBiKSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtMzJfMSA9IHN1bTMyO1xuXG5cdGZ1bmN0aW9uIHN1bTMyXzMoYSwgYiwgYykge1xuXHQgIHJldHVybiAoYSArIGIgKyBjKSA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtMzJfM18xID0gc3VtMzJfMztcblxuXHRmdW5jdGlvbiBzdW0zMl80KGEsIGIsIGMsIGQpIHtcblx0ICByZXR1cm4gKGEgKyBiICsgYyArIGQpID4+PiAwO1xuXHR9XG5cdHZhciBzdW0zMl80XzEgPSBzdW0zMl80O1xuXG5cdGZ1bmN0aW9uIHN1bTMyXzUoYSwgYiwgYywgZCwgZSkge1xuXHQgIHJldHVybiAoYSArIGIgKyBjICsgZCArIGUpID4+PiAwO1xuXHR9XG5cdHZhciBzdW0zMl81XzEgPSBzdW0zMl81O1xuXG5cdGZ1bmN0aW9uIHN1bTY0KGJ1ZiwgcG9zLCBhaCwgYWwpIHtcblx0ICB2YXIgYmggPSBidWZbcG9zXTtcblx0ICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cblx0ICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG5cdCAgdmFyIGhpID0gKGxvIDwgYWwgPyAxIDogMCkgKyBhaCArIGJoO1xuXHQgIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG5cdCAgYnVmW3BvcyArIDFdID0gbG87XG5cdH1cblx0dmFyIHN1bTY0XzEgPSBzdW02NDtcblxuXHRmdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuXHQgIHZhciBsbyA9IChhbCArIGJsKSA+Pj4gMDtcblx0ICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG5cdCAgcmV0dXJuIGhpID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF9oaV8xID0gc3VtNjRfaGk7XG5cblx0ZnVuY3Rpb24gc3VtNjRfbG8oYWgsIGFsLCBiaCwgYmwpIHtcblx0ICB2YXIgbG8gPSBhbCArIGJsO1xuXHQgIHJldHVybiBsbyA+Pj4gMDtcblx0fVxuXHR2YXIgc3VtNjRfbG9fMSA9IHN1bTY0X2xvO1xuXG5cdGZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG5cdCAgdmFyIGNhcnJ5ID0gMDtcblx0ICB2YXIgbG8gPSBhbDtcblx0ICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGFsID8gMSA6IDA7XG5cdCAgbG8gPSAobG8gKyBjbCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuXHQgIGxvID0gKGxvICsgZGwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgZGwgPyAxIDogMDtcblxuXHQgIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG5cdCAgcmV0dXJuIGhpID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF80X2hpXzEgPSBzdW02NF80X2hpO1xuXG5cdGZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG5cdCAgdmFyIGxvID0gYWwgKyBibCArIGNsICsgZGw7XG5cdCAgcmV0dXJuIGxvID4+PiAwO1xuXHR9XG5cdHZhciBzdW02NF80X2xvXzEgPSBzdW02NF80X2xvO1xuXG5cdGZ1bmN0aW9uIHN1bTY0XzVfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsLCBlaCwgZWwpIHtcblx0ICB2YXIgY2FycnkgPSAwO1xuXHQgIHZhciBsbyA9IGFsO1xuXHQgIGxvID0gKGxvICsgYmwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgYWwgPyAxIDogMDtcblx0ICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcblx0ICBjYXJyeSArPSBsbyA8IGNsID8gMSA6IDA7XG5cdCAgbG8gPSAobG8gKyBkbCkgPj4+IDA7XG5cdCAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXHQgIGxvID0gKGxvICsgZWwpID4+PiAwO1xuXHQgIGNhcnJ5ICs9IGxvIDwgZWwgPyAxIDogMDtcblxuXHQgIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcblx0ICByZXR1cm4gaGkgPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0XzVfaGlfMSA9IHN1bTY0XzVfaGk7XG5cblx0ZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuXHQgIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsICsgZWw7XG5cblx0ICByZXR1cm4gbG8gPj4+IDA7XG5cdH1cblx0dmFyIHN1bTY0XzVfbG9fMSA9IHN1bTY0XzVfbG87XG5cblx0ZnVuY3Rpb24gcm90cjY0X2hpKGFoLCBhbCwgbnVtKSB7XG5cdCAgdmFyIHIgPSAoYWwgPDwgKDMyIC0gbnVtKSkgfCAoYWggPj4+IG51bSk7XG5cdCAgcmV0dXJuIHIgPj4+IDA7XG5cdH1cblx0dmFyIHJvdHI2NF9oaV8xID0gcm90cjY0X2hpO1xuXG5cdGZ1bmN0aW9uIHJvdHI2NF9sbyhhaCwgYWwsIG51bSkge1xuXHQgIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuXHQgIHJldHVybiByID4+PiAwO1xuXHR9XG5cdHZhciByb3RyNjRfbG9fMSA9IHJvdHI2NF9sbztcblxuXHRmdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuXHQgIHJldHVybiBhaCA+Pj4gbnVtO1xuXHR9XG5cdHZhciBzaHI2NF9oaV8xID0gc2hyNjRfaGk7XG5cblx0ZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcblx0ICB2YXIgciA9IChhaCA8PCAoMzIgLSBudW0pKSB8IChhbCA+Pj4gbnVtKTtcblx0ICByZXR1cm4gciA+Pj4gMDtcblx0fVxuXHR2YXIgc2hyNjRfbG9fMSA9IHNocjY0X2xvO1xuXG5cdHZhciB1dGlscyA9IHtcblx0XHRpbmhlcml0czogaW5oZXJpdHNfMSxcblx0XHR0b0FycmF5OiB0b0FycmF5XzEsXG5cdFx0dG9IZXg6IHRvSGV4XzEsXG5cdFx0aHRvbmw6IGh0b25sXzEsXG5cdFx0dG9IZXgzMjogdG9IZXgzMl8xLFxuXHRcdHplcm8yOiB6ZXJvMl8xLFxuXHRcdHplcm84OiB6ZXJvOF8xLFxuXHRcdGpvaW4zMjogam9pbjMyXzEsXG5cdFx0c3BsaXQzMjogc3BsaXQzMl8xLFxuXHRcdHJvdHIzMjogcm90cjMyXzEsXG5cdFx0cm90bDMyOiByb3RsMzJfMSxcblx0XHRzdW0zMjogc3VtMzJfMSxcblx0XHRzdW0zMl8zOiBzdW0zMl8zXzEsXG5cdFx0c3VtMzJfNDogc3VtMzJfNF8xLFxuXHRcdHN1bTMyXzU6IHN1bTMyXzVfMSxcblx0XHRzdW02NDogc3VtNjRfMSxcblx0XHRzdW02NF9oaTogc3VtNjRfaGlfMSxcblx0XHRzdW02NF9sbzogc3VtNjRfbG9fMSxcblx0XHRzdW02NF80X2hpOiBzdW02NF80X2hpXzEsXG5cdFx0c3VtNjRfNF9sbzogc3VtNjRfNF9sb18xLFxuXHRcdHN1bTY0XzVfaGk6IHN1bTY0XzVfaGlfMSxcblx0XHRzdW02NF81X2xvOiBzdW02NF81X2xvXzEsXG5cdFx0cm90cjY0X2hpOiByb3RyNjRfaGlfMSxcblx0XHRyb3RyNjRfbG86IHJvdHI2NF9sb18xLFxuXHRcdHNocjY0X2hpOiBzaHI2NF9oaV8xLFxuXHRcdHNocjY0X2xvOiBzaHI2NF9sb18xXG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdGZ1bmN0aW9uIEJsb2NrSGFzaCgpIHtcblx0ICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXHQgIHRoaXMucGVuZGluZ1RvdGFsID0gMDtcblx0ICB0aGlzLmJsb2NrU2l6ZSA9IHRoaXMuY29uc3RydWN0b3IuYmxvY2tTaXplO1xuXHQgIHRoaXMub3V0U2l6ZSA9IHRoaXMuY29uc3RydWN0b3Iub3V0U2l6ZTtcblx0ICB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoO1xuXHQgIHRoaXMucGFkTGVuZ3RoID0gdGhpcy5jb25zdHJ1Y3Rvci5wYWRMZW5ndGggLyA4O1xuXHQgIHRoaXMuZW5kaWFuID0gJ2JpZyc7XG5cblx0ICB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDg7XG5cdCAgdGhpcy5fZGVsdGEzMiA9IHRoaXMuYmxvY2tTaXplIC8gMzI7XG5cdH1cblx0dmFyIEJsb2NrSGFzaF8xID0gQmxvY2tIYXNoO1xuXG5cdEJsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG5cdCAgLy8gQ29udmVydCBtZXNzYWdlIHRvIGFycmF5LCBwYWQgaXQsIGFuZCBqb2luIGludG8gMzJiaXQgYmxvY2tzXG5cdCAgbXNnID0gdXRpbHMudG9BcnJheShtc2csIGVuYyk7XG5cdCAgaWYgKCF0aGlzLnBlbmRpbmcpXG5cdCAgICB0aGlzLnBlbmRpbmcgPSBtc2c7XG5cdCAgZWxzZVxuXHQgICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuXHQgIHRoaXMucGVuZGluZ1RvdGFsICs9IG1zZy5sZW5ndGg7XG5cblx0ICAvLyBFbm91Z2ggZGF0YSwgdHJ5IHVwZGF0aW5nXG5cdCAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG5cdCAgICBtc2cgPSB0aGlzLnBlbmRpbmc7XG5cblx0ICAgIC8vIFByb2Nlc3MgcGVuZGluZyBkYXRhIGluIGJsb2Nrc1xuXHQgICAgdmFyIHIgPSBtc2cubGVuZ3RoICUgdGhpcy5fZGVsdGE4O1xuXHQgICAgdGhpcy5wZW5kaW5nID0gbXNnLnNsaWNlKG1zZy5sZW5ndGggLSByLCBtc2cubGVuZ3RoKTtcblx0ICAgIGlmICh0aGlzLnBlbmRpbmcubGVuZ3RoID09PSAwKVxuXHQgICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG5cdCAgICBtc2cgPSB1dGlscy5qb2luMzIobXNnLCAwLCBtc2cubGVuZ3RoIC0gciwgdGhpcy5lbmRpYW4pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IHRoaXMuX2RlbHRhMzIpXG5cdCAgICAgIHRoaXMuX3VwZGF0ZShtc2csIGksIGkgKyB0aGlzLl9kZWx0YTMyKTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRCbG9ja0hhc2gucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICB0aGlzLnVwZGF0ZSh0aGlzLl9wYWQoKSk7XG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG5cblx0ICByZXR1cm4gdGhpcy5fZGlnZXN0KGVuYyk7XG5cdH07XG5cblx0QmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuXHQgIHZhciBsZW4gPSB0aGlzLnBlbmRpbmdUb3RhbDtcblx0ICB2YXIgYnl0ZXMgPSB0aGlzLl9kZWx0YTg7XG5cdCAgdmFyIGsgPSBieXRlcyAtICgobGVuICsgdGhpcy5wYWRMZW5ndGgpICUgYnl0ZXMpO1xuXHQgIHZhciByZXMgPSBuZXcgQXJyYXkoayArIHRoaXMucGFkTGVuZ3RoKTtcblx0ICByZXNbMF0gPSAweDgwO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgazsgaSsrKVxuXHQgICAgcmVzW2ldID0gMDtcblxuXHQgIC8vIEFwcGVuZCBsZW5ndGhcblx0ICBsZW4gPDw9IDM7XG5cdCAgaWYgKHRoaXMuZW5kaWFuID09PSAnYmlnJykge1xuXHQgICAgZm9yICh2YXIgdCA9IDg7IHQgPCB0aGlzLnBhZExlbmd0aDsgdCsrKVxuXHQgICAgICByZXNbaSsrXSA9IDA7XG5cblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuXHQgICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuXHQgIH0gZWxzZSB7XG5cdCAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG5cdCAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMjQpICYgMHhmZjtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblx0ICAgIHJlc1tpKytdID0gMDtcblxuXHQgICAgZm9yICh0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG5cdCAgICAgIHJlc1tpKytdID0gMDtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzO1xuXHR9O1xuXG5cdHZhciBjb21tb24gPSB7XG5cdFx0QmxvY2tIYXNoOiBCbG9ja0hhc2hfMVxuXHR9O1xuXG5cdHZhciBfMSA9IHt9O1xuXG5cdHZhciBfMjI0ID0ge307XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblx0dmFyIHJvdHIzMiQxID0gdXRpbHMucm90cjMyO1xuXG5cdGZ1bmN0aW9uIGZ0XzEocywgeCwgeSwgeikge1xuXHQgIGlmIChzID09PSAwKVxuXHQgICAgcmV0dXJuIGNoMzIoeCwgeSwgeik7XG5cdCAgaWYgKHMgPT09IDEgfHwgcyA9PT0gMylcblx0ICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG5cdCAgaWYgKHMgPT09IDIpXG5cdCAgICByZXR1cm4gbWFqMzIoeCwgeSwgeik7XG5cdH1cblx0dmFyIGZ0XzFfMSA9IGZ0XzE7XG5cblx0ZnVuY3Rpb24gY2gzMih4LCB5LCB6KSB7XG5cdCAgcmV0dXJuICh4ICYgeSkgXiAoKH54KSAmIHopO1xuXHR9XG5cdHZhciBjaDMyXzEgPSBjaDMyO1xuXG5cdGZ1bmN0aW9uIG1hajMyKHgsIHksIHopIHtcblx0ICByZXR1cm4gKHggJiB5KSBeICh4ICYgeikgXiAoeSAmIHopO1xuXHR9XG5cdHZhciBtYWozMl8xID0gbWFqMzI7XG5cblx0ZnVuY3Rpb24gcDMyKHgsIHksIHopIHtcblx0ICByZXR1cm4geCBeIHkgXiB6O1xuXHR9XG5cdHZhciBwMzJfMSA9IHAzMjtcblxuXHRmdW5jdGlvbiBzMF8yNTYoeCkge1xuXHQgIHJldHVybiByb3RyMzIkMSh4LCAyKSBeIHJvdHIzMiQxKHgsIDEzKSBeIHJvdHIzMiQxKHgsIDIyKTtcblx0fVxuXHR2YXIgczBfMjU2XzEgPSBzMF8yNTY7XG5cblx0ZnVuY3Rpb24gczFfMjU2KHgpIHtcblx0ICByZXR1cm4gcm90cjMyJDEoeCwgNikgXiByb3RyMzIkMSh4LCAxMSkgXiByb3RyMzIkMSh4LCAyNSk7XG5cdH1cblx0dmFyIHMxXzI1Nl8xID0gczFfMjU2O1xuXG5cdGZ1bmN0aW9uIGcwXzI1Nih4KSB7XG5cdCAgcmV0dXJuIHJvdHIzMiQxKHgsIDcpIF4gcm90cjMyJDEoeCwgMTgpIF4gKHggPj4+IDMpO1xuXHR9XG5cdHZhciBnMF8yNTZfMSA9IGcwXzI1NjtcblxuXHRmdW5jdGlvbiBnMV8yNTYoeCkge1xuXHQgIHJldHVybiByb3RyMzIkMSh4LCAxNykgXiByb3RyMzIkMSh4LCAxOSkgXiAoeCA+Pj4gMTApO1xuXHR9XG5cdHZhciBnMV8yNTZfMSA9IGcxXzI1NjtcblxuXHR2YXIgY29tbW9uJDEgPSB7XG5cdFx0ZnRfMTogZnRfMV8xLFxuXHRcdGNoMzI6IGNoMzJfMSxcblx0XHRtYWozMjogbWFqMzJfMSxcblx0XHRwMzI6IHAzMl8xLFxuXHRcdHMwXzI1NjogczBfMjU2XzEsXG5cdFx0czFfMjU2OiBzMV8yNTZfMSxcblx0XHRnMF8yNTY6IGcwXzI1Nl8xLFxuXHRcdGcxXzI1NjogZzFfMjU2XzFcblx0fTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXG5cdHZhciBzdW0zMiQxID0gdXRpbHMuc3VtMzI7XG5cdHZhciBzdW0zMl80JDEgPSB1dGlscy5zdW0zMl80O1xuXHR2YXIgc3VtMzJfNSQxID0gdXRpbHMuc3VtMzJfNTtcblx0dmFyIGNoMzIkMSA9IGNvbW1vbiQxLmNoMzI7XG5cdHZhciBtYWozMiQxID0gY29tbW9uJDEubWFqMzI7XG5cdHZhciBzMF8yNTYkMSA9IGNvbW1vbiQxLnMwXzI1Njtcblx0dmFyIHMxXzI1NiQxID0gY29tbW9uJDEuczFfMjU2O1xuXHR2YXIgZzBfMjU2JDEgPSBjb21tb24kMS5nMF8yNTY7XG5cdHZhciBnMV8yNTYkMSA9IGNvbW1vbiQxLmcxXzI1NjtcblxuXHR2YXIgQmxvY2tIYXNoJDEgPSBjb21tb24uQmxvY2tIYXNoO1xuXG5cdHZhciBzaGEyNTZfSyA9IFtcblx0ICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LFxuXHQgIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG5cdCAgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSwgMHgyNDMxODViZSwgMHg1NTBjN2RjMyxcblx0ICAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuXHQgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG5cdCAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcblx0ICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LFxuXHQgIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG5cdCAgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYywgMHg1MzM4MGQxMyxcblx0ICAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuXHQgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG5cdCAgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcblx0ICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LFxuXHQgIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG5cdCAgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcblx0ICAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5cdF07XG5cblx0ZnVuY3Rpb24gU0hBMjU2KCkge1xuXHQgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEyNTYpKVxuXHQgICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuXHQgIEJsb2NrSGFzaCQxLmNhbGwodGhpcyk7XG5cdCAgdGhpcy5oID0gW1xuXHQgICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSxcblx0ICAgIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcblx0ICBdO1xuXHQgIHRoaXMuayA9IHNoYTI1Nl9LO1xuXHQgIHRoaXMuVyA9IG5ldyBBcnJheSg2NCk7XG5cdH1cblx0dXRpbHMuaW5oZXJpdHMoU0hBMjU2LCBCbG9ja0hhc2gkMSk7XG5cdHZhciBfMjU2ID0gU0hBMjU2O1xuXG5cdFNIQTI1Ni5ibG9ja1NpemUgPSA1MTI7XG5cdFNIQTI1Ni5vdXRTaXplID0gMjU2O1xuXHRTSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuXHRTSEEyNTYucGFkTGVuZ3RoID0gNjQ7XG5cblx0U0hBMjU2LnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG5cdCAgdmFyIFcgPSB0aGlzLlc7XG5cblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspXG5cdCAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG5cdCAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuXHQgICAgV1tpXSA9IHN1bTMyXzQkMShnMV8yNTYkMShXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYkMShXW2kgLSAxNV0pLCBXW2kgLSAxNl0pO1xuXG5cdCAgdmFyIGEgPSB0aGlzLmhbMF07XG5cdCAgdmFyIGIgPSB0aGlzLmhbMV07XG5cdCAgdmFyIGMgPSB0aGlzLmhbMl07XG5cdCAgdmFyIGQgPSB0aGlzLmhbM107XG5cdCAgdmFyIGUgPSB0aGlzLmhbNF07XG5cdCAgdmFyIGYgPSB0aGlzLmhbNV07XG5cdCAgdmFyIGcgPSB0aGlzLmhbNl07XG5cdCAgdmFyIGggPSB0aGlzLmhbN107XG5cblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQodGhpcy5rLmxlbmd0aCA9PT0gVy5sZW5ndGgpO1xuXHQgIGZvciAoaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgVDEgPSBzdW0zMl81JDEoaCwgczFfMjU2JDEoZSksIGNoMzIkMShlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcblx0ICAgIHZhciBUMiA9IHN1bTMyJDEoczBfMjU2JDEoYSksIG1hajMyJDEoYSwgYiwgYykpO1xuXHQgICAgaCA9IGc7XG5cdCAgICBnID0gZjtcblx0ICAgIGYgPSBlO1xuXHQgICAgZSA9IHN1bTMyJDEoZCwgVDEpO1xuXHQgICAgZCA9IGM7XG5cdCAgICBjID0gYjtcblx0ICAgIGIgPSBhO1xuXHQgICAgYSA9IHN1bTMyJDEoVDEsIFQyKTtcblx0ICB9XG5cblx0ICB0aGlzLmhbMF0gPSBzdW0zMiQxKHRoaXMuaFswXSwgYSk7XG5cdCAgdGhpcy5oWzFdID0gc3VtMzIkMSh0aGlzLmhbMV0sIGIpO1xuXHQgIHRoaXMuaFsyXSA9IHN1bTMyJDEodGhpcy5oWzJdLCBjKTtcblx0ICB0aGlzLmhbM10gPSBzdW0zMiQxKHRoaXMuaFszXSwgZCk7XG5cdCAgdGhpcy5oWzRdID0gc3VtMzIkMSh0aGlzLmhbNF0sIGUpO1xuXHQgIHRoaXMuaFs1XSA9IHN1bTMyJDEodGhpcy5oWzVdLCBmKTtcblx0ICB0aGlzLmhbNl0gPSBzdW0zMiQxKHRoaXMuaFs2XSwgZyk7XG5cdCAgdGhpcy5oWzddID0gc3VtMzIkMSh0aGlzLmhbN10sIGgpO1xuXHR9O1xuXG5cdFNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xuXHR9O1xuXG5cdHZhciBfMzg0ID0ge307XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblx0dmFyIHJvdHI2NF9oaSQxID0gdXRpbHMucm90cjY0X2hpO1xuXHR2YXIgcm90cjY0X2xvJDEgPSB1dGlscy5yb3RyNjRfbG87XG5cdHZhciBzaHI2NF9oaSQxID0gdXRpbHMuc2hyNjRfaGk7XG5cdHZhciBzaHI2NF9sbyQxID0gdXRpbHMuc2hyNjRfbG87XG5cdHZhciBzdW02NCQxID0gdXRpbHMuc3VtNjQ7XG5cdHZhciBzdW02NF9oaSQxID0gdXRpbHMuc3VtNjRfaGk7XG5cdHZhciBzdW02NF9sbyQxID0gdXRpbHMuc3VtNjRfbG87XG5cdHZhciBzdW02NF80X2hpJDEgPSB1dGlscy5zdW02NF80X2hpO1xuXHR2YXIgc3VtNjRfNF9sbyQxID0gdXRpbHMuc3VtNjRfNF9sbztcblx0dmFyIHN1bTY0XzVfaGkkMSA9IHV0aWxzLnN1bTY0XzVfaGk7XG5cdHZhciBzdW02NF81X2xvJDEgPSB1dGlscy5zdW02NF81X2xvO1xuXG5cdHZhciBCbG9ja0hhc2gkMiA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cblx0dmFyIHNoYTUxMl9LID0gW1xuXHQgIDB4NDI4YTJmOTgsIDB4ZDcyOGFlMjIsIDB4NzEzNzQ0OTEsIDB4MjNlZjY1Y2QsXG5cdCAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcblx0ICAweDM5NTZjMjViLCAweGYzNDhiNTM4LCAweDU5ZjExMWYxLCAweGI2MDVkMDE5LFxuXHQgIDB4OTIzZjgyYTQsIDB4YWYxOTRmOWIsIDB4YWIxYzVlZDUsIDB4ZGE2ZDgxMTgsXG5cdCAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcblx0ICAweDI0MzE4NWJlLCAweDRlZTRiMjhjLCAweDU1MGM3ZGMzLCAweGQ1ZmZiNGUyLFxuXHQgIDB4NzJiZTVkNzQsIDB4ZjI3Yjg5NmYsIDB4ODBkZWIxZmUsIDB4M2IxNjk2YjEsXG5cdCAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcblx0ICAweGU0OWI2OWMxLCAweDllZjE0YWQyLCAweGVmYmU0Nzg2LCAweDM4NGYyNWUzLFxuXHQgIDB4MGZjMTlkYzYsIDB4OGI4Y2Q1YjUsIDB4MjQwY2ExY2MsIDB4NzdhYzljNjUsXG5cdCAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4Myxcblx0ICAweDVjYjBhOWRjLCAweGJkNDFmYmQ0LCAweDc2Zjk4OGRhLCAweDgzMTE1M2I1LFxuXHQgIDB4OTgzZTUxNTIsIDB4ZWU2NmRmYWIsIDB4YTgzMWM2NmQsIDB4MmRiNDMyMTAsXG5cdCAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcblx0ICAweGM2ZTAwYmYzLCAweDNkYTg4ZmMyLCAweGQ1YTc5MTQ3LCAweDkzMGFhNzI1LFxuXHQgIDB4MDZjYTYzNTEsIDB4ZTAwMzgyNmYsIDB4MTQyOTI5NjcsIDB4MGEwZTZlNzAsXG5cdCAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcblx0ICAweDRkMmM2ZGZjLCAweDVhYzQyYWVkLCAweDUzMzgwZDEzLCAweDlkOTViM2RmLFxuXHQgIDB4NjUwYTczNTQsIDB4OGJhZjYzZGUsIDB4NzY2YTBhYmIsIDB4M2M3N2IyYTgsXG5cdCAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcblx0ICAweGEyYmZlOGExLCAweDRjZjEwMzY0LCAweGE4MWE2NjRiLCAweGJjNDIzMDAxLFxuXHQgIDB4YzI0YjhiNzAsIDB4ZDBmODk3OTEsIDB4Yzc2YzUxYTMsIDB4MDY1NGJlMzAsXG5cdCAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcblx0ICAweGY0MGUzNTg1LCAweDU3NzEyMDJhLCAweDEwNmFhMDcwLCAweDMyYmJkMWI4LFxuXHQgIDB4MTlhNGMxMTYsIDB4YjhkMmQwYzgsIDB4MWUzNzZjMDgsIDB4NTE0MWFiNTMsXG5cdCAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcblx0ICAweDM5MWMwY2IzLCAweGM1Yzk1YTYzLCAweDRlZDhhYTRhLCAweGUzNDE4YWNiLFxuXHQgIDB4NWI5Y2NhNGYsIDB4Nzc2M2UzNzMsIDB4NjgyZTZmZjMsIDB4ZDZiMmI4YTMsXG5cdCAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcblx0ICAweDg0Yzg3ODE0LCAweGExZjBhYjcyLCAweDhjYzcwMjA4LCAweDFhNjQzOWVjLFxuXHQgIDB4OTBiZWZmZmEsIDB4MjM2MzFlMjgsIDB4YTQ1MDZjZWIsIDB4ZGU4MmJkZTksXG5cdCAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcblx0ICAweGNhMjczZWNlLCAweGVhMjY2MTljLCAweGQxODZiOGM3LCAweDIxYzBjMjA3LFxuXHQgIDB4ZWFkYTdkZDYsIDB4Y2RlMGViMWUsIDB4ZjU3ZDRmN2YsIDB4ZWU2ZWQxNzgsXG5cdCAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcblx0ICAweDExM2Y5ODA0LCAweGJlZjkwZGFlLCAweDFiNzEwYjM1LCAweDEzMWM0NzFiLFxuXHQgIDB4MjhkYjc3ZjUsIDB4MjMwNDdkODQsIDB4MzJjYWFiN2IsIDB4NDBjNzI0OTMsXG5cdCAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0Yyxcblx0ICAweDRjYzVkNGJlLCAweGNiM2U0MmI2LCAweDU5N2YyOTljLCAweGZjNjU3ZTJhLFxuXHQgIDB4NWZjYjZmYWIsIDB4M2FkNmZhZWMsIDB4NmM0NDE5OGMsIDB4NGE0NzU4MTdcblx0XTtcblxuXHRmdW5jdGlvbiBTSEE1MTIoKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTUxMikpXG5cdCAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG5cdCAgQmxvY2tIYXNoJDIuY2FsbCh0aGlzKTtcblx0ICB0aGlzLmggPSBbXG5cdCAgICAweDZhMDllNjY3LCAweGYzYmNjOTA4LFxuXHQgICAgMHhiYjY3YWU4NSwgMHg4NGNhYTczYixcblx0ICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG5cdCAgICAweGE1NGZmNTNhLCAweDVmMWQzNmYxLFxuXHQgICAgMHg1MTBlNTI3ZiwgMHhhZGU2ODJkMSxcblx0ICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG5cdCAgICAweDFmODNkOWFiLCAweGZiNDFiZDZiLFxuXHQgICAgMHg1YmUwY2QxOSwgMHgxMzdlMjE3OSBdO1xuXHQgIHRoaXMuayA9IHNoYTUxMl9LO1xuXHQgIHRoaXMuVyA9IG5ldyBBcnJheSgxNjApO1xuXHR9XG5cdHV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoJDIpO1xuXHR2YXIgXzUxMiA9IFNIQTUxMjtcblxuXHRTSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblx0U0hBNTEyLm91dFNpemUgPSA1MTI7XG5cdFNIQTUxMi5obWFjU3RyZW5ndGggPSAxOTI7XG5cdFNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblx0U0hBNTEyLnByb3RvdHlwZS5fcHJlcGFyZUJsb2NrID0gZnVuY3Rpb24gX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KSB7XG5cdCAgdmFyIFcgPSB0aGlzLlc7XG5cblx0ICAvLyAzMiB4IDMyYml0IHdvcmRzXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKVxuXHQgICAgV1tpXSA9IG1zZ1tzdGFydCArIGldO1xuXHQgIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgdmFyIGMwX2hpID0gZzFfNTEyX2hpKFdbaSAtIDRdLCBXW2kgLSAzXSk7ICAvLyBpIC0gMlxuXHQgICAgdmFyIGMwX2xvID0gZzFfNTEyX2xvKFdbaSAtIDRdLCBXW2kgLSAzXSk7XG5cdCAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuXHQgICAgdmFyIGMxX2xvID0gV1tpIC0gMTNdO1xuXHQgICAgdmFyIGMyX2hpID0gZzBfNTEyX2hpKFdbaSAtIDMwXSwgV1tpIC0gMjldKTsgIC8vIGkgLSAxNVxuXHQgICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcblx0ICAgIHZhciBjM19oaSA9IFdbaSAtIDMyXTsgIC8vIGkgLSAxNlxuXHQgICAgdmFyIGMzX2xvID0gV1tpIC0gMzFdO1xuXG5cdCAgICBXW2ldID0gc3VtNjRfNF9oaSQxKFxuXHQgICAgICBjMF9oaSwgYzBfbG8sXG5cdCAgICAgIGMxX2hpLCBjMV9sbyxcblx0ICAgICAgYzJfaGksIGMyX2xvLFxuXHQgICAgICBjM19oaSwgYzNfbG8pO1xuXHQgICAgV1tpICsgMV0gPSBzdW02NF80X2xvJDEoXG5cdCAgICAgIGMwX2hpLCBjMF9sbyxcblx0ICAgICAgYzFfaGksIGMxX2xvLFxuXHQgICAgICBjMl9oaSwgYzJfbG8sXG5cdCAgICAgIGMzX2hpLCBjM19sbyk7XG5cdCAgfVxuXHR9O1xuXG5cdFNIQTUxMi5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIF91cGRhdGUobXNnLCBzdGFydCkge1xuXHQgIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuXHQgIHZhciBXID0gdGhpcy5XO1xuXG5cdCAgdmFyIGFoID0gdGhpcy5oWzBdO1xuXHQgIHZhciBhbCA9IHRoaXMuaFsxXTtcblx0ICB2YXIgYmggPSB0aGlzLmhbMl07XG5cdCAgdmFyIGJsID0gdGhpcy5oWzNdO1xuXHQgIHZhciBjaCA9IHRoaXMuaFs0XTtcblx0ICB2YXIgY2wgPSB0aGlzLmhbNV07XG5cdCAgdmFyIGRoID0gdGhpcy5oWzZdO1xuXHQgIHZhciBkbCA9IHRoaXMuaFs3XTtcblx0ICB2YXIgZWggPSB0aGlzLmhbOF07XG5cdCAgdmFyIGVsID0gdGhpcy5oWzldO1xuXHQgIHZhciBmaCA9IHRoaXMuaFsxMF07XG5cdCAgdmFyIGZsID0gdGhpcy5oWzExXTtcblx0ICB2YXIgZ2ggPSB0aGlzLmhbMTJdO1xuXHQgIHZhciBnbCA9IHRoaXMuaFsxM107XG5cdCAgdmFyIGhoID0gdGhpcy5oWzE0XTtcblx0ICB2YXIgaGwgPSB0aGlzLmhbMTVdO1xuXG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IFcubGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgIHZhciBjMF9oaSA9IGhoO1xuXHQgICAgdmFyIGMwX2xvID0gaGw7XG5cdCAgICB2YXIgYzFfaGkgPSBzMV81MTJfaGkoZWgsIGVsKTtcblx0ICAgIHZhciBjMV9sbyA9IHMxXzUxMl9sbyhlaCwgZWwpO1xuXHQgICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcblx0ICAgIHZhciBjMl9sbyA9IGNoNjRfbG8oZWgsIGVsLCBmaCwgZmwsIGdoLCBnbCk7XG5cdCAgICB2YXIgYzNfaGkgPSB0aGlzLmtbaV07XG5cdCAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuXHQgICAgdmFyIGM0X2hpID0gV1tpXTtcblx0ICAgIHZhciBjNF9sbyA9IFdbaSArIDFdO1xuXG5cdCAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpJDEoXG5cdCAgICAgIGMwX2hpLCBjMF9sbyxcblx0ICAgICAgYzFfaGksIGMxX2xvLFxuXHQgICAgICBjMl9oaSwgYzJfbG8sXG5cdCAgICAgIGMzX2hpLCBjM19sbyxcblx0ICAgICAgYzRfaGksIGM0X2xvKTtcblx0ICAgIHZhciBUMV9sbyA9IHN1bTY0XzVfbG8kMShcblx0ICAgICAgYzBfaGksIGMwX2xvLFxuXHQgICAgICBjMV9oaSwgYzFfbG8sXG5cdCAgICAgIGMyX2hpLCBjMl9sbyxcblx0ICAgICAgYzNfaGksIGMzX2xvLFxuXHQgICAgICBjNF9oaSwgYzRfbG8pO1xuXG5cdCAgICBjMF9oaSA9IHMwXzUxMl9oaShhaCwgYWwpO1xuXHQgICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcblx0ICAgIGMxX2hpID0gbWFqNjRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cdCAgICBjMV9sbyA9IG1hajY0X2xvKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuXG5cdCAgICB2YXIgVDJfaGkgPSBzdW02NF9oaSQxKGMwX2hpLCBjMF9sbywgYzFfaGksIGMxX2xvKTtcblx0ICAgIHZhciBUMl9sbyA9IHN1bTY0X2xvJDEoYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG5cdCAgICBoaCA9IGdoO1xuXHQgICAgaGwgPSBnbDtcblxuXHQgICAgZ2ggPSBmaDtcblx0ICAgIGdsID0gZmw7XG5cblx0ICAgIGZoID0gZWg7XG5cdCAgICBmbCA9IGVsO1xuXG5cdCAgICBlaCA9IHN1bTY0X2hpJDEoZGgsIGRsLCBUMV9oaSwgVDFfbG8pO1xuXHQgICAgZWwgPSBzdW02NF9sbyQxKGRsLCBkbCwgVDFfaGksIFQxX2xvKTtcblxuXHQgICAgZGggPSBjaDtcblx0ICAgIGRsID0gY2w7XG5cblx0ICAgIGNoID0gYmg7XG5cdCAgICBjbCA9IGJsO1xuXG5cdCAgICBiaCA9IGFoO1xuXHQgICAgYmwgPSBhbDtcblxuXHQgICAgYWggPSBzdW02NF9oaSQxKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcblx0ICAgIGFsID0gc3VtNjRfbG8kMShUMV9oaSwgVDFfbG8sIFQyX2hpLCBUMl9sbyk7XG5cdCAgfVxuXG5cdCAgc3VtNjQkMSh0aGlzLmgsIDAsIGFoLCBhbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDIsIGJoLCBibCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDQsIGNoLCBjbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDYsIGRoLCBkbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDgsIGVoLCBlbCk7XG5cdCAgc3VtNjQkMSh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuXHQgIHN1bTY0JDEodGhpcy5oLCAxMiwgZ2gsIGdsKTtcblx0ICBzdW02NCQxKHRoaXMuaCwgMTQsIGhoLCBobCk7XG5cdH07XG5cblx0U0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcblx0ICB2YXIgciA9ICh4aCAmIHloKSBeICgofnhoKSAmIHpoKTtcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG5cdCAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoKH54bCkgJiB6bCk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuXHQgIHZhciByID0gKHhoICYgeWgpIF4gKHhoICYgemgpIF4gKHloICYgemgpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG5cdCAgdmFyIHIgPSAoeGwgJiB5bCkgXiAoeGwgJiB6bCkgXiAoeWwgJiB6bCk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcblx0ICB2YXIgYzBfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDI4KTtcblx0ICB2YXIgYzFfaGkgPSByb3RyNjRfaGkkMSh4bCwgeGgsIDIpOyAgLy8gMzRcblx0ICB2YXIgYzJfaGkgPSByb3RyNjRfaGkkMSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAyOCk7XG5cdCAgdmFyIGMxX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCAyKTsgIC8vIDM0XG5cdCAgdmFyIGMyX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCA3KTsgIC8vIDM5XG5cblx0ICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcblx0ICBpZiAociA8IDApXG5cdCAgICByICs9IDB4MTAwMDAwMDAwO1xuXHQgIHJldHVybiByO1xuXHR9XG5cblx0ZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuXHQgIHZhciBjMF9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgMTQpO1xuXHQgIHZhciBjMV9oaSA9IHJvdHI2NF9oaSQxKHhoLCB4bCwgMTgpO1xuXHQgIHZhciBjMl9oaSA9IHJvdHI2NF9oaSQxKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG5cdCAgdmFyIHIgPSBjMF9oaSBeIGMxX2hpIF4gYzJfaGk7XG5cdCAgaWYgKHIgPCAwKVxuXHQgICAgciArPSAweDEwMDAwMDAwMDtcblx0ICByZXR1cm4gcjtcblx0fVxuXG5cdGZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcblx0ICB2YXIgYzBfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDE0KTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDE4KTtcblx0ICB2YXIgYzJfbG8gPSByb3RyNjRfbG8kMSh4bCwgeGgsIDkpOyAgLy8gNDFcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxKTtcblx0ICB2YXIgYzFfaGkgPSByb3RyNjRfaGkkMSh4aCwgeGwsIDgpO1xuXHQgIHZhciBjMl9oaSA9IHNocjY0X2hpJDEoeGgsIHhsLCA3KTtcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAxKTtcblx0ICB2YXIgYzFfbG8gPSByb3RyNjRfbG8kMSh4aCwgeGwsIDgpO1xuXHQgIHZhciBjMl9sbyA9IHNocjY0X2xvJDEoeGgsIHhsLCA3KTtcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2hpID0gcm90cjY0X2hpJDEoeGgsIHhsLCAxOSk7XG5cdCAgdmFyIGMxX2hpID0gcm90cjY0X2hpJDEoeGwsIHhoLCAyOSk7ICAvLyA2MVxuXHQgIHZhciBjMl9oaSA9IHNocjY0X2hpJDEoeGgsIHhsLCA2KTtcblxuXHQgIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHRmdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG5cdCAgdmFyIGMwX2xvID0gcm90cjY0X2xvJDEoeGgsIHhsLCAxOSk7XG5cdCAgdmFyIGMxX2xvID0gcm90cjY0X2xvJDEoeGwsIHhoLCAyOSk7ICAvLyA2MVxuXHQgIHZhciBjMl9sbyA9IHNocjY0X2xvJDEoeGgsIHhsLCA2KTtcblxuXHQgIHZhciByID0gYzBfbG8gXiBjMV9sbyBeIGMyX2xvO1xuXHQgIGlmIChyIDwgMClcblx0ICAgIHIgKz0gMHgxMDAwMDAwMDA7XG5cdCAgcmV0dXJuIHI7XG5cdH1cblxuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHNoYTEgPSBfMTtcblx0dmFyIHNoYTIyNCA9IF8yMjQ7XG5cdHZhciBzaGEyNTYgPSBfMjU2O1xuXHR2YXIgc2hhMzg0ID0gXzM4NDtcblx0dmFyIHNoYTUxMiA9IF81MTI7XG5cblx0dmFyIHNoYSA9IHtcblx0XHRzaGExOiBzaGExLFxuXHRcdHNoYTIyNDogc2hhMjI0LFxuXHRcdHNoYTI1Njogc2hhMjU2LFxuXHRcdHNoYTM4NDogc2hhMzg0LFxuXHRcdHNoYTUxMjogc2hhNTEyXG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdHZhciByb3RsMzIkMSA9IHV0aWxzLnJvdGwzMjtcblx0dmFyIHN1bTMyJDIgPSB1dGlscy5zdW0zMjtcblx0dmFyIHN1bTMyXzMkMSA9IHV0aWxzLnN1bTMyXzM7XG5cdHZhciBzdW0zMl80JDIgPSB1dGlscy5zdW0zMl80O1xuXHR2YXIgQmxvY2tIYXNoJDMgPSBjb21tb24uQmxvY2tIYXNoO1xuXG5cdGZ1bmN0aW9uIFJJUEVNRDE2MCgpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlcblx0ICAgIHJldHVybiBuZXcgUklQRU1EMTYwKCk7XG5cblx0ICBCbG9ja0hhc2gkMy5jYWxsKHRoaXMpO1xuXG5cdCAgdGhpcy5oID0gWyAweDY3NDUyMzAxLCAweGVmY2RhYjg5LCAweDk4YmFkY2ZlLCAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG5cdCAgdGhpcy5lbmRpYW4gPSAnbGl0dGxlJztcblx0fVxuXHR1dGlscy5pbmhlcml0cyhSSVBFTUQxNjAsIEJsb2NrSGFzaCQzKTtcblx0dmFyIHJpcGVtZDE2MCA9IFJJUEVNRDE2MDtcblxuXHRSSVBFTUQxNjAuYmxvY2tTaXplID0gNTEyO1xuXHRSSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcblx0UklQRU1EMTYwLmhtYWNTdHJlbmd0aCA9IDE5Mjtcblx0UklQRU1EMTYwLnBhZExlbmd0aCA9IDY0O1xuXG5cdFJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIHN0YXJ0KSB7XG5cdCAgdmFyIEEgPSB0aGlzLmhbMF07XG5cdCAgdmFyIEIgPSB0aGlzLmhbMV07XG5cdCAgdmFyIEMgPSB0aGlzLmhbMl07XG5cdCAgdmFyIEQgPSB0aGlzLmhbM107XG5cdCAgdmFyIEUgPSB0aGlzLmhbNF07XG5cdCAgdmFyIEFoID0gQTtcblx0ICB2YXIgQmggPSBCO1xuXHQgIHZhciBDaCA9IEM7XG5cdCAgdmFyIERoID0gRDtcblx0ICB2YXIgRWggPSBFO1xuXHQgIGZvciAodmFyIGogPSAwOyBqIDwgODA7IGorKykge1xuXHQgICAgdmFyIFQgPSBzdW0zMiQyKFxuXHQgICAgICByb3RsMzIkMShcblx0ICAgICAgICBzdW0zMl80JDIoQSwgZihqLCBCLCBDLCBEKSwgbXNnW3Jbal0gKyBzdGFydF0sIEsoaikpLFxuXHQgICAgICAgIHNbal0pLFxuXHQgICAgICBFKTtcblx0ICAgIEEgPSBFO1xuXHQgICAgRSA9IEQ7XG5cdCAgICBEID0gcm90bDMyJDEoQywgMTApO1xuXHQgICAgQyA9IEI7XG5cdCAgICBCID0gVDtcblx0ICAgIFQgPSBzdW0zMiQyKFxuXHQgICAgICByb3RsMzIkMShcblx0ICAgICAgICBzdW0zMl80JDIoQWgsIGYoNzkgLSBqLCBCaCwgQ2gsIERoKSwgbXNnW3JoW2pdICsgc3RhcnRdLCBLaChqKSksXG5cdCAgICAgICAgc2hbal0pLFxuXHQgICAgICBFaCk7XG5cdCAgICBBaCA9IEVoO1xuXHQgICAgRWggPSBEaDtcblx0ICAgIERoID0gcm90bDMyJDEoQ2gsIDEwKTtcblx0ICAgIENoID0gQmg7XG5cdCAgICBCaCA9IFQ7XG5cdCAgfVxuXHQgIFQgPSBzdW0zMl8zJDEodGhpcy5oWzFdLCBDLCBEaCk7XG5cdCAgdGhpcy5oWzFdID0gc3VtMzJfMyQxKHRoaXMuaFsyXSwgRCwgRWgpO1xuXHQgIHRoaXMuaFsyXSA9IHN1bTMyXzMkMSh0aGlzLmhbM10sIEUsIEFoKTtcblx0ICB0aGlzLmhbM10gPSBzdW0zMl8zJDEodGhpcy5oWzRdLCBBLCBCaCk7XG5cdCAgdGhpcy5oWzRdID0gc3VtMzJfMyQxKHRoaXMuaFswXSwgQiwgQ2gpO1xuXHQgIHRoaXMuaFswXSA9IFQ7XG5cdH07XG5cblx0UklQRU1EMTYwLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuXHQgIGlmIChlbmMgPT09ICdoZXgnKVxuXHQgICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnbGl0dGxlJyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnbGl0dGxlJyk7XG5cdH07XG5cblx0ZnVuY3Rpb24gZihqLCB4LCB5LCB6KSB7XG5cdCAgaWYgKGogPD0gMTUpXG5cdCAgICByZXR1cm4geCBeIHkgXiB6O1xuXHQgIGVsc2UgaWYgKGogPD0gMzEpXG5cdCAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG5cdCAgZWxzZSBpZiAoaiA8PSA0Nylcblx0ICAgIHJldHVybiAoeCB8ICh+eSkpIF4gejtcblx0ICBlbHNlIGlmIChqIDw9IDYzKVxuXHQgICAgcmV0dXJuICh4ICYgeikgfCAoeSAmICh+eikpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB4IF4gKHkgfCAofnopKTtcblx0fVxuXG5cdGZ1bmN0aW9uIEsoaikge1xuXHQgIGlmIChqIDw9IDE1KVxuXHQgICAgcmV0dXJuIDB4MDAwMDAwMDA7XG5cdCAgZWxzZSBpZiAoaiA8PSAzMSlcblx0ICAgIHJldHVybiAweDVhODI3OTk5O1xuXHQgIGVsc2UgaWYgKGogPD0gNDcpXG5cdCAgICByZXR1cm4gMHg2ZWQ5ZWJhMTtcblx0ICBlbHNlIGlmIChqIDw9IDYzKVxuXHQgICAgcmV0dXJuIDB4OGYxYmJjZGM7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIDB4YTk1M2ZkNGU7XG5cdH1cblxuXHRmdW5jdGlvbiBLaChqKSB7XG5cdCAgaWYgKGogPD0gMTUpXG5cdCAgICByZXR1cm4gMHg1MGEyOGJlNjtcblx0ICBlbHNlIGlmIChqIDw9IDMxKVxuXHQgICAgcmV0dXJuIDB4NWM0ZGQxMjQ7XG5cdCAgZWxzZSBpZiAoaiA8PSA0Nylcblx0ICAgIHJldHVybiAweDZkNzAzZWYzO1xuXHQgIGVsc2UgaWYgKGogPD0gNjMpXG5cdCAgICByZXR1cm4gMHg3YTZkNzZlOTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gMHgwMDAwMDAwMDtcblx0fVxuXG5cdHZhciByID0gW1xuXHQgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG5cdCAgNywgNCwgMTMsIDEsIDEwLCA2LCAxNSwgMywgMTIsIDAsIDksIDUsIDIsIDE0LCAxMSwgOCxcblx0ICAzLCAxMCwgMTQsIDQsIDksIDE1LCA4LCAxLCAyLCA3LCAwLCA2LCAxMywgMTEsIDUsIDEyLFxuXHQgIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG5cdCAgNCwgMCwgNSwgOSwgNywgMTIsIDIsIDEwLCAxNCwgMSwgMywgOCwgMTEsIDYsIDE1LCAxM1xuXHRdO1xuXG5cdHZhciByaCA9IFtcblx0ICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuXHQgIDYsIDExLCAzLCA3LCAwLCAxMywgNSwgMTAsIDE0LCAxNSwgOCwgMTIsIDQsIDksIDEsIDIsXG5cdCAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcblx0ICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuXHQgIDEyLCAxNSwgMTAsIDQsIDEsIDUsIDgsIDcsIDYsIDIsIDEzLCAxNCwgMCwgMywgOSwgMTFcblx0XTtcblxuXHR2YXIgcyA9IFtcblx0ICAxMSwgMTQsIDE1LCAxMiwgNSwgOCwgNywgOSwgMTEsIDEzLCAxNCwgMTUsIDYsIDcsIDksIDgsXG5cdCAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuXHQgIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcblx0ICAxMSwgMTIsIDE0LCAxNSwgMTQsIDE1LCA5LCA4LCA5LCAxNCwgNSwgNiwgOCwgNiwgNSwgMTIsXG5cdCAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5cdF07XG5cblx0dmFyIHNoID0gW1xuXHQgIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcblx0ICA5LCAxMywgMTUsIDcsIDEyLCA4LCA5LCAxMSwgNywgNywgMTIsIDcsIDYsIDE1LCAxMywgMTEsXG5cdCAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuXHQgIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcblx0ICA4LCA1LCAxMiwgOSwgMTIsIDUsIDE0LCA2LCA4LCAxMywgNiwgNSwgMTUsIDEzLCAxMSwgMTFcblx0XTtcblxuXHR2YXIgcmlwZW1kID0ge1xuXHRcdHJpcGVtZDE2MDogcmlwZW1kMTYwXG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdGZ1bmN0aW9uIEhtYWMoaGFzaCwga2V5LCBlbmMpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG5cdCAgICByZXR1cm4gbmV3IEhtYWMoaGFzaCwga2V5LCBlbmMpO1xuXHQgIHRoaXMuSGFzaCA9IGhhc2g7XG5cdCAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG5cdCAgdGhpcy5vdXRTaXplID0gaGFzaC5vdXRTaXplIC8gODtcblx0ICB0aGlzLmlubmVyID0gbnVsbDtcblx0ICB0aGlzLm91dGVyID0gbnVsbDtcblxuXHQgIHRoaXMuX2luaXQodXRpbHMudG9BcnJheShrZXksIGVuYykpO1xuXHR9XG5cdHZhciBobWFjID0gSG1hYztcblxuXHRIbWFjLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoa2V5KSB7XG5cdCAgLy8gU2hvcnRlbiBrZXksIGlmIG5lZWRlZFxuXHQgIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG5cdCAgICBrZXkgPSBuZXcgdGhpcy5IYXNoKCkudXBkYXRlKGtleSkuZGlnZXN0KCk7XG5cdCAgbWluaW1hbGlzdGljQXNzZXJ0KGtleS5sZW5ndGggPD0gdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG5cdCAgZm9yICh2YXIgaSA9IGtleS5sZW5ndGg7IGkgPCB0aGlzLmJsb2NrU2l6ZTsgaSsrKVxuXHQgICAga2V5LnB1c2goMCk7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuXHQgICAga2V5W2ldIF49IDB4MzY7XG5cdCAgdGhpcy5pbm5lciA9IG5ldyB0aGlzLkhhc2goKS51cGRhdGUoa2V5KTtcblxuXHQgIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuXHQgIGZvciAoaSA9IDA7IGkgPCBrZXkubGVuZ3RoOyBpKyspXG5cdCAgICBrZXlbaV0gXj0gMHg2YTtcblx0ICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXHR9O1xuXG5cdEhtYWMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIGVuYykge1xuXHQgIHRoaXMuaW5uZXIudXBkYXRlKG1zZywgZW5jKTtcblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRIbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG5cdCAgdGhpcy5vdXRlci51cGRhdGUodGhpcy5pbm5lci5kaWdlc3QoKSk7XG5cdCAgcmV0dXJuIHRoaXMub3V0ZXIuZGlnZXN0KGVuYyk7XG5cdH07XG5cblx0dmFyIGhhc2hfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0dmFyIGhhc2ggPSBleHBvcnRzO1xuXG5cdGhhc2gudXRpbHMgPSB1dGlscztcblx0aGFzaC5jb21tb24gPSBjb21tb247XG5cdGhhc2guc2hhID0gc2hhO1xuXHRoYXNoLnJpcGVtZCA9IHJpcGVtZDtcblx0aGFzaC5obWFjID0gaG1hYztcblxuXHQvLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcblx0aGFzaC5zaGExID0gaGFzaC5zaGEuc2hhMTtcblx0aGFzaC5zaGEyNTYgPSBoYXNoLnNoYS5zaGEyNTY7XG5cdGhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuXHRoYXNoLnNoYTM4NCA9IGhhc2guc2hhLnNoYTM4NDtcblx0aGFzaC5zaGE1MTIgPSBoYXNoLnNoYS5zaGE1MTI7XG5cdGhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuXHR9KTtcblx0dmFyIGhhc2hfMiA9IGhhc2hfMS5obWFjO1xuXHR2YXIgaGFzaF8zID0gaGFzaF8xLnJpcGVtZDE2MDtcblx0dmFyIGhhc2hfNCA9IGhhc2hfMS5zaGEyNTY7XG5cdHZhciBoYXNoXzUgPSBoYXNoXzEuc2hhNTEyO1xuXG5cdHZhciBfdmVyc2lvbiRvID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInNoYTIvNS4wLjNcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kcCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kbyk7XG5cdHZhciBfdmVyc2lvbl8xJGMgPSBfdmVyc2lvbiRvLnZlcnNpb247XG5cblx0dmFyIGJyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG5cdCAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHR2YXIgaGFzaCA9IF9faW1wb3J0U3RhcihoYXNoXzEpO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kby52ZXJzaW9uKTtcblx0dmFyIFN1cHBvcnRlZEFsZ29yaXRobTtcblx0KGZ1bmN0aW9uIChTdXBwb3J0ZWRBbGdvcml0aG0pIHtcblx0ICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG5cdCAgICBTdXBwb3J0ZWRBbGdvcml0aG1bXCJzaGE1MTJcIl0gPSBcInNoYTUxMlwiO1xuXHR9KShTdXBwb3J0ZWRBbGdvcml0aG0gPSBleHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSB8fCAoZXhwb3J0cy5TdXBwb3J0ZWRBbGdvcml0aG0gPSB7fSkpO1xuXHQ7XG5cdGZ1bmN0aW9uIHJpcGVtZDE2MChkYXRhKSB7XG5cdCAgICByZXR1cm4gXCIweFwiICsgKGhhc2gucmlwZW1kMTYwKCkudXBkYXRlKGxpYiQxLmFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xuXHR9XG5cdGV4cG9ydHMucmlwZW1kMTYwID0gcmlwZW1kMTYwO1xuXHRmdW5jdGlvbiBzaGEyNTYoZGF0YSkge1xuXHQgICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTI1NigpLnVwZGF0ZShsaWIkMS5hcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcblx0fVxuXHRleHBvcnRzLnNoYTI1NiA9IHNoYTI1Njtcblx0ZnVuY3Rpb24gc2hhNTEyKGRhdGEpIHtcblx0ICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5zaGE1MTIoKS51cGRhdGUobGliJDEuYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG5cdH1cblx0ZXhwb3J0cy5zaGE1MTIgPSBzaGE1MTI7XG5cdGZ1bmN0aW9uIGNvbXB1dGVIbWFjKGFsZ29yaXRobSwga2V5LCBkYXRhKSB7XG5cdCAgICBpZiAoIVN1cHBvcnRlZEFsZ29yaXRobVthbGdvcml0aG1dKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG0gXCIgKyBhbGdvcml0aG0sIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwiaG1hY1wiLFxuXHQgICAgICAgICAgICBhbGdvcml0aG06IGFsZ29yaXRobVxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFwiMHhcIiArIGhhc2guaG1hYyhoYXNoW2FsZ29yaXRobV0sIGxpYiQxLmFycmF5aWZ5KGtleSkpLnVwZGF0ZShsaWIkMS5hcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpO1xuXHR9XG5cdGV4cG9ydHMuY29tcHV0ZUhtYWMgPSBjb21wdXRlSG1hYztcblxuXHR9KTtcblxuXHR2YXIgYnJvd3NlciQxID0gdW53cmFwRXhwb3J0cyhicm93c2VyKTtcblx0dmFyIGJyb3dzZXJfMSA9IGJyb3dzZXIuU3VwcG9ydGVkQWxnb3JpdGhtO1xuXHR2YXIgYnJvd3Nlcl8yID0gYnJvd3Nlci5yaXBlbWQxNjA7XG5cdHZhciBicm93c2VyXzMgPSBicm93c2VyLnNoYTI1Njtcblx0dmFyIGJyb3dzZXJfNCA9IGJyb3dzZXIuc2hhNTEyO1xuXHR2YXIgYnJvd3Nlcl81ID0gYnJvd3Nlci5jb21wdXRlSG1hYztcblxuXHR2YXIgYnJvd3NlciQyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0ZnVuY3Rpb24gcGJrZGYyKHBhc3N3b3JkLCBzYWx0LCBpdGVyYXRpb25zLCBrZXlsZW4sIGhhc2hBbGdvcml0aG0pIHtcblx0ICAgIHBhc3N3b3JkID0gbGliJDEuYXJyYXlpZnkocGFzc3dvcmQpO1xuXHQgICAgc2FsdCA9IGxpYiQxLmFycmF5aWZ5KHNhbHQpO1xuXHQgICAgdmFyIGhMZW47XG5cdCAgICB2YXIgbCA9IDE7XG5cdCAgICB2YXIgREsgPSBuZXcgVWludDhBcnJheShrZXlsZW4pO1xuXHQgICAgdmFyIGJsb2NrMSA9IG5ldyBVaW50OEFycmF5KHNhbHQubGVuZ3RoICsgNCk7XG5cdCAgICBibG9jazEuc2V0KHNhbHQpO1xuXHQgICAgLy9zYWx0LmNvcHkoYmxvY2sxLCAwLCAwLCBzYWx0Lmxlbmd0aClcblx0ICAgIHZhciByO1xuXHQgICAgdmFyIFQ7XG5cdCAgICBmb3IgKHZhciBpID0gMTsgaSA8PSBsOyBpKyspIHtcblx0ICAgICAgICAvL2Jsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuXHQgICAgICAgIGJsb2NrMVtzYWx0Lmxlbmd0aF0gPSAoaSA+PiAyNCkgJiAweGZmO1xuXHQgICAgICAgIGJsb2NrMVtzYWx0Lmxlbmd0aCArIDFdID0gKGkgPj4gMTYpICYgMHhmZjtcblx0ICAgICAgICBibG9jazFbc2FsdC5sZW5ndGggKyAyXSA9IChpID4+IDgpICYgMHhmZjtcblx0ICAgICAgICBibG9jazFbc2FsdC5sZW5ndGggKyAzXSA9IGkgJiAweGZmO1xuXHQgICAgICAgIC8vbGV0IFUgPSBjcmVhdGVIbWFjKHBhc3N3b3JkKS51cGRhdGUoYmxvY2sxKS5kaWdlc3QoKTtcblx0ICAgICAgICB2YXIgVSA9IGxpYiQxLmFycmF5aWZ5KGJyb3dzZXIuY29tcHV0ZUhtYWMoaGFzaEFsZ29yaXRobSwgcGFzc3dvcmQsIGJsb2NrMSkpO1xuXHQgICAgICAgIGlmICghaExlbikge1xuXHQgICAgICAgICAgICBoTGVuID0gVS5sZW5ndGg7XG5cdCAgICAgICAgICAgIFQgPSBuZXcgVWludDhBcnJheShoTGVuKTtcblx0ICAgICAgICAgICAgbCA9IE1hdGguY2VpbChrZXlsZW4gLyBoTGVuKTtcblx0ICAgICAgICAgICAgciA9IGtleWxlbiAtIChsIC0gMSkgKiBoTGVuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvL1UuY29weShULCAwLCAwLCBoTGVuKVxuXHQgICAgICAgIFQuc2V0KFUpO1xuXHQgICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgaXRlcmF0aW9uczsgaisrKSB7XG5cdCAgICAgICAgICAgIC8vVSA9IGNyZWF0ZUhtYWMocGFzc3dvcmQpLnVwZGF0ZShVKS5kaWdlc3QoKTtcblx0ICAgICAgICAgICAgVSA9IGxpYiQxLmFycmF5aWZ5KGJyb3dzZXIuY29tcHV0ZUhtYWMoaGFzaEFsZ29yaXRobSwgcGFzc3dvcmQsIFUpKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBoTGVuOyBrKyspXG5cdCAgICAgICAgICAgICAgICBUW2tdIF49IFVba107XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkZXN0UG9zID0gKGkgLSAxKSAqIGhMZW47XG5cdCAgICAgICAgdmFyIGxlbiA9IChpID09PSBsID8gciA6IGhMZW4pO1xuXHQgICAgICAgIC8vVC5jb3B5KERLLCBkZXN0UG9zLCAwLCBsZW4pXG5cdCAgICAgICAgREsuc2V0KGxpYiQxLmFycmF5aWZ5KFQpLnNsaWNlKDAsIGxlbiksIGRlc3RQb3MpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkoREspO1xuXHR9XG5cdGV4cG9ydHMucGJrZGYyID0gcGJrZGYyO1xuXG5cdH0pO1xuXG5cdHZhciBicm93c2VyJDMgPSB1bndyYXBFeHBvcnRzKGJyb3dzZXIkMik7XG5cdHZhciBicm93c2VyXzEkMSA9IGJyb3dzZXIkMi5wYmtkZjI7XG5cblx0dmFyIHZlcnNpb24gPSBcIjYuNS4zXCI7XG5cdHZhciBfcGFja2FnZSA9IHtcblx0XHR2ZXJzaW9uOiB2ZXJzaW9uXG5cdH07XG5cblx0dmFyIF9wYWNrYWdlJDEgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG5cdFx0dmVyc2lvbjogdmVyc2lvbixcblx0XHQnZGVmYXVsdCc6IF9wYWNrYWdlXG5cdH0pO1xuXG5cdHZhciBibiQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQgICd1c2Ugc3RyaWN0JztcblxuXHQgIC8vIFV0aWxzXG5cdCAgZnVuY3Rpb24gYXNzZXJ0ICh2YWwsIG1zZykge1xuXHQgICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcblx0ICB9XG5cblx0ICAvLyBDb3VsZCB1c2UgYGluaGVyaXRzYCBtb2R1bGUsIGJ1dCBkb24ndCB3YW50IHRvIG1vdmUgZnJvbSBzaW5nbGUgZmlsZVxuXHQgIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG5cdCAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuXHQgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdCAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcblx0ICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG5cdCAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuXHQgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuXHQgIH1cblxuXHQgIC8vIEJOXG5cblx0ICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcblx0ICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcblx0ICAgICAgcmV0dXJuIG51bWJlcjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICB0aGlzLndvcmRzID0gbnVsbDtcblx0ICAgIHRoaXMubGVuZ3RoID0gMDtcblxuXHQgICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcblx0ICAgIHRoaXMucmVkID0gbnVsbDtcblxuXHQgICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuXHQgICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG5cdCAgICAgICAgZW5kaWFuID0gYmFzZTtcblx0ICAgICAgICBiYXNlID0gMTA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLl9pbml0KG51bWJlciB8fCAwLCBiYXNlIHx8IDEwLCBlbmRpYW4gfHwgJ2JlJyk7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jykge1xuXHQgICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcblx0ICB9IGVsc2Uge1xuXHQgICAgZXhwb3J0cy5CTiA9IEJOO1xuXHQgIH1cblxuXHQgIEJOLkJOID0gQk47XG5cdCAgQk4ud29yZFNpemUgPSAyNjtcblxuXHQgIHZhciBCdWZmZXI7XG5cdCAgdHJ5IHtcblx0ICAgIEJ1ZmZlciA9IHJlcXVpcmUkJDAuQnVmZmVyO1xuXHQgIH0gY2F0Y2ggKGUpIHtcblx0ICB9XG5cblx0ICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG5cdCAgICBpZiAobnVtIGluc3RhbmNlb2YgQk4pIHtcblx0ICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBudW0gIT09IG51bGwgJiYgdHlwZW9mIG51bSA9PT0gJ29iamVjdCcgJiZcblx0ICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG5cdCAgfTtcblxuXHQgIEJOLm1heCA9IGZ1bmN0aW9uIG1heCAobGVmdCwgcmlnaHQpIHtcblx0ICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcblx0ICAgIHJldHVybiByaWdodDtcblx0ICB9O1xuXG5cdCAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuXHQgICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuXHQgICAgcmV0dXJuIHJpZ2h0O1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdudW1iZXInKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHR5cGVvZiBudW1iZXIgPT09ICdvYmplY3QnKSB7XG5cdCAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoYmFzZSA9PT0gJ2hleCcpIHtcblx0ICAgICAgYmFzZSA9IDE2O1xuXHQgICAgfVxuXHQgICAgYXNzZXJ0KGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpO1xuXG5cdCAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcblx0ICAgIHZhciBzdGFydCA9IDA7XG5cdCAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcblx0ICAgICAgc3RhcnQrKztcblx0ICAgIH1cblxuXHQgICAgaWYgKGJhc2UgPT09IDE2KSB7XG5cdCAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQpO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuXHQgICAgfVxuXG5cdCAgICBpZiAobnVtYmVyWzBdID09PSAnLScpIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG5cdCAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgaWYgKG51bWJlciA8IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIG51bWJlciA9IC1udW1iZXI7XG5cdCAgICB9XG5cdCAgICBpZiAobnVtYmVyIDwgMHg0MDAwMDAwKSB7XG5cdCAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDE7XG5cdCAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcblx0ICAgICAgdGhpcy53b3JkcyA9IFtcblx0ICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcblx0ICAgICAgXTtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAyO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcblx0ICAgICAgdGhpcy53b3JkcyA9IFtcblx0ICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG5cdCAgICAgICAgMVxuXHQgICAgICBdO1xuXHQgICAgICB0aGlzLmxlbmd0aCA9IDM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuXHQgICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcblx0ICAgIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgYmFzZSwgZW5kaWFuKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuXHQgICAgLy8gUGVyaGFwcyBhIFVpbnQ4QXJyYXlcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuXHQgICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzID0gWyAwIF07XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcblx0ICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaiwgdztcblx0ICAgIHZhciBvZmYgPSAwO1xuXHQgICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuXHQgICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG5cdCAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuXHQgICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuXHQgICAgICAgICAgb2ZmIC09IDI2O1xuXHQgICAgICAgICAgaisrO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcblx0ICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcblx0ICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG9mZiArPSAyNDtcblx0ICAgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgICBqKys7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBwYXJzZUhleCAoc3RyLCBzdGFydCwgZW5kKSB7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuXHQgICAgICByIDw8PSA0O1xuXG5cdCAgICAgIC8vICdhJyAtICdmJ1xuXHQgICAgICBpZiAoYyA+PSA0OSAmJiBjIDw9IDU0KSB7XG5cdCAgICAgICAgciB8PSBjIC0gNDkgKyAweGE7XG5cblx0ICAgICAgLy8gJ0EnIC0gJ0YnXG5cdCAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNyAmJiBjIDw9IDIyKSB7XG5cdCAgICAgICAgciB8PSBjIC0gMTcgKyAweGE7XG5cblx0ICAgICAgLy8gJzAnIC0gJzknXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgciB8PSBjICYgMHhmO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0KSB7XG5cdCAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuXHQgICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcblx0ICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaiwgdztcblx0ICAgIC8vIFNjYW4gMjQtYml0IGNodW5rcyBhbmQgYWRkIHRoZW0gdG8gdGhlIG51bWJlclxuXHQgICAgdmFyIG9mZiA9IDA7XG5cdCAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gNiwgaiA9IDA7IGkgPj0gc3RhcnQ7IGkgLT0gNikge1xuXHQgICAgICB3ID0gcGFyc2VIZXgobnVtYmVyLCBpLCBpICsgNik7XG5cdCAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgLy8gTk9URTogYDB4M2ZmZmZmYCBpcyBpbnRlbnRpb25hbCBoZXJlLCAyNmJpdHMgbWF4IHNoaWZ0ICsgMjRiaXQgaGV4IGxpbWJcblx0ICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuXHQgICAgICBvZmYgKz0gMjQ7XG5cdCAgICAgIGlmIChvZmYgPj0gMjYpIHtcblx0ICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgaisrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICBpZiAoaSArIDYgIT09IHN0YXJ0KSB7XG5cdCAgICAgIHcgPSBwYXJzZUhleChudW1iZXIsIHN0YXJ0LCBpICsgNik7XG5cdCAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdGhpcy53b3Jkc1tqICsgMV0gfD0gdyA+Pj4gKDI2IC0gb2ZmKSAmIDB4M2ZmZmZmO1xuXHQgICAgfVxuXHQgICAgdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG5cdCAgICB2YXIgciA9IDA7XG5cdCAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcblx0ICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuXHQgICAgICByICo9IG11bDtcblxuXHQgICAgICAvLyAnYSdcblx0ICAgICAgaWYgKGMgPj0gNDkpIHtcblx0ICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuXHQgICAgICAvLyAnQSdcblx0ICAgICAgfSBlbHNlIGlmIChjID49IDE3KSB7XG5cdCAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cblx0ICAgICAgLy8gJzAnIC0gJzknXG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgciArPSBjO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcjtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcblx0ICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuXHQgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuXHQgICAgdGhpcy5sZW5ndGggPSAxO1xuXG5cdCAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2Vcblx0ICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuXHQgICAgICBsaW1iTGVuKys7XG5cdCAgICB9XG5cdCAgICBsaW1iTGVuLS07XG5cdCAgICBsaW1iUG93ID0gKGxpbWJQb3cgLyBiYXNlKSB8IDA7XG5cblx0ICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcblx0ICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG5cdCAgICB2YXIgZW5kID0gTWF0aC5taW4odG90YWwsIHRvdGFsIC0gbW9kKSArIHN0YXJ0O1xuXG5cdCAgICB2YXIgd29yZCA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuXHQgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgaSArIGxpbWJMZW4sIGJhc2UpO1xuXG5cdCAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG5cdCAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBpZiAobW9kICE9PSAwKSB7XG5cdCAgICAgIHZhciBwb3cgPSAxO1xuXHQgICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cblx0ICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG5cdCAgICAgICAgcG93ICo9IGJhc2U7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmltdWxuKHBvdyk7XG5cdCAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcblx0ICAgIGRlc3Qud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgfVxuXHQgICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcblx0ICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuXHQgICAgZGVzdC5yZWQgPSB0aGlzLnJlZDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuXHQgICAgdmFyIHIgPSBuZXcgQk4obnVsbCk7XG5cdCAgICB0aGlzLmNvcHkocik7XG5cdCAgICByZXR1cm4gcjtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG5cdCAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG5cdCAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcblx0ICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgIHRoaXMubGVuZ3RoLS07XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG5cdCAgICAvLyAtMCA9IDBcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG5cdCAgICByZXR1cm4gKHRoaXMucmVkID8gJzxCTi1SOiAnIDogJzxCTjogJykgKyB0aGlzLnRvU3RyaW5nKDE2KSArICc+Jztcblx0ICB9O1xuXG5cdCAgLypcblxuXHQgIHZhciB6ZXJvcyA9IFtdO1xuXHQgIHZhciBncm91cFNpemVzID0gW107XG5cdCAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuXHQgIHZhciBzID0gJyc7XG5cdCAgdmFyIGkgPSAtMTtcblx0ICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcblx0ICAgIHplcm9zW2ldID0gcztcblx0ICAgIHMgKz0gJzAnO1xuXHQgIH1cblx0ICBncm91cFNpemVzWzBdID0gMDtcblx0ICBncm91cFNpemVzWzFdID0gMDtcblx0ICBncm91cEJhc2VzWzBdID0gMDtcblx0ICBncm91cEJhc2VzWzFdID0gMDtcblx0ICB2YXIgYmFzZSA9IDIgLSAxO1xuXHQgIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcblx0ICAgIHZhciBncm91cFNpemUgPSAwO1xuXHQgICAgdmFyIGdyb3VwQmFzZSA9IDE7XG5cdCAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuXHQgICAgICBncm91cEJhc2UgKj0gYmFzZTtcblx0ICAgICAgZ3JvdXBTaXplICs9IDE7XG5cdCAgICB9XG5cdCAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuXHQgICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcblx0ICB9XG5cblx0ICAqL1xuXG5cdCAgdmFyIHplcm9zID0gW1xuXHQgICAgJycsXG5cdCAgICAnMCcsXG5cdCAgICAnMDAnLFxuXHQgICAgJzAwMCcsXG5cdCAgICAnMDAwMCcsXG5cdCAgICAnMDAwMDAnLFxuXHQgICAgJzAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuXHQgICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG5cdCAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcblx0ICBdO1xuXG5cdCAgdmFyIGdyb3VwU2l6ZXMgPSBbXG5cdCAgICAwLCAwLFxuXHQgICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuXHQgICAgOCwgNywgNywgNywgNywgNiwgNixcblx0ICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG5cdCAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuXHQgICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuXHQgIF07XG5cblx0ICB2YXIgZ3JvdXBCYXNlcyA9IFtcblx0ICAgIDAsIDAsXG5cdCAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcblx0ICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG5cdCAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG5cdCAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcblx0ICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG5cdCAgXTtcblxuXHQgIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG5cdCAgICBiYXNlID0gYmFzZSB8fCAxMDtcblx0ICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG5cdCAgICB2YXIgb3V0O1xuXHQgICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG5cdCAgICAgIG91dCA9ICcnO1xuXHQgICAgICB2YXIgb2ZmID0gMDtcblx0ICAgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcblx0ICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuXHQgICAgICAgIGlmIChjYXJyeSAhPT0gMCB8fCBpICE9PSB0aGlzLmxlbmd0aCAtIDEpIHtcblx0ICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBvdXQgPSB3b3JkICsgb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBvZmYgKz0gMjtcblx0ICAgICAgICBpZiAob2ZmID49IDI2KSB7XG5cdCAgICAgICAgICBvZmYgLT0gMjY7XG5cdCAgICAgICAgICBpLS07XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH1cblxuXHQgICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcblx0ICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcblx0ICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG5cdCAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuXHQgICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcblx0ICAgICAgb3V0ID0gJyc7XG5cdCAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuXHQgICAgICBjLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG5cdCAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcblx0ICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG5cdCAgICAgICAgaWYgKCFjLmlzWmVybygpKSB7XG5cdCAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuXHQgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICBvdXQgPSByICsgb3V0O1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAodGhpcy5pc1plcm8oKSkge1xuXHQgICAgICAgIG91dCA9ICcwJyArIG91dDtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIG91dDtcblx0ICAgIH1cblxuXHQgICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG5cdCAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuXHQgICAgICAvLyBOT1RFOiBhdCB0aGlzIHN0YWdlIGl0IGlzIGtub3duIHRoYXQgdGhlIHRvcCBiaXQgaXMgc2V0XG5cdCAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcblx0ICAgICAgYXNzZXJ0KGZhbHNlLCAnTnVtYmVyIGNhbiBvbmx5IHNhZmVseSBzdG9yZSB1cCB0byA1MyBiaXRzJyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNik7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBCdWZmZXIgIT09ICd1bmRlZmluZWQnKTtcblx0ICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG5cdCAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuXHQgICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcblx0ICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG5cdCAgICBhc3NlcnQoYnl0ZUxlbmd0aCA8PSByZXFMZW5ndGgsICdieXRlIGFycmF5IGxvbmdlciB0aGFuIGRlc2lyZWQgbGVuZ3RoJyk7XG5cdCAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG5cdCAgICB0aGlzLnN0cmlwKCk7XG5cdCAgICB2YXIgbGl0dGxlRW5kaWFuID0gZW5kaWFuID09PSAnbGUnO1xuXHQgICAgdmFyIHJlcyA9IG5ldyBBcnJheVR5cGUocmVxTGVuZ3RoKTtcblxuXHQgICAgdmFyIGIsIGk7XG5cdCAgICB2YXIgcSA9IHRoaXMuY2xvbmUoKTtcblx0ICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG5cdCAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCByZXFMZW5ndGggLSBieXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICByZXNbaV0gPSAwO1xuXHQgICAgICB9XG5cblx0ICAgICAgZm9yIChpID0gMDsgIXEuaXNaZXJvKCk7IGkrKykge1xuXHQgICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuXHQgICAgICAgIHEuaXVzaHJuKDgpO1xuXG5cdCAgICAgICAgcmVzW3JlcUxlbmd0aCAtIGkgLSAxXSA9IGI7XG5cdCAgICAgIH1cblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcblx0ICAgICAgICBiID0gcS5hbmRsbigweGZmKTtcblx0ICAgICAgICBxLml1c2hybig4KTtcblxuXHQgICAgICAgIHJlc1tpXSA9IGI7XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgcmVzW2ldID0gMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBpZiAoTWF0aC5jbHozMikge1xuXHQgICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG5cdCAgICAgIHJldHVybiAzMiAtIE1hdGguY2x6MzIodyk7XG5cdCAgICB9O1xuXHQgIH0gZWxzZSB7XG5cdCAgICBCTi5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uIF9jb3VudEJpdHMgKHcpIHtcblx0ICAgICAgdmFyIHQgPSB3O1xuXHQgICAgICB2YXIgciA9IDA7XG5cdCAgICAgIGlmICh0ID49IDB4MTAwMCkge1xuXHQgICAgICAgIHIgKz0gMTM7XG5cdCAgICAgICAgdCA+Pj49IDEzO1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4NDApIHtcblx0ICAgICAgICByICs9IDc7XG5cdCAgICAgICAgdCA+Pj49IDc7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKHQgPj0gMHg4KSB7XG5cdCAgICAgICAgciArPSA0O1xuXHQgICAgICAgIHQgPj4+PSA0O1xuXHQgICAgICB9XG5cdCAgICAgIGlmICh0ID49IDB4MDIpIHtcblx0ICAgICAgICByICs9IDI7XG5cdCAgICAgICAgdCA+Pj49IDI7XG5cdCAgICAgIH1cblx0ICAgICAgcmV0dXJuIHIgKyB0O1xuXHQgICAgfTtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG5cdCAgICAvLyBTaG9ydC1jdXRcblx0ICAgIGlmICh3ID09PSAwKSByZXR1cm4gMjY7XG5cblx0ICAgIHZhciB0ID0gdztcblx0ICAgIHZhciByID0gMDtcblx0ICAgIGlmICgodCAmIDB4MWZmZikgPT09IDApIHtcblx0ICAgICAgciArPSAxMztcblx0ICAgICAgdCA+Pj49IDEzO1xuXHQgICAgfVxuXHQgICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcblx0ICAgICAgciArPSA3O1xuXHQgICAgICB0ID4+Pj0gNztcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcblx0ICAgICAgciArPSA0O1xuXHQgICAgICB0ID4+Pj0gNDtcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4MykgPT09IDApIHtcblx0ICAgICAgciArPSAyO1xuXHQgICAgICB0ID4+Pj0gMjtcblx0ICAgIH1cblx0ICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcblx0ICAgICAgcisrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBudW1iZXIgb2YgdXNlZCBiaXRzIGluIGEgQk5cblx0ICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcblx0ICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuXHQgICAgdmFyIGhpID0gdGhpcy5fY291bnRCaXRzKHcpO1xuXHQgICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gdG9CaXRBcnJheSAobnVtKSB7XG5cdCAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG5cdCAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcblx0ICAgICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuXHQgICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG5cdCAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSAmICgxIDw8IHdiaXQpKSA+Pj4gd2JpdDtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHc7XG5cdCAgfVxuXG5cdCAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuXHQgIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuXHQgICAgdmFyIHIgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG5cdCAgICAgIHIgKz0gYjtcblx0ICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcblx0ICAgIH1cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuXHQgICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcblx0ICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcblx0ICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuXHQgICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcblx0ICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVvcihudW0pO1xuXHQgIH07XG5cblx0ICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pdWFuZCA9IGZ1bmN0aW9uIGl1YW5kIChudW0pIHtcblx0ICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcblx0ICAgIHZhciBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSAmIG51bS53b3Jkc1tpXTtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlhbmQgPSBmdW5jdGlvbiBpYW5kIChudW0pIHtcblx0ICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuXHQgICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhbmQobnVtKTtcblx0ICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudWFuZCA9IGZ1bmN0aW9uIHVhbmQgKG51bSkge1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG5cdCAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG5cdCAgICB2YXIgYTtcblx0ICAgIHZhciBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcyAhPT0gYSkge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB0aGlzLmxlbmd0aCA9IGEubGVuZ3RoO1xuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuXHQgICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuXHQgIH07XG5cblx0ICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG5cdCAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuXHQgIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cblx0ICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG5cdCAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG5cdCAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG5cdCAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG5cdCAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG5cdCAgICAgIGJ5dGVzTmVlZGVkLS07XG5cdCAgICB9XG5cblx0ICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG5cdCAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm5vdG4gPSBmdW5jdGlvbiBub3RuICh3aWR0aCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG5cdCAgfTtcblxuXHQgIC8vIFNldCBgYml0YCBvZiBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG5cdCAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG5cdCAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG5cdCAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cblx0ICAgIGlmICh2YWwpIHtcblx0ICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gJiB+KDEgPDwgd2JpdCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uIGlhZGQgKG51bSkge1xuXHQgICAgdmFyIHI7XG5cblx0ICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG5cdCAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG5cdCAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcblx0ICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcblx0ICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG5cdCAgICB9XG5cblx0ICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcblx0ICAgIHZhciBhLCBiO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuXHQgICAgICBhID0gdGhpcztcblx0ICAgICAgYiA9IG51bTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGEgPSBudW07XG5cdCAgICAgIGIgPSB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSByID4+PiAyNjtcblx0ICAgIH1cblx0ICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSByID4+PiAyNjtcblx0ICAgIH1cblxuXHQgICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuXHQgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgLy8gQ29weSB0aGUgcmVzdCBvZiB0aGUgd29yZHNcblx0ICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuXHQgICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKG51bSkge1xuXHQgICAgdmFyIHJlcztcblx0ICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICBudW0ubmVnYXRpdmUgPSAwO1xuXHQgICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuXHQgICAgICBudW0ubmVnYXRpdmUgXj0gMTtcblx0ICAgICAgcmV0dXJuIHJlcztcblx0ICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHJlcyA9IG51bS5zdWIodGhpcyk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gcmVzO1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuXHQgICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG5cdCAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcblx0ICAgIC8vIHRoaXMgLSAoLW51bSkgPSB0aGlzICsgbnVtXG5cdCAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHZhciByID0gdGhpcy5pYWRkKG51bSk7XG5cdCAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG5cdCAgICAvLyAtdGhpcyAtIG51bSA9IC0odGhpcyArIG51bSlcblx0ICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5pYWRkKG51bSk7XG5cdCAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXHQgICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcblx0ICAgIH1cblxuXHQgICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG5cdCAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuXHQgICAgLy8gT3B0aW1pemF0aW9uIC0gemVyb2lmeVxuXHQgICAgaWYgKGNtcCA9PT0gMCkge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblx0ICAgICAgdGhpcy5sZW5ndGggPSAxO1xuXHQgICAgICB0aGlzLndvcmRzWzBdID0gMDtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIC8vIGEgPiBiXG5cdCAgICB2YXIgYSwgYjtcblx0ICAgIGlmIChjbXAgPiAwKSB7XG5cdCAgICAgIGEgPSB0aGlzO1xuXHQgICAgICBiID0gbnVtO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IG51bTtcblx0ICAgICAgYiA9IHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgLSAoYi53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gciA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cdCAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcblx0ICAgICAgY2FycnkgPSByID4+IDI2O1xuXHQgICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgIH1cblxuXHQgICAgLy8gQ29weSByZXN0IG9mIHRoZSB3b3Jkc1xuXHQgICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG5cdCAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkpO1xuXG5cdCAgICBpZiAoYSAhPT0gdGhpcykge1xuXHQgICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcblx0ICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG5cdCAgICBvdXQubGVuZ3RoID0gbGVuO1xuXHQgICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuXHQgICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG5cdCAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuXHQgICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuXHQgICAgdmFyIHIgPSBhICogYjtcblxuXHQgICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG5cdCAgICBvdXQud29yZHNbMF0gPSBsbztcblxuXHQgICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuXHQgICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG5cdCAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG5cdCAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG5cdCAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuXHQgICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcblx0ICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuXHQgICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG5cdCAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuXHQgICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuXHQgICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuXHQgICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcblx0ICAgICAgfVxuXHQgICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG5cdCAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBvdXQubGVuZ3RoLS07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBvdXQuc3RyaXAoKTtcblx0ICB9XG5cblx0ICAvLyBUT0RPKGluZHV0bnkpOiBpdCBtYXkgYmUgcmVhc29uYWJsZSB0byBvbWl0IGl0IGZvciB1c2VycyB3aG8gZG9uJ3QgbmVlZFxuXHQgIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcblx0ICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuXHQgIHZhciBjb21iMTBNdWxUbyA9IGZ1bmN0aW9uIGNvbWIxME11bFRvIChzZWxmLCBudW0sIG91dCkge1xuXHQgICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuXHQgICAgdmFyIGIgPSBudW0ud29yZHM7XG5cdCAgICB2YXIgbyA9IG91dC53b3Jkcztcblx0ICAgIHZhciBjID0gMDtcblx0ICAgIHZhciBsbztcblx0ICAgIHZhciBtaWQ7XG5cdCAgICB2YXIgaGk7XG5cdCAgICB2YXIgYTAgPSBhWzBdIHwgMDtcblx0ICAgIHZhciBhbDAgPSBhMCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG5cdCAgICB2YXIgYTEgPSBhWzFdIHwgMDtcblx0ICAgIHZhciBhbDEgPSBhMSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG5cdCAgICB2YXIgYTIgPSBhWzJdIHwgMDtcblx0ICAgIHZhciBhbDIgPSBhMiAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG5cdCAgICB2YXIgYTMgPSBhWzNdIHwgMDtcblx0ICAgIHZhciBhbDMgPSBhMyAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG5cdCAgICB2YXIgYTQgPSBhWzRdIHwgMDtcblx0ICAgIHZhciBhbDQgPSBhNCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG5cdCAgICB2YXIgYTUgPSBhWzVdIHwgMDtcblx0ICAgIHZhciBhbDUgPSBhNSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG5cdCAgICB2YXIgYTYgPSBhWzZdIHwgMDtcblx0ICAgIHZhciBhbDYgPSBhNiAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG5cdCAgICB2YXIgYTcgPSBhWzddIHwgMDtcblx0ICAgIHZhciBhbDcgPSBhNyAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG5cdCAgICB2YXIgYTggPSBhWzhdIHwgMDtcblx0ICAgIHZhciBhbDggPSBhOCAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG5cdCAgICB2YXIgYTkgPSBhWzldIHwgMDtcblx0ICAgIHZhciBhbDkgPSBhOSAmIDB4MWZmZjtcblx0ICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG5cdCAgICB2YXIgYjAgPSBiWzBdIHwgMDtcblx0ICAgIHZhciBibDAgPSBiMCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG5cdCAgICB2YXIgYjEgPSBiWzFdIHwgMDtcblx0ICAgIHZhciBibDEgPSBiMSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG5cdCAgICB2YXIgYjIgPSBiWzJdIHwgMDtcblx0ICAgIHZhciBibDIgPSBiMiAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG5cdCAgICB2YXIgYjMgPSBiWzNdIHwgMDtcblx0ICAgIHZhciBibDMgPSBiMyAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG5cdCAgICB2YXIgYjQgPSBiWzRdIHwgMDtcblx0ICAgIHZhciBibDQgPSBiNCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG5cdCAgICB2YXIgYjUgPSBiWzVdIHwgMDtcblx0ICAgIHZhciBibDUgPSBiNSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG5cdCAgICB2YXIgYjYgPSBiWzZdIHwgMDtcblx0ICAgIHZhciBibDYgPSBiNiAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG5cdCAgICB2YXIgYjcgPSBiWzddIHwgMDtcblx0ICAgIHZhciBibDcgPSBiNyAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG5cdCAgICB2YXIgYjggPSBiWzhdIHwgMDtcblx0ICAgIHZhciBibDggPSBiOCAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG5cdCAgICB2YXIgYjkgPSBiWzldIHwgMDtcblx0ICAgIHZhciBibDkgPSBiOSAmIDB4MWZmZjtcblx0ICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cblx0ICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG5cdCAgICBvdXQubGVuZ3RoID0gMTk7XG5cdCAgICAvKiBrID0gMCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMCwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG5cdCAgICB2YXIgdzAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzAgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuXHQgICAgdmFyIHcxID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcblx0ICAgIHcxICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAyICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMikpIHwgMDtcblx0ICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMyAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsMywgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG5cdCAgICB2YXIgdzMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzMgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDQgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuXHQgICAgdmFyIHc0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcblx0ICAgIHc0ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA1ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNSkpIHwgMDtcblx0ICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3NSAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gNiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsNiwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG5cdCAgICB2YXIgdzYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzYgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDcgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwwKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgyKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuXHQgICAgdmFyIHc3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcblx0ICAgIHc3ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSA4ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoOCkpIHwgMDtcblx0ICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3OCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gOSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgwKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDEpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzkgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzkgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEwICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMSkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDQpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMCAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTEgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMik7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDMpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgzKSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzExICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxMiAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgzKTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDQpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzEyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTIgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDEzICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNCkpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNikpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDcpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcblx0ICAgIHcxMyAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTQgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNSk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDYpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg2KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNykpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE0ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxNSAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg2KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNykpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDcpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG5cdCAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuXHQgICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG5cdCAgICB2YXIgdzE1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTUgJj0gMHgzZmZmZmZmO1xuXHQgICAgLyogayA9IDE2ICovXG5cdCAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG5cdCAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNykpIHwgMDtcblx0ICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoOCkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcblx0ICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOSkpIHwgMDtcblx0ICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG5cdCAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcblx0ICAgIHcxNiAmPSAweDNmZmZmZmY7XG5cdCAgICAvKiBrID0gMTcgKi9cblx0ICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcblx0ICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOCk7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuXHQgICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuXHQgICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDkpKSB8IDA7XG5cdCAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuXHQgICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcblx0ICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg5KSkgfCAwO1xuXHQgICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcblx0ICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuXHQgICAgdzE3ICY9IDB4M2ZmZmZmZjtcblx0ICAgIC8qIGsgPSAxOCAqL1xuXHQgICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuXHQgICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg5KTtcblx0ICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG5cdCAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG5cdCAgICB2YXIgdzE4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuXHQgICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG5cdCAgICB3MTggJj0gMHgzZmZmZmZmO1xuXHQgICAgb1swXSA9IHcwO1xuXHQgICAgb1sxXSA9IHcxO1xuXHQgICAgb1syXSA9IHcyO1xuXHQgICAgb1szXSA9IHczO1xuXHQgICAgb1s0XSA9IHc0O1xuXHQgICAgb1s1XSA9IHc1O1xuXHQgICAgb1s2XSA9IHc2O1xuXHQgICAgb1s3XSA9IHc3O1xuXHQgICAgb1s4XSA9IHc4O1xuXHQgICAgb1s5XSA9IHc5O1xuXHQgICAgb1sxMF0gPSB3MTA7XG5cdCAgICBvWzExXSA9IHcxMTtcblx0ICAgIG9bMTJdID0gdzEyO1xuXHQgICAgb1sxM10gPSB3MTM7XG5cdCAgICBvWzE0XSA9IHcxNDtcblx0ICAgIG9bMTVdID0gdzE1O1xuXHQgICAgb1sxNl0gPSB3MTY7XG5cdCAgICBvWzE3XSA9IHcxNztcblx0ICAgIG9bMThdID0gdzE4O1xuXHQgICAgaWYgKGMgIT09IDApIHtcblx0ICAgICAgb1sxOV0gPSBjO1xuXHQgICAgICBvdXQubGVuZ3RoKys7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gb3V0O1xuXHQgIH07XG5cblx0ICAvLyBQb2x5ZmlsbCBjb21iXG5cdCAgaWYgKCFNYXRoLmltdWwpIHtcblx0ICAgIGNvbWIxME11bFRvID0gc21hbGxNdWxUbztcblx0ICB9XG5cblx0ICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcblx0ICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG5cdCAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgdmFyIGhuY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG5cdCAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcblx0ICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcblx0ICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG5cdCAgICAgIGhuY2FycnkgPSAwO1xuXHQgICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcblx0ICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG5cdCAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcblx0ICAgICAgICB2YXIgaSA9IGsgLSBqO1xuXHQgICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG5cdCAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuXHQgICAgICAgIHZhciByID0gYSAqIGI7XG5cblx0ICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuXHQgICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcblx0ICAgICAgICBsbyA9IChsbyArIHJ3b3JkKSB8IDA7XG5cdCAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcblx0ICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuXHQgICAgICAgIGhuY2FycnkgKz0gbmNhcnJ5ID4+PiAyNjtcblx0ICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuXHQgICAgICB9XG5cdCAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkO1xuXHQgICAgICBjYXJyeSA9IG5jYXJyeTtcblx0ICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcblx0ICAgIH1cblx0ICAgIGlmIChjYXJyeSAhPT0gMCkge1xuXHQgICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIG91dC5sZW5ndGgtLTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIG91dC5zdHJpcCgpO1xuXHQgIH1cblxuXHQgIGZ1bmN0aW9uIGp1bWJvTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG5cdCAgICB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG5cdCAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcblx0ICB9XG5cblx0ICBCTi5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbiBtdWxUbyAobnVtLCBvdXQpIHtcblx0ICAgIHZhciByZXM7XG5cdCAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxMCAmJiBudW0ubGVuZ3RoID09PSAxMCkge1xuXHQgICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG5cdCAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG5cdCAgICAgIHJlcyA9IHNtYWxsTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG5cdCAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcblx0ICAvLyBzbGlnaHRseSByZXZpc2l0ZWQgdG8gcmVseSBvbiBsb29waW5nIGluc3RlYWQgb2YgcmVjdXJzaW9uXG5cblx0ICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG5cdCAgICB0aGlzLnggPSB4O1xuXHQgICAgdGhpcy55ID0geTtcblx0ICB9XG5cblx0ICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuXHQgICAgdmFyIHQgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG5cdCAgICAgIHRbaV0gPSB0aGlzLnJldkJpbihpLCBsLCBOKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHQ7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuXHQgIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuXHQgICAgaWYgKHggPT09IDAgfHwgeCA9PT0gTiAtIDEpIHJldHVybiB4O1xuXG5cdCAgICB2YXIgcmIgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcblx0ICAgICAgcmIgfD0gKHggJiAxKSA8PCAobCAtIGkgLSAxKTtcblx0ICAgICAgeCA+Pj0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJiO1xuXHQgIH07XG5cblx0ICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcblx0ICAvLyBiZWhhdmlvdXIgb2YgdGhlIHJlY3Vyc2l2ZSBhbGdvcml0aG1cblx0ICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgcnR3c1tpXSA9IHJ3c1tyYnRbaV1dO1xuXHQgICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuXHQgICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG5cdCAgICBmb3IgKHZhciBzID0gMTsgcyA8IE47IHMgPDw9IDEpIHtcblx0ICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cblx0ICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcblx0ICAgICAgdmFyIGl0d2RmID0gTWF0aC5zaW4oMiAqIE1hdGguUEkgLyBsKTtcblxuXHQgICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuXHQgICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcblx0ICAgICAgICB2YXIgaXR3ZGZfID0gaXR3ZGY7XG5cblx0ICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuXHQgICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG5cdCAgICAgICAgICB2YXIgaWUgPSBpdHdzW3AgKyBqXTtcblxuXHQgICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuXHQgICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG5cdCAgICAgICAgICB2YXIgcnggPSBydHdkZl8gKiBybyAtIGl0d2RmXyAqIGlvO1xuXG5cdCAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG5cdCAgICAgICAgICBybyA9IHJ4O1xuXG5cdCAgICAgICAgICBydHdzW3AgKyBqXSA9IHJlICsgcm87XG5cdCAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cblx0ICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG5cdCAgICAgICAgICBpdHdzW3AgKyBqICsgc10gPSBpZSAtIGlvO1xuXG5cdCAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuXHQgICAgICAgICAgaWYgKGogIT09IGwpIHtcblx0ICAgICAgICAgICAgcnggPSBydHdkZiAqIHJ0d2RmXyAtIGl0d2RmICogaXR3ZGZfO1xuXG5cdCAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG5cdCAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuXHQgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG5cdCAgICB2YXIgTiA9IE1hdGgubWF4KG0sIG4pIHwgMTtcblx0ICAgIHZhciBvZGQgPSBOICYgMTtcblx0ICAgIHZhciBpID0gMDtcblx0ICAgIGZvciAoTiA9IE4gLyAyIHwgMDsgTjsgTiA9IE4gPj4+IDEpIHtcblx0ICAgICAgaSsrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gMSA8PCBpICsgMSArIG9kZDtcblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuXHQgICAgaWYgKE4gPD0gMSkgcmV0dXJuO1xuXG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcblx0ICAgICAgdmFyIHQgPSByd3NbaV07XG5cblx0ICAgICAgcndzW2ldID0gcndzW04gLSBpIC0gMV07XG5cdCAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuXHQgICAgICB0ID0gaXdzW2ldO1xuXG5cdCAgICAgIGl3c1tpXSA9IC1pd3NbTiAtIGkgLSAxXTtcblx0ICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcblx0ICAgIH1cblx0ICB9O1xuXG5cdCAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuXHQgICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcblx0ICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcblx0ICAgICAgICBjYXJyeTtcblxuXHQgICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cblx0ICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcblx0ICAgICAgICBjYXJyeSA9IDA7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gd3M7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuXHQgICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuXHQgICAgICByd3NbMiAqIGkgKyAxXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcblx0ICAgIH1cblxuXHQgICAgLy8gUGFkIHdpdGggemVyb2VzXG5cdCAgICBmb3IgKGkgPSAyICogbGVuOyBpIDwgTjsgKytpKSB7XG5cdCAgICAgIHJ3c1tpXSA9IDA7XG5cdCAgICB9XG5cblx0ICAgIGFzc2VydChjYXJyeSA9PT0gMCk7XG5cdCAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuXHQgIH07XG5cblx0ICBGRlRNLnByb3RvdHlwZS5zdHViID0gZnVuY3Rpb24gc3R1YiAoTikge1xuXHQgICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgcGhbaV0gPSAwO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcGg7XG5cdCAgfTtcblxuXHQgIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcblx0ICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuXHQgICAgdmFyIHJidCA9IHRoaXMubWFrZVJCVChOKTtcblxuXHQgICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cblx0ICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG5cdCAgICB2YXIgcndzdCA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG5cdCAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBucndzdCA9IG5ldyBBcnJheShOKTtcblx0ICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuXHQgICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG5cdCAgICBybXdzLmxlbmd0aCA9IE47XG5cblx0ICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcblx0ICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cblx0ICAgIHRoaXMudHJhbnNmb3JtKHJ3cywgXywgcndzdCwgaXdzdCwgTiwgcmJ0KTtcblx0ICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcblx0ICAgICAgdmFyIHJ4ID0gcndzdFtpXSAqIG5yd3N0W2ldIC0gaXdzdFtpXSAqIG5pd3N0W2ldO1xuXHQgICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuXHQgICAgICByd3N0W2ldID0gcng7XG5cdCAgICB9XG5cblx0ICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuXHQgICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcblx0ICAgIHRoaXMuY29uanVnYXRlKHJtd3MsIF8sIE4pO1xuXHQgICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cblx0ICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuXHQgICAgb3V0Lmxlbmd0aCA9IHgubGVuZ3RoICsgeS5sZW5ndGg7XG5cdCAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuXHQgIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuXHQgICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcblx0ICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuXHQgICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuXHQgIH07XG5cblx0ICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG5cdCAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcblx0ICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG5cdCAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcblx0ICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcblx0ICB9O1xuXG5cdCAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cblx0ICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhudW0sIHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cblx0ICAgIC8vIENhcnJ5XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcblx0ICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcblx0ICAgICAgY2FycnkgPj49IDI2O1xuXHQgICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuXHQgICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG5cdCAgICAgIGNhcnJ5ICs9IGxvID4+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXG5cdCAgICBpZiAoY2FycnkgIT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuXHQgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcblx0ICB9O1xuXG5cdCAgLy8gYHRoaXNgICogYHRoaXNgXG5cdCAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tdWwodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuXHQgIEJOLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoKSB7XG5cdCAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG5cdCAgfTtcblxuXHQgIC8vIE1hdGgucG93KGB0aGlzYCwgYG51bWApXG5cdCAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG5cdCAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcblx0ICAgIGlmICh3Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIG5ldyBCTigxKTtcblxuXHQgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuXHQgICAgdmFyIHJlcyA9IHRoaXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHcubGVuZ3RoOyBpKyssIHJlcyA9IHJlcy5zcXIoKSkge1xuXHQgICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG5cdCAgICB9XG5cblx0ICAgIGlmICgrK2kgPCB3Lmxlbmd0aCkge1xuXHQgICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcblx0ICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cblx0ICAgICAgICByZXMgPSByZXMubXVsKHEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2Vcblx0ICBCTi5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24gaXVzaGxuIChiaXRzKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG5cdCAgICB2YXIgciA9IGJpdHMgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXHQgICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcblx0ICAgIHZhciBpO1xuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICB2YXIgY2FycnkgPSAwO1xuXG5cdCAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgdmFyIG5ld0NhcnJ5ID0gdGhpcy53b3Jkc1tpXSAmIGNhcnJ5TWFzaztcblx0ICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcblx0ICAgICAgICBjYXJyeSA9IG5ld0NhcnJ5ID4+PiAoMjYgLSByKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIGlmIChjYXJyeSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgICB0aGlzLmxlbmd0aCsrO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIGlmIChzICE9PSAwKSB7XG5cdCAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyBzXSA9IHRoaXMud29yZHNbaV07XG5cdCAgICAgIH1cblxuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG5cdCAgICAgIH1cblxuXHQgICAgICB0aGlzLmxlbmd0aCArPSBzO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuXHQgICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG5cdCAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG5cdCAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG5cdCAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG5cdCAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuXHQgIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG5cdCAgICB2YXIgaDtcblx0ICAgIGlmIChoaW50KSB7XG5cdCAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaCA9IDA7XG5cdCAgICB9XG5cblx0ICAgIHZhciByID0gYml0cyAlIDI2O1xuXHQgICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcblx0ICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuXHQgICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cblx0ICAgIGggLT0gcztcblx0ICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuXHQgICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuXHQgICAgaWYgKG1hc2tlZFdvcmRzKSB7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG5cdCAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuXHQgICAgICB9XG5cdCAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChzID09PSAwKSB7XG5cdCAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG5cdCAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuXHQgICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuXHQgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcblx0ICAgICAgfVxuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGNhcnJ5ID0gMDtcblx0ICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcblx0ICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG5cdCAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG5cdCAgICB9XG5cblx0ICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuXHQgICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuXHQgICAgfVxuXG5cdCAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcblx0ICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHRoaXMubGVuZ3RoID0gMTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG5cdCAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcblx0ICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG5cdCAgfTtcblxuXHQgIC8vIFNoaWZ0LWxlZnRcblx0ICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gU2hpZnQtcmlnaHRcblx0ICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcblx0ICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oYml0cyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hybihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcblx0ICBCTi5wcm90b3R5cGUudGVzdG4gPSBmdW5jdGlvbiB0ZXN0biAoYml0KSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXQgJSAyNjtcblx0ICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG5cdCAgICB2YXIgcSA9IDEgPDwgcjtcblxuXHQgICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSByZXR1cm4gZmFsc2U7XG5cblx0ICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG5cdCAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cblx0ICAgIHJldHVybiAhISh3ICYgcSk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG5cdCAgQk4ucHJvdG90eXBlLmltYXNrbiA9IGZ1bmN0aW9uIGltYXNrbiAoYml0cykge1xuXHQgICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuXHQgICAgdmFyIHIgPSBiaXRzICUgMjY7XG5cdCAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcblxuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcblx0ICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyICE9PSAwKSB7XG5cdCAgICAgIHMrKztcblx0ICAgIH1cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG5cdCAgICBpZiAociAhPT0gMCkge1xuXHQgICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcblx0ICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuXHQgIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihiaXRzKTtcblx0ICB9O1xuXG5cdCAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2Bcblx0ICBCTi5wcm90b3R5cGUuaWFkZG4gPSBmdW5jdGlvbiBpYWRkbiAobnVtKSB7XG5cdCAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuXHQgICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG5cdCAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaXN1Ym4oLW51bSk7XG5cblx0ICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgKHRoaXMud29yZHNbMF0gfCAwKSA8IG51bSkge1xuXHQgICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuXHQgICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXHQgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICB9XG5cblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaXN1Ym4obnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBZGQgd2l0aG91dCBjaGVja3Ncblx0ICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcblx0ICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG5cdCAgICAvLyBDYXJyeVxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuXHQgICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG5cdCAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG5cdCAgICAgIH1cblx0ICAgIH1cblx0ICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuXHQgIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG5cdCAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblx0ICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cdCAgICAgIHRoaXMuaWFkZG4obnVtKTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcblx0ICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBDYXJyeVxuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcblx0ICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcblx0ICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWJuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG5cdCAgICB0aGlzLm5lZ2F0aXZlID0gMDtcblxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMgKCkge1xuXHQgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5faXNobG5zdWJtdWwgPSBmdW5jdGlvbiBfaXNobG5zdWJtdWwgKG51bSwgbXVsLCBzaGlmdCkge1xuXHQgICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcblx0ICAgIHZhciBpO1xuXG5cdCAgICB0aGlzLl9leHBhbmQobGVuKTtcblxuXHQgICAgdmFyIHc7XG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG5cdCAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcblx0ICAgICAgdyAtPSByaWdodCAmIDB4M2ZmZmZmZjtcblx0ICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuXHQgICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuXHQgICAgfVxuXHQgICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcblx0ICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuXHQgICAgICBjYXJyeSA9IHcgPj4gMjY7XG5cdCAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cblx0ICAgIGlmIChjYXJyeSA9PT0gMCkgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcblx0ICAgIGFzc2VydChjYXJyeSA9PT0gLTEpO1xuXHQgICAgY2FycnkgPSAwO1xuXHQgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdyA9IC0odGhpcy53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG5cdCAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcblx0ICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cdCAgICB9XG5cdCAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuXHQgICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuXHQgICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG5cdCAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcblx0ICAgIHZhciBiID0gbnVtO1xuXG5cdCAgICAvLyBOb3JtYWxpemVcblx0ICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuXHQgICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcblx0ICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuXHQgICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG5cdCAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcblx0ICAgICAgYS5pdXNobG4oc2hpZnQpO1xuXHQgICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuXHQgICAgfVxuXG5cdCAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG5cdCAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG5cdCAgICB2YXIgcTtcblxuXHQgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG5cdCAgICAgIHEubGVuZ3RoID0gbSArIDE7XG5cdCAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuXHQgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICBxLndvcmRzW2ldID0gMDtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG5cdCAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuXHQgICAgICBhID0gZGlmZjtcblx0ICAgICAgaWYgKHEpIHtcblx0ICAgICAgICBxLndvcmRzW21dID0gMTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG5cdCAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG5cdCAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuXHQgICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuXHQgICAgICAvLyAoMHg3ZmZmZmZmKVxuXHQgICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG5cdCAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcblx0ICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICBxai0tO1xuXHQgICAgICAgIGEubmVnYXRpdmUgPSAwO1xuXHQgICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuXHQgICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICBpZiAocSkge1xuXHQgICAgICAgIHEud29yZHNbal0gPSBxajtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKHEpIHtcblx0ICAgICAgcS5zdHJpcCgpO1xuXHQgICAgfVxuXHQgICAgYS5zdHJpcCgpO1xuXG5cdCAgICAvLyBEZW5vcm1hbGl6ZVxuXHQgICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG5cdCAgICAgIGEuaXVzaHJuKHNoaWZ0KTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHtcblx0ICAgICAgZGl2OiBxIHx8IG51bGwsXG5cdCAgICAgIG1vZDogYVxuXHQgICAgfTtcblx0ICB9O1xuXG5cdCAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcblx0ICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cblx0ICAvLyAgICAgICByZXF1ZXN0IGJvdGggZGl2ICYgbW9kXG5cdCAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcblx0ICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG5cdCAgICBhc3NlcnQoIW51bS5pc1plcm8oKSk7XG5cblx0ICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBuZXcgQk4oMCksXG5cdCAgICAgICAgbW9kOiBuZXcgQk4oMClcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGRpdiwgbW9kLCByZXM7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcblx0ICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLCBtb2RlKTtcblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcblx0ICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG5cdCAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcblx0ICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgICAgICBtb2QuaWFkZChudW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBkaXYsXG5cdCAgICAgICAgbW9kOiBtb2Rcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cblx0ICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG5cdCAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcblx0ICAgICAgfVxuXG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgZGl2OiBkaXYsXG5cdCAgICAgICAgbW9kOiByZXMubW9kXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcblx0ICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuXHQgICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcblx0ICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuXHQgICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcblx0ICAgICAgICAgIG1vZC5pc3ViKG51bSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgcmV0dXJuIHtcblx0ICAgICAgICBkaXY6IHJlcy5kaXYsXG5cdCAgICAgICAgbW9kOiBtb2Rcblx0ICAgICAgfTtcblx0ICAgIH1cblxuXHQgICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cblx0ICAgIC8vIFN0cmlwIGJvdGggbnVtYmVycyB0byBhcHByb3hpbWF0ZSBzaGlmdCB2YWx1ZVxuXHQgICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogbmV3IEJOKDApLFxuXHQgICAgICAgIG1vZDogdGhpc1xuXHQgICAgICB9O1xuXHQgICAgfVxuXG5cdCAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuXHQgICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcblx0ICAgICAgaWYgKG1vZGUgPT09ICdkaXYnKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG5cdCAgICAgICAgICBtb2Q6IG51bGxcblx0ICAgICAgICB9O1xuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKG1vZGUgPT09ICdtb2QnKSB7XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgIGRpdjogbnVsbCxcblx0ICAgICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kbihudW0ud29yZHNbMF0pKVxuXHQgICAgICAgIH07XG5cdCAgICAgIH1cblxuXHQgICAgICByZXR1cm4ge1xuXHQgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG5cdCAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG5cdCAgICAgIH07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG5cdCAgfTtcblxuXHQgIC8vIEZpbmQgYHRoaXNgIC8gYG51bWBcblx0ICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuXHQgIH07XG5cblx0ICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgZmFsc2UpLm1vZDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCB0cnVlKS5tb2Q7XG5cdCAgfTtcblxuXHQgIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG5cdCAgQk4ucHJvdG90eXBlLmRpdlJvdW5kID0gZnVuY3Rpb24gZGl2Um91bmQgKG51bSkge1xuXHQgICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuXHQgICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cblx0ICAgIGlmIChkbS5tb2QuaXNaZXJvKCkpIHJldHVybiBkbS5kaXY7XG5cblx0ICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG5cdCAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcblx0ICAgIHZhciByMiA9IG51bS5hbmRsbigxKTtcblx0ICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG5cdCAgICAvLyBSb3VuZCBkb3duXG5cdCAgICBpZiAoY21wIDwgMCB8fCByMiA9PT0gMSAmJiBjbXAgPT09IDApIHJldHVybiBkbS5kaXY7XG5cblx0ICAgIC8vIFJvdW5kIHVwXG5cdCAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuXHQgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXHQgICAgdmFyIHAgPSAoMSA8PCAyNikgJSBudW07XG5cblx0ICAgIHZhciBhY2MgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgYWNjID0gKHAgKiBhY2MgKyAodGhpcy53b3Jkc1tpXSB8IDApKSAlIG51bTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGFjYztcblx0ICB9O1xuXG5cdCAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG5cdCAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuXHQgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG5cdCAgICB2YXIgY2FycnkgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuXHQgICAgICBjYXJyeSA9IHcgJSBudW07XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24gZGl2biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5lZ2NkID0gZnVuY3Rpb24gZWdjZCAocCkge1xuXHQgICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuXHQgICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuXHQgICAgdmFyIHggPSB0aGlzO1xuXHQgICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cblx0ICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG5cdCAgICAgIHggPSB4LnVtb2QocCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB4ID0geC5jbG9uZSgpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBBICogeCArIEIgKiB5ID0geFxuXHQgICAgdmFyIEEgPSBuZXcgQk4oMSk7XG5cdCAgICB2YXIgQiA9IG5ldyBCTigwKTtcblxuXHQgICAgLy8gQyAqIHggKyBEICogeSA9IHlcblx0ICAgIHZhciBDID0gbmV3IEJOKDApO1xuXHQgICAgdmFyIEQgPSBuZXcgQk4oMSk7XG5cblx0ICAgIHZhciBnID0gMDtcblxuXHQgICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuXHQgICAgICB4Lml1c2hybigxKTtcblx0ICAgICAgeS5pdXNocm4oMSk7XG5cdCAgICAgICsrZztcblx0ICAgIH1cblxuXHQgICAgdmFyIHlwID0geS5jbG9uZSgpO1xuXHQgICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG5cdCAgICB3aGlsZSAoIXguaXNaZXJvKCkpIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcblx0ICAgICAgaWYgKGkgPiAwKSB7XG5cdCAgICAgICAgeC5pdXNocm4oaSk7XG5cdCAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcblx0ICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIEEuaWFkZCh5cCk7XG5cdCAgICAgICAgICAgIEIuaXN1Yih4cCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIEEuaXVzaHJuKDEpO1xuXHQgICAgICAgICAgQi5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcblx0ICAgICAgaWYgKGogPiAwKSB7XG5cdCAgICAgICAgeS5pdXNocm4oaik7XG5cdCAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcblx0ICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIEMuaWFkZCh5cCk7XG5cdCAgICAgICAgICAgIEQuaXN1Yih4cCk7XG5cdCAgICAgICAgICB9XG5cblx0ICAgICAgICAgIEMuaXVzaHJuKDEpO1xuXHQgICAgICAgICAgRC5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKHguY21wKHkpID49IDApIHtcblx0ICAgICAgICB4LmlzdWIoeSk7XG5cdCAgICAgICAgQS5pc3ViKEMpO1xuXHQgICAgICAgIEIuaXN1YihEKTtcblx0ICAgICAgfSBlbHNlIHtcblx0ICAgICAgICB5LmlzdWIoeCk7XG5cdCAgICAgICAgQy5pc3ViKEEpO1xuXHQgICAgICAgIEQuaXN1YihCKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICByZXR1cm4ge1xuXHQgICAgICBhOiBDLFxuXHQgICAgICBiOiBELFxuXHQgICAgICBnY2Q6IHkuaXVzaGxuKGcpXG5cdCAgICB9O1xuXHQgIH07XG5cblx0ICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcblx0ICAvLyBhYm92ZSwgZGVzaWduYXRlZCB0byBpbnZlcnQgbWVtYmVycyBvZiB0aGVcblx0ICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuXHQgIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcblx0ICAgIGFzc2VydChwLm5lZ2F0aXZlID09PSAwKTtcblx0ICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cblx0ICAgIHZhciBhID0gdGhpcztcblx0ICAgIHZhciBiID0gcC5jbG9uZSgpO1xuXG5cdCAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBhID0gYS51bW9kKHApO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYSA9IGEuY2xvbmUoKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHgxID0gbmV3IEJOKDEpO1xuXHQgICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG5cdCAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cblx0ICAgIHdoaWxlIChhLmNtcG4oMSkgPiAwICYmIGIuY21wbigxKSA+IDApIHtcblx0ICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcblx0ICAgICAgaWYgKGkgPiAwKSB7XG5cdCAgICAgICAgYS5pdXNocm4oaSk7XG5cdCAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcblx0ICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIHgxLmlhZGQoZGVsdGEpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB4MS5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcblx0ICAgICAgaWYgKGogPiAwKSB7XG5cdCAgICAgICAgYi5pdXNocm4oaik7XG5cdCAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcblx0ICAgICAgICAgIGlmICh4Mi5pc09kZCgpKSB7XG5cdCAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuXHQgICAgICAgICAgfVxuXG5cdCAgICAgICAgICB4Mi5pdXNocm4oMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICB9XG5cblx0ICAgICAgaWYgKGEuY21wKGIpID49IDApIHtcblx0ICAgICAgICBhLmlzdWIoYik7XG5cdCAgICAgICAgeDEuaXN1Yih4Mik7XG5cdCAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgYi5pc3ViKGEpO1xuXHQgICAgICAgIHgyLmlzdWIoeDEpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHZhciByZXM7XG5cdCAgICBpZiAoYS5jbXBuKDEpID09PSAwKSB7XG5cdCAgICAgIHJlcyA9IHgxO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgcmVzID0geDI7XG5cdCAgICB9XG5cblx0ICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcblx0ICAgICAgcmVzLmlhZGQocCk7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuXHQgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG5cdCAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcblxuXHQgICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG5cdCAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuXHQgICAgYS5uZWdhdGl2ZSA9IDA7XG5cdCAgICBiLm5lZ2F0aXZlID0gMDtcblxuXHQgICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG5cdCAgICBmb3IgKHZhciBzaGlmdCA9IDA7IGEuaXNFdmVuKCkgJiYgYi5pc0V2ZW4oKTsgc2hpZnQrKykge1xuXHQgICAgICBhLml1c2hybigxKTtcblx0ICAgICAgYi5pdXNocm4oMSk7XG5cdCAgICB9XG5cblx0ICAgIGRvIHtcblx0ICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcblx0ICAgICAgICBhLml1c2hybigxKTtcblx0ICAgICAgfVxuXHQgICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuXHQgICAgICAgIGIuaXVzaHJuKDEpO1xuXHQgICAgICB9XG5cblx0ICAgICAgdmFyIHIgPSBhLmNtcChiKTtcblx0ICAgICAgaWYgKHIgPCAwKSB7XG5cdCAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG5cdCAgICAgICAgdmFyIHQgPSBhO1xuXHQgICAgICAgIGEgPSBiO1xuXHQgICAgICAgIGIgPSB0O1xuXHQgICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICAgIH1cblxuXHQgICAgICBhLmlzdWIoYik7XG5cdCAgICB9IHdoaWxlICh0cnVlKTtcblxuXHQgICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcblx0ICB9O1xuXG5cdCAgLy8gSW52ZXJ0IG51bWJlciBpbiB0aGUgZmllbGQgRihudW0pXG5cdCAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG5cdCAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuXHQgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG5cdCAgfTtcblxuXHQgIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cblx0ICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy53b3Jkc1swXSAmIG51bTtcblx0ICB9O1xuXG5cdCAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuXHQgIEJOLnByb3RvdHlwZS5iaW5jbiA9IGZ1bmN0aW9uIGJpbmNuIChiaXQpIHtcblx0ICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG5cdCAgICB2YXIgciA9IGJpdCAlIDI2O1xuXHQgICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcblx0ICAgIHZhciBxID0gMSA8PCByO1xuXG5cdCAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuXHQgICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcblx0ICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcblx0ICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuXHQgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH1cblxuXHQgICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcblx0ICAgIHZhciBjYXJyeSA9IHE7XG5cdCAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdyArPSBjYXJyeTtcblx0ICAgICAgY2FycnkgPSB3ID4+PiAyNjtcblx0ICAgICAgdyAmPSAweDNmZmZmZmY7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSB3O1xuXHQgICAgfVxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIHRoaXMud29yZHNbaV0gPSBjYXJyeTtcblx0ICAgICAgdGhpcy5sZW5ndGgrKztcblx0ICAgIH1cblx0ICAgIHJldHVybiB0aGlzO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcblx0ICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gbnVtIDwgMDtcblxuXHQgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cblx0ICAgIHRoaXMuc3RyaXAoKTtcblxuXHQgICAgdmFyIHJlcztcblx0ICAgIGlmICh0aGlzLmxlbmd0aCA+IDEpIHtcblx0ICAgICAgcmVzID0gMTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChuZWdhdGl2ZSkge1xuXHQgICAgICAgIG51bSA9IC1udW07XG5cdCAgICAgIH1cblxuXHQgICAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZiwgJ051bWJlciBpcyB0b28gYmlnJyk7XG5cblx0ICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcblx0ICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG5cdCAgICB9XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuXHQgIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuXHQgIC8vIDAgLSBpZiBgdGhpc2AgPT0gYG51bWBcblx0ICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG5cdCAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG5cdCAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cblx0ICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcblx0ICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICAvLyBVbnNpZ25lZCBjb21wYXJpc29uXG5cdCAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcblx0ICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuXHQgICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIDE7XG5cdCAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cblx0ICAgIHZhciByZXMgPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcblx0ICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG5cdCAgICAgIGlmIChhID09PSBiKSBjb250aW51ZTtcblx0ICAgICAgaWYgKGEgPCBiKSB7XG5cdCAgICAgICAgcmVzID0gLTE7XG5cdCAgICAgIH0gZWxzZSBpZiAoYSA+IGIpIHtcblx0ICAgICAgICByZXMgPSAxO1xuXHQgICAgICB9XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG5cdCAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuXHQgICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG5cdCAgfTtcblxuXHQgIC8vXG5cdCAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcblx0ICAvLyBvbiB0aGUgYG1gIGl0c2VsZi5cblx0ICAvL1xuXHQgIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG5cdCAgICByZXR1cm4gbmV3IFJlZChudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG5cdCAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuXHQgICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuXHQgICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuY29udmVydEZyb20odGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuXHQgICAgdGhpcy5yZWQgPSBjdHg7XG5cdCAgICByZXR1cm4gdGhpcztcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24gZm9yY2VSZWQgKGN0eCkge1xuXHQgICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcblx0ICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5hZGQodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24gcmVkU3ViIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuaXN1Yih0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNobCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZE11bCA9IGZ1bmN0aW9uIHJlZE11bCAobnVtKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLm11bCh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuXHQgIH07XG5cblx0ICBCTi5wcm90b3R5cGUucmVkSVNxciA9IGZ1bmN0aW9uIHJlZElTcXIgKCkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLmlzcXIodGhpcyk7XG5cdCAgfTtcblxuXHQgIC8vIFNxdWFyZSByb290IG92ZXIgcFxuXHQgIEJOLnByb3RvdHlwZS5yZWRTcXJ0ID0gZnVuY3Rpb24gcmVkU3FydCAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG5cdCAgICByZXR1cm4gdGhpcy5yZWQuc3FydCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcblx0ICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuXHQgIH07XG5cblx0ICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG5cdCAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG5cdCAgICBhc3NlcnQodGhpcy5yZWQsICdyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcblx0ICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG5cdCAgfTtcblxuXHQgIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuXHQgICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcblx0ICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuXHQgICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuXHQgIH07XG5cblx0ICAvLyBQcmltZSBudW1iZXJzIHdpdGggZWZmaWNpZW50IHJlZHVjdGlvblxuXHQgIHZhciBwcmltZXMgPSB7XG5cdCAgICBrMjU2OiBudWxsLFxuXHQgICAgcDIyNDogbnVsbCxcblx0ICAgIHAxOTI6IG51bGwsXG5cdCAgICBwMjU1MTk6IG51bGxcblx0ICB9O1xuXG5cdCAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG5cdCAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG5cdCAgICAvLyBQID0gMiBeIE4gLSBLXG5cdCAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHQgICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcblx0ICAgIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKTtcblx0ICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cblx0ICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG5cdCAgfVxuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG5cdCAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuXHQgICAgdG1wLndvcmRzID0gbmV3IEFycmF5KE1hdGguY2VpbCh0aGlzLm4gLyAxMykpO1xuXHQgICAgcmV0dXJuIHRtcDtcblx0ICB9O1xuXG5cdCAgTVByaW1lLnByb3RvdHlwZS5pcmVkdWNlID0gZnVuY3Rpb24gaXJlZHVjZSAobnVtKSB7XG5cdCAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG5cdCAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG5cdCAgICB2YXIgciA9IG51bTtcblx0ICAgIHZhciBybGVuO1xuXG5cdCAgICBkbyB7XG5cdCAgICAgIHRoaXMuc3BsaXQociwgdGhpcy50bXApO1xuXHQgICAgICByID0gdGhpcy5pbXVsSyhyKTtcblx0ICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG5cdCAgICAgIHJsZW4gPSByLmJpdExlbmd0aCgpO1xuXHQgICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cblx0ICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcblx0ICAgIGlmIChjbXAgPT09IDApIHtcblx0ICAgICAgci53b3Jkc1swXSA9IDA7XG5cdCAgICAgIHIubGVuZ3RoID0gMTtcblx0ICAgIH0gZWxzZSBpZiAoY21wID4gMCkge1xuXHQgICAgICByLmlzdWIodGhpcy5wKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGlmIChyLnN0cmlwICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAvLyByIGlzIEJOIHY0IGluc3RhbmNlXG5cdCAgICAgICAgci5zdHJpcCgpO1xuXHQgICAgICB9IGVsc2Uge1xuXHQgICAgICAgIC8vIHIgaXMgQk4gdjUgaW5zdGFuY2Vcblx0ICAgICAgICByLl9zdHJpcCgpO1xuXHQgICAgICB9XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByO1xuXHQgIH07XG5cblx0ICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcblx0ICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG5cdCAgfTtcblxuXHQgIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG5cdCAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcblx0ICB9O1xuXG5cdCAgZnVuY3Rpb24gSzI1NiAoKSB7XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJ2syNTYnLFxuXHQgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuXHQgIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcblx0ICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG5cdCAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG5cdCAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcblx0ICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG5cdCAgICB9XG5cdCAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG5cdCAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcblx0ICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuXHQgICAgICBpbnB1dC5sZW5ndGggPSAxO1xuXHQgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcblx0ICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG5cdCAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG5cdCAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuXHQgICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuXHQgICAgICBwcmV2ID0gbmV4dDtcblx0ICAgIH1cblx0ICAgIHByZXYgPj4+PSAyMjtcblx0ICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuXHQgICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcblx0ICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuXHQgICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG5cdCAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuXHQgICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG5cdCAgICBudW0ubGVuZ3RoICs9IDI7XG5cblx0ICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG5cdCAgICB2YXIgbG8gPSAwO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuXHQgICAgICBsbyArPSB3ICogMHgzZDE7XG5cdCAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuXHQgICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcblx0ICAgIH1cblxuXHQgICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG5cdCAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuXHQgICAgICBudW0ubGVuZ3RoLS07XG5cdCAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG5cdCAgICAgICAgbnVtLmxlbmd0aC0tO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVtO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBQMjI0ICgpIHtcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAncDIyNCcsXG5cdCAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG5cdCAgZnVuY3Rpb24gUDE5MiAoKSB7XG5cdCAgICBNUHJpbWUuY2FsbChcblx0ICAgICAgdGhpcyxcblx0ICAgICAgJ3AxOTInLFxuXHQgICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcblx0ICB9XG5cdCAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuXHQgIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG5cdCAgICAvLyAyIF4gMjU1IC0gMTlcblx0ICAgIE1QcmltZS5jYWxsKFxuXHQgICAgICB0aGlzLFxuXHQgICAgICAnMjU1MTknLFxuXHQgICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cblx0ICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuXHQgICAgLy8gSyA9IDB4MTNcblx0ICAgIHZhciBjYXJyeSA9IDA7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuXHQgICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG5cdCAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuXHQgICAgICBoaSA+Pj49IDI2O1xuXG5cdCAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuXHQgICAgICBjYXJyeSA9IGhpO1xuXHQgICAgfVxuXHQgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG5cdCAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbnVtO1xuXHQgIH07XG5cblx0ICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcblx0ICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuXHQgICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcblx0ICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cblx0ICAgIHZhciBwcmltZTtcblx0ICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuXHQgICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuXHQgICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcblx0ICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuXHQgICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuXHQgICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG5cdCAgICB9XG5cdCAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuXHQgICAgcmV0dXJuIHByaW1lO1xuXHQgIH07XG5cblx0ICAvL1xuXHQgIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuXHQgIC8vXG5cdCAgZnVuY3Rpb24gUmVkIChtKSB7XG5cdCAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG5cdCAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcblx0ICAgICAgdGhpcy5tID0gcHJpbWUucDtcblx0ICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG5cdCAgICAgIHRoaXMubSA9IG07XG5cdCAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuXHQgICAgfVxuXHQgIH1cblxuXHQgIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuXHQgICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuXHQgICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcblx0ICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcblx0ICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG5cdCAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcblx0ICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcblx0ICAgIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnIChhKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSkge1xuXHQgICAgICByZXR1cm4gYS5jbG9uZSgpO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5hZGQoYik7XG5cdCAgICBpZiAocmVzLmNtcCh0aGlzLm0pID49IDApIHtcblx0ICAgICAgcmVzLmlzdWIodGhpcy5tKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG5cdCAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuXHQgICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcy5pc3ViKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuXHQgICAgdmFyIHJlcyA9IGEuc3ViKGIpO1xuXHQgICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaXN1YiA9IGZ1bmN0aW9uIGlzdWIgKGEsIGIpIHtcblx0ICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cblx0ICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG5cdCAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkxKGEpO1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG5cdCAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXHQgICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuXHQgICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblx0ICAgIHJldHVybiB0aGlzLmltb2QoYS5tdWwoYikpO1xuXHQgIH07XG5cblx0ICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG5cdCAgICByZXR1cm4gdGhpcy5pbXVsKGEsIGEuY2xvbmUoKSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG5cdCAgICByZXR1cm4gdGhpcy5tdWwoYSwgYSk7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcblx0ICAgIGlmIChhLmlzWmVybygpKSByZXR1cm4gYS5jbG9uZSgpO1xuXG5cdCAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcblx0ICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cblx0ICAgIC8vIEZhc3QgY2FzZVxuXHQgICAgaWYgKG1vZDMgPT09IDMpIHtcblx0ICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG5cdCAgICAgIHJldHVybiB0aGlzLnBvdyhhLCBwb3cpO1xuXHQgICAgfVxuXG5cdCAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG5cdCAgICAvL1xuXHQgICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcblx0ICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG5cdCAgICB2YXIgcyA9IDA7XG5cdCAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuXHQgICAgICBzKys7XG5cdCAgICAgIHEuaXVzaHJuKDEpO1xuXHQgICAgfVxuXHQgICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuXHQgICAgdmFyIG9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcblx0ICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG5cdCAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuXHQgICAgLy8gTk9URTogTWF4IGlzIHN1Y2ggYmVjYXVzZSBvZiBnZW5lcmFsaXplZCBSaWVtYW5uIGh5cG90aGVzaXMuXG5cdCAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcblx0ICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuXHQgICAgeiA9IG5ldyBCTigyICogeiAqIHopLnRvUmVkKHRoaXMpO1xuXG5cdCAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG5cdCAgICAgIHoucmVkSUFkZChuT25lKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcblx0ICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG5cdCAgICB2YXIgdCA9IHRoaXMucG93KGEsIHEpO1xuXHQgICAgdmFyIG0gPSBzO1xuXHQgICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcblx0ICAgICAgdmFyIHRtcCA9IHQ7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuXHQgICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcblx0ICAgICAgfVxuXHQgICAgICBhc3NlcnQoaSA8IG0pO1xuXHQgICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cblx0ICAgICAgciA9IHIucmVkTXVsKGIpO1xuXHQgICAgICBjID0gYi5yZWRTcXIoKTtcblx0ICAgICAgdCA9IHQucmVkTXVsKGMpO1xuXHQgICAgICBtID0gaTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcblx0ICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuXHQgICAgaWYgKGludi5uZWdhdGl2ZSAhPT0gMCkge1xuXHQgICAgICBpbnYubmVnYXRpdmUgPSAwO1xuXHQgICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG5cdCAgICB9XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcblx0ICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG5cdCAgICBpZiAobnVtLmNtcG4oMSkgPT09IDApIHJldHVybiBhLmNsb25lKCk7XG5cblx0ICAgIHZhciB3aW5kb3dTaXplID0gNDtcblx0ICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcblx0ICAgIHduZFswXSA9IG5ldyBCTigxKS50b1JlZCh0aGlzKTtcblx0ICAgIHduZFsxXSA9IGE7XG5cdCAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICB3bmRbaV0gPSB0aGlzLm11bCh3bmRbaSAtIDFdLCBhKTtcblx0ICAgIH1cblxuXHQgICAgdmFyIHJlcyA9IHduZFswXTtcblx0ICAgIHZhciBjdXJyZW50ID0gMDtcblx0ICAgIHZhciBjdXJyZW50TGVuID0gMDtcblx0ICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuXHQgICAgaWYgKHN0YXJ0ID09PSAwKSB7XG5cdCAgICAgIHN0YXJ0ID0gMjY7XG5cdCAgICB9XG5cblx0ICAgIGZvciAoaSA9IG51bS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHQgICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcblx0ICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0ICAgICAgICB2YXIgYml0ID0gKHdvcmQgPj4gaikgJiAxO1xuXHQgICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuXHQgICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcblx0ICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuXHQgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgY3VycmVudCA8PD0gMTtcblx0ICAgICAgICBjdXJyZW50IHw9IGJpdDtcblx0ICAgICAgICBjdXJyZW50TGVuKys7XG5cdCAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG5cdCAgICAgICAgcmVzID0gdGhpcy5tdWwocmVzLCB3bmRbY3VycmVudF0pO1xuXHQgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuXHQgICAgICAgIGN1cnJlbnQgPSAwO1xuXHQgICAgICB9XG5cdCAgICAgIHN0YXJ0ID0gMjY7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcblx0ICAgIHZhciByID0gbnVtLnVtb2QodGhpcy5tKTtcblxuXHQgICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG5cdCAgfTtcblxuXHQgIFJlZC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG5cdCAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG5cdCAgICByZXMucmVkID0gbnVsbDtcblx0ICAgIHJldHVybiByZXM7XG5cdCAgfTtcblxuXHQgIC8vXG5cdCAgLy8gTW9udGdvbWVyeSBtZXRob2QgZW5naW5lXG5cdCAgLy9cblxuXHQgIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcblx0ICAgIHJldHVybiBuZXcgTW9udChudW0pO1xuXHQgIH07XG5cblx0ICBmdW5jdGlvbiBNb250IChtKSB7XG5cdCAgICBSZWQuY2FsbCh0aGlzLCBtKTtcblxuXHQgICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcblx0ICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcblx0ICAgICAgdGhpcy5zaGlmdCArPSAyNiAtICh0aGlzLnNoaWZ0ICUgMjYpO1xuXHQgICAgfVxuXG5cdCAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuXHQgICAgdGhpcy5yMiA9IHRoaXMuaW1vZCh0aGlzLnIuc3FyKCkpO1xuXHQgICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG5cdCAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG5cdCAgICB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpO1xuXHQgICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuXHQgIH1cblx0ICBpbmhlcml0cyhNb250LCBSZWQpO1xuXG5cdCAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcblx0ICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG5cdCAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuXHQgICAgci5yZWQgPSBudWxsO1xuXHQgICAgcmV0dXJuIHI7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChhLCBiKSB7XG5cdCAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG5cdCAgICAgIGEud29yZHNbMF0gPSAwO1xuXHQgICAgICBhLmxlbmd0aCA9IDE7XG5cdCAgICAgIHJldHVybiBhO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgdCA9IGEuaW11bChiKTtcblx0ICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG5cdCAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG5cdCAgICB2YXIgcmVzID0gdTtcblxuXHQgICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuXHQgICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcblx0ICAgIH0gZWxzZSBpZiAodS5jbXBuKDApIDwgMCkge1xuXHQgICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblxuXHQgIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuXHQgICAgaWYgKGEuaXNaZXJvKCkgfHwgYi5pc1plcm8oKSkgcmV0dXJuIG5ldyBCTigwKS5fZm9yY2VSZWQodGhpcyk7XG5cblx0ICAgIHZhciB0ID0gYS5tdWwoYik7XG5cdCAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuXHQgICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuXHQgICAgdmFyIHJlcyA9IHU7XG5cdCAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaXN1Yih0aGlzLm0pO1xuXHQgICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG5cdCAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcblx0ICB9O1xuXG5cdCAgTW9udC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcblx0ICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcblx0ICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuXHQgICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG5cdCAgfTtcblx0fSkoJ29iamVjdCcgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgY29tbW9uanNHbG9iYWwpO1xuXHR9KTtcblxuXHR2YXIgdXRpbHNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciB1dGlscyA9IGV4cG9ydHM7XG5cblx0ZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuXHQgIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG5cdCAgICByZXR1cm4gbXNnLnNsaWNlKCk7XG5cdCAgaWYgKCFtc2cpXG5cdCAgICByZXR1cm4gW107XG5cdCAgdmFyIHJlcyA9IFtdO1xuXHQgIGlmICh0eXBlb2YgbXNnICE9PSAnc3RyaW5nJykge1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG5cdCAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH1cblx0ICBpZiAoZW5jID09PSAnaGV4Jykge1xuXHQgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcblx0ICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcblx0ICAgICAgbXNnID0gJzAnICsgbXNnO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpICs9IDIpXG5cdCAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG5cdCAgICAgIHZhciBoaSA9IGMgPj4gODtcblx0ICAgICAgdmFyIGxvID0gYyAmIDB4ZmY7XG5cdCAgICAgIGlmIChoaSlcblx0ICAgICAgICByZXMucHVzaChoaSwgbG8pO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgcmVzLnB1c2gobG8pO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHV0aWxzLnRvQXJyYXkgPSB0b0FycmF5O1xuXG5cdGZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcblx0ICBpZiAod29yZC5sZW5ndGggPT09IDEpXG5cdCAgICByZXR1cm4gJzAnICsgd29yZDtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gd29yZDtcblx0fVxuXHR1dGlscy56ZXJvMiA9IHplcm8yO1xuXG5cdGZ1bmN0aW9uIHRvSGV4KG1zZykge1xuXHQgIHZhciByZXMgPSAnJztcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcblx0ICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcblx0ICByZXR1cm4gcmVzO1xuXHR9XG5cdHV0aWxzLnRvSGV4ID0gdG9IZXg7XG5cblx0dXRpbHMuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGFyciwgZW5jKSB7XG5cdCAgaWYgKGVuYyA9PT0gJ2hleCcpXG5cdCAgICByZXR1cm4gdG9IZXgoYXJyKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gYXJyO1xuXHR9O1xuXHR9KTtcblxuXHR2YXIgdXRpbHNfMSQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIHV0aWxzID0gZXhwb3J0cztcblxuXG5cblxuXHR1dGlscy5hc3NlcnQgPSBtaW5pbWFsaXN0aWNBc3NlcnQ7XG5cdHV0aWxzLnRvQXJyYXkgPSB1dGlsc18xLnRvQXJyYXk7XG5cdHV0aWxzLnplcm8yID0gdXRpbHNfMS56ZXJvMjtcblx0dXRpbHMudG9IZXggPSB1dGlsc18xLnRvSGV4O1xuXHR1dGlscy5lbmNvZGUgPSB1dGlsc18xLmVuY29kZTtcblxuXHQvLyBSZXByZXNlbnQgbnVtIGluIGEgdy1OQUYgZm9ybVxuXHRmdW5jdGlvbiBnZXROQUYobnVtLCB3LCBiaXRzKSB7XG5cdCAgdmFyIG5hZiA9IG5ldyBBcnJheShNYXRoLm1heChudW0uYml0TGVuZ3RoKCksIGJpdHMpICsgMSk7XG5cdCAgbmFmLmZpbGwoMCk7XG5cblx0ICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG5cdCAgdmFyIGsgPSBudW0uY2xvbmUoKTtcblxuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFmLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB2YXIgejtcblx0ICAgIHZhciBtb2QgPSBrLmFuZGxuKHdzIC0gMSk7XG5cdCAgICBpZiAoay5pc09kZCgpKSB7XG5cdCAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuXHQgICAgICAgIHogPSAod3MgPj4gMSkgLSBtb2Q7XG5cdCAgICAgIGVsc2Vcblx0ICAgICAgICB6ID0gbW9kO1xuXHQgICAgICBrLmlzdWJuKHopO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgeiA9IDA7XG5cdCAgICB9XG5cblx0ICAgIG5hZltpXSA9IHo7XG5cdCAgICBrLml1c2hybigxKTtcblx0ICB9XG5cblx0ICByZXR1cm4gbmFmO1xuXHR9XG5cdHV0aWxzLmdldE5BRiA9IGdldE5BRjtcblxuXHQvLyBSZXByZXNlbnQgazEsIGsyIGluIGEgSm9pbnQgU3BhcnNlIEZvcm1cblx0ZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuXHQgIHZhciBqc2YgPSBbXG5cdCAgICBbXSxcblx0ICAgIFtdXG5cdCAgXTtcblxuXHQgIGsxID0gazEuY2xvbmUoKTtcblx0ICBrMiA9IGsyLmNsb25lKCk7XG5cdCAgdmFyIGQxID0gMDtcblx0ICB2YXIgZDIgPSAwO1xuXHQgIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcblxuXHQgICAgLy8gRmlyc3QgcGhhc2Vcblx0ICAgIHZhciBtMTQgPSAoazEuYW5kbG4oMykgKyBkMSkgJiAzO1xuXHQgICAgdmFyIG0yNCA9IChrMi5hbmRsbigzKSArIGQyKSAmIDM7XG5cdCAgICBpZiAobTE0ID09PSAzKVxuXHQgICAgICBtMTQgPSAtMTtcblx0ICAgIGlmIChtMjQgPT09IDMpXG5cdCAgICAgIG0yNCA9IC0xO1xuXHQgICAgdmFyIHUxO1xuXHQgICAgaWYgKChtMTQgJiAxKSA9PT0gMCkge1xuXHQgICAgICB1MSA9IDA7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICB2YXIgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuXHQgICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMjQgPT09IDIpXG5cdCAgICAgICAgdTEgPSAtbTE0O1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgdTEgPSBtMTQ7XG5cdCAgICB9XG5cdCAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cblx0ICAgIHZhciB1Mjtcblx0ICAgIGlmICgobTI0ICYgMSkgPT09IDApIHtcblx0ICAgICAgdTIgPSAwO1xuXHQgICAgfSBlbHNlIHtcblx0ICAgICAgdmFyIG04ID0gKGsyLmFuZGxuKDcpICsgZDIpICYgNztcblx0ICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTE0ID09PSAyKVxuXHQgICAgICAgIHUyID0gLW0yNDtcblx0ICAgICAgZWxzZVxuXHQgICAgICAgIHUyID0gbTI0O1xuXHQgICAgfVxuXHQgICAganNmWzFdLnB1c2godTIpO1xuXG5cdCAgICAvLyBTZWNvbmQgcGhhc2Vcblx0ICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcblx0ICAgICAgZDEgPSAxIC0gZDE7XG5cdCAgICBpZiAoMiAqIGQyID09PSB1MiArIDEpXG5cdCAgICAgIGQyID0gMSAtIGQyO1xuXHQgICAgazEuaXVzaHJuKDEpO1xuXHQgICAgazIuaXVzaHJuKDEpO1xuXHQgIH1cblxuXHQgIHJldHVybiBqc2Y7XG5cdH1cblx0dXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5cdGZ1bmN0aW9uIGNhY2hlZFByb3BlcnR5KG9iaiwgbmFtZSwgY29tcHV0ZXIpIHtcblx0ICB2YXIga2V5ID0gJ18nICsgbmFtZTtcblx0ICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG5cdCAgICByZXR1cm4gdGhpc1trZXldICE9PSB1bmRlZmluZWQgPyB0aGlzW2tleV0gOlxuXHQgICAgICAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG5cdCAgfTtcblx0fVxuXHR1dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIHBhcnNlQnl0ZXMoYnl0ZXMpIHtcblx0ICByZXR1cm4gdHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJyA/IHV0aWxzLnRvQXJyYXkoYnl0ZXMsICdoZXgnKSA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcztcblx0fVxuXHR1dGlscy5wYXJzZUJ5dGVzID0gcGFyc2VCeXRlcztcblxuXHRmdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcblx0ICByZXR1cm4gbmV3IGJuJDEoYnl0ZXMsICdoZXgnLCAnbGUnKTtcblx0fVxuXHR1dGlscy5pbnRGcm9tTEUgPSBpbnRGcm9tTEU7XG5cdH0pO1xuXG5cdHZhciBicm9yYW5kID0gZnVuY3Rpb24obGVuZ3RoKSB7IHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpOyAoY29tbW9uanNHbG9iYWwuY3J5cHRvIHx8IGNvbW1vbmpzR2xvYmFsLm1zQ3J5cHRvKS5nZXRSYW5kb21WYWx1ZXMocmVzdWx0KTsgcmV0dXJuIHJlc3VsdDsgfTtcblxuXHQndXNlIHN0cmljdCc7XG5cblxuXG5cdHZhciBnZXROQUYgPSB1dGlsc18xJDEuZ2V0TkFGO1xuXHR2YXIgZ2V0SlNGID0gdXRpbHNfMSQxLmdldEpTRjtcblx0dmFyIGFzc2VydCQxID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuXHQgIHRoaXMudHlwZSA9IHR5cGU7XG5cdCAgdGhpcy5wID0gbmV3IGJuJDEoY29uZi5wLCAxNik7XG5cblx0ICAvLyBVc2UgTW9udGdvbWVyeSwgd2hlbiB0aGVyZSBpcyBubyBmYXN0IHJlZHVjdGlvbiBmb3IgdGhlIHByaW1lXG5cdCAgdGhpcy5yZWQgPSBjb25mLnByaW1lID8gYm4kMS5yZWQoY29uZi5wcmltZSkgOiBibiQxLm1vbnQodGhpcy5wKTtcblxuXHQgIC8vIFVzZWZ1bCBmb3IgbWFueSBjdXJ2ZXNcblx0ICB0aGlzLnplcm8gPSBuZXcgYm4kMSgwKS50b1JlZCh0aGlzLnJlZCk7XG5cdCAgdGhpcy5vbmUgPSBuZXcgYm4kMSgxKS50b1JlZCh0aGlzLnJlZCk7XG5cdCAgdGhpcy50d28gPSBuZXcgYm4kMSgyKS50b1JlZCh0aGlzLnJlZCk7XG5cblx0ICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuXHQgIHRoaXMubiA9IGNvbmYubiAmJiBuZXcgYm4kMShjb25mLm4sIDE2KTtcblx0ICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuXHQgIC8vIFRlbXBvcmFyeSBhcnJheXNcblx0ICB0aGlzLl93bmFmVDEgPSBuZXcgQXJyYXkoNCk7XG5cdCAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuXHQgIHRoaXMuX3duYWZUMyA9IG5ldyBBcnJheSg0KTtcblx0ICB0aGlzLl93bmFmVDQgPSBuZXcgQXJyYXkoNCk7XG5cblx0ICB0aGlzLl9iaXRMZW5ndGggPSB0aGlzLm4gPyB0aGlzLm4uYml0TGVuZ3RoKCkgOiAwO1xuXG5cdCAgLy8gR2VuZXJhbGl6ZWQgR3JlZyBNYXh3ZWxsJ3MgdHJpY2tcblx0ICB2YXIgYWRqdXN0Q291bnQgPSB0aGlzLm4gJiYgdGhpcy5wLmRpdih0aGlzLm4pO1xuXHQgIGlmICghYWRqdXN0Q291bnQgfHwgYWRqdXN0Q291bnQuY21wbigxMDApID4gMCkge1xuXHQgICAgdGhpcy5yZWROID0gbnVsbDtcblx0ICB9IGVsc2Uge1xuXHQgICAgdGhpcy5fbWF4d2VsbFRyaWNrID0gdHJ1ZTtcblx0ICAgIHRoaXMucmVkTiA9IHRoaXMubi50b1JlZCh0aGlzLnJlZCk7XG5cdCAgfVxuXHR9XG5cdHZhciBiYXNlID0gQmFzZUN1cnZlO1xuXG5cdEJhc2VDdXJ2ZS5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiBwb2ludCgpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdEJhc2VDdXJ2ZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcblx0ICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xuXHR9O1xuXG5cdEJhc2VDdXJ2ZS5wcm90b3R5cGUuX2ZpeGVkTmFmTXVsID0gZnVuY3Rpb24gX2ZpeGVkTmFmTXVsKHAsIGspIHtcblx0ICBhc3NlcnQkMShwLnByZWNvbXB1dGVkKTtcblx0ICB2YXIgZG91YmxlcyA9IHAuX2dldERvdWJsZXMoKTtcblxuXHQgIHZhciBuYWYgPSBnZXROQUYoaywgMSwgdGhpcy5fYml0TGVuZ3RoKTtcblx0ICB2YXIgSSA9ICgxIDw8IChkb3VibGVzLnN0ZXAgKyAxKSkgLSAoZG91Ymxlcy5zdGVwICUgMiA9PT0gMCA/IDIgOiAxKTtcblx0ICBJIC89IDM7XG5cblx0ICAvLyBUcmFuc2xhdGUgaW50byBtb3JlIHdpbmRvd2VkIGZvcm1cblx0ICB2YXIgcmVwciA9IFtdO1xuXHQgIGZvciAodmFyIGogPSAwOyBqIDwgbmFmLmxlbmd0aDsgaiArPSBkb3VibGVzLnN0ZXApIHtcblx0ICAgIHZhciBuYWZXID0gMDtcblx0ICAgIGZvciAodmFyIGsgPSBqICsgZG91Ymxlcy5zdGVwIC0gMTsgayA+PSBqOyBrLS0pXG5cdCAgICAgIG5hZlcgPSAobmFmVyA8PCAxKSArIG5hZltrXTtcblx0ICAgIHJlcHIucHVzaChuYWZXKTtcblx0ICB9XG5cblx0ICB2YXIgYSA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgIHZhciBiID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVwci5sZW5ndGg7IGorKykge1xuXHQgICAgICB2YXIgbmFmVyA9IHJlcHJbal07XG5cdCAgICAgIGlmIChuYWZXID09PSBpKVxuXHQgICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdKTtcblx0ICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG5cdCAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0ubmVnKCkpO1xuXHQgICAgfVxuXHQgICAgYSA9IGEuYWRkKGIpO1xuXHQgIH1cblx0ICByZXR1cm4gYS50b1AoKTtcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsID0gZnVuY3Rpb24gX3duYWZNdWwocCwgaykge1xuXHQgIHZhciB3ID0gNDtcblxuXHQgIC8vIFByZWNvbXB1dGUgd2luZG93XG5cdCAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyh3KTtcblx0ICB3ID0gbmFmUG9pbnRzLnduZDtcblx0ICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuXHQgIC8vIEdldCBOQUYgZm9ybVxuXHQgIHZhciBuYWYgPSBnZXROQUYoaywgdywgdGhpcy5fYml0TGVuZ3RoKTtcblxuXHQgIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG5cdCAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgIGZvciAodmFyIGkgPSBuYWYubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgIC8vIENvdW50IHplcm9lc1xuXHQgICAgZm9yICh2YXIgayA9IDA7IGkgPj0gMCAmJiBuYWZbaV0gPT09IDA7IGktLSlcblx0ICAgICAgaysrO1xuXHQgICAgaWYgKGkgPj0gMClcblx0ICAgICAgaysrO1xuXHQgICAgYWNjID0gYWNjLmRibHAoayk7XG5cblx0ICAgIGlmIChpIDwgMClcblx0ICAgICAgYnJlYWs7XG5cdCAgICB2YXIgeiA9IG5hZltpXTtcblx0ICAgIGFzc2VydCQxKHogIT09IDApO1xuXHQgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpIHtcblx0ICAgICAgLy8gSiArLSBQXG5cdCAgICAgIGlmICh6ID4gMClcblx0ICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBKICstIEpcblx0ICAgICAgaWYgKHogPiAwKVxuXHQgICAgICAgIGFjYyA9IGFjYy5hZGQod25kWyh6IC0gMSkgPj4gMV0pO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuXHQgICAgfVxuXHQgIH1cblx0ICByZXR1cm4gcC50eXBlID09PSAnYWZmaW5lJyA/IGFjYy50b1AoKSA6IGFjYztcblx0fTtcblxuXHRCYXNlQ3VydmUucHJvdG90eXBlLl93bmFmTXVsQWRkID0gZnVuY3Rpb24gX3duYWZNdWxBZGQoZGVmVyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50cyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZWZmcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGphY29iaWFuUmVzdWx0KSB7XG5cdCAgdmFyIHduZFdpZHRoID0gdGhpcy5fd25hZlQxO1xuXHQgIHZhciB3bmQgPSB0aGlzLl93bmFmVDI7XG5cdCAgdmFyIG5hZiA9IHRoaXMuX3duYWZUMztcblxuXHQgIC8vIEZpbGwgYWxsIGFycmF5c1xuXHQgIHZhciBtYXggPSAwO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgIHZhciBwID0gcG9pbnRzW2ldO1xuXHQgICAgdmFyIG5hZlBvaW50cyA9IHAuX2dldE5BRlBvaW50cyhkZWZXKTtcblx0ICAgIHduZFdpZHRoW2ldID0gbmFmUG9pbnRzLnduZDtcblx0ICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG5cdCAgfVxuXG5cdCAgLy8gQ29tYiBzbWFsbCB3aW5kb3cgTkFGc1xuXHQgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDE7IGkgLT0gMikge1xuXHQgICAgdmFyIGEgPSBpIC0gMTtcblx0ICAgIHZhciBiID0gaTtcblx0ICAgIGlmICh3bmRXaWR0aFthXSAhPT0gMSB8fCB3bmRXaWR0aFtiXSAhPT0gMSkge1xuXHQgICAgICBuYWZbYV0gPSBnZXROQUYoY29lZmZzW2FdLCB3bmRXaWR0aFthXSwgdGhpcy5fYml0TGVuZ3RoKTtcblx0ICAgICAgbmFmW2JdID0gZ2V0TkFGKGNvZWZmc1tiXSwgd25kV2lkdGhbYl0sIHRoaXMuX2JpdExlbmd0aCk7XG5cdCAgICAgIG1heCA9IE1hdGgubWF4KG5hZlthXS5sZW5ndGgsIG1heCk7XG5cdCAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG5cdCAgICAgIGNvbnRpbnVlO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgY29tYiA9IFtcblx0ICAgICAgcG9pbnRzW2FdLCAvKiAxICovXG5cdCAgICAgIG51bGwsIC8qIDMgKi9cblx0ICAgICAgbnVsbCwgLyogNSAqL1xuXHQgICAgICBwb2ludHNbYl0gLyogNyAqL1xuXHQgICAgXTtcblxuXHQgICAgLy8gVHJ5IHRvIGF2b2lkIFByb2plY3RpdmUgcG9pbnRzLCBpZiBwb3NzaWJsZVxuXHQgICAgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueSkgPT09IDApIHtcblx0ICAgICAgY29tYlsxXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdKTtcblx0ICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuXHQgICAgfSBlbHNlIGlmIChwb2ludHNbYV0ueS5jbXAocG9pbnRzW2JdLnkucmVkTmVnKCkpID09PSAwKSB7XG5cdCAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcblx0ICAgICAgY29tYlsyXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdLm5lZygpKTtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcblx0ICAgICAgY29tYlsyXSA9IHBvaW50c1thXS50b0ooKS5taXhlZEFkZChwb2ludHNbYl0ubmVnKCkpO1xuXHQgICAgfVxuXG5cdCAgICB2YXIgaW5kZXggPSBbXG5cdCAgICAgIC0zLCAvKiAtMSAtMSAqL1xuXHQgICAgICAtMSwgLyogLTEgMCAqL1xuXHQgICAgICAtNSwgLyogLTEgMSAqL1xuXHQgICAgICAtNywgLyogMCAtMSAqL1xuXHQgICAgICAwLCAvKiAwIDAgKi9cblx0ICAgICAgNywgLyogMCAxICovXG5cdCAgICAgIDUsIC8qIDEgLTEgKi9cblx0ICAgICAgMSwgLyogMSAwICovXG5cdCAgICAgIDMgIC8qIDEgMSAqL1xuXHQgICAgXTtcblxuXHQgICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG5cdCAgICBtYXggPSBNYXRoLm1heChqc2ZbMF0ubGVuZ3RoLCBtYXgpO1xuXHQgICAgbmFmW2FdID0gbmV3IEFycmF5KG1heCk7XG5cdCAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcblx0ICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF4OyBqKyspIHtcblx0ICAgICAgdmFyIGphID0ganNmWzBdW2pdIHwgMDtcblx0ICAgICAgdmFyIGpiID0ganNmWzFdW2pdIHwgMDtcblxuXHQgICAgICBuYWZbYV1bal0gPSBpbmRleFsoamEgKyAxKSAqIDMgKyAoamIgKyAxKV07XG5cdCAgICAgIG5hZltiXVtqXSA9IDA7XG5cdCAgICAgIHduZFthXSA9IGNvbWI7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdmFyIGFjYyA9IHRoaXMuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgIHZhciB0bXAgPSB0aGlzLl93bmFmVDQ7XG5cdCAgZm9yICh2YXIgaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcblx0ICAgIHZhciBrID0gMDtcblxuXHQgICAgd2hpbGUgKGkgPj0gMCkge1xuXHQgICAgICB2YXIgemVybyA9IHRydWU7XG5cdCAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuOyBqKyspIHtcblx0ICAgICAgICB0bXBbal0gPSBuYWZbal1baV0gfCAwO1xuXHQgICAgICAgIGlmICh0bXBbal0gIT09IDApXG5cdCAgICAgICAgICB6ZXJvID0gZmFsc2U7XG5cdCAgICAgIH1cblx0ICAgICAgaWYgKCF6ZXJvKVxuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgICBrKys7XG5cdCAgICAgIGktLTtcblx0ICAgIH1cblx0ICAgIGlmIChpID49IDApXG5cdCAgICAgIGsrKztcblx0ICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuXHQgICAgaWYgKGkgPCAwKVxuXHQgICAgICBicmVhaztcblxuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW47IGorKykge1xuXHQgICAgICB2YXIgeiA9IHRtcFtqXTtcblx0ICAgICAgdmFyIHA7XG5cdCAgICAgIGlmICh6ID09PSAwKVxuXHQgICAgICAgIGNvbnRpbnVlO1xuXHQgICAgICBlbHNlIGlmICh6ID4gMClcblx0ICAgICAgICBwID0gd25kW2pdWyh6IC0gMSkgPj4gMV07XG5cdCAgICAgIGVsc2UgaWYgKHogPCAwKVxuXHQgICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cblx0ICAgICAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG5cdCAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHApO1xuXHQgICAgICBlbHNlXG5cdCAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcblx0ICAgIH1cblx0ICB9XG5cdCAgLy8gWmVyb2lmeSByZWZlcmVuY2VzXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcblx0ICAgIHduZFtpXSA9IG51bGw7XG5cblx0ICBpZiAoamFjb2JpYW5SZXN1bHQpXG5cdCAgICByZXR1cm4gYWNjO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiBhY2MudG9QKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gQmFzZVBvaW50KGN1cnZlLCB0eXBlKSB7XG5cdCAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuXHQgIHRoaXMudHlwZSA9IHR5cGU7XG5cdCAgdGhpcy5wcmVjb21wdXRlZCA9IG51bGw7XG5cdH1cblx0QmFzZUN1cnZlLkJhc2VQb2ludCA9IEJhc2VQb2ludDtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEoLypvdGhlciovKSB7XG5cdCAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG5cdCAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG5cdH07XG5cblx0QmFzZUN1cnZlLnByb3RvdHlwZS5kZWNvZGVQb2ludCA9IGZ1bmN0aW9uIGRlY29kZVBvaW50KGJ5dGVzLCBlbmMpIHtcblx0ICBieXRlcyA9IHV0aWxzXzEkMS50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG5cdCAgdmFyIGxlbiA9IHRoaXMucC5ieXRlTGVuZ3RoKCk7XG5cblx0ICAvLyB1bmNvbXByZXNzZWQsIGh5YnJpZC1vZGQsIGh5YnJpZC1ldmVuXG5cdCAgaWYgKChieXRlc1swXSA9PT0gMHgwNCB8fCBieXRlc1swXSA9PT0gMHgwNiB8fCBieXRlc1swXSA9PT0gMHgwNykgJiZcblx0ICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gMiAqIGxlbikge1xuXHQgICAgaWYgKGJ5dGVzWzBdID09PSAweDA2KVxuXHQgICAgICBhc3NlcnQkMShieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuXHQgICAgZWxzZSBpZiAoYnl0ZXNbMF0gPT09IDB4MDcpXG5cdCAgICAgIGFzc2VydCQxKGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdICUgMiA9PT0gMSk7XG5cblx0ICAgIHZhciByZXMgPSAgdGhpcy5wb2ludChieXRlcy5zbGljZSgxLCAxICsgbGVuKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICBieXRlcy5zbGljZSgxICsgbGVuLCAxICsgMiAqIGxlbikpO1xuXG5cdCAgICByZXR1cm4gcmVzO1xuXHQgIH0gZWxzZSBpZiAoKGJ5dGVzWzBdID09PSAweDAyIHx8IGJ5dGVzWzBdID09PSAweDAzKSAmJlxuXHQgICAgICAgICAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IGxlbikge1xuXHQgICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuXHQgIH1cblx0ICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcG9pbnQgZm9ybWF0Jyk7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGVDb21wcmVzc2VkID0gZnVuY3Rpb24gZW5jb2RlQ29tcHJlc3NlZChlbmMpIHtcblx0ICByZXR1cm4gdGhpcy5lbmNvZGUoZW5jLCB0cnVlKTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9lbmNvZGUgPSBmdW5jdGlvbiBfZW5jb2RlKGNvbXBhY3QpIHtcblx0ICB2YXIgbGVuID0gdGhpcy5jdXJ2ZS5wLmJ5dGVMZW5ndGgoKTtcblx0ICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuXHQgIGlmIChjb21wYWN0KVxuXHQgICAgcmV0dXJuIFsgdGhpcy5nZXRZKCkuaXNFdmVuKCkgPyAweDAyIDogMHgwMyBdLmNvbmNhdCh4KTtcblxuXHQgIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKSA7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoZW5jLCBjb21wYWN0KSB7XG5cdCAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUodGhpcy5fZW5jb2RlKGNvbXBhY3QpLCBlbmMpO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUucHJlY29tcHV0ZSA9IGZ1bmN0aW9uIHByZWNvbXB1dGUocG93ZXIpIHtcblx0ICBpZiAodGhpcy5wcmVjb21wdXRlZClcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgdmFyIHByZWNvbXB1dGVkID0ge1xuXHQgICAgZG91YmxlczogbnVsbCxcblx0ICAgIG5hZjogbnVsbCxcblx0ICAgIGJldGE6IG51bGxcblx0ICB9O1xuXHQgIHByZWNvbXB1dGVkLm5hZiA9IHRoaXMuX2dldE5BRlBvaW50cyg4KTtcblx0ICBwcmVjb21wdXRlZC5kb3VibGVzID0gdGhpcy5fZ2V0RG91Ymxlcyg0LCBwb3dlcik7XG5cdCAgcHJlY29tcHV0ZWQuYmV0YSA9IHRoaXMuX2dldEJldGEoKTtcblx0ICB0aGlzLnByZWNvbXB1dGVkID0gcHJlY29tcHV0ZWQ7XG5cblx0ICByZXR1cm4gdGhpcztcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9oYXNEb3VibGVzID0gZnVuY3Rpb24gX2hhc0RvdWJsZXMoaykge1xuXHQgIGlmICghdGhpcy5wcmVjb21wdXRlZClcblx0ICAgIHJldHVybiBmYWxzZTtcblxuXHQgIHZhciBkb3VibGVzID0gdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzO1xuXHQgIGlmICghZG91Ymxlcylcblx0ICAgIHJldHVybiBmYWxzZTtcblxuXHQgIHJldHVybiBkb3VibGVzLnBvaW50cy5sZW5ndGggPj0gTWF0aC5jZWlsKChrLmJpdExlbmd0aCgpICsgMSkgLyBkb3VibGVzLnN0ZXApO1xuXHR9O1xuXG5cdEJhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXMgPSBmdW5jdGlvbiBfZ2V0RG91YmxlcyhzdGVwLCBwb3dlcikge1xuXHQgIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcylcblx0ICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXM7XG5cblx0ICB2YXIgZG91YmxlcyA9IFsgdGhpcyBdO1xuXHQgIHZhciBhY2MgPSB0aGlzO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93ZXI7IGkgKz0gc3RlcCkge1xuXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwOyBqKyspXG5cdCAgICAgIGFjYyA9IGFjYy5kYmwoKTtcblx0ICAgIGRvdWJsZXMucHVzaChhY2MpO1xuXHQgIH1cblx0ICByZXR1cm4ge1xuXHQgICAgc3RlcDogc3RlcCxcblx0ICAgIHBvaW50czogZG91Ymxlc1xuXHQgIH07XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5fZ2V0TkFGUG9pbnRzID0gZnVuY3Rpb24gX2dldE5BRlBvaW50cyh3bmQpIHtcblx0ICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLm5hZilcblx0ICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLm5hZjtcblxuXHQgIHZhciByZXMgPSBbIHRoaXMgXTtcblx0ICB2YXIgbWF4ID0gKDEgPDwgd25kKSAtIDE7XG5cdCAgdmFyIGRibCA9IG1heCA9PT0gMSA/IG51bGwgOiB0aGlzLmRibCgpO1xuXHQgIGZvciAodmFyIGkgPSAxOyBpIDwgbWF4OyBpKyspXG5cdCAgICByZXNbaV0gPSByZXNbaSAtIDFdLmFkZChkYmwpO1xuXHQgIHJldHVybiB7XG5cdCAgICB3bmQ6IHduZCxcblx0ICAgIHBvaW50czogcmVzXG5cdCAgfTtcblx0fTtcblxuXHRCYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG5cdCAgcmV0dXJuIG51bGw7XG5cdH07XG5cblx0QmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG5cdCAgdmFyIHIgPSB0aGlzO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgazsgaSsrKVxuXHQgICAgciA9IHIuZGJsKCk7XG5cdCAgcmV0dXJuIHI7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cblxuXHR2YXIgYXNzZXJ0JDIgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cdGZ1bmN0aW9uIFNob3J0Q3VydmUoY29uZikge1xuXHQgIGJhc2UuY2FsbCh0aGlzLCAnc2hvcnQnLCBjb25mKTtcblxuXHQgIHRoaXMuYSA9IG5ldyBibiQxKGNvbmYuYSwgMTYpLnRvUmVkKHRoaXMucmVkKTtcblx0ICB0aGlzLmIgPSBuZXcgYm4kMShjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG5cdCAgdGhpcy50aW52ID0gdGhpcy50d28ucmVkSW52bSgpO1xuXG5cdCAgdGhpcy56ZXJvQSA9IHRoaXMuYS5mcm9tUmVkKCkuY21wbigwKSA9PT0gMDtcblx0ICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cblx0ICAvLyBJZiB0aGUgY3VydmUgaXMgZW5kb21vcnBoaWMsIHByZWNhbGN1bGF0ZSBiZXRhIGFuZCBsYW1iZGFcblx0ICB0aGlzLmVuZG8gPSB0aGlzLl9nZXRFbmRvbW9ycGhpc20oY29uZik7XG5cdCAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcblx0ICB0aGlzLl9lbmRvV25hZlQyID0gbmV3IEFycmF5KDQpO1xuXHR9XG5cdGluaGVyaXRzX2Jyb3dzZXIoU2hvcnRDdXJ2ZSwgYmFzZSk7XG5cdHZhciBzaG9ydF8xID0gU2hvcnRDdXJ2ZTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb21vcnBoaXNtID0gZnVuY3Rpb24gX2dldEVuZG9tb3JwaGlzbShjb25mKSB7XG5cdCAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuXHQgIGlmICghdGhpcy56ZXJvQSB8fCAhdGhpcy5nIHx8ICF0aGlzLm4gfHwgdGhpcy5wLm1vZG4oMykgIT09IDEpXG5cdCAgICByZXR1cm47XG5cblx0ICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG5cdCAgdmFyIGJldGE7XG5cdCAgdmFyIGxhbWJkYTtcblx0ICBpZiAoY29uZi5iZXRhKSB7XG5cdCAgICBiZXRhID0gbmV3IGJuJDEoY29uZi5iZXRhLCAxNikudG9SZWQodGhpcy5yZWQpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB2YXIgYmV0YXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5wKTtcblx0ICAgIC8vIENob29zZSB0aGUgc21hbGxlc3QgYmV0YVxuXHQgICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcblx0ICAgIGJldGEgPSBiZXRhLnRvUmVkKHRoaXMucmVkKTtcblx0ICB9XG5cdCAgaWYgKGNvbmYubGFtYmRhKSB7XG5cdCAgICBsYW1iZGEgPSBuZXcgYm4kMShjb25mLmxhbWJkYSwgMTYpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBDaG9vc2UgdGhlIGxhbWJkYSB0aGF0IGlzIG1hdGNoaW5nIHNlbGVjdGVkIGJldGFcblx0ICAgIHZhciBsYW1iZGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMubik7XG5cdCAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG5cdCAgICAgIGxhbWJkYSA9IGxhbWJkYXNbMF07XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuXHQgICAgICBhc3NlcnQkMih0aGlzLmcubXVsKGxhbWJkYSkueC5jbXAodGhpcy5nLngucmVkTXVsKGJldGEpKSA9PT0gMCk7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgLy8gR2V0IGJhc2lzIHZlY3RvcnMsIHVzZWQgZm9yIGJhbGFuY2VkIGxlbmd0aC10d28gcmVwcmVzZW50YXRpb25cblx0ICB2YXIgYmFzaXM7XG5cdCAgaWYgKGNvbmYuYmFzaXMpIHtcblx0ICAgIGJhc2lzID0gY29uZi5iYXNpcy5tYXAoZnVuY3Rpb24odmVjKSB7XG5cdCAgICAgIHJldHVybiB7XG5cdCAgICAgICAgYTogbmV3IGJuJDEodmVjLmEsIDE2KSxcblx0ICAgICAgICBiOiBuZXcgYm4kMSh2ZWMuYiwgMTYpXG5cdCAgICAgIH07XG5cdCAgICB9KTtcblx0ICB9IGVsc2Uge1xuXHQgICAgYmFzaXMgPSB0aGlzLl9nZXRFbmRvQmFzaXMobGFtYmRhKTtcblx0ICB9XG5cblx0ICByZXR1cm4ge1xuXHQgICAgYmV0YTogYmV0YSxcblx0ICAgIGxhbWJkYTogbGFtYmRhLFxuXHQgICAgYmFzaXM6IGJhc2lzXG5cdCAgfTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZ2V0RW5kb1Jvb3RzID0gZnVuY3Rpb24gX2dldEVuZG9Sb290cyhudW0pIHtcblx0ICAvLyBGaW5kIHJvb3RzIG9mIGZvciB4XjIgKyB4ICsgMSBpbiBGXG5cdCAgLy8gUm9vdCA9ICgtMSArLSBTcXJ0KC0zKSkgLyAyXG5cdCAgLy9cblx0ICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IGJuJDEubW9udChudW0pO1xuXHQgIHZhciB0aW52ID0gbmV3IGJuJDEoMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG5cdCAgdmFyIG50aW52ID0gdGludi5yZWROZWcoKTtcblxuXHQgIHZhciBzID0gbmV3IGJuJDEoMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO1xuXG5cdCAgdmFyIGwxID0gbnRpbnYucmVkQWRkKHMpLmZyb21SZWQoKTtcblx0ICB2YXIgbDIgPSBudGludi5yZWRTdWIocykuZnJvbVJlZCgpO1xuXHQgIHJldHVybiBbIGwxLCBsMiBdO1xuXHR9O1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvQmFzaXMgPSBmdW5jdGlvbiBfZ2V0RW5kb0Jhc2lzKGxhbWJkYSkge1xuXHQgIC8vIGFwcnhTcXJ0ID49IHNxcnQodGhpcy5uKVxuXHQgIHZhciBhcHJ4U3FydCA9IHRoaXMubi51c2hybihNYXRoLmZsb29yKHRoaXMubi5iaXRMZW5ndGgoKSAvIDIpKTtcblxuXHQgIC8vIDMuNzRcblx0ICAvLyBSdW4gRUdDRCwgdW50aWwgcihMICsgMSkgPCBhcHJ4U3FydFxuXHQgIHZhciB1ID0gbGFtYmRhO1xuXHQgIHZhciB2ID0gdGhpcy5uLmNsb25lKCk7XG5cdCAgdmFyIHgxID0gbmV3IGJuJDEoMSk7XG5cdCAgdmFyIHkxID0gbmV3IGJuJDEoMCk7XG5cdCAgdmFyIHgyID0gbmV3IGJuJDEoMCk7XG5cdCAgdmFyIHkyID0gbmV3IGJuJDEoMSk7XG5cblx0ICAvLyBOT1RFOiBhbGwgdmVjdG9ycyBhcmUgcm9vdHMgb2Y6IGEgKyBiICogbGFtYmRhID0gMCAobW9kIG4pXG5cdCAgdmFyIGEwO1xuXHQgIHZhciBiMDtcblx0ICAvLyBGaXJzdCB2ZWN0b3Jcblx0ICB2YXIgYTE7XG5cdCAgdmFyIGIxO1xuXHQgIC8vIFNlY29uZCB2ZWN0b3Jcblx0ICB2YXIgYTI7XG5cdCAgdmFyIGIyO1xuXG5cdCAgdmFyIHByZXZSO1xuXHQgIHZhciBpID0gMDtcblx0ICB2YXIgcjtcblx0ICB2YXIgeDtcblx0ICB3aGlsZSAodS5jbXBuKDApICE9PSAwKSB7XG5cdCAgICB2YXIgcSA9IHYuZGl2KHUpO1xuXHQgICAgciA9IHYuc3ViKHEubXVsKHUpKTtcblx0ICAgIHggPSB4Mi5zdWIocS5tdWwoeDEpKTtcblx0ICAgIHZhciB5ID0geTIuc3ViKHEubXVsKHkxKSk7XG5cblx0ICAgIGlmICghYTEgJiYgci5jbXAoYXByeFNxcnQpIDwgMCkge1xuXHQgICAgICBhMCA9IHByZXZSLm5lZygpO1xuXHQgICAgICBiMCA9IHgxO1xuXHQgICAgICBhMSA9IHIubmVnKCk7XG5cdCAgICAgIGIxID0geDtcblx0ICAgIH0gZWxzZSBpZiAoYTEgJiYgKytpID09PSAyKSB7XG5cdCAgICAgIGJyZWFrO1xuXHQgICAgfVxuXHQgICAgcHJldlIgPSByO1xuXG5cdCAgICB2ID0gdTtcblx0ICAgIHUgPSByO1xuXHQgICAgeDIgPSB4MTtcblx0ICAgIHgxID0geDtcblx0ICAgIHkyID0geTE7XG5cdCAgICB5MSA9IHk7XG5cdCAgfVxuXHQgIGEyID0gci5uZWcoKTtcblx0ICBiMiA9IHg7XG5cblx0ICB2YXIgbGVuMSA9IGExLnNxcigpLmFkZChiMS5zcXIoKSk7XG5cdCAgdmFyIGxlbjIgPSBhMi5zcXIoKS5hZGQoYjIuc3FyKCkpO1xuXHQgIGlmIChsZW4yLmNtcChsZW4xKSA+PSAwKSB7XG5cdCAgICBhMiA9IGEwO1xuXHQgICAgYjIgPSBiMDtcblx0ICB9XG5cblx0ICAvLyBOb3JtYWxpemUgc2lnbnNcblx0ICBpZiAoYTEubmVnYXRpdmUpIHtcblx0ICAgIGExID0gYTEubmVnKCk7XG5cdCAgICBiMSA9IGIxLm5lZygpO1xuXHQgIH1cblx0ICBpZiAoYTIubmVnYXRpdmUpIHtcblx0ICAgIGEyID0gYTIubmVnKCk7XG5cdCAgICBiMiA9IGIyLm5lZygpO1xuXHQgIH1cblxuXHQgIHJldHVybiBbXG5cdCAgICB7IGE6IGExLCBiOiBiMSB9LFxuXHQgICAgeyBhOiBhMiwgYjogYjIgfVxuXHQgIF07XG5cdH07XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2VuZG9TcGxpdCA9IGZ1bmN0aW9uIF9lbmRvU3BsaXQoaykge1xuXHQgIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcblx0ICB2YXIgdjEgPSBiYXNpc1swXTtcblx0ICB2YXIgdjIgPSBiYXNpc1sxXTtcblxuXHQgIHZhciBjMSA9IHYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cdCAgdmFyIGMyID0gdjEuYi5uZWcoKS5tdWwoaykuZGl2Um91bmQodGhpcy5uKTtcblxuXHQgIHZhciBwMSA9IGMxLm11bCh2MS5hKTtcblx0ICB2YXIgcDIgPSBjMi5tdWwodjIuYSk7XG5cdCAgdmFyIHExID0gYzEubXVsKHYxLmIpO1xuXHQgIHZhciBxMiA9IGMyLm11bCh2Mi5iKTtcblxuXHQgIC8vIENhbGN1bGF0ZSBhbnN3ZXJcblx0ICB2YXIgazEgPSBrLnN1YihwMSkuc3ViKHAyKTtcblx0ICB2YXIgazIgPSBxMS5hZGQocTIpLm5lZygpO1xuXHQgIHJldHVybiB7IGsxOiBrMSwgazI6IGsyIH07XG5cdH07XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tWCA9IGZ1bmN0aW9uIHBvaW50RnJvbVgoeCwgb2RkKSB7XG5cdCAgeCA9IG5ldyBibiQxKHgsIDE2KTtcblx0ICBpZiAoIXgucmVkKVxuXHQgICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG5cdCAgdmFyIHkyID0geC5yZWRTcXIoKS5yZWRNdWwoeCkucmVkSUFkZCh4LnJlZE11bCh0aGlzLmEpKS5yZWRJQWRkKHRoaXMuYik7XG5cdCAgdmFyIHkgPSB5Mi5yZWRTcXJ0KCk7XG5cdCAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcblx0ICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwb2ludCcpO1xuXG5cdCAgLy8gWFhYIElzIHRoZXJlIGFueSB3YXkgdG8gdGVsbCBpZiB0aGUgbnVtYmVyIGlzIG9kZCB3aXRob3V0IGNvbnZlcnRpbmcgaXRcblx0ICAvLyB0byBub24tcmVkIGZvcm0/XG5cdCAgdmFyIGlzT2RkID0geS5mcm9tUmVkKCkuaXNPZGQoKTtcblx0ICBpZiAob2RkICYmICFpc09kZCB8fCAhb2RkICYmIGlzT2RkKVxuXHQgICAgeSA9IHkucmVkTmVnKCk7XG5cblx0ICByZXR1cm4gdGhpcy5wb2ludCh4LCB5KTtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG5cdCAgaWYgKHBvaW50LmluZilcblx0ICAgIHJldHVybiB0cnVlO1xuXG5cdCAgdmFyIHggPSBwb2ludC54O1xuXHQgIHZhciB5ID0gcG9pbnQueTtcblxuXHQgIHZhciBheCA9IHRoaXMuYS5yZWRNdWwoeCk7XG5cdCAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcblx0ICByZXR1cm4geS5yZWRTcXIoKS5yZWRJU3ViKHJocykuY21wbigwKSA9PT0gMDtcblx0fTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuXHQgICAgZnVuY3Rpb24gX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCBqYWNvYmlhblJlc3VsdCkge1xuXHQgIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcblx0ICB2YXIgbmNvZWZmcyA9IHRoaXMuX2VuZG9XbmFmVDI7XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcblx0ICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuXHQgICAgdmFyIHAgPSBwb2ludHNbaV07XG5cdCAgICB2YXIgYmV0YSA9IHAuX2dldEJldGEoKTtcblxuXHQgICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG5cdCAgICAgIHNwbGl0LmsxLmluZWcoKTtcblx0ICAgICAgcCA9IHAubmVnKHRydWUpO1xuXHQgICAgfVxuXHQgICAgaWYgKHNwbGl0LmsyLm5lZ2F0aXZlKSB7XG5cdCAgICAgIHNwbGl0LmsyLmluZWcoKTtcblx0ICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuXHQgICAgfVxuXG5cdCAgICBucG9pbnRzW2kgKiAyXSA9IHA7XG5cdCAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuXHQgICAgbmNvZWZmc1tpICogMl0gPSBzcGxpdC5rMTtcblx0ICAgIG5jb2VmZnNbaSAqIDIgKyAxXSA9IHNwbGl0LmsyO1xuXHQgIH1cblx0ICB2YXIgcmVzID0gdGhpcy5fd25hZk11bEFkZCgxLCBucG9pbnRzLCBuY29lZmZzLCBpICogMiwgamFjb2JpYW5SZXN1bHQpO1xuXG5cdCAgLy8gQ2xlYW4tdXAgcmVmZXJlbmNlcyB0byBwb2ludHMgYW5kIGNvZWZmaWNpZW50c1xuXHQgIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuXHQgICAgbnBvaW50c1tqXSA9IG51bGw7XG5cdCAgICBuY29lZmZzW2pdID0gbnVsbDtcblx0ICB9XG5cdCAgcmV0dXJuIHJlcztcblx0fTtcblxuXHRmdW5jdGlvbiBQb2ludChjdXJ2ZSwgeCwgeSwgaXNSZWQpIHtcblx0ICBiYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG5cdCAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCkge1xuXHQgICAgdGhpcy54ID0gbnVsbDtcblx0ICAgIHRoaXMueSA9IG51bGw7XG5cdCAgICB0aGlzLmluZiA9IHRydWU7XG5cdCAgfSBlbHNlIHtcblx0ICAgIHRoaXMueCA9IG5ldyBibiQxKHgsIDE2KTtcblx0ICAgIHRoaXMueSA9IG5ldyBibiQxKHksIDE2KTtcblx0ICAgIC8vIEZvcmNlIHJlZGdvbWVyeSByZXByZXNlbnRhdGlvbiB3aGVuIGxvYWRpbmcgZnJvbSBKU09OXG5cdCAgICBpZiAoaXNSZWQpIHtcblx0ICAgICAgdGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcblx0ICAgICAgdGhpcy55LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcblx0ICAgIH1cblx0ICAgIGlmICghdGhpcy54LnJlZClcblx0ICAgICAgdGhpcy54ID0gdGhpcy54LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblx0ICAgIGlmICghdGhpcy55LnJlZClcblx0ICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblx0ICAgIHRoaXMuaW5mID0gZmFsc2U7XG5cdCAgfVxuXHR9XG5cdGluaGVyaXRzX2Jyb3dzZXIoUG9pbnQsIGJhc2UuQmFzZVBvaW50KTtcblxuXHRTaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KHgsIHksIGlzUmVkKSB7XG5cdCAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCBpc1JlZCk7XG5cdH07XG5cblx0U2hvcnRDdXJ2ZS5wcm90b3R5cGUucG9pbnRGcm9tSlNPTiA9IGZ1bmN0aW9uIHBvaW50RnJvbUpTT04ob2JqLCByZWQpIHtcblx0ICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqLCByZWQpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5fZ2V0QmV0YSA9IGZ1bmN0aW9uIF9nZXRCZXRhKCkge1xuXHQgIGlmICghdGhpcy5jdXJ2ZS5lbmRvKVxuXHQgICAgcmV0dXJuO1xuXG5cdCAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG5cdCAgaWYgKHByZSAmJiBwcmUuYmV0YSlcblx0ICAgIHJldHVybiBwcmUuYmV0YTtcblxuXHQgIHZhciBiZXRhID0gdGhpcy5jdXJ2ZS5wb2ludCh0aGlzLngucmVkTXVsKHRoaXMuY3VydmUuZW5kby5iZXRhKSwgdGhpcy55KTtcblx0ICBpZiAocHJlKSB7XG5cdCAgICB2YXIgY3VydmUgPSB0aGlzLmN1cnZlO1xuXHQgICAgdmFyIGVuZG9NdWwgPSBmdW5jdGlvbihwKSB7XG5cdCAgICAgIHJldHVybiBjdXJ2ZS5wb2ludChwLngucmVkTXVsKGN1cnZlLmVuZG8uYmV0YSksIHAueSk7XG5cdCAgICB9O1xuXHQgICAgcHJlLmJldGEgPSBiZXRhO1xuXHQgICAgYmV0YS5wcmVjb21wdXRlZCA9IHtcblx0ICAgICAgYmV0YTogbnVsbCxcblx0ICAgICAgbmFmOiBwcmUubmFmICYmIHtcblx0ICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuXHQgICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKGVuZG9NdWwpXG5cdCAgICAgIH0sXG5cdCAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcblx0ICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuXHQgICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKVxuXHQgICAgICB9XG5cdCAgICB9O1xuXHQgIH1cblx0ICByZXR1cm4gYmV0YTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuXHQgIGlmICghdGhpcy5wcmVjb21wdXRlZClcblx0ICAgIHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XG5cblx0ICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy5wcmVjb21wdXRlZCAmJiB7XG5cdCAgICBkb3VibGVzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMgJiYge1xuXHQgICAgICBzdGVwOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMuc3RlcCxcblx0ICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMucG9pbnRzLnNsaWNlKDEpXG5cdCAgICB9LFxuXHQgICAgbmFmOiB0aGlzLnByZWNvbXB1dGVkLm5hZiAmJiB7XG5cdCAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuXHQgICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQubmFmLnBvaW50cy5zbGljZSgxKVxuXHQgICAgfVxuXHQgIH0gXTtcblx0fTtcblxuXHRQb2ludC5mcm9tSlNPTiA9IGZ1bmN0aW9uIGZyb21KU09OKGN1cnZlLCBvYmosIHJlZCkge1xuXHQgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJylcblx0ICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKTtcblx0ICB2YXIgcmVzID0gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG5cdCAgaWYgKCFvYmpbMl0pXG5cdCAgICByZXR1cm4gcmVzO1xuXG5cdCAgZnVuY3Rpb24gb2JqMnBvaW50KG9iaikge1xuXHQgICAgcmV0dXJuIGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuXHQgIH1cblxuXHQgIHZhciBwcmUgPSBvYmpbMl07XG5cdCAgcmVzLnByZWNvbXB1dGVkID0ge1xuXHQgICAgYmV0YTogbnVsbCxcblx0ICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcblx0ICAgICAgc3RlcDogcHJlLmRvdWJsZXMuc3RlcCxcblx0ICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUuZG91Ymxlcy5wb2ludHMubWFwKG9iajJwb2ludCkpXG5cdCAgICB9LFxuXHQgICAgbmFmOiBwcmUubmFmICYmIHtcblx0ICAgICAgd25kOiBwcmUubmFmLnduZCxcblx0ICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUubmFmLnBvaW50cy5tYXAob2JqMnBvaW50KSlcblx0ICAgIH1cblx0ICB9O1xuXHQgIHJldHVybiByZXM7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiAnPEVDIFBvaW50IEluZmluaXR5Pic7XG5cdCAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcblx0ICAgICAgJyB5OiAnICsgdGhpcy55LmZyb21SZWQoKS50b1N0cmluZygxNiwgMikgKyAnPic7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuXHQgIHJldHVybiB0aGlzLmluZjtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcblx0ICAvLyBPICsgUCA9IFBcblx0ICBpZiAodGhpcy5pbmYpXG5cdCAgICByZXR1cm4gcDtcblxuXHQgIC8vIFAgKyBPID0gUFxuXHQgIGlmIChwLmluZilcblx0ICAgIHJldHVybiB0aGlzO1xuXG5cdCAgLy8gUCArIFAgPSAyUFxuXHQgIGlmICh0aGlzLmVxKHApKVxuXHQgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cblx0ICAvLyBQICsgKC1QKSA9IE9cblx0ICBpZiAodGhpcy5uZWcoKS5lcShwKSlcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG5cdCAgLy8gUCArIFEgPSBPXG5cdCAgaWYgKHRoaXMueC5jbXAocC54KSA9PT0gMClcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG5cdCAgdmFyIGMgPSB0aGlzLnkucmVkU3ViKHAueSk7XG5cdCAgaWYgKGMuY21wbigwKSAhPT0gMClcblx0ICAgIGMgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKHAueCkucmVkSW52bSgpKTtcblx0ICB2YXIgbnggPSBjLnJlZFNxcigpLnJlZElTdWIodGhpcy54KS5yZWRJU3ViKHAueCk7XG5cdCAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG5cdCAgaWYgKHRoaXMuaW5mKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyAyUCA9IE9cblx0ICB2YXIgeXMxID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuXHQgIGlmICh5czEuY21wbigwKSA9PT0gMClcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG5cdCAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cblx0ICB2YXIgeDIgPSB0aGlzLngucmVkU3FyKCk7XG5cdCAgdmFyIGR5aW52ID0geXMxLnJlZEludm0oKTtcblx0ICB2YXIgYyA9IHgyLnJlZEFkZCh4MikucmVkSUFkZCh4MikucmVkSUFkZChhKS5yZWRNdWwoZHlpbnYpO1xuXG5cdCAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueC5yZWRBZGQodGhpcy54KSk7XG5cdCAgdmFyIG55ID0gYy5yZWRNdWwodGhpcy54LnJlZFN1YihueCkpLnJlZElTdWIodGhpcy55KTtcblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5nZXRYID0gZnVuY3Rpb24gZ2V0WCgpIHtcblx0ICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcblx0fTtcblxuXHRQb2ludC5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG5cdCAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bChrKSB7XG5cdCAgayA9IG5ldyBibiQxKGssIDE2KTtcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcztcblx0ICBlbHNlIGlmICh0aGlzLl9oYXNEb3VibGVzKGspKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2ZpeGVkTmFmTXVsKHRoaXMsIGspO1xuXHQgIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChbIHRoaXMgXSwgWyBrIF0pO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5tdWxBZGQgPSBmdW5jdGlvbiBtdWxBZGQoazEsIHAyLCBrMikge1xuXHQgIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG5cdCAgdmFyIGNvZWZmcyA9IFsgazEsIGsyIF07XG5cdCAgaWYgKHRoaXMuY3VydmUuZW5kbylcblx0ICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG5cdCAgZWxzZVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIpO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5qbXVsQWRkID0gZnVuY3Rpb24gam11bEFkZChrMSwgcDIsIGsyKSB7XG5cdCAgdmFyIHBvaW50cyA9IFsgdGhpcywgcDIgXTtcblx0ICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcblx0ICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUuX2VuZG9XbmFmTXVsQWRkKHBvaW50cywgY29lZmZzLCB0cnVlKTtcblx0ICBlbHNlXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMiwgdHJ1ZSk7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuXHQgIHJldHVybiB0aGlzID09PSBwIHx8XG5cdCAgICAgICAgIHRoaXMuaW5mID09PSBwLmluZiAmJlxuXHQgICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xuXHR9O1xuXG5cdFBvaW50LnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcoX3ByZWNvbXB1dGUpIHtcblx0ICBpZiAodGhpcy5pbmYpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIHZhciByZXMgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueCwgdGhpcy55LnJlZE5lZygpKTtcblx0ICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuXHQgICAgdmFyIHByZSA9IHRoaXMucHJlY29tcHV0ZWQ7XG5cdCAgICB2YXIgbmVnYXRlID0gZnVuY3Rpb24ocCkge1xuXHQgICAgICByZXR1cm4gcC5uZWcoKTtcblx0ICAgIH07XG5cdCAgICByZXMucHJlY29tcHV0ZWQgPSB7XG5cdCAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG5cdCAgICAgICAgd25kOiBwcmUubmFmLnduZCxcblx0ICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChuZWdhdGUpXG5cdCAgICAgIH0sXG5cdCAgICAgIGRvdWJsZXM6IHByZS5kb3VibGVzICYmIHtcblx0ICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuXHQgICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChuZWdhdGUpXG5cdCAgICAgIH1cblx0ICAgIH07XG5cdCAgfVxuXHQgIHJldHVybiByZXM7XG5cdH07XG5cblx0UG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcblx0ICBpZiAodGhpcy5pbmYpXG5cdCAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcblx0ICByZXR1cm4gcmVzO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuXHQgIGJhc2UuQmFzZVBvaW50LmNhbGwodGhpcywgY3VydmUsICdqYWNvYmlhbicpO1xuXHQgIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwgJiYgeiA9PT0gbnVsbCkge1xuXHQgICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG5cdCAgICB0aGlzLnkgPSB0aGlzLmN1cnZlLm9uZTtcblx0ICAgIHRoaXMueiA9IG5ldyBibiQxKDApO1xuXHQgIH0gZWxzZSB7XG5cdCAgICB0aGlzLnggPSBuZXcgYm4kMSh4LCAxNik7XG5cdCAgICB0aGlzLnkgPSBuZXcgYm4kMSh5LCAxNik7XG5cdCAgICB0aGlzLnogPSBuZXcgYm4kMSh6LCAxNik7XG5cdCAgfVxuXHQgIGlmICghdGhpcy54LnJlZClcblx0ICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cdCAgaWYgKCF0aGlzLnkucmVkKVxuXHQgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcblx0ICBpZiAoIXRoaXMuei5yZWQpXG5cdCAgICB0aGlzLnogPSB0aGlzLnoudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuXG5cdCAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcblx0fVxuXHRpbmhlcml0c19icm93c2VyKEpQb2ludCwgYmFzZS5CYXNlUG9pbnQpO1xuXG5cdFNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG5cdCAgcmV0dXJuIG5ldyBKUG9pbnQodGhpcywgeCwgeSwgeik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cblx0ICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG5cdCAgdmFyIHppbnYyID0gemludi5yZWRTcXIoKTtcblx0ICB2YXIgYXggPSB0aGlzLngucmVkTXVsKHppbnYyKTtcblx0ICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChheCwgYXkpO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludCh0aGlzLngsIHRoaXMueS5yZWROZWcoKSwgdGhpcy56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG5cdCAgLy8gTyArIFAgPSBQXG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHA7XG5cblx0ICAvLyBQICsgTyA9IFBcblx0ICBpZiAocC5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIC8vIDEyTSArIDRTICsgN0Fcblx0ICB2YXIgcHoyID0gcC56LnJlZFNxcigpO1xuXHQgIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcblx0ICB2YXIgdTEgPSB0aGlzLngucmVkTXVsKHB6Mik7XG5cdCAgdmFyIHUyID0gcC54LnJlZE11bCh6Mik7XG5cdCAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuXHQgIHZhciBzMiA9IHAueS5yZWRNdWwoejIucmVkTXVsKHRoaXMueikpO1xuXG5cdCAgdmFyIGggPSB1MS5yZWRTdWIodTIpO1xuXHQgIHZhciByID0gczEucmVkU3ViKHMyKTtcblx0ICBpZiAoaC5jbXBuKDApID09PSAwKSB7XG5cdCAgICBpZiAoci5jbXBuKDApICE9PSAwKVxuXHQgICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG5cdCAgICBlbHNlXG5cdCAgICAgIHJldHVybiB0aGlzLmRibCgpO1xuXHQgIH1cblxuXHQgIHZhciBoMiA9IGgucmVkU3FyKCk7XG5cdCAgdmFyIGgzID0gaDIucmVkTXVsKGgpO1xuXHQgIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuXHQgIHZhciBueCA9IHIucmVkU3FyKCkucmVkSUFkZChoMykucmVkSVN1Yih2KS5yZWRJU3ViKHYpO1xuXHQgIHZhciBueSA9IHIucmVkTXVsKHYucmVkSVN1YihueCkpLnJlZElTdWIoczEucmVkTXVsKGgzKSk7XG5cdCAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuXHQgIC8vIE8gKyBQID0gUFxuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiBwLnRvSigpO1xuXG5cdCAgLy8gUCArIE8gPSBQXG5cdCAgaWYgKHAuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cblx0ICAvLyA4TSArIDNTICsgN0Fcblx0ICB2YXIgejIgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgdmFyIHUxID0gdGhpcy54O1xuXHQgIHZhciB1MiA9IHAueC5yZWRNdWwoejIpO1xuXHQgIHZhciBzMSA9IHRoaXMueTtcblx0ICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuXHQgIHZhciBoID0gdTEucmVkU3ViKHUyKTtcblx0ICB2YXIgciA9IHMxLnJlZFN1YihzMik7XG5cdCAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuXHQgICAgaWYgKHIuY21wbigwKSAhPT0gMClcblx0ICAgICAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG51bGwsIG51bGwsIG51bGwpO1xuXHQgICAgZWxzZVxuXHQgICAgICByZXR1cm4gdGhpcy5kYmwoKTtcblx0ICB9XG5cblx0ICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuXHQgIHZhciBoMyA9IGgyLnJlZE11bChoKTtcblx0ICB2YXIgdiA9IHUxLnJlZE11bChoMik7XG5cblx0ICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcblx0ICB2YXIgbnkgPSByLnJlZE11bCh2LnJlZElTdWIobngpKS5yZWRJU3ViKHMxLnJlZE11bChoMykpO1xuXHQgIHZhciBueiA9IHRoaXMuei5yZWRNdWwoaCk7XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChwb3cpIHtcblx0ICBpZiAocG93ID09PSAwKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuXHQgICAgcmV0dXJuIHRoaXM7XG5cdCAgaWYgKCFwb3cpXG5cdCAgICByZXR1cm4gdGhpcy5kYmwoKTtcblxuXHQgIGlmICh0aGlzLmN1cnZlLnplcm9BIHx8IHRoaXMuY3VydmUudGhyZWVBKSB7XG5cdCAgICB2YXIgciA9IHRoaXM7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvdzsgaSsrKVxuXHQgICAgICByID0gci5kYmwoKTtcblx0ICAgIHJldHVybiByO1xuXHQgIH1cblxuXHQgIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuXHQgIC8vIE4gPSAxID0+IDZNICsgNlMgKyA5QVxuXHQgIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXHQgIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG5cdCAgdmFyIGp4ID0gdGhpcy54O1xuXHQgIHZhciBqeSA9IHRoaXMueTtcblx0ICB2YXIganogPSB0aGlzLno7XG5cdCAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG5cdCAgLy8gUmV1c2UgcmVzdWx0c1xuXHQgIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcG93OyBpKyspIHtcblx0ICAgIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcblx0ICAgIHZhciBqeWQyID0ganlkLnJlZFNxcigpO1xuXHQgICAgdmFyIGp5ZDQgPSBqeWQyLnJlZFNxcigpO1xuXHQgICAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cblx0ICAgIHZhciB0MSA9IGp4LnJlZE11bChqeWQyKTtcblx0ICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcblx0ICAgIHZhciB0MiA9IHQxLnJlZElTdWIobngpO1xuXHQgICAgdmFyIGRueSA9IGMucmVkTXVsKHQyKTtcblx0ICAgIGRueSA9IGRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTtcblx0ICAgIHZhciBueiA9IGp5ZC5yZWRNdWwoanopO1xuXHQgICAgaWYgKGkgKyAxIDwgcG93KVxuXHQgICAgICBqejQgPSBqejQucmVkTXVsKGp5ZDQpO1xuXG5cdCAgICBqeCA9IG54O1xuXHQgICAganogPSBuejtcblx0ICAgIGp5ZCA9IGRueTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQoangsIGp5ZC5yZWRNdWwodGludiksIGp6KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcblx0ICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4gdGhpcztcblxuXHQgIGlmICh0aGlzLmN1cnZlLnplcm9BKVxuXHQgICAgcmV0dXJuIHRoaXMuX3plcm9EYmwoKTtcblx0ICBlbHNlIGlmICh0aGlzLmN1cnZlLnRocmVlQSlcblx0ICAgIHJldHVybiB0aGlzLl90aHJlZURibCgpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB0aGlzLl9kYmwoKTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLl96ZXJvRGJsID0gZnVuY3Rpb24gX3plcm9EYmwoKSB7XG5cdCAgdmFyIG54O1xuXHQgIHZhciBueTtcblx0ICB2YXIgbno7XG5cdCAgLy8gWiA9IDFcblx0ICBpZiAodGhpcy56T25lKSB7XG5cdCAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTAuaHRtbFxuXHQgICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcblx0ICAgIC8vIDFNICsgNVMgKyAxNEFcblxuXHQgICAgLy8gWFggPSBYMV4yXG5cdCAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG5cdCAgICAvLyBZWSA9IFkxXjJcblx0ICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcblx0ICAgIC8vIFlZWVkgPSBZWV4yXG5cdCAgICB2YXIgeXl5eSA9IHl5LnJlZFNxcigpO1xuXHQgICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG5cdCAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG5cdCAgICBzID0gcy5yZWRJQWRkKHMpO1xuXHQgICAgLy8gTSA9IDMgKiBYWCArIGE7IGEgPSAwXG5cdCAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG5cdCAgICAvLyBUID0gTSBeIDIgLSAyKlNcblx0ICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG5cblx0ICAgIC8vIDggKiBZWVlZXG5cdCAgICB2YXIgeXl5eTggPSB5eXl5LnJlZElBZGQoeXl5eSk7XG5cdCAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXHQgICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblxuXHQgICAgLy8gWDMgPSBUXG5cdCAgICBueCA9IHQ7XG5cdCAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcblx0ICAgIG55ID0gbS5yZWRNdWwocy5yZWRJU3ViKHQpKS5yZWRJU3ViKHl5eXk4KTtcblx0ICAgIC8vIFozID0gMipZMVxuXHQgICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG5cdCAgfSBlbHNlIHtcblx0ICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG5cdCAgICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA5LWxcblx0ICAgIC8vIDJNICsgNVMgKyAxM0FcblxuXHQgICAgLy8gQSA9IFgxXjJcblx0ICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuXHQgICAgLy8gQiA9IFkxXjJcblx0ICAgIHZhciBiID0gdGhpcy55LnJlZFNxcigpO1xuXHQgICAgLy8gQyA9IEJeMlxuXHQgICAgdmFyIGMgPSBiLnJlZFNxcigpO1xuXHQgICAgLy8gRCA9IDIgKiAoKFgxICsgQileMiAtIEEgLSBDKVxuXHQgICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKTtcblx0ICAgIGQgPSBkLnJlZElBZGQoZCk7XG5cdCAgICAvLyBFID0gMyAqIEFcblx0ICAgIHZhciBlID0gYS5yZWRBZGQoYSkucmVkSUFkZChhKTtcblx0ICAgIC8vIEYgPSBFXjJcblx0ICAgIHZhciBmID0gZS5yZWRTcXIoKTtcblxuXHQgICAgLy8gOCAqIENcblx0ICAgIHZhciBjOCA9IGMucmVkSUFkZChjKTtcblx0ICAgIGM4ID0gYzgucmVkSUFkZChjOCk7XG5cdCAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXG5cdCAgICAvLyBYMyA9IEYgLSAyICogRFxuXHQgICAgbnggPSBmLnJlZElTdWIoZCkucmVkSVN1YihkKTtcblx0ICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcblx0ICAgIG55ID0gZS5yZWRNdWwoZC5yZWRJU3ViKG54KSkucmVkSVN1YihjOCk7XG5cdCAgICAvLyBaMyA9IDIgKiBZMSAqIFoxXG5cdCAgICBueiA9IHRoaXMueS5yZWRNdWwodGhpcy56KTtcblx0ICAgIG56ID0gbnoucmVkSUFkZChueik7XG5cdCAgfVxuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuX3RocmVlRGJsID0gZnVuY3Rpb24gX3RocmVlRGJsKCkge1xuXHQgIHZhciBueDtcblx0ICB2YXIgbnk7XG5cdCAgdmFyIG56O1xuXHQgIC8vIFogPSAxXG5cdCAgaWYgKHRoaXMuek9uZSkge1xuXHQgICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWxcblx0ICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG5cdCAgICAvLyAxTSArIDVTICsgMTVBXG5cblx0ICAgIC8vIFhYID0gWDFeMlxuXHQgICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuXHQgICAgLy8gWVkgPSBZMV4yXG5cdCAgICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG5cdCAgICAvLyBZWVlZID0gWVleMlxuXHQgICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcblx0ICAgIC8vIFMgPSAyICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKVxuXHQgICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuXHQgICAgcyA9IHMucmVkSUFkZChzKTtcblx0ICAgIC8vIE0gPSAzICogWFggKyBhXG5cdCAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCkucmVkSUFkZCh0aGlzLmN1cnZlLmEpO1xuXHQgICAgLy8gVCA9IE1eMiAtIDIgKiBTXG5cdCAgICB2YXIgdCA9IG0ucmVkU3FyKCkucmVkSVN1YihzKS5yZWRJU3ViKHMpO1xuXHQgICAgLy8gWDMgPSBUXG5cdCAgICBueCA9IHQ7XG5cdCAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcblx0ICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcblx0ICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG5cdCAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuXHQgICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuXHQgICAgLy8gWjMgPSAyICogWTFcblx0ICAgIG56ID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuXHQgIH0gZWxzZSB7XG5cdCAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbCNkb3VibGluZy1kYmwtMjAwMS1iXG5cdCAgICAvLyAzTSArIDVTXG5cblx0ICAgIC8vIGRlbHRhID0gWjFeMlxuXHQgICAgdmFyIGRlbHRhID0gdGhpcy56LnJlZFNxcigpO1xuXHQgICAgLy8gZ2FtbWEgPSBZMV4yXG5cdCAgICB2YXIgZ2FtbWEgPSB0aGlzLnkucmVkU3FyKCk7XG5cdCAgICAvLyBiZXRhID0gWDEgKiBnYW1tYVxuXHQgICAgdmFyIGJldGEgPSB0aGlzLngucmVkTXVsKGdhbW1hKTtcblx0ICAgIC8vIGFscGhhID0gMyAqIChYMSAtIGRlbHRhKSAqIChYMSArIGRlbHRhKVxuXHQgICAgdmFyIGFscGhhID0gdGhpcy54LnJlZFN1YihkZWx0YSkucmVkTXVsKHRoaXMueC5yZWRBZGQoZGVsdGEpKTtcblx0ICAgIGFscGhhID0gYWxwaGEucmVkQWRkKGFscGhhKS5yZWRJQWRkKGFscGhhKTtcblx0ICAgIC8vIFgzID0gYWxwaGFeMiAtIDggKiBiZXRhXG5cdCAgICB2YXIgYmV0YTQgPSBiZXRhLnJlZElBZGQoYmV0YSk7XG5cdCAgICBiZXRhNCA9IGJldGE0LnJlZElBZGQoYmV0YTQpO1xuXHQgICAgdmFyIGJldGE4ID0gYmV0YTQucmVkQWRkKGJldGE0KTtcblx0ICAgIG54ID0gYWxwaGEucmVkU3FyKCkucmVkSVN1YihiZXRhOCk7XG5cdCAgICAvLyBaMyA9IChZMSArIFoxKV4yIC0gZ2FtbWEgLSBkZWx0YVxuXHQgICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueikucmVkU3FyKCkucmVkSVN1YihnYW1tYSkucmVkSVN1YihkZWx0YSk7XG5cdCAgICAvLyBZMyA9IGFscGhhICogKDQgKiBiZXRhIC0gWDMpIC0gOCAqIGdhbW1hXjJcblx0ICAgIHZhciBnZ2FtbWE4ID0gZ2FtbWEucmVkU3FyKCk7XG5cdCAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuXHQgICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcblx0ICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG5cdCAgICBueSA9IGFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KTtcblx0ICB9XG5cblx0ICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG5cdH07XG5cblx0SlBvaW50LnByb3RvdHlwZS5fZGJsID0gZnVuY3Rpb24gX2RibCgpIHtcblx0ICB2YXIgYSA9IHRoaXMuY3VydmUuYTtcblxuXHQgIC8vIDRNICsgNlMgKyAxMEFcblx0ICB2YXIganggPSB0aGlzLng7XG5cdCAgdmFyIGp5ID0gdGhpcy55O1xuXHQgIHZhciBqeiA9IHRoaXMuejtcblx0ICB2YXIgano0ID0ganoucmVkU3FyKCkucmVkU3FyKCk7XG5cblx0ICB2YXIgangyID0gangucmVkU3FyKCk7XG5cdCAgdmFyIGp5MiA9IGp5LnJlZFNxcigpO1xuXG5cdCAgdmFyIGMgPSBqeDIucmVkQWRkKGp4MikucmVkSUFkZChqeDIpLnJlZElBZGQoYS5yZWRNdWwoano0KSk7XG5cblx0ICB2YXIganhkNCA9IGp4LnJlZEFkZChqeCk7XG5cdCAganhkNCA9IGp4ZDQucmVkSUFkZChqeGQ0KTtcblx0ICB2YXIgdDEgPSBqeGQ0LnJlZE11bChqeTIpO1xuXHQgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcblx0ICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblxuXHQgIHZhciBqeWQ4ID0gankyLnJlZFNxcigpO1xuXHQgIGp5ZDggPSBqeWQ4LnJlZElBZGQoanlkOCk7XG5cdCAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcblx0ICBqeWQ4ID0ganlkOC5yZWRJQWRkKGp5ZDgpO1xuXHQgIHZhciBueSA9IGMucmVkTXVsKHQyKS5yZWRJU3ViKGp5ZDgpO1xuXHQgIHZhciBueiA9IGp5LnJlZEFkZChqeSkucmVkTXVsKGp6KTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLnRycGwgPSBmdW5jdGlvbiB0cnBsKCkge1xuXHQgIGlmICghdGhpcy5jdXJ2ZS56ZXJvQSlcblx0ICAgIHJldHVybiB0aGlzLmRibCgpLmFkZCh0aGlzKTtcblxuXHQgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sI3RyaXBsaW5nLXRwbC0yMDA3LWJsXG5cdCAgLy8gNU0gKyAxMFMgKyAuLi5cblxuXHQgIC8vIFhYID0gWDFeMlxuXHQgIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcblx0ICAvLyBZWSA9IFkxXjJcblx0ICB2YXIgeXkgPSB0aGlzLnkucmVkU3FyKCk7XG5cdCAgLy8gWlogPSBaMV4yXG5cdCAgdmFyIHp6ID0gdGhpcy56LnJlZFNxcigpO1xuXHQgIC8vIFlZWVkgPSBZWV4yXG5cdCAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcblx0ICAvLyBNID0gMyAqIFhYICsgYSAqIFpaMjsgYSA9IDBcblx0ICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG5cdCAgLy8gTU0gPSBNXjJcblx0ICB2YXIgbW0gPSBtLnJlZFNxcigpO1xuXHQgIC8vIEUgPSA2ICogKChYMSArIFlZKV4yIC0gWFggLSBZWVlZKSAtIE1NXG5cdCAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuXHQgIGUgPSBlLnJlZElBZGQoZSk7XG5cdCAgZSA9IGUucmVkQWRkKGUpLnJlZElBZGQoZSk7XG5cdCAgZSA9IGUucmVkSVN1YihtbSk7XG5cdCAgLy8gRUUgPSBFXjJcblx0ICB2YXIgZWUgPSBlLnJlZFNxcigpO1xuXHQgIC8vIFQgPSAxNipZWVlZXG5cdCAgdmFyIHQgPSB5eXl5LnJlZElBZGQoeXl5eSk7XG5cdCAgdCA9IHQucmVkSUFkZCh0KTtcblx0ICB0ID0gdC5yZWRJQWRkKHQpO1xuXHQgIHQgPSB0LnJlZElBZGQodCk7XG5cdCAgLy8gVSA9IChNICsgRSleMiAtIE1NIC0gRUUgLSBUXG5cdCAgdmFyIHUgPSBtLnJlZElBZGQoZSkucmVkU3FyKCkucmVkSVN1YihtbSkucmVkSVN1YihlZSkucmVkSVN1Yih0KTtcblx0ICAvLyBYMyA9IDQgKiAoWDEgKiBFRSAtIDQgKiBZWSAqIFUpXG5cdCAgdmFyIHl5dTQgPSB5eS5yZWRNdWwodSk7XG5cdCAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcblx0ICB5eXU0ID0geXl1NC5yZWRJQWRkKHl5dTQpO1xuXHQgIHZhciBueCA9IHRoaXMueC5yZWRNdWwoZWUpLnJlZElTdWIoeXl1NCk7XG5cdCAgbnggPSBueC5yZWRJQWRkKG54KTtcblx0ICBueCA9IG54LnJlZElBZGQobngpO1xuXHQgIC8vIFkzID0gOCAqIFkxICogKFUgKiAoVCAtIFUpIC0gRSAqIEVFKVxuXHQgIHZhciBueSA9IHRoaXMueS5yZWRNdWwodS5yZWRNdWwodC5yZWRJU3ViKHUpKS5yZWRJU3ViKGUucmVkTXVsKGVlKSkpO1xuXHQgIG55ID0gbnkucmVkSUFkZChueSk7XG5cdCAgbnkgPSBueS5yZWRJQWRkKG55KTtcblx0ICBueSA9IG55LnJlZElBZGQobnkpO1xuXHQgIC8vIFozID0gKFoxICsgRSleMiAtIFpaIC0gRUVcblx0ICB2YXIgbnogPSB0aGlzLnoucmVkQWRkKGUpLnJlZFNxcigpLnJlZElTdWIoenopLnJlZElTdWIoZWUpO1xuXG5cdCAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGssIGtiYXNlKSB7XG5cdCAgayA9IG5ldyBibiQxKGssIGtiYXNlKTtcblxuXHQgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcShwKSB7XG5cdCAgaWYgKHAudHlwZSA9PT0gJ2FmZmluZScpXG5cdCAgICByZXR1cm4gdGhpcy5lcShwLnRvSigpKTtcblxuXHQgIGlmICh0aGlzID09PSBwKVxuXHQgICAgcmV0dXJuIHRydWU7XG5cblx0ICAvLyB4MSAqIHoyXjIgPT0geDIgKiB6MV4yXG5cdCAgdmFyIHoyID0gdGhpcy56LnJlZFNxcigpO1xuXHQgIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG5cdCAgaWYgKHRoaXMueC5yZWRNdWwocHoyKS5yZWRJU3ViKHAueC5yZWRNdWwoejIpKS5jbXBuKDApICE9PSAwKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgLy8geTEgKiB6Ml4zID09IHkyICogejFeM1xuXHQgIHZhciB6MyA9IHoyLnJlZE11bCh0aGlzLnopO1xuXHQgIHZhciBwejMgPSBwejIucmVkTXVsKHAueik7XG5cdCAgcmV0dXJuIHRoaXMueS5yZWRNdWwocHozKS5yZWRJU3ViKHAueS5yZWRNdWwoejMpKS5jbXBuKDApID09PSAwO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuZXFYVG9QID0gZnVuY3Rpb24gZXFYVG9QKHgpIHtcblx0ICB2YXIgenMgPSB0aGlzLnoucmVkU3FyKCk7XG5cdCAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHpzKTtcblx0ICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG5cdCAgICByZXR1cm4gdHJ1ZTtcblxuXHQgIHZhciB4YyA9IHguY2xvbmUoKTtcblx0ICB2YXIgdCA9IHRoaXMuY3VydmUucmVkTi5yZWRNdWwoenMpO1xuXHQgIGZvciAoOzspIHtcblx0ICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcblx0ICAgIGlmICh4Yy5jbXAodGhpcy5jdXJ2ZS5wKSA+PSAwKVxuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cblx0ICAgIHJ4LnJlZElBZGQodCk7XG5cdCAgICBpZiAodGhpcy54LmNtcChyeCkgPT09IDApXG5cdCAgICAgIHJldHVybiB0cnVlO1xuXHQgIH1cblx0fTtcblxuXHRKUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuXHQgIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiAnPEVDIEpQb2ludCBJbmZpbml0eT4nO1xuXHQgIHJldHVybiAnPEVDIEpQb2ludCB4OiAnICsgdGhpcy54LnRvU3RyaW5nKDE2LCAyKSArXG5cdCAgICAgICcgeTogJyArIHRoaXMueS50b1N0cmluZygxNiwgMikgK1xuXHQgICAgICAnIHo6ICcgKyB0aGlzLnoudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xuXHR9O1xuXG5cdEpQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG5cdCAgLy8gWFhYIFRoaXMgY29kZSBhc3N1bWVzIHRoYXQgemVybyBpcyBhbHdheXMgemVybyBpbiByZWRcblx0ICByZXR1cm4gdGhpcy56LmNtcG4oMCkgPT09IDA7XG5cdH07XG5cblx0dmFyIG1vbnQgPSB7fTtcblxuXHR2YXIgZWR3YXJkcyA9IHt9O1xuXG5cdHZhciBjdXJ2ZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGN1cnZlID0gZXhwb3J0cztcblxuXHRjdXJ2ZS5iYXNlID0gYmFzZTtcblx0Y3VydmUuc2hvcnQgPSBzaG9ydF8xO1xuXHRjdXJ2ZS5tb250ID0gbW9udDtcblx0Y3VydmUuZWR3YXJkcyA9IGVkd2FyZHM7XG5cdH0pO1xuXG5cdHZhciBzZWNwMjU2azEgPSB1bmRlZmluZWQ7XG5cblx0dmFyIGN1cnZlc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cblx0dmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cblxuXG5cblxuXHR2YXIgYXNzZXJ0ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBQcmVzZXRDdXJ2ZShvcHRpb25zKSB7XG5cdCAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3Nob3J0Jylcblx0ICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5zaG9ydChvcHRpb25zKTtcblx0ICBlbHNlIGlmIChvcHRpb25zLnR5cGUgPT09ICdlZHdhcmRzJylcblx0ICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5lZHdhcmRzKG9wdGlvbnMpO1xuXHQgIGVsc2Vcblx0ICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5tb250KG9wdGlvbnMpO1xuXHQgIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblx0ICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG5cdCAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoO1xuXG5cdCAgYXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLCAnSW52YWxpZCBjdXJ2ZScpO1xuXHQgIGFzc2VydCh0aGlzLmcubXVsKHRoaXMubikuaXNJbmZpbml0eSgpLCAnSW52YWxpZCBjdXJ2ZSwgRypOICE9IE8nKTtcblx0fVxuXHRjdXJ2ZXMuUHJlc2V0Q3VydmUgPSBQcmVzZXRDdXJ2ZTtcblxuXHRmdW5jdGlvbiBkZWZpbmVDdXJ2ZShuYW1lLCBvcHRpb25zKSB7XG5cdCAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuXHQgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuXHQgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgIGdldDogZnVuY3Rpb24oKSB7XG5cdCAgICAgIHZhciBjdXJ2ZSA9IG5ldyBQcmVzZXRDdXJ2ZShvcHRpb25zKTtcblx0ICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN1cnZlcywgbmFtZSwge1xuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIHZhbHVlOiBjdXJ2ZVxuXHQgICAgICB9KTtcblx0ICAgICAgcmV0dXJuIGN1cnZlO1xuXHQgICAgfVxuXHQgIH0pO1xuXHR9XG5cblx0ZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogJ3AxOTInLFxuXHQgIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG5cdCAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZjJyxcblx0ICBiOiAnNjQyMTA1MTkgZTU5YzgwZTcgMGZhN2U5YWIgNzIyNDMwNDkgZmViOGRlZWMgYzE0NmI5YjEnLFxuXHQgIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1Nixcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnMTg4ZGE4MGUgYjAzMDkwZjYgN2NiZjIwZWIgNDNhMTg4MDAgZjRmZjBhZmQgODJmZjEwMTInLFxuXHQgICAgJzA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExJ1xuXHQgIF1cblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ3AyMjQnLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogJ3AyMjQnLFxuXHQgIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScsXG5cdCAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcblx0ICBiOiAnYjQwNTBhODUgMGMwNGIzYWIgZjU0MTMyNTYgNTA0NGIwYjcgZDdiZmQ4YmEgMjcwYjM5NDMgMjM1NWZmYjQnLFxuXHQgIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmMTZhMiBlMGI4ZjAzZSAxM2RkMjk0NSA1YzVjMmEzZCcsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTI1Nixcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnYjcwZTBjYmQgNmJiNGJmN2YgMzIxMzkwYjkgNGEwM2MxZDMgNTZjMjExMjIgMzQzMjgwZDYgMTE1YzFkMjEnLFxuXHQgICAgJ2JkMzc2Mzg4IGI1ZjcyM2ZiIDRjMjJkZmU2IGNkNDM3NWEwIDVhMDc0NzY0IDQ0ZDU4MTk5IDg1MDA3ZTM0J1xuXHQgIF1cblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ3AyNTYnLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogbnVsbCxcblx0ICBwOiAnZmZmZmZmZmYgMDAwMDAwMDEgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuXHQgIGE6ICdmZmZmZmZmZiAwMDAwMDAwMSAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmYycsXG5cdCAgYjogJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJyxcblx0ICBuOiAnZmZmZmZmZmYgMDAwMDAwMDAgZmZmZmZmZmYgZmZmZmZmZmYgYmNlNmZhYWQgYTcxNzllODQgZjNiOWNhYzIgZmM2MzI1NTEnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyIDc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2Jyxcblx0ICAgICc0ZmUzNDJlMiBmZTFhN2Y5YiA4ZWU3ZWI0YSA3YzBmOWUxNiAyYmNlMzM1NyA2YjMxNWVjZSBjYmI2NDA2OCAzN2JmNTFmNSdcblx0ICBdXG5cdH0pO1xuXG5cdGRlZmluZUN1cnZlKCdwMzg0Jywge1xuXHQgIHR5cGU6ICdzaG9ydCcsXG5cdCAgcHJpbWU6IG51bGwsXG5cdCAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmZicsXG5cdCAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmYycsXG5cdCAgYjogJ2IzMzEyZmE3IGUyM2VlN2U0IDk4OGUwNTZiIGUzZjgyZDE5IDE4MWQ5YzZlIGZlODE0MTEyIDAzMTQwODhmICcgK1xuXHQgICAgICc1MDEzODc1YSBjNjU2Mzk4ZCA4YTJlZDE5ZCAyYTg1YzhlZCBkM2VjMmFlZicsXG5cdCAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxICcgK1xuXHQgICAgICdmNDM3MmRkZiA1ODFhMGRiMiA0OGIwYTc3YSBlY2VjMTk2YSBjY2M1Mjk3MycsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTM4NCxcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggJyArXG5cdCAgICAnNTUwMmYyNWQgYmY1NTI5NmMgM2E1NDVlMzggNzI3NjBhYjcnLFxuXHQgICAgJzM2MTdkZTRhIDk2MjYyYzZmIDVkOWU5OGJmIDkyOTJkYzI5IGY4ZjQxZGJkIDI4OWExNDdjIGU5ZGEzMTEzIGI1ZjBiOGMwICcgK1xuXHQgICAgJzBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmJ1xuXHQgIF1cblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ3A1MjEnLCB7XG5cdCAgdHlwZTogJ3Nob3J0Jyxcblx0ICBwcmltZTogbnVsbCxcblx0ICBwOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZicsXG5cdCAgYTogJzAwMDAwMWZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuXHQgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcblx0ICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmMnLFxuXHQgIGI6ICcwMDAwMDA1MSA5NTNlYjk2MSA4ZTFjOWExZiA5MjlhMjFhMCBiNjg1NDBlZSBhMmRhNzI1YiAnICtcblx0ICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG5cdCAgICAgJzNiYjFiZjA3IDM1NzNkZjg4IDNkMmMzNGYxIGVmNDUxZmQ0IDZiNTAzZjAwJyxcblx0ICBuOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG5cdCAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuXHQgICAgICdmNzA5YTVkMCAzYmI1YzliOCA4OTljNDdhZSBiYjZmYjcxZSA5MTM4NjQwOScsXG5cdCAgaGFzaDogaGFzaF8xLnNoYTUxMixcblx0ICBnUmVkOiBmYWxzZSxcblx0ICBnOiBbXG5cdCAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG5cdCAgICAnMDUzZmI1MjEgZjgyOGFmNjAgNmI0ZDNkYmEgYTE0YjVlNzcgZWZlNzU5MjggZmUxZGMxMjcgJyArXG5cdCAgICAnYTJmZmE4ZGUgMzM0OGIzYzEgODU2YTQyOWIgZjk3ZTdlMzEgYzJlNWJkNjYnLFxuXHQgICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuXHQgICAgJzU3OWI0NDY4IDE3YWZiZDE3IDI3M2U2NjJjIDk3ZWU3Mjk5IDVlZjQyNjQwIGM1NTBiOTAxICcgK1xuXHQgICAgJzNmYWQwNzYxIDM1M2M3MDg2IGEyNzJjMjQwIDg4YmU5NDc2IDlmZDE2NjUwJ1xuXHQgIF1cblx0fSk7XG5cblx0ZGVmaW5lQ3VydmUoJ2N1cnZlMjU1MTknLCB7XG5cdCAgdHlwZTogJ21vbnQnLFxuXHQgIHByaW1lOiAncDI1NTE5Jyxcblx0ICBwOiAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcsXG5cdCAgYTogJzc2ZDA2Jyxcblx0ICBiOiAnMScsXG5cdCAgbjogJzEwMDAwMDAwMDAwMDAwMDAgMDAwMDAwMDAwMDAwMDAwMCAxNGRlZjlkZWEyZjc5Y2Q2IDU4MTI2MzFhNWNmNWQzZWQnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cdCAgZ1JlZDogZmFsc2UsXG5cdCAgZzogW1xuXHQgICAgJzknXG5cdCAgXVxuXHR9KTtcblxuXHRkZWZpbmVDdXJ2ZSgnZWQyNTUxOScsIHtcblx0ICB0eXBlOiAnZWR3YXJkcycsXG5cdCAgcHJpbWU6ICdwMjU1MTknLFxuXHQgIHA6ICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyxcblx0ICBhOiAnLTEnLFxuXHQgIGM6ICcxJyxcblx0ICAvLyAtMTIxNjY1ICogKDEyMTY2Nl4oLTEpKSAobW9kIFApXG5cdCAgZDogJzUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTMnLFxuXHQgIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcblx0ICBoYXNoOiBoYXNoXzEuc2hhMjU2LFxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICcyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhJyxcblxuXHQgICAgLy8gNC81XG5cdCAgICAnNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY1OCdcblx0ICBdXG5cdH0pO1xuXG5cdHZhciBwcmU7XG5cdHRyeSB7XG5cdCAgcHJlID0gc2VjcDI1NmsxO1xuXHR9IGNhdGNoIChlKSB7XG5cdCAgcHJlID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0ZGVmaW5lQ3VydmUoJ3NlY3AyNTZrMScsIHtcblx0ICB0eXBlOiAnc2hvcnQnLFxuXHQgIHByaW1lOiAnazI1NicsXG5cdCAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyxcblx0ICBhOiAnMCcsXG5cdCAgYjogJzcnLFxuXHQgIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBiYWFlZGNlNiBhZjQ4YTAzYiBiZmQyNWU4YyBkMDM2NDE0MScsXG5cdCAgaDogJzEnLFxuXHQgIGhhc2g6IGhhc2hfMS5zaGEyNTYsXG5cblx0ICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cblx0ICBiZXRhOiAnN2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScsXG5cdCAgbGFtYmRhOiAnNTM2M2FkNGNjMDVjMzBlMGE1MjYxYzAyODgxMjY0NWExMjJlMjJlYTIwODE2Njc4ZGYwMjk2N2MxYjIzYmQ3MicsXG5cdCAgYmFzaXM6IFtcblx0ICAgIHtcblx0ICAgICAgYTogJzMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1Jyxcblx0ICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMydcblx0ICAgIH0sXG5cdCAgICB7XG5cdCAgICAgIGE6ICcxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnLFxuXHQgICAgICBiOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnXG5cdCAgICB9XG5cdCAgXSxcblxuXHQgIGdSZWQ6IGZhbHNlLFxuXHQgIGc6IFtcblx0ICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4Jyxcblx0ICAgICc0ODNhZGE3NzI2YTNjNDY1NWRhNGZiZmMwZTExMDhhOGZkMTdiNDQ4YTY4NTU0MTk5YzQ3ZDA4ZmZiMTBkNGI4Jyxcblx0ICAgIHByZVxuXHQgIF1cblx0fSk7XG5cdH0pO1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cdGZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcblx0ICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hY0RSQkcpKVxuXHQgICAgcmV0dXJuIG5ldyBIbWFjRFJCRyhvcHRpb25zKTtcblx0ICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cdCAgdGhpcy5wcmVkUmVzaXN0ID0gISFvcHRpb25zLnByZWRSZXNpc3Q7XG5cblx0ICB0aGlzLm91dExlbiA9IHRoaXMuaGFzaC5vdXRTaXplO1xuXHQgIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG5cdCAgdGhpcy5fcmVzZWVkID0gbnVsbDtcblx0ICB0aGlzLnJlc2VlZEludGVydmFsID0gbnVsbDtcblx0ICB0aGlzLksgPSBudWxsO1xuXHQgIHRoaXMuViA9IG51bGw7XG5cblx0ICB2YXIgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLmVudHJvcHksIG9wdGlvbnMuZW50cm9weUVuYyB8fCAnaGV4Jyk7XG5cdCAgdmFyIG5vbmNlID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMubm9uY2UsIG9wdGlvbnMubm9uY2VFbmMgfHwgJ2hleCcpO1xuXHQgIHZhciBwZXJzID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMucGVycywgb3B0aW9ucy5wZXJzRW5jIHx8ICdoZXgnKTtcblx0ICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuXHQgICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG5cdCAgdGhpcy5faW5pdChlbnRyb3B5LCBub25jZSwgcGVycyk7XG5cdH1cblx0dmFyIGhtYWNEcmJnID0gSG1hY0RSQkc7XG5cblx0SG1hY0RSQkcucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdChlbnRyb3B5LCBub25jZSwgcGVycykge1xuXHQgIHZhciBzZWVkID0gZW50cm9weS5jb25jYXQobm9uY2UpLmNvbmNhdChwZXJzKTtcblxuXHQgIHRoaXMuSyA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuXHQgIHRoaXMuViA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5WLmxlbmd0aDsgaSsrKSB7XG5cdCAgICB0aGlzLktbaV0gPSAweDAwO1xuXHQgICAgdGhpcy5WW2ldID0gMHgwMTtcblx0ICB9XG5cblx0ICB0aGlzLl91cGRhdGUoc2VlZCk7XG5cdCAgdGhpcy5fcmVzZWVkID0gMTtcblx0ICB0aGlzLnJlc2VlZEludGVydmFsID0gMHgxMDAwMDAwMDAwMDAwOyAgLy8gMl40OFxuXHR9O1xuXG5cdEhtYWNEUkJHLnByb3RvdHlwZS5faG1hYyA9IGZ1bmN0aW9uIGhtYWMoKSB7XG5cdCAgcmV0dXJuIG5ldyBoYXNoXzEuaG1hYyh0aGlzLmhhc2gsIHRoaXMuSyk7XG5cdH07XG5cblx0SG1hY0RSQkcucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoc2VlZCkge1xuXHQgIHZhciBrbWFjID0gdGhpcy5faG1hYygpXG5cdCAgICAgICAgICAgICAgICAgLnVwZGF0ZSh0aGlzLlYpXG5cdCAgICAgICAgICAgICAgICAgLnVwZGF0ZShbIDB4MDAgXSk7XG5cdCAgaWYgKHNlZWQpXG5cdCAgICBrbWFjID0ga21hYy51cGRhdGUoc2VlZCk7XG5cdCAgdGhpcy5LID0ga21hYy5kaWdlc3QoKTtcblx0ICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG5cdCAgaWYgKCFzZWVkKVxuXHQgICAgcmV0dXJuO1xuXG5cdCAgdGhpcy5LID0gdGhpcy5faG1hYygpXG5cdCAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuXHQgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMSBdKVxuXHQgICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXG5cdCAgICAgICAgICAgICAgIC5kaWdlc3QoKTtcblx0ICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG5cdH07XG5cblx0SG1hY0RSQkcucHJvdG90eXBlLnJlc2VlZCA9IGZ1bmN0aW9uIHJlc2VlZChlbnRyb3B5LCBlbnRyb3B5RW5jLCBhZGQsIGFkZEVuYykge1xuXHQgIC8vIE9wdGlvbmFsIGVudHJvcHkgZW5jXG5cdCAgaWYgKHR5cGVvZiBlbnRyb3B5RW5jICE9PSAnc3RyaW5nJykge1xuXHQgICAgYWRkRW5jID0gYWRkO1xuXHQgICAgYWRkID0gZW50cm9weUVuYztcblx0ICAgIGVudHJvcHlFbmMgPSBudWxsO1xuXHQgIH1cblxuXHQgIGVudHJvcHkgPSB1dGlsc18xLnRvQXJyYXkoZW50cm9weSwgZW50cm9weUVuYyk7XG5cdCAgYWRkID0gdXRpbHNfMS50b0FycmF5KGFkZCwgYWRkRW5jKTtcblxuXHQgIG1pbmltYWxpc3RpY0Fzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG5cdCAgICAgICAgICdOb3QgZW5vdWdoIGVudHJvcHkuIE1pbmltdW0gaXM6ICcgKyB0aGlzLm1pbkVudHJvcHkgKyAnIGJpdHMnKTtcblxuXHQgIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcblx0ICB0aGlzLl9yZXNlZWQgPSAxO1xuXHR9O1xuXG5cdEhtYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbiwgZW5jLCBhZGQsIGFkZEVuYykge1xuXHQgIGlmICh0aGlzLl9yZXNlZWQgPiB0aGlzLnJlc2VlZEludGVydmFsKVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdSZXNlZWQgaXMgcmVxdWlyZWQnKTtcblxuXHQgIC8vIE9wdGlvbmFsIGVuY29kaW5nXG5cdCAgaWYgKHR5cGVvZiBlbmMgIT09ICdzdHJpbmcnKSB7XG5cdCAgICBhZGRFbmMgPSBhZGQ7XG5cdCAgICBhZGQgPSBlbmM7XG5cdCAgICBlbmMgPSBudWxsO1xuXHQgIH1cblxuXHQgIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YVxuXHQgIGlmIChhZGQpIHtcblx0ICAgIGFkZCA9IHV0aWxzXzEudG9BcnJheShhZGQsIGFkZEVuYyB8fCAnaGV4Jyk7XG5cdCAgICB0aGlzLl91cGRhdGUoYWRkKTtcblx0ICB9XG5cblx0ICB2YXIgdGVtcCA9IFtdO1xuXHQgIHdoaWxlICh0ZW1wLmxlbmd0aCA8IGxlbikge1xuXHQgICAgdGhpcy5WID0gdGhpcy5faG1hYygpLnVwZGF0ZSh0aGlzLlYpLmRpZ2VzdCgpO1xuXHQgICAgdGVtcCA9IHRlbXAuY29uY2F0KHRoaXMuVik7XG5cdCAgfVxuXG5cdCAgdmFyIHJlcyA9IHRlbXAuc2xpY2UoMCwgbGVuKTtcblx0ICB0aGlzLl91cGRhdGUoYWRkKTtcblx0ICB0aGlzLl9yZXNlZWQrKztcblx0ICByZXR1cm4gdXRpbHNfMS5lbmNvZGUocmVzLCBlbmMpO1xuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblx0dmFyIGFzc2VydCQzID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXHRmdW5jdGlvbiBLZXlQYWlyKGVjLCBvcHRpb25zKSB7XG5cdCAgdGhpcy5lYyA9IGVjO1xuXHQgIHRoaXMucHJpdiA9IG51bGw7XG5cdCAgdGhpcy5wdWIgPSBudWxsO1xuXG5cdCAgLy8gS2V5UGFpcihlYywgeyBwcml2OiAuLi4sIHB1YjogLi4uIH0pXG5cdCAgaWYgKG9wdGlvbnMucHJpdilcblx0ICAgIHRoaXMuX2ltcG9ydFByaXZhdGUob3B0aW9ucy5wcml2LCBvcHRpb25zLnByaXZFbmMpO1xuXHQgIGlmIChvcHRpb25zLnB1Yilcblx0ICAgIHRoaXMuX2ltcG9ydFB1YmxpYyhvcHRpb25zLnB1Yiwgb3B0aW9ucy5wdWJFbmMpO1xuXHR9XG5cdHZhciBrZXkgPSBLZXlQYWlyO1xuXG5cdEtleVBhaXIuZnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGZyb21QdWJsaWMoZWMsIHB1YiwgZW5jKSB7XG5cdCAgaWYgKHB1YiBpbnN0YW5jZW9mIEtleVBhaXIpXG5cdCAgICByZXR1cm4gcHViO1xuXG5cdCAgcmV0dXJuIG5ldyBLZXlQYWlyKGVjLCB7XG5cdCAgICBwdWI6IHB1Yixcblx0ICAgIHB1YkVuYzogZW5jXG5cdCAgfSk7XG5cdH07XG5cblx0S2V5UGFpci5mcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGZyb21Qcml2YXRlKGVjLCBwcml2LCBlbmMpIHtcblx0ICBpZiAocHJpdiBpbnN0YW5jZW9mIEtleVBhaXIpXG5cdCAgICByZXR1cm4gcHJpdjtcblxuXHQgIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuXHQgICAgcHJpdjogcHJpdixcblx0ICAgIHByaXZFbmM6IGVuY1xuXHQgIH0pO1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gdmFsaWRhdGUoKSB7XG5cdCAgdmFyIHB1YiA9IHRoaXMuZ2V0UHVibGljKCk7XG5cblx0ICBpZiAocHViLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ0ludmFsaWQgcHVibGljIGtleScgfTtcblx0ICBpZiAoIXB1Yi52YWxpZGF0ZSgpKVxuXHQgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcblx0ICBpZiAoIXB1Yi5tdWwodGhpcy5lYy5jdXJ2ZS5uKS5pc0luZmluaXR5KCkpXG5cdCAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdQdWJsaWMga2V5ICogTiAhPSBPJyB9O1xuXG5cdCAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5nZXRQdWJsaWMgPSBmdW5jdGlvbiBnZXRQdWJsaWMoY29tcGFjdCwgZW5jKSB7XG5cdCAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuXHQgIGlmICh0eXBlb2YgY29tcGFjdCA9PT0gJ3N0cmluZycpIHtcblx0ICAgIGVuYyA9IGNvbXBhY3Q7XG5cdCAgICBjb21wYWN0ID0gbnVsbDtcblx0ICB9XG5cblx0ICBpZiAoIXRoaXMucHViKVxuXHQgICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cblx0ICBpZiAoIWVuYylcblx0ICAgIHJldHVybiB0aGlzLnB1YjtcblxuXHQgIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcblx0fTtcblxuXHRLZXlQYWlyLnByb3RvdHlwZS5nZXRQcml2YXRlID0gZnVuY3Rpb24gZ2V0UHJpdmF0ZShlbmMpIHtcblx0ICBpZiAoZW5jID09PSAnaGV4Jylcblx0ICAgIHJldHVybiB0aGlzLnByaXYudG9TdHJpbmcoMTYsIDIpO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiB0aGlzLnByaXY7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFByaXZhdGUgPSBmdW5jdGlvbiBfaW1wb3J0UHJpdmF0ZShrZXksIGVuYykge1xuXHQgIHRoaXMucHJpdiA9IG5ldyBibiQxKGtleSwgZW5jIHx8IDE2KTtcblxuXHQgIC8vIEVuc3VyZSB0aGF0IHRoZSBwcml2IHdvbid0IGJlIGJpZ2dlciB0aGFuIG4sIG90aGVyd2lzZSB3ZSBtYXkgZmFpbFxuXHQgIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuXHQgIHRoaXMucHJpdiA9IHRoaXMucHJpdi51bW9kKHRoaXMuZWMuY3VydmUubik7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcblx0ICBpZiAoa2V5LnggfHwga2V5LnkpIHtcblx0ICAgIC8vIE1vbnRnb21lcnkgcG9pbnRzIG9ubHkgaGF2ZSBhbiBgeGAgY29vcmRpbmF0ZS5cblx0ICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG5cdCAgICAvLyBgeWAgY29vcmRpbmF0ZXMuXG5cdCAgICBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnbW9udCcpIHtcblx0ICAgICAgYXNzZXJ0JDMoa2V5LngsICdOZWVkIHggY29vcmRpbmF0ZScpO1xuXHQgICAgfSBlbHNlIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdzaG9ydCcgfHxcblx0ICAgICAgICAgICAgICAgdGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnZWR3YXJkcycpIHtcblx0ICAgICAgYXNzZXJ0JDMoa2V5LnggJiYga2V5LnksICdOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlJyk7XG5cdCAgICB9XG5cdCAgICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUucG9pbnQoa2V5LngsIGtleS55KTtcblx0ICAgIHJldHVybjtcblx0ICB9XG5cdCAgdGhpcy5wdWIgPSB0aGlzLmVjLmN1cnZlLmRlY29kZVBvaW50KGtleSwgZW5jKTtcblx0fTtcblxuXHQvLyBFQ0RIXG5cdEtleVBhaXIucHJvdG90eXBlLmRlcml2ZSA9IGZ1bmN0aW9uIGRlcml2ZShwdWIpIHtcblx0ICByZXR1cm4gcHViLm11bCh0aGlzLnByaXYpLmdldFgoKTtcblx0fTtcblxuXHQvLyBFQ0RTQVxuXHRLZXlQYWlyLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGVuYywgb3B0aW9ucykge1xuXHQgIHJldHVybiB0aGlzLmVjLnNpZ24obXNnLCB0aGlzLCBlbmMsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdEtleVBhaXIucHJvdG90eXBlLnZlcmlmeSA9IGZ1bmN0aW9uIHZlcmlmeShtc2csIHNpZ25hdHVyZSkge1xuXHQgIHJldHVybiB0aGlzLmVjLnZlcmlmeShtc2csIHNpZ25hdHVyZSwgdGhpcyk7XG5cdH07XG5cblx0S2V5UGFpci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG5cdCAgcmV0dXJuICc8S2V5IHByaXY6ICcgKyAodGhpcy5wcml2ICYmIHRoaXMucHJpdi50b1N0cmluZygxNiwgMikpICtcblx0ICAgICAgICAgJyBwdWI6ICcgKyAodGhpcy5wdWIgJiYgdGhpcy5wdWIuaW5zcGVjdCgpKSArICcgPic7XG5cdH07XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cdHZhciBhc3NlcnQkNCA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cblx0ZnVuY3Rpb24gU2lnbmF0dXJlKG9wdGlvbnMsIGVuYykge1xuXHQgIGlmIChvcHRpb25zIGluc3RhbmNlb2YgU2lnbmF0dXJlKVxuXHQgICAgcmV0dXJuIG9wdGlvbnM7XG5cblx0ICBpZiAodGhpcy5faW1wb3J0REVSKG9wdGlvbnMsIGVuYykpXG5cdCAgICByZXR1cm47XG5cblx0ICBhc3NlcnQkNChvcHRpb25zLnIgJiYgb3B0aW9ucy5zLCAnU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzJyk7XG5cdCAgdGhpcy5yID0gbmV3IGJuJDEob3B0aW9ucy5yLCAxNik7XG5cdCAgdGhpcy5zID0gbmV3IGJuJDEob3B0aW9ucy5zLCAxNik7XG5cdCAgaWYgKG9wdGlvbnMucmVjb3ZlcnlQYXJhbSA9PT0gdW5kZWZpbmVkKVxuXHQgICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblx0ICBlbHNlXG5cdCAgICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBvcHRpb25zLnJlY292ZXJ5UGFyYW07XG5cdH1cblx0dmFyIHNpZ25hdHVyZSA9IFNpZ25hdHVyZTtcblxuXHRmdW5jdGlvbiBQb3NpdGlvbigpIHtcblx0ICB0aGlzLnBsYWNlID0gMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldExlbmd0aChidWYsIHApIHtcblx0ICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuXHQgIGlmICghKGluaXRpYWwgJiAweDgwKSkge1xuXHQgICAgcmV0dXJuIGluaXRpYWw7XG5cdCAgfVxuXHQgIHZhciBvY3RldExlbiA9IGluaXRpYWwgJiAweGY7XG5cblx0ICAvLyBJbmRlZmluaXRlIGxlbmd0aCBvciBvdmVyZmxvd1xuXHQgIGlmIChvY3RldExlbiA9PT0gMCB8fCBvY3RldExlbiA+IDQpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cblx0ICB2YXIgdmFsID0gMDtcblx0ICBmb3IgKHZhciBpID0gMCwgb2ZmID0gcC5wbGFjZTsgaSA8IG9jdGV0TGVuOyBpKyssIG9mZisrKSB7XG5cdCAgICB2YWwgPDw9IDg7XG5cdCAgICB2YWwgfD0gYnVmW29mZl07XG5cdCAgICB2YWwgPj4+PSAwO1xuXHQgIH1cblxuXHQgIC8vIExlYWRpbmcgemVyb2VzXG5cdCAgaWYgKHZhbCA8PSAweDdmKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXG5cdCAgcC5wbGFjZSA9IG9mZjtcblx0ICByZXR1cm4gdmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gcm1QYWRkaW5nKGJ1Zikge1xuXHQgIHZhciBpID0gMDtcblx0ICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG5cdCAgd2hpbGUgKCFidWZbaV0gJiYgIShidWZbaSArIDFdICYgMHg4MCkgJiYgaSA8IGxlbikge1xuXHQgICAgaSsrO1xuXHQgIH1cblx0ICBpZiAoaSA9PT0gMCkge1xuXHQgICAgcmV0dXJuIGJ1Zjtcblx0ICB9XG5cdCAgcmV0dXJuIGJ1Zi5zbGljZShpKTtcblx0fVxuXG5cdFNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG5cdCAgZGF0YSA9IHV0aWxzXzEkMS50b0FycmF5KGRhdGEsIGVuYyk7XG5cdCAgdmFyIHAgPSBuZXcgUG9zaXRpb24oKTtcblx0ICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgfVxuXHQgIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG5cdCAgaWYgKGxlbiA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgaWYgKChsZW4gKyBwLnBsYWNlKSAhPT0gZGF0YS5sZW5ndGgpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgcmxlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcblx0ICBpZiAocmxlbiA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgdmFyIHIgPSBkYXRhLnNsaWNlKHAucGxhY2UsIHJsZW4gKyBwLnBsYWNlKTtcblx0ICBwLnBsYWNlICs9IHJsZW47XG5cdCAgaWYgKGRhdGFbcC5wbGFjZSsrXSAhPT0gMHgwMikge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgc2xlbiA9IGdldExlbmd0aChkYXRhLCBwKTtcblx0ICBpZiAoc2xlbiA9PT0gZmFsc2UpIHtcblx0ICAgIHJldHVybiBmYWxzZTtcblx0ICB9XG5cdCAgaWYgKGRhdGEubGVuZ3RoICE9PSBzbGVuICsgcC5wbGFjZSkge1xuXHQgICAgcmV0dXJuIGZhbHNlO1xuXHQgIH1cblx0ICB2YXIgcyA9IGRhdGEuc2xpY2UocC5wbGFjZSwgc2xlbiArIHAucGxhY2UpO1xuXHQgIGlmIChyWzBdID09PSAwKSB7XG5cdCAgICBpZiAoclsxXSAmIDB4ODApIHtcblx0ICAgICAgciA9IHIuc2xpY2UoMSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBMZWFkaW5nIHplcm9lc1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXHQgIGlmIChzWzBdID09PSAwKSB7XG5cdCAgICBpZiAoc1sxXSAmIDB4ODApIHtcblx0ICAgICAgcyA9IHMuc2xpY2UoMSk7XG5cdCAgICB9IGVsc2Uge1xuXHQgICAgICAvLyBMZWFkaW5nIHplcm9lc1xuXHQgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgdGhpcy5yID0gbmV3IGJuJDEocik7XG5cdCAgdGhpcy5zID0gbmV3IGJuJDEocyk7XG5cdCAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcblxuXHQgIHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIGNvbnN0cnVjdExlbmd0aChhcnIsIGxlbikge1xuXHQgIGlmIChsZW4gPCAweDgwKSB7XG5cdCAgICBhcnIucHVzaChsZW4pO1xuXHQgICAgcmV0dXJuO1xuXHQgIH1cblx0ICB2YXIgb2N0ZXRzID0gMSArIChNYXRoLmxvZyhsZW4pIC8gTWF0aC5MTjIgPj4+IDMpO1xuXHQgIGFyci5wdXNoKG9jdGV0cyB8IDB4ODApO1xuXHQgIHdoaWxlICgtLW9jdGV0cykge1xuXHQgICAgYXJyLnB1c2goKGxlbiA+Pj4gKG9jdGV0cyA8PCAzKSkgJiAweGZmKTtcblx0ICB9XG5cdCAgYXJyLnB1c2gobGVuKTtcblx0fVxuXG5cdFNpZ25hdHVyZS5wcm90b3R5cGUudG9ERVIgPSBmdW5jdGlvbiB0b0RFUihlbmMpIHtcblx0ICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG5cdCAgdmFyIHMgPSB0aGlzLnMudG9BcnJheSgpO1xuXG5cdCAgLy8gUGFkIHZhbHVlc1xuXHQgIGlmIChyWzBdICYgMHg4MClcblx0ICAgIHIgPSBbIDAgXS5jb25jYXQocik7XG5cdCAgLy8gUGFkIHZhbHVlc1xuXHQgIGlmIChzWzBdICYgMHg4MClcblx0ICAgIHMgPSBbIDAgXS5jb25jYXQocyk7XG5cblx0ICByID0gcm1QYWRkaW5nKHIpO1xuXHQgIHMgPSBybVBhZGRpbmcocyk7XG5cblx0ICB3aGlsZSAoIXNbMF0gJiYgIShzWzFdICYgMHg4MCkpIHtcblx0ICAgIHMgPSBzLnNsaWNlKDEpO1xuXHQgIH1cblx0ICB2YXIgYXJyID0gWyAweDAyIF07XG5cdCAgY29uc3RydWN0TGVuZ3RoKGFyciwgci5sZW5ndGgpO1xuXHQgIGFyciA9IGFyci5jb25jYXQocik7XG5cdCAgYXJyLnB1c2goMHgwMik7XG5cdCAgY29uc3RydWN0TGVuZ3RoKGFyciwgcy5sZW5ndGgpO1xuXHQgIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG5cdCAgdmFyIHJlcyA9IFsgMHgzMCBdO1xuXHQgIGNvbnN0cnVjdExlbmd0aChyZXMsIGJhY2tIYWxmLmxlbmd0aCk7XG5cdCAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG5cdCAgcmV0dXJuIHV0aWxzXzEkMS5lbmNvZGUocmVzLCBlbmMpO1xuXHR9O1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXG5cblxuXG5cblx0dmFyIGFzc2VydCQ1ID0gdXRpbHNfMSQxLmFzc2VydDtcblxuXG5cblxuXHRmdW5jdGlvbiBFQyhvcHRpb25zKSB7XG5cdCAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVDKSlcblx0ICAgIHJldHVybiBuZXcgRUMob3B0aW9ucyk7XG5cblx0ICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG5cdCAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuXHQgICAgYXNzZXJ0JDUoY3VydmVzXzEuaGFzT3duUHJvcGVydHkob3B0aW9ucyksICdVbmtub3duIGN1cnZlICcgKyBvcHRpb25zKTtcblxuXHQgICAgb3B0aW9ucyA9IGN1cnZlc18xW29wdGlvbnNdO1xuXHQgIH1cblxuXHQgIC8vIFNob3J0Y3V0IGZvciBgZWxsaXB0aWMuZWMoZWxsaXB0aWMuY3VydmVzLmN1cnZlTmFtZSlgXG5cdCAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXNfMS5QcmVzZXRDdXJ2ZSlcblx0ICAgIG9wdGlvbnMgPSB7IGN1cnZlOiBvcHRpb25zIH07XG5cblx0ICB0aGlzLmN1cnZlID0gb3B0aW9ucy5jdXJ2ZS5jdXJ2ZTtcblx0ICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG5cdCAgdGhpcy5uaCA9IHRoaXMubi51c2hybigxKTtcblx0ICB0aGlzLmcgPSB0aGlzLmN1cnZlLmc7XG5cblx0ICAvLyBQb2ludCBvbiBjdXJ2ZVxuXHQgIHRoaXMuZyA9IG9wdGlvbnMuY3VydmUuZztcblx0ICB0aGlzLmcucHJlY29tcHV0ZShvcHRpb25zLmN1cnZlLm4uYml0TGVuZ3RoKCkgKyAxKTtcblxuXHQgIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG5cdCAgdGhpcy5oYXNoID0gb3B0aW9ucy5oYXNoIHx8IG9wdGlvbnMuY3VydmUuaGFzaDtcblx0fVxuXHR2YXIgZWMgPSBFQztcblxuXHRFQy5wcm90b3R5cGUua2V5UGFpciA9IGZ1bmN0aW9uIGtleVBhaXIob3B0aW9ucykge1xuXHQgIHJldHVybiBuZXcga2V5KHRoaXMsIG9wdGlvbnMpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5rZXlGcm9tUHJpdmF0ZSA9IGZ1bmN0aW9uIGtleUZyb21Qcml2YXRlKHByaXYsIGVuYykge1xuXHQgIHJldHVybiBrZXkuZnJvbVByaXZhdGUodGhpcywgcHJpdiwgZW5jKTtcblx0fTtcblxuXHRFQy5wcm90b3R5cGUua2V5RnJvbVB1YmxpYyA9IGZ1bmN0aW9uIGtleUZyb21QdWJsaWMocHViLCBlbmMpIHtcblx0ICByZXR1cm4ga2V5LmZyb21QdWJsaWModGhpcywgcHViLCBlbmMpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5nZW5LZXlQYWlyID0gZnVuY3Rpb24gZ2VuS2V5UGFpcihvcHRpb25zKSB7XG5cdCAgaWYgKCFvcHRpb25zKVxuXHQgICAgb3B0aW9ucyA9IHt9O1xuXG5cdCAgLy8gSW5zdGFudGlhdGUgSG1hY19EUkJHXG5cdCAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuXHQgICAgaGFzaDogdGhpcy5oYXNoLFxuXHQgICAgcGVyczogb3B0aW9ucy5wZXJzLFxuXHQgICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4Jyxcblx0ICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCBicm9yYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuXHQgICAgZW50cm9weUVuYzogb3B0aW9ucy5lbnRyb3B5ICYmIG9wdGlvbnMuZW50cm9weUVuYyB8fCAndXRmOCcsXG5cdCAgICBub25jZTogdGhpcy5uLnRvQXJyYXkoKVxuXHQgIH0pO1xuXG5cdCAgdmFyIGJ5dGVzID0gdGhpcy5uLmJ5dGVMZW5ndGgoKTtcblx0ICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgYm4kMSgyKSk7XG5cdCAgZG8ge1xuXHQgICAgdmFyIHByaXYgPSBuZXcgYm4kMShkcmJnLmdlbmVyYXRlKGJ5dGVzKSk7XG5cdCAgICBpZiAocHJpdi5jbXAobnMyKSA+IDApXG5cdCAgICAgIGNvbnRpbnVlO1xuXG5cdCAgICBwcml2LmlhZGRuKDEpO1xuXHQgICAgcmV0dXJuIHRoaXMua2V5RnJvbVByaXZhdGUocHJpdik7XG5cdCAgfSB3aGlsZSAodHJ1ZSk7XG5cdH07XG5cblx0RUMucHJvdG90eXBlLl90cnVuY2F0ZVRvTiA9IGZ1bmN0aW9uIHRydW5jYXRlVG9OKG1zZywgdHJ1bmNPbmx5KSB7XG5cdCAgdmFyIGRlbHRhID0gbXNnLmJ5dGVMZW5ndGgoKSAqIDggLSB0aGlzLm4uYml0TGVuZ3RoKCk7XG5cdCAgaWYgKGRlbHRhID4gMClcblx0ICAgIG1zZyA9IG1zZy51c2hybihkZWx0YSk7XG5cdCAgaWYgKCF0cnVuY09ubHkgJiYgbXNnLmNtcCh0aGlzLm4pID49IDApXG5cdCAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuXHQgIGVsc2Vcblx0ICAgIHJldHVybiBtc2c7XG5cdH07XG5cblx0RUMucHJvdG90eXBlLnNpZ24gPSBmdW5jdGlvbiBzaWduKG1zZywga2V5LCBlbmMsIG9wdGlvbnMpIHtcblx0ICBpZiAodHlwZW9mIGVuYyA9PT0gJ29iamVjdCcpIHtcblx0ICAgIG9wdGlvbnMgPSBlbmM7XG5cdCAgICBlbmMgPSBudWxsO1xuXHQgIH1cblx0ICBpZiAoIW9wdGlvbnMpXG5cdCAgICBvcHRpb25zID0ge307XG5cblx0ICBrZXkgPSB0aGlzLmtleUZyb21Qcml2YXRlKGtleSwgZW5jKTtcblx0ICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgYm4kMShtc2csIDE2KSk7XG5cblx0ICAvLyBaZXJvLWV4dGVuZCBrZXkgdG8gcHJvdmlkZSBlbm91Z2ggZW50cm9weVxuXHQgIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG5cdCAgdmFyIGJrZXkgPSBrZXkuZ2V0UHJpdmF0ZSgpLnRvQXJyYXkoJ2JlJywgYnl0ZXMpO1xuXG5cdCAgLy8gWmVyby1leHRlbmQgbm9uY2UgdG8gaGF2ZSB0aGUgc2FtZSBieXRlIHNpemUgYXMgTlxuXHQgIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuXHQgIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuXHQgIHZhciBkcmJnID0gbmV3IGhtYWNEcmJnKHtcblx0ICAgIGhhc2g6IHRoaXMuaGFzaCxcblx0ICAgIGVudHJvcHk6IGJrZXksXG5cdCAgICBub25jZTogbm9uY2UsXG5cdCAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG5cdCAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnXG5cdCAgfSk7XG5cblx0ICAvLyBOdW1iZXIgb2YgYnl0ZXMgdG8gZ2VuZXJhdGVcblx0ICB2YXIgbnMxID0gdGhpcy5uLnN1YihuZXcgYm4kMSgxKSk7XG5cblx0ICBmb3IgKHZhciBpdGVyID0gMDsgdHJ1ZTsgaXRlcisrKSB7XG5cdCAgICB2YXIgayA9IG9wdGlvbnMuayA/XG5cdCAgICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcblx0ICAgICAgICBuZXcgYm4kMShkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcblx0ICAgIGsgPSB0aGlzLl90cnVuY2F0ZVRvTihrLCB0cnVlKTtcblx0ICAgIGlmIChrLmNtcG4oMSkgPD0gMCB8fCBrLmNtcChuczEpID49IDApXG5cdCAgICAgIGNvbnRpbnVlO1xuXG5cdCAgICB2YXIga3AgPSB0aGlzLmcubXVsKGspO1xuXHQgICAgaWYgKGtwLmlzSW5maW5pdHkoKSlcblx0ICAgICAgY29udGludWU7XG5cblx0ICAgIHZhciBrcFggPSBrcC5nZXRYKCk7XG5cdCAgICB2YXIgciA9IGtwWC51bW9kKHRoaXMubik7XG5cdCAgICBpZiAoci5jbXBuKDApID09PSAwKVxuXHQgICAgICBjb250aW51ZTtcblxuXHQgICAgdmFyIHMgPSBrLmludm0odGhpcy5uKS5tdWwoci5tdWwoa2V5LmdldFByaXZhdGUoKSkuaWFkZChtc2cpKTtcblx0ICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcblx0ICAgIGlmIChzLmNtcG4oMCkgPT09IDApXG5cdCAgICAgIGNvbnRpbnVlO1xuXG5cdCAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIChrcFguY21wKHIpICE9PSAwID8gMiA6IDApO1xuXG5cdCAgICAvLyBVc2UgY29tcGxlbWVudCBvZiBgc2AsIGlmIGl0IGlzID4gYG4gLyAyYFxuXHQgICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuXHQgICAgICBzID0gdGhpcy5uLnN1YihzKTtcblx0ICAgICAgcmVjb3ZlcnlQYXJhbSBePSAxO1xuXHQgICAgfVxuXG5cdCAgICByZXR1cm4gbmV3IHNpZ25hdHVyZSh7IHI6IHIsIHM6IHMsIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG5cdCAgfVxuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUkMSwga2V5LCBlbmMpIHtcblx0ICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgYm4kMShtc2csIDE2KSk7XG5cdCAga2V5ID0gdGhpcy5rZXlGcm9tUHVibGljKGtleSwgZW5jKTtcblx0ICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsICdoZXgnKTtcblxuXHQgIC8vIFBlcmZvcm0gcHJpbWl0aXZlIHZhbHVlcyB2YWxpZGF0aW9uXG5cdCAgdmFyIHIgPSBzaWduYXR1cmUkMS5yO1xuXHQgIHZhciBzID0gc2lnbmF0dXJlJDEucztcblx0ICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdCAgaWYgKHMuY21wbigxKSA8IDAgfHwgcy5jbXAodGhpcy5uKSA+PSAwKVxuXHQgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgLy8gVmFsaWRhdGUgc2lnbmF0dXJlXG5cdCAgdmFyIHNpbnYgPSBzLmludm0odGhpcy5uKTtcblx0ICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcblx0ICB2YXIgdTIgPSBzaW52Lm11bChyKS51bW9kKHRoaXMubik7XG5cblx0ICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuXHQgICAgdmFyIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcblx0ICAgIGlmIChwLmlzSW5maW5pdHkoKSlcblx0ICAgICAgcmV0dXJuIGZhbHNlO1xuXG5cdCAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcblx0ICB9XG5cblx0ICAvLyBOT1RFOiBHcmVnIE1heHdlbGwncyB0cmljaywgaW5zcGlyZWQgYnk6XG5cdCAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuXHQgIHZhciBwID0gdGhpcy5nLmptdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuXHQgIGlmIChwLmlzSW5maW5pdHkoKSlcblx0ICAgIHJldHVybiBmYWxzZTtcblxuXHQgIC8vIENvbXBhcmUgYHAueGAgb2YgSmFjb2JpYW4gcG9pbnQgd2l0aCBgcmAsXG5cdCAgLy8gdGhpcyB3aWxsIGRvIGBwLnggPT0gciAqIHAuel4yYCBpbnN0ZWFkIG9mIG11bHRpcGx5aW5nIGBwLnhgIGJ5IHRoZVxuXHQgIC8vIGludmVyc2Ugb2YgYHAuel4yYFxuXHQgIHJldHVybiBwLmVxWFRvUChyKTtcblx0fTtcblxuXHRFQy5wcm90b3R5cGUucmVjb3ZlclB1YktleSA9IGZ1bmN0aW9uKG1zZywgc2lnbmF0dXJlJDEsIGosIGVuYykge1xuXHQgIGFzc2VydCQ1KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG5cdCAgc2lnbmF0dXJlJDEgPSBuZXcgc2lnbmF0dXJlKHNpZ25hdHVyZSQxLCBlbmMpO1xuXG5cdCAgdmFyIG4gPSB0aGlzLm47XG5cdCAgdmFyIGUgPSBuZXcgYm4kMShtc2cpO1xuXHQgIHZhciByID0gc2lnbmF0dXJlJDEucjtcblx0ICB2YXIgcyA9IHNpZ25hdHVyZSQxLnM7XG5cblx0ICAvLyBBIHNldCBMU0Igc2lnbmlmaWVzIHRoYXQgdGhlIHktY29vcmRpbmF0ZSBpcyBvZGRcblx0ICB2YXIgaXNZT2RkID0gaiAmIDE7XG5cdCAgdmFyIGlzU2Vjb25kS2V5ID0gaiA+PiAxO1xuXHQgIGlmIChyLmNtcCh0aGlzLmN1cnZlLnAudW1vZCh0aGlzLmN1cnZlLm4pKSA+PSAwICYmIGlzU2Vjb25kS2V5KVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBzZW5jb25kIGtleSBjYW5kaW5hdGUnKTtcblxuXHQgIC8vIDEuMS4gTGV0IHggPSByICsgam4uXG5cdCAgaWYgKGlzU2Vjb25kS2V5KVxuXHQgICAgciA9IHRoaXMuY3VydmUucG9pbnRGcm9tWChyLmFkZCh0aGlzLmN1cnZlLm4pLCBpc1lPZGQpO1xuXHQgIGVsc2Vcblx0ICAgIHIgPSB0aGlzLmN1cnZlLnBvaW50RnJvbVgociwgaXNZT2RkKTtcblxuXHQgIHZhciBySW52ID0gc2lnbmF0dXJlJDEuci5pbnZtKG4pO1xuXHQgIHZhciBzMSA9IG4uc3ViKGUpLm11bChySW52KS51bW9kKG4pO1xuXHQgIHZhciBzMiA9IHMubXVsKHJJbnYpLnVtb2Qobik7XG5cblx0ICAvLyAxLjYuMSBDb21wdXRlIFEgPSByXi0xIChzUiAtICBlRylcblx0ICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcblx0ICByZXR1cm4gdGhpcy5nLm11bEFkZChzMSwgciwgczIpO1xuXHR9O1xuXG5cdEVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlJDEsIFEsIGVuYykge1xuXHQgIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgZW5jKTtcblx0ICBpZiAoc2lnbmF0dXJlJDEucmVjb3ZlcnlQYXJhbSAhPT0gbnVsbClcblx0ICAgIHJldHVybiBzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtO1xuXG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgIHZhciBRcHJpbWU7XG5cdCAgICB0cnkge1xuXHQgICAgICBRcHJpbWUgPSB0aGlzLnJlY292ZXJQdWJLZXkoZSwgc2lnbmF0dXJlJDEsIGkpO1xuXHQgICAgfSBjYXRjaCAoZSkge1xuXHQgICAgICBjb250aW51ZTtcblx0ICAgIH1cblxuXHQgICAgaWYgKFFwcmltZS5lcShRKSlcblx0ICAgICAgcmV0dXJuIGk7XG5cdCAgfVxuXHQgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgdmFsaWQgcmVjb3ZlcnkgZmFjdG9yJyk7XG5cdH07XG5cblx0dmFyIGVkZHNhID0ge307XG5cblx0dmFyIHJlcXVpcmUkJDAkMSA9IGdldENqc0V4cG9ydEZyb21OYW1lc3BhY2UoX3BhY2thZ2UkMSk7XG5cblx0dmFyIGVsbGlwdGljXzEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5cdGVsbGlwdGljLnZlcnNpb24gPSByZXF1aXJlJCQwJDEudmVyc2lvbjtcblx0ZWxsaXB0aWMudXRpbHMgPSB1dGlsc18xJDE7XG5cdGVsbGlwdGljLnJhbmQgPSBicm9yYW5kO1xuXHRlbGxpcHRpYy5jdXJ2ZSA9IGN1cnZlXzE7XG5cdGVsbGlwdGljLmN1cnZlcyA9IGN1cnZlc18xO1xuXG5cdC8vIFByb3RvY29sc1xuXHRlbGxpcHRpYy5lYyA9IGVjO1xuXHRlbGxpcHRpYy5lZGRzYSA9IGVkZHNhO1xuXHR9KTtcblx0dmFyIGVsbGlwdGljXzIgPSBlbGxpcHRpY18xLmVjO1xuXG5cdHZhciBfdmVyc2lvbiRxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInNpZ25pbmcta2V5LzUuMC40XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHIgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJHEpO1xuXHR2YXIgX3ZlcnNpb25fMSRkID0gX3ZlcnNpb24kcS52ZXJzaW9uO1xuXG5cdHZhciBsaWIkZiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRxLnZlcnNpb24pO1xuXHR2YXIgX2N1cnZlID0gbnVsbDtcblx0ZnVuY3Rpb24gZ2V0Q3VydmUoKSB7XG5cdCAgICBpZiAoIV9jdXJ2ZSkge1xuXHQgICAgICAgIF9jdXJ2ZSA9IG5ldyBlbGxpcHRpY18xLmVjKFwic2VjcDI1NmsxXCIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF9jdXJ2ZTtcblx0fVxuXHR2YXIgU2lnbmluZ0tleSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFNpZ25pbmdLZXkocHJpdmF0ZUtleSkge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY3VydmVcIiwgXCJzZWNwMjU2azFcIik7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcml2YXRlS2V5XCIsIGxpYiQxLmhleGxpZnkocHJpdmF0ZUtleSkpO1xuXHQgICAgICAgIHZhciBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShsaWIkMS5hcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyhmYWxzZSwgXCJoZXhcIikpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY29tcHJlc3NlZFB1YmxpY0tleVwiLCBcIjB4XCIgKyBrZXlQYWlyLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNTaWduaW5nS2V5XCIsIHRydWUpO1xuXHQgICAgfVxuXHQgICAgU2lnbmluZ0tleS5wcm90b3R5cGUuX2FkZFBvaW50ID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdCAgICAgICAgdmFyIHAwID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGxpYiQxLmFycmF5aWZ5KHRoaXMucHVibGljS2V5KSk7XG5cdCAgICAgICAgdmFyIHAxID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGxpYiQxLmFycmF5aWZ5KG90aGVyKSk7XG5cdCAgICAgICAgcmV0dXJuIFwiMHhcIiArIHAwLnB1Yi5hZGQocDEucHViKS5lbmNvZGVDb21wcmVzc2VkKFwiaGV4XCIpO1xuXHQgICAgfTtcblx0ICAgIFNpZ25pbmdLZXkucHJvdG90eXBlLnNpZ25EaWdlc3QgPSBmdW5jdGlvbiAoZGlnZXN0KSB7XG5cdCAgICAgICAgdmFyIGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGxpYiQxLmFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuXHQgICAgICAgIHZhciBzaWduYXR1cmUgPSBrZXlQYWlyLnNpZ24obGliJDEuYXJyYXlpZnkoZGlnZXN0KSwgeyBjYW5vbmljYWw6IHRydWUgfSk7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLnNwbGl0U2lnbmF0dXJlKHtcblx0ICAgICAgICAgICAgcmVjb3ZlcnlQYXJhbTogc2lnbmF0dXJlLnJlY292ZXJ5UGFyYW0sXG5cdCAgICAgICAgICAgIHI6IGxpYiQxLmhleFplcm9QYWQoXCIweFwiICsgc2lnbmF0dXJlLnIudG9TdHJpbmcoMTYpLCAzMiksXG5cdCAgICAgICAgICAgIHM6IGxpYiQxLmhleFplcm9QYWQoXCIweFwiICsgc2lnbmF0dXJlLnMudG9TdHJpbmcoMTYpLCAzMiksXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgU2lnbmluZ0tleS5wcm90b3R5cGUuY29tcHV0ZVNoYXJlZFNlY3JldCA9IGZ1bmN0aW9uIChvdGhlcktleSkge1xuXHQgICAgICAgIHZhciBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShsaWIkMS5hcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcblx0ICAgICAgICB2YXIgb3RoZXJLZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGxpYiQxLmFycmF5aWZ5KGNvbXB1dGVQdWJsaWNLZXkob3RoZXJLZXkpKSk7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLmhleFplcm9QYWQoXCIweFwiICsga2V5UGFpci5kZXJpdmUob3RoZXJLZXlQYWlyLmdldFB1YmxpYygpKS50b1N0cmluZygxNiksIDMyKTtcblx0ICAgIH07XG5cdCAgICBTaWduaW5nS2V5LmlzU2lnbmluZ0tleSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNTaWduaW5nS2V5KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gU2lnbmluZ0tleTtcblx0fSgpKTtcblx0ZXhwb3J0cy5TaWduaW5nS2V5ID0gU2lnbmluZ0tleTtcblx0ZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShkaWdlc3QsIHNpZ25hdHVyZSkge1xuXHQgICAgdmFyIHNpZyA9IGxpYiQxLnNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG5cdCAgICB2YXIgcnMgPSB7IHI6IGxpYiQxLmFycmF5aWZ5KHNpZy5yKSwgczogbGliJDEuYXJyYXlpZnkoc2lnLnMpIH07XG5cdCAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5yZWNvdmVyUHViS2V5KGxpYiQxLmFycmF5aWZ5KGRpZ2VzdCksIHJzLCBzaWcucmVjb3ZlcnlQYXJhbSkuZW5jb2RlKFwiaGV4XCIsIGZhbHNlKTtcblx0fVxuXHRleHBvcnRzLnJlY292ZXJQdWJsaWNLZXkgPSByZWNvdmVyUHVibGljS2V5O1xuXHRmdW5jdGlvbiBjb21wdXRlUHVibGljS2V5KGtleSwgY29tcHJlc3NlZCkge1xuXHQgICAgdmFyIGJ5dGVzID0gbGliJDEuYXJyYXlpZnkoa2V5KTtcblx0ICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG5cdCAgICAgICAgdmFyIHNpZ25pbmdLZXkgPSBuZXcgU2lnbmluZ0tleShieXRlcyk7XG5cdCAgICAgICAgaWYgKGNvbXByZXNzZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVByaXZhdGUoYnl0ZXMpLmdldFB1YmxpYyh0cnVlLCBcImhleFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHNpZ25pbmdLZXkucHVibGljS2V5O1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMykge1xuXHQgICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5oZXhsaWZ5KGJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhieXRlcykuZ2V0UHVibGljKGZhbHNlLCBcImhleFwiKTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcblx0ICAgICAgICBpZiAoIWNvbXByZXNzZWQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkoYnl0ZXMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHVibGljKGJ5dGVzKS5nZXRQdWJsaWModHJ1ZSwgXCJoZXhcIik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHVibGljIG9yIHByaXZhdGUga2V5XCIsIFwia2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0fVxuXHRleHBvcnRzLmNvbXB1dGVQdWJsaWNLZXkgPSBjb21wdXRlUHVibGljS2V5O1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRmID0gdW53cmFwRXhwb3J0cyhsaWIkZik7XG5cdHZhciBsaWJfMSRmID0gbGliJGYuU2lnbmluZ0tleTtcblx0dmFyIGxpYl8yJGUgPSBsaWIkZi5yZWNvdmVyUHVibGljS2V5O1xuXHR2YXIgbGliXzMkYiA9IGxpYiRmLmNvbXB1dGVQdWJsaWNLZXk7XG5cblx0dmFyIF92ZXJzaW9uJHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwidHJhbnNhY3Rpb25zLzUuMC41XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHQgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJHMpO1xuXHR2YXIgX3ZlcnNpb25fMSRlID0gX3ZlcnNpb24kcy52ZXJzaW9uO1xuXG5cdHZhciBsaWIkZyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcblx0ICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXG5cdHZhciBSTFAgPSBfX2ltcG9ydFN0YXIobGliJDUpO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kcy52ZXJzaW9uKTtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHRmdW5jdGlvbiBoYW5kbGVBZGRyZXNzKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQ2LmdldEFkZHJlc3ModmFsdWUpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhbmRsZU51bWJlcih2YWx1ZSkge1xuXHQgICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDcuWmVybztcblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG5cdH1cblx0dmFyIHRyYW5zYWN0aW9uRmllbGRzID0gW1xuXHQgICAgeyBuYW1lOiBcIm5vbmNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcblx0ICAgIHsgbmFtZTogXCJnYXNQcmljZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG5cdCAgICB7IG5hbWU6IFwiZ2FzTGltaXRcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuXHQgICAgeyBuYW1lOiBcInRvXCIsIGxlbmd0aDogMjAgfSxcblx0ICAgIHsgbmFtZTogXCJ2YWx1ZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG5cdCAgICB7IG5hbWU6IFwiZGF0YVwiIH0sXG5cdF07XG5cdHZhciBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuXHQgICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlXG5cdH07XG5cdGZ1bmN0aW9uIGNvbXB1dGVBZGRyZXNzKGtleSkge1xuXHQgICAgdmFyIHB1YmxpY0tleSA9IGxpYiRmLmNvbXB1dGVQdWJsaWNLZXkoa2V5KTtcblx0ICAgIHJldHVybiBsaWIkNi5nZXRBZGRyZXNzKGxpYiQxLmhleERhdGFTbGljZShsaWIkNC5rZWNjYWsyNTYobGliJDEuaGV4RGF0YVNsaWNlKHB1YmxpY0tleSwgMSkpLCAxMikpO1xuXHR9XG5cdGV4cG9ydHMuY29tcHV0ZUFkZHJlc3MgPSBjb21wdXRlQWRkcmVzcztcblx0ZnVuY3Rpb24gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCBzaWduYXR1cmUpIHtcblx0ICAgIHJldHVybiBjb21wdXRlQWRkcmVzcyhsaWIkZi5yZWNvdmVyUHVibGljS2V5KGxpYiQxLmFycmF5aWZ5KGRpZ2VzdCksIHNpZ25hdHVyZSkpO1xuXHR9XG5cdGV4cG9ydHMucmVjb3ZlckFkZHJlc3MgPSByZWNvdmVyQWRkcmVzcztcblx0ZnVuY3Rpb24gc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcblx0ICAgIGxpYiQzLmNoZWNrUHJvcGVydGllcyh0cmFuc2FjdGlvbiwgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyk7XG5cdCAgICB2YXIgcmF3ID0gW107XG5cdCAgICB0cmFuc2FjdGlvbkZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZEluZm8pIHtcblx0ICAgICAgICB2YXIgdmFsdWUgPSB0cmFuc2FjdGlvbltmaWVsZEluZm8ubmFtZV0gfHwgKFtdKTtcblx0ICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIGlmIChmaWVsZEluZm8ubnVtZXJpYykge1xuXHQgICAgICAgICAgICBvcHRpb25zLmhleFBhZCA9IFwibGVmdFwiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YWx1ZSA9IGxpYiQxLmFycmF5aWZ5KGxpYiQxLmhleGxpZnkodmFsdWUsIG9wdGlvbnMpKTtcblx0ICAgICAgICAvLyBGaXhlZC13aWR0aCBmaWVsZFxuXHQgICAgICAgIGlmIChmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gZmllbGRJbmZvLmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBmaWVsZEluZm8ubmFtZSwgKFwidHJhbnNhY3Rpb246XCIgKyBmaWVsZEluZm8ubmFtZSksIHZhbHVlKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gVmFyaWFibGUtd2lkdGggKHdpdGggYSBtYXhpbXVtKVxuXHQgICAgICAgIGlmIChmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHZhbHVlID0gbGliJDEuc3RyaXBaZXJvcyh2YWx1ZSk7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgZmllbGRJbmZvLm5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgZmllbGRJbmZvLm5hbWUpLCB2YWx1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmF3LnB1c2gobGliJDEuaGV4bGlmeSh2YWx1ZSkpO1xuXHQgICAgfSk7XG5cdCAgICB2YXIgY2hhaW5JZCA9IDA7XG5cdCAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCAhPSBudWxsKSB7XG5cdCAgICAgICAgLy8gQSBjaGFpbklkIHdhcyBwcm92aWRlZDsgaWYgbm9uLXplcm8gd2UnbGwgdXNlIEVJUC0xNTVcblx0ICAgICAgICBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcblx0ICAgICAgICBpZiAodHlwZW9mIChjaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbi5jaGFpbklkXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHNpZ25hdHVyZSAmJiAhbGliJDEuaXNCeXRlc0xpa2Uoc2lnbmF0dXJlKSAmJiBzaWduYXR1cmUudiA+IDI4KSB7XG5cdCAgICAgICAgLy8gTm8gY2hhaW5JZCBwcm92aWRlZCwgYnV0IHRoZSBzaWduYXR1cmUgaXMgc2lnbmluZyB3aXRoIEVJUC0xNTU7IGRlcml2ZSBjaGFpbklkXG5cdCAgICAgICAgY2hhaW5JZCA9IE1hdGguZmxvb3IoKHNpZ25hdHVyZS52IC0gMzUpIC8gMik7XG5cdCAgICB9XG5cdCAgICAvLyBXZSBoYXZlIGFuIEVJUC0xNTUgdHJhbnNhY3Rpb24gKGNoYWluSWQgd2FzIHNwZWNpZmllZCBhbmQgbm9uLXplcm8pXG5cdCAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuXHQgICAgICAgIHJhdy5wdXNoKGxpYiQxLmhleGxpZnkoY2hhaW5JZCkpOyAvLyBAVE9ETzogaGV4VmFsdWU/XG5cdCAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcblx0ICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuXHQgICAgfVxuXHQgICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2F0aW9uXG5cdCAgICBpZiAoIXNpZ25hdHVyZSkge1xuXHQgICAgICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG5cdCAgICB9XG5cdCAgICAvLyBUaGUgc3BsaXRTaWduYXR1cmUgd2lsbCBlbnN1cmUgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIHJlY292ZXJ5UGFyYW0gaW4gdGhlXG5cdCAgICAvLyBjYXNlIHRoYXQgdGhlIHNpZ25UcmFuc2FjdGlvbiBmdW5jdGlvbiBvbmx5IGFkZHMgYSB2LlxuXHQgICAgdmFyIHNpZyA9IGxpYiQxLnNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG5cdCAgICAvLyBXZSBwdXNoZWQgYSBjaGFpbklkIGFuZCBudWxsIHIsIHMgb24gZm9yIGhhc2hpbmcgb25seTsgcmVtb3ZlIHRob3NlXG5cdCAgICB2YXIgdiA9IDI3ICsgc2lnLnJlY292ZXJ5UGFyYW07XG5cdCAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuXHQgICAgICAgIHJhdy5wb3AoKTtcblx0ICAgICAgICByYXcucG9wKCk7XG5cdCAgICAgICAgcmF3LnBvcCgpO1xuXHQgICAgICAgIHYgKz0gY2hhaW5JZCAqIDIgKyA4O1xuXHQgICAgICAgIC8vIElmIGFuIEVJUC0xNTUgdiAoZGlyZWN0bHkgb3IgaW5kaXJlY3RseTsgbWF5YmUgX3ZzKSB3YXMgcHJvdmlkZWQsIGNoZWNrIGl0IVxuXHQgICAgICAgIGlmIChzaWcudiA+IDI4ICYmIHNpZy52ICE9PSB2KSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAoc2lnLnYgIT09IHYpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuXHQgICAgfVxuXHQgICAgcmF3LnB1c2gobGliJDEuaGV4bGlmeSh2KSk7XG5cdCAgICByYXcucHVzaChsaWIkMS5zdHJpcFplcm9zKGxpYiQxLmFycmF5aWZ5KHNpZy5yKSkpO1xuXHQgICAgcmF3LnB1c2gobGliJDEuc3RyaXBaZXJvcyhsaWIkMS5hcnJheWlmeShzaWcucykpKTtcblx0ICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG5cdH1cblx0ZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5cdGZ1bmN0aW9uIHBhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG5cdCAgICB2YXIgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHJhd1RyYW5zYWN0aW9uKTtcblx0ICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDkgJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA2KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcmF3IHRyYW5zYWN0aW9uXCIsIFwicmF3VHJhbnNhY3Rpb25cIiwgcmF3VHJhbnNhY3Rpb24pO1xuXHQgICAgfVxuXHQgICAgdmFyIHR4ID0ge1xuXHQgICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG5cdCAgICAgICAgZ2FzUHJpY2U6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsxXSksXG5cdCAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG5cdCAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bM10pLFxuXHQgICAgICAgIHZhbHVlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bNF0pLFxuXHQgICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzVdLFxuXHQgICAgICAgIGNoYWluSWQ6IDBcblx0ICAgIH07XG5cdCAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cblx0ICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggPT09IDYpIHtcblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9XG5cdCAgICB0cnkge1xuXHQgICAgICAgIHR4LnYgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbls2XSkudG9OdW1iZXIoKTtcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcblx0ICAgICAgICByZXR1cm4gdHg7XG5cdCAgICB9XG5cdCAgICB0eC5yID0gbGliJDEuaGV4WmVyb1BhZCh0cmFuc2FjdGlvbls3XSwgMzIpO1xuXHQgICAgdHgucyA9IGxpYiQxLmhleFplcm9QYWQodHJhbnNhY3Rpb25bOF0sIDMyKTtcblx0ICAgIGlmIChsaWIkMi5CaWdOdW1iZXIuZnJvbSh0eC5yKS5pc1plcm8oKSAmJiBsaWIkMi5CaWdOdW1iZXIuZnJvbSh0eC5zKS5pc1plcm8oKSkge1xuXHQgICAgICAgIC8vIEVJUC0xNTUgdW5zaWduZWQgdHJhbnNhY3Rpb25cblx0ICAgICAgICB0eC5jaGFpbklkID0gdHgudjtcblx0ICAgICAgICB0eC52ID0gMDtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIC8vIFNpZ25lZCBUcmFuYXNhY3Rpb25cblx0ICAgICAgICB0eC5jaGFpbklkID0gTWF0aC5mbG9vcigodHgudiAtIDM1KSAvIDIpO1xuXHQgICAgICAgIGlmICh0eC5jaGFpbklkIDwgMCkge1xuXHQgICAgICAgICAgICB0eC5jaGFpbklkID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlY292ZXJ5UGFyYW0gPSB0eC52IC0gMjc7XG5cdCAgICAgICAgdmFyIHJhdyA9IHRyYW5zYWN0aW9uLnNsaWNlKDAsIDYpO1xuXHQgICAgICAgIGlmICh0eC5jaGFpbklkICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHJhdy5wdXNoKGxpYiQxLmhleGxpZnkodHguY2hhaW5JZCkpO1xuXHQgICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuXHQgICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuXHQgICAgICAgICAgICByZWNvdmVyeVBhcmFtIC09IHR4LmNoYWluSWQgKiAyICsgODtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGRpZ2VzdCA9IGxpYiQ0LmtlY2NhazI1NihSTFAuZW5jb2RlKHJhdykpO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogbGliJDEuaGV4bGlmeSh0eC5yKSwgczogbGliJDEuaGV4bGlmeSh0eC5zKSwgcmVjb3ZlcnlQYXJhbTogcmVjb3ZlcnlQYXJhbSB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdHguaGFzaCA9IGxpYiQ0LmtlY2NhazI1NihyYXdUcmFuc2FjdGlvbik7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdHg7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRnID0gdW53cmFwRXhwb3J0cyhsaWIkZyk7XG5cdHZhciBsaWJfMSRnID0gbGliJGcuY29tcHV0ZUFkZHJlc3M7XG5cdHZhciBsaWJfMiRmID0gbGliJGcucmVjb3ZlckFkZHJlc3M7XG5cdHZhciBsaWJfMyRjID0gbGliJGcuc2VyaWFsaXplO1xuXHR2YXIgbGliXzQkOSA9IGxpYiRnLnBhcnNlO1xuXG5cdHZhciBfdmVyc2lvbiR1ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIndvcmRsaXN0cy81LjAuNFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiR2ID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiR1KTtcblx0dmFyIF92ZXJzaW9uXzEkZiA9IF92ZXJzaW9uJHUudmVyc2lvbjtcblxuXHR2YXIgd29yZGxpc3QgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdC8vIFRoaXMgZ2V0cyBvdmVycmlkZGVuIGJ5IHJvbGx1cFxuXHR2YXIgZXhwb3J0V29yZGxpc3QgPSBmYWxzZTtcblxuXG5cblxuXHRleHBvcnRzLmxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHUudmVyc2lvbik7XG5cdHZhciBXb3JkbGlzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIFdvcmRsaXN0KGxvY2FsZSkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBleHBvcnRzLmxvZ2dlci5jaGVja0Fic3RyYWN0KF9uZXdUYXJnZXQsIFdvcmRsaXN0KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImxvY2FsZVwiLCBsb2NhbGUpO1xuXHQgICAgfVxuXHQgICAgLy8gU3ViY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpc1xuXHQgICAgV29yZGxpc3QucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKG1uZW1vbmljKSB7XG5cdCAgICAgICAgcmV0dXJuIG1uZW1vbmljLnRvTG93ZXJDYXNlKCkuc3BsaXQoLyArL2cpO1xuXHQgICAgfTtcblx0ICAgIC8vIFN1YmNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXNcblx0ICAgIFdvcmRsaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gKHdvcmRzKSB7XG5cdCAgICAgICAgcmV0dXJuIHdvcmRzLmpvaW4oXCIgXCIpO1xuXHQgICAgfTtcblx0ICAgIFdvcmRsaXN0LmNoZWNrID0gZnVuY3Rpb24gKHdvcmRsaXN0KSB7XG5cdCAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyMDQ4OyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmQgPSB3b3JkbGlzdC5nZXRXb3JkKGkpO1xuXHQgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICAgICAgaWYgKGkgIT09IHdvcmRsaXN0LmdldFdvcmRJbmRleCh3b3JkKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiMHhcIjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB3b3Jkcy5wdXNoKHdvcmQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDkuaWQod29yZHMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuXHQgICAgfTtcblx0ICAgIFdvcmRsaXN0LnJlZ2lzdGVyID0gZnVuY3Rpb24gKGxhbmcsIG5hbWUpIHtcblx0ICAgICAgICBpZiAoIW5hbWUpIHtcblx0ICAgICAgICAgICAgbmFtZSA9IGxhbmcubG9jYWxlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICBpZiAoZXhwb3J0V29yZGxpc3QpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHZhciBhbnlHbG9iYWwgPSB3aW5kb3c7XG5cdCAgICAgICAgICAgICAgICBpZiAoYW55R2xvYmFsLl9ldGhlcnMgJiYgYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFhbnlHbG9iYWwuX2V0aGVycy53b3JkbGlzdHNbbmFtZV0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzLCBuYW1lLCBsYW5nKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdvcmRsaXN0O1xuXHR9KCkpO1xuXHRleHBvcnRzLldvcmRsaXN0ID0gV29yZGxpc3Q7XG5cblx0fSk7XG5cblx0dmFyIHdvcmRsaXN0JDEgPSB1bndyYXBFeHBvcnRzKHdvcmRsaXN0KTtcblx0dmFyIHdvcmRsaXN0XzEgPSB3b3JkbGlzdC5sb2dnZXI7XG5cdHZhciB3b3JkbGlzdF8yID0gd29yZGxpc3QuV29yZGxpc3Q7XG5cblx0dmFyIGxhbmdFbl8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdHZhciB3b3JkcyA9IFwiQWJhbmRvbkFiaWxpdHlBYmxlQWJvdXRBYm92ZUFic2VudEFic29yYkFic3RyYWN0QWJzdXJkQWJ1c2VBY2Nlc3NBY2NpZGVudEFjY291bnRBY2N1c2VBY2hpZXZlQWNpZEFjb3VzdGljQWNxdWlyZUFjcm9zc0FjdEFjdGlvbkFjdG9yQWN0cmVzc0FjdHVhbEFkYXB0QWRkQWRkaWN0QWRkcmVzc0FkanVzdEFkbWl0QWR1bHRBZHZhbmNlQWR2aWNlQWVyb2JpY0FmZmFpckFmZm9yZEFmcmFpZEFnYWluQWdlQWdlbnRBZ3JlZUFoZWFkQWltQWlyQWlycG9ydEFpc2xlQWxhcm1BbGJ1bUFsY29ob2xBbGVydEFsaWVuQWxsQWxsZXlBbGxvd0FsbW9zdEFsb25lQWxwaGFBbHJlYWR5QWxzb0FsdGVyQWx3YXlzQW1hdGV1ckFtYXppbmdBbW9uZ0Ftb3VudEFtdXNlZEFuYWx5c3RBbmNob3JBbmNpZW50QW5nZXJBbmdsZUFuZ3J5QW5pbWFsQW5rbGVBbm5vdW5jZUFubnVhbEFub3RoZXJBbnN3ZXJBbnRlbm5hQW50aXF1ZUFueGlldHlBbnlBcGFydEFwb2xvZ3lBcHBlYXJBcHBsZUFwcHJvdmVBcHJpbEFyY2hBcmN0aWNBcmVhQXJlbmFBcmd1ZUFybUFybWVkQXJtb3JBcm15QXJvdW5kQXJyYW5nZUFycmVzdEFycml2ZUFycm93QXJ0QXJ0ZWZhY3RBcnRpc3RBcnR3b3JrQXNrQXNwZWN0QXNzYXVsdEFzc2V0QXNzaXN0QXNzdW1lQXN0aG1hQXRobGV0ZUF0b21BdHRhY2tBdHRlbmRBdHRpdHVkZUF0dHJhY3RBdWN0aW9uQXVkaXRBdWd1c3RBdW50QXV0aG9yQXV0b0F1dHVtbkF2ZXJhZ2VBdm9jYWRvQXZvaWRBd2FrZUF3YXJlQXdheUF3ZXNvbWVBd2Z1bEF3a3dhcmRBeGlzQmFieUJhY2hlbG9yQmFjb25CYWRnZUJhZ0JhbGFuY2VCYWxjb255QmFsbEJhbWJvb0JhbmFuYUJhbm5lckJhckJhcmVseUJhcmdhaW5CYXJyZWxCYXNlQmFzaWNCYXNrZXRCYXR0bGVCZWFjaEJlYW5CZWF1dHlCZWNhdXNlQmVjb21lQmVlZkJlZm9yZUJlZ2luQmVoYXZlQmVoaW5kQmVsaWV2ZUJlbG93QmVsdEJlbmNoQmVuZWZpdEJlc3RCZXRyYXlCZXR0ZXJCZXR3ZWVuQmV5b25kQmljeWNsZUJpZEJpa2VCaW5kQmlvbG9neUJpcmRCaXJ0aEJpdHRlckJsYWNrQmxhZGVCbGFtZUJsYW5rZXRCbGFzdEJsZWFrQmxlc3NCbGluZEJsb29kQmxvc3NvbUJsb3VzZUJsdWVCbHVyQmx1c2hCb2FyZEJvYXRCb2R5Qm9pbEJvbWJCb25lQm9udXNCb29rQm9vc3RCb3JkZXJCb3JpbmdCb3Jyb3dCb3NzQm90dG9tQm91bmNlQm94Qm95QnJhY2tldEJyYWluQnJhbmRCcmFzc0JyYXZlQnJlYWRCcmVlemVCcmlja0JyaWRnZUJyaWVmQnJpZ2h0QnJpbmdCcmlza0Jyb2Njb2xpQnJva2VuQnJvbnplQnJvb21Ccm90aGVyQnJvd25CcnVzaEJ1YmJsZUJ1ZGR5QnVkZ2V0QnVmZmFsb0J1aWxkQnVsYkJ1bGtCdWxsZXRCdW5kbGVCdW5rZXJCdXJkZW5CdXJnZXJCdXJzdEJ1c0J1c2luZXNzQnVzeUJ1dHRlckJ1eWVyQnV6ekNhYmJhZ2VDYWJpbkNhYmxlQ2FjdHVzQ2FnZUNha2VDYWxsQ2FsbUNhbWVyYUNhbXBDYW5DYW5hbENhbmNlbENhbmR5Q2Fubm9uQ2Fub2VDYW52YXNDYW55b25DYXBhYmxlQ2FwaXRhbENhcHRhaW5DYXJDYXJib25DYXJkQ2FyZ29DYXJwZXRDYXJyeUNhcnRDYXNlQ2FzaENhc2lub0Nhc3RsZUNhc3VhbENhdENhdGFsb2dDYXRjaENhdGVnb3J5Q2F0dGxlQ2F1Z2h0Q2F1c2VDYXV0aW9uQ2F2ZUNlaWxpbmdDZWxlcnlDZW1lbnRDZW5zdXNDZW50dXJ5Q2VyZWFsQ2VydGFpbkNoYWlyQ2hhbGtDaGFtcGlvbkNoYW5nZUNoYW9zQ2hhcHRlckNoYXJnZUNoYXNlQ2hhdENoZWFwQ2hlY2tDaGVlc2VDaGVmQ2hlcnJ5Q2hlc3RDaGlja2VuQ2hpZWZDaGlsZENoaW1uZXlDaG9pY2VDaG9vc2VDaHJvbmljQ2h1Y2tsZUNodW5rQ2h1cm5DaWdhckNpbm5hbW9uQ2lyY2xlQ2l0aXplbkNpdHlDaXZpbENsYWltQ2xhcENsYXJpZnlDbGF3Q2xheUNsZWFuQ2xlcmtDbGV2ZXJDbGlja0NsaWVudENsaWZmQ2xpbWJDbGluaWNDbGlwQ2xvY2tDbG9nQ2xvc2VDbG90aENsb3VkQ2xvd25DbHViQ2x1bXBDbHVzdGVyQ2x1dGNoQ29hY2hDb2FzdENvY29udXRDb2RlQ29mZmVlQ29pbENvaW5Db2xsZWN0Q29sb3JDb2x1bW5Db21iaW5lQ29tZUNvbWZvcnRDb21pY0NvbW1vbkNvbXBhbnlDb25jZXJ0Q29uZHVjdENvbmZpcm1Db25ncmVzc0Nvbm5lY3RDb25zaWRlckNvbnRyb2xDb252aW5jZUNvb2tDb29sQ29wcGVyQ29weUNvcmFsQ29yZUNvcm5Db3JyZWN0Q29zdENvdHRvbkNvdWNoQ291bnRyeUNvdXBsZUNvdXJzZUNvdXNpbkNvdmVyQ295b3RlQ3JhY2tDcmFkbGVDcmFmdENyYW1DcmFuZUNyYXNoQ3JhdGVyQ3Jhd2xDcmF6eUNyZWFtQ3JlZGl0Q3JlZWtDcmV3Q3JpY2tldENyaW1lQ3Jpc3BDcml0aWNDcm9wQ3Jvc3NDcm91Y2hDcm93ZENydWNpYWxDcnVlbENydWlzZUNydW1ibGVDcnVuY2hDcnVzaENyeUNyeXN0YWxDdWJlQ3VsdHVyZUN1cEN1cGJvYXJkQ3VyaW91c0N1cnJlbnRDdXJ0YWluQ3VydmVDdXNoaW9uQ3VzdG9tQ3V0ZUN5Y2xlRGFkRGFtYWdlRGFtcERhbmNlRGFuZ2VyRGFyaW5nRGFzaERhdWdodGVyRGF3bkRheURlYWxEZWJhdGVEZWJyaXNEZWNhZGVEZWNlbWJlckRlY2lkZURlY2xpbmVEZWNvcmF0ZURlY3JlYXNlRGVlckRlZmVuc2VEZWZpbmVEZWZ5RGVncmVlRGVsYXlEZWxpdmVyRGVtYW5kRGVtaXNlRGVuaWFsRGVudGlzdERlbnlEZXBhcnREZXBlbmREZXBvc2l0RGVwdGhEZXB1dHlEZXJpdmVEZXNjcmliZURlc2VydERlc2lnbkRlc2tEZXNwYWlyRGVzdHJveURldGFpbERldGVjdERldmVsb3BEZXZpY2VEZXZvdGVEaWFncmFtRGlhbERpYW1vbmREaWFyeURpY2VEaWVzZWxEaWV0RGlmZmVyRGlnaXRhbERpZ25pdHlEaWxlbW1hRGlubmVyRGlub3NhdXJEaXJlY3REaXJ0RGlzYWdyZWVEaXNjb3ZlckRpc2Vhc2VEaXNoRGlzbWlzc0Rpc29yZGVyRGlzcGxheURpc3RhbmNlRGl2ZXJ0RGl2aWRlRGl2b3JjZURpenp5RG9jdG9yRG9jdW1lbnREb2dEb2xsRG9scGhpbkRvbWFpbkRvbmF0ZURvbmtleURvbm9yRG9vckRvc2VEb3VibGVEb3ZlRHJhZnREcmFnb25EcmFtYURyYXN0aWNEcmF3RHJlYW1EcmVzc0RyaWZ0RHJpbGxEcmlua0RyaXBEcml2ZURyb3BEcnVtRHJ5RHVja0R1bWJEdW5lRHVyaW5nRHVzdER1dGNoRHV0eUR3YXJmRHluYW1pY0VhZ2VyRWFnbGVFYXJseUVhcm5FYXJ0aEVhc2lseUVhc3RFYXN5RWNob0Vjb2xvZ3lFY29ub215RWRnZUVkaXRFZHVjYXRlRWZmb3J0RWdnRWlnaHRFaXRoZXJFbGJvd0VsZGVyRWxlY3RyaWNFbGVnYW50RWxlbWVudEVsZXBoYW50RWxldmF0b3JFbGl0ZUVsc2VFbWJhcmtFbWJvZHlFbWJyYWNlRW1lcmdlRW1vdGlvbkVtcGxveUVtcG93ZXJFbXB0eUVuYWJsZUVuYWN0RW5kRW5kbGVzc0VuZG9yc2VFbmVteUVuZXJneUVuZm9yY2VFbmdhZ2VFbmdpbmVFbmhhbmNlRW5qb3lFbmxpc3RFbm91Z2hFbnJpY2hFbnJvbGxFbnN1cmVFbnRlckVudGlyZUVudHJ5RW52ZWxvcGVFcGlzb2RlRXF1YWxFcXVpcEVyYUVyYXNlRXJvZGVFcm9zaW9uRXJyb3JFcnVwdEVzY2FwZUVzc2F5RXNzZW5jZUVzdGF0ZUV0ZXJuYWxFdGhpY3NFdmlkZW5jZUV2aWxFdm9rZUV2b2x2ZUV4YWN0RXhhbXBsZUV4Y2Vzc0V4Y2hhbmdlRXhjaXRlRXhjbHVkZUV4Y3VzZUV4ZWN1dGVFeGVyY2lzZUV4aGF1c3RFeGhpYml0RXhpbGVFeGlzdEV4aXRFeG90aWNFeHBhbmRFeHBlY3RFeHBpcmVFeHBsYWluRXhwb3NlRXhwcmVzc0V4dGVuZEV4dHJhRXllRXllYnJvd0ZhYnJpY0ZhY2VGYWN1bHR5RmFkZUZhaW50RmFpdGhGYWxsRmFsc2VGYW1lRmFtaWx5RmFtb3VzRmFuRmFuY3lGYW50YXN5RmFybUZhc2hpb25GYXRGYXRhbEZhdGhlckZhdGlndWVGYXVsdEZhdm9yaXRlRmVhdHVyZUZlYnJ1YXJ5RmVkZXJhbEZlZUZlZWRGZWVsRmVtYWxlRmVuY2VGZXN0aXZhbEZldGNoRmV2ZXJGZXdGaWJlckZpY3Rpb25GaWVsZEZpZ3VyZUZpbGVGaWxtRmlsdGVyRmluYWxGaW5kRmluZUZpbmdlckZpbmlzaEZpcmVGaXJtRmlyc3RGaXNjYWxGaXNoRml0Rml0bmVzc0ZpeEZsYWdGbGFtZUZsYXNoRmxhdEZsYXZvckZsZWVGbGlnaHRGbGlwRmxvYXRGbG9ja0Zsb29yRmxvd2VyRmx1aWRGbHVzaEZseUZvYW1Gb2N1c0ZvZ0ZvaWxGb2xkRm9sbG93Rm9vZEZvb3RGb3JjZUZvcmVzdEZvcmdldEZvcmtGb3J0dW5lRm9ydW1Gb3J3YXJkRm9zc2lsRm9zdGVyRm91bmRGb3hGcmFnaWxlRnJhbWVGcmVxdWVudEZyZXNoRnJpZW5kRnJpbmdlRnJvZ0Zyb250RnJvc3RGcm93bkZyb3plbkZydWl0RnVlbEZ1bkZ1bm55RnVybmFjZUZ1cnlGdXR1cmVHYWRnZXRHYWluR2FsYXh5R2FsbGVyeUdhbWVHYXBHYXJhZ2VHYXJiYWdlR2FyZGVuR2FybGljR2FybWVudEdhc0dhc3BHYXRlR2F0aGVyR2F1Z2VHYXplR2VuZXJhbEdlbml1c0dlbnJlR2VudGxlR2VudWluZUdlc3R1cmVHaG9zdEdpYW50R2lmdEdpZ2dsZUdpbmdlckdpcmFmZmVHaXJsR2l2ZUdsYWRHbGFuY2VHbGFyZUdsYXNzR2xpZGVHbGltcHNlR2xvYmVHbG9vbUdsb3J5R2xvdmVHbG93R2x1ZUdvYXRHb2RkZXNzR29sZEdvb2RHb29zZUdvcmlsbGFHb3NwZWxHb3NzaXBHb3Zlcm5Hb3duR3JhYkdyYWNlR3JhaW5HcmFudEdyYXBlR3Jhc3NHcmF2aXR5R3JlYXRHcmVlbkdyaWRHcmllZkdyaXRHcm9jZXJ5R3JvdXBHcm93R3J1bnRHdWFyZEd1ZXNzR3VpZGVHdWlsdEd1aXRhckd1bkd5bUhhYml0SGFpckhhbGZIYW1tZXJIYW1zdGVySGFuZEhhcHB5SGFyYm9ySGFyZEhhcnNoSGFydmVzdEhhdEhhdmVIYXdrSGF6YXJkSGVhZEhlYWx0aEhlYXJ0SGVhdnlIZWRnZWhvZ0hlaWdodEhlbGxvSGVsbWV0SGVscEhlbkhlcm9IaWRkZW5IaWdoSGlsbEhpbnRIaXBIaXJlSGlzdG9yeUhvYmJ5SG9ja2V5SG9sZEhvbGVIb2xpZGF5SG9sbG93SG9tZUhvbmV5SG9vZEhvcGVIb3JuSG9ycm9ySG9yc2VIb3NwaXRhbEhvc3RIb3RlbEhvdXJIb3Zlckh1Ykh1Z2VIdW1hbkh1bWJsZUh1bW9ySHVuZHJlZEh1bmdyeUh1bnRIdXJkbGVIdXJyeUh1cnRIdXNiYW5kSHlicmlkSWNlSWNvbklkZWFJZGVudGlmeUlkbGVJZ25vcmVJbGxJbGxlZ2FsSWxsbmVzc0ltYWdlSW1pdGF0ZUltbWVuc2VJbW11bmVJbXBhY3RJbXBvc2VJbXByb3ZlSW1wdWxzZUluY2hJbmNsdWRlSW5jb21lSW5jcmVhc2VJbmRleEluZGljYXRlSW5kb29ySW5kdXN0cnlJbmZhbnRJbmZsaWN0SW5mb3JtSW5oYWxlSW5oZXJpdEluaXRpYWxJbmplY3RJbmp1cnlJbm1hdGVJbm5lcklubm9jZW50SW5wdXRJbnF1aXJ5SW5zYW5lSW5zZWN0SW5zaWRlSW5zcGlyZUluc3RhbGxJbnRhY3RJbnRlcmVzdEludG9JbnZlc3RJbnZpdGVJbnZvbHZlSXJvbklzbGFuZElzb2xhdGVJc3N1ZUl0ZW1Jdm9yeUphY2tldEphZ3VhckphckphenpKZWFsb3VzSmVhbnNKZWxseUpld2VsSm9iSm9pbkpva2VKb3VybmV5Sm95SnVkZ2VKdWljZUp1bXBKdW5nbGVKdW5pb3JKdW5rSnVzdEthbmdhcm9vS2VlbktlZXBLZXRjaHVwS2V5S2lja0tpZEtpZG5leUtpbmRLaW5nZG9tS2lzc0tpdEtpdGNoZW5LaXRlS2l0dGVuS2l3aUtuZWVLbmlmZUtub2NrS25vd0xhYkxhYmVsTGFib3JMYWRkZXJMYWR5TGFrZUxhbXBMYW5ndWFnZUxhcHRvcExhcmdlTGF0ZXJMYXRpbkxhdWdoTGF1bmRyeUxhdmFMYXdMYXduTGF3c3VpdExheWVyTGF6eUxlYWRlckxlYWZMZWFybkxlYXZlTGVjdHVyZUxlZnRMZWdMZWdhbExlZ2VuZExlaXN1cmVMZW1vbkxlbmRMZW5ndGhMZW5zTGVvcGFyZExlc3NvbkxldHRlckxldmVsTGlhckxpYmVydHlMaWJyYXJ5TGljZW5zZUxpZmVMaWZ0TGlnaHRMaWtlTGltYkxpbWl0TGlua0xpb25MaXF1aWRMaXN0TGl0dGxlTGl2ZUxpemFyZExvYWRMb2FuTG9ic3RlckxvY2FsTG9ja0xvZ2ljTG9uZWx5TG9uZ0xvb3BMb3R0ZXJ5TG91ZExvdW5nZUxvdmVMb3lhbEx1Y2t5THVnZ2FnZUx1bWJlckx1bmFyTHVuY2hMdXh1cnlMeXJpY3NNYWNoaW5lTWFkTWFnaWNNYWduZXRNYWlkTWFpbE1haW5NYWpvck1ha2VNYW1tYWxNYW5NYW5hZ2VNYW5kYXRlTWFuZ29NYW5zaW9uTWFudWFsTWFwbGVNYXJibGVNYXJjaE1hcmdpbk1hcmluZU1hcmtldE1hcnJpYWdlTWFza01hc3NNYXN0ZXJNYXRjaE1hdGVyaWFsTWF0aE1hdHJpeE1hdHRlck1heGltdW1NYXplTWVhZG93TWVhbk1lYXN1cmVNZWF0TWVjaGFuaWNNZWRhbE1lZGlhTWVsb2R5TWVsdE1lbWJlck1lbW9yeU1lbnRpb25NZW51TWVyY3lNZXJnZU1lcml0TWVycnlNZXNoTWVzc2FnZU1ldGFsTWV0aG9kTWlkZGxlTWlkbmlnaHRNaWxrTWlsbGlvbk1pbWljTWluZE1pbmltdW1NaW5vck1pbnV0ZU1pcmFjbGVNaXJyb3JNaXNlcnlNaXNzTWlzdGFrZU1peE1peGVkTWl4dHVyZU1vYmlsZU1vZGVsTW9kaWZ5TW9tTW9tZW50TW9uaXRvck1vbmtleU1vbnN0ZXJNb250aE1vb25Nb3JhbE1vcmVNb3JuaW5nTW9zcXVpdG9Nb3RoZXJNb3Rpb25Nb3Rvck1vdW50YWluTW91c2VNb3ZlTW92aWVNdWNoTXVmZmluTXVsZU11bHRpcGx5TXVzY2xlTXVzZXVtTXVzaHJvb21NdXNpY011c3RNdXR1YWxNeXNlbGZNeXN0ZXJ5TXl0aE5haXZlTmFtZU5hcGtpbk5hcnJvd05hc3R5TmF0aW9uTmF0dXJlTmVhck5lY2tOZWVkTmVnYXRpdmVOZWdsZWN0TmVpdGhlck5lcGhld05lcnZlTmVzdE5ldE5ldHdvcmtOZXV0cmFsTmV2ZXJOZXdzTmV4dE5pY2VOaWdodE5vYmxlTm9pc2VOb21pbmVlTm9vZGxlTm9ybWFsTm9ydGhOb3NlTm90YWJsZU5vdGVOb3RoaW5nTm90aWNlTm92ZWxOb3dOdWNsZWFyTnVtYmVyTnVyc2VOdXRPYWtPYmV5T2JqZWN0T2JsaWdlT2JzY3VyZU9ic2VydmVPYnRhaW5PYnZpb3VzT2NjdXJPY2Vhbk9jdG9iZXJPZG9yT2ZmT2ZmZXJPZmZpY2VPZnRlbk9pbE9rYXlPbGRPbGl2ZU9seW1waWNPbWl0T25jZU9uZU9uaW9uT25saW5lT25seU9wZW5PcGVyYU9waW5pb25PcHBvc2VPcHRpb25PcmFuZ2VPcmJpdE9yY2hhcmRPcmRlck9yZGluYXJ5T3JnYW5PcmllbnRPcmlnaW5hbE9ycGhhbk9zdHJpY2hPdGhlck91dGRvb3JPdXRlck91dHB1dE91dHNpZGVPdmFsT3Zlbk92ZXJPd25Pd25lck94eWdlbk95c3Rlck96b25lUGFjdFBhZGRsZVBhZ2VQYWlyUGFsYWNlUGFsbVBhbmRhUGFuZWxQYW5pY1BhbnRoZXJQYXBlclBhcmFkZVBhcmVudFBhcmtQYXJyb3RQYXJ0eVBhc3NQYXRjaFBhdGhQYXRpZW50UGF0cm9sUGF0dGVyblBhdXNlUGF2ZVBheW1lbnRQZWFjZVBlYW51dFBlYXJQZWFzYW50UGVsaWNhblBlblBlbmFsdHlQZW5jaWxQZW9wbGVQZXBwZXJQZXJmZWN0UGVybWl0UGVyc29uUGV0UGhvbmVQaG90b1BocmFzZVBoeXNpY2FsUGlhbm9QaWNuaWNQaWN0dXJlUGllY2VQaWdQaWdlb25QaWxsUGlsb3RQaW5rUGlvbmVlclBpcGVQaXN0b2xQaXRjaFBpenphUGxhY2VQbGFuZXRQbGFzdGljUGxhdGVQbGF5UGxlYXNlUGxlZGdlUGx1Y2tQbHVnUGx1bmdlUG9lbVBvZXRQb2ludFBvbGFyUG9sZVBvbGljZVBvbmRQb255UG9vbFBvcHVsYXJQb3J0aW9uUG9zaXRpb25Qb3NzaWJsZVBvc3RQb3RhdG9Qb3R0ZXJ5UG92ZXJ0eVBvd2RlclBvd2VyUHJhY3RpY2VQcmFpc2VQcmVkaWN0UHJlZmVyUHJlcGFyZVByZXNlbnRQcmV0dHlQcmV2ZW50UHJpY2VQcmlkZVByaW1hcnlQcmludFByaW9yaXR5UHJpc29uUHJpdmF0ZVByaXplUHJvYmxlbVByb2Nlc3NQcm9kdWNlUHJvZml0UHJvZ3JhbVByb2plY3RQcm9tb3RlUHJvb2ZQcm9wZXJ0eVByb3NwZXJQcm90ZWN0UHJvdWRQcm92aWRlUHVibGljUHVkZGluZ1B1bGxQdWxwUHVsc2VQdW1wa2luUHVuY2hQdXBpbFB1cHB5UHVyY2hhc2VQdXJpdHlQdXJwb3NlUHVyc2VQdXNoUHV0UHV6emxlUHlyYW1pZFF1YWxpdHlRdWFudHVtUXVhcnRlclF1ZXN0aW9uUXVpY2tRdWl0UXVpelF1b3RlUmFiYml0UmFjY29vblJhY2VSYWNrUmFkYXJSYWRpb1JhaWxSYWluUmFpc2VSYWxseVJhbXBSYW5jaFJhbmRvbVJhbmdlUmFwaWRSYXJlUmF0ZVJhdGhlclJhdmVuUmF3UmF6b3JSZWFkeVJlYWxSZWFzb25SZWJlbFJlYnVpbGRSZWNhbGxSZWNlaXZlUmVjaXBlUmVjb3JkUmVjeWNsZVJlZHVjZVJlZmxlY3RSZWZvcm1SZWZ1c2VSZWdpb25SZWdyZXRSZWd1bGFyUmVqZWN0UmVsYXhSZWxlYXNlUmVsaWVmUmVseVJlbWFpblJlbWVtYmVyUmVtaW5kUmVtb3ZlUmVuZGVyUmVuZXdSZW50UmVvcGVuUmVwYWlyUmVwZWF0UmVwbGFjZVJlcG9ydFJlcXVpcmVSZXNjdWVSZXNlbWJsZVJlc2lzdFJlc291cmNlUmVzcG9uc2VSZXN1bHRSZXRpcmVSZXRyZWF0UmV0dXJuUmV1bmlvblJldmVhbFJldmlld1Jld2FyZFJoeXRobVJpYlJpYmJvblJpY2VSaWNoUmlkZVJpZGdlUmlmbGVSaWdodFJpZ2lkUmluZ1Jpb3RSaXBwbGVSaXNrUml0dWFsUml2YWxSaXZlclJvYWRSb2FzdFJvYm90Um9idXN0Um9ja2V0Um9tYW5jZVJvb2ZSb29raWVSb29tUm9zZVJvdGF0ZVJvdWdoUm91bmRSb3V0ZVJveWFsUnViYmVyUnVkZVJ1Z1J1bGVSdW5SdW53YXlSdXJhbFNhZFNhZGRsZVNhZG5lc3NTYWZlU2FpbFNhbGFkU2FsbW9uU2Fsb25TYWx0U2FsdXRlU2FtZVNhbXBsZVNhbmRTYXRpc2Z5U2F0b3NoaVNhdWNlU2F1c2FnZVNhdmVTYXlTY2FsZVNjYW5TY2FyZVNjYXR0ZXJTY2VuZVNjaGVtZVNjaG9vbFNjaWVuY2VTY2lzc29yc1Njb3JwaW9uU2NvdXRTY3JhcFNjcmVlblNjcmlwdFNjcnViU2VhU2VhcmNoU2Vhc29uU2VhdFNlY29uZFNlY3JldFNlY3Rpb25TZWN1cml0eVNlZWRTZWVrU2VnbWVudFNlbGVjdFNlbGxTZW1pbmFyU2VuaW9yU2Vuc2VTZW50ZW5jZVNlcmllc1NlcnZpY2VTZXNzaW9uU2V0dGxlU2V0dXBTZXZlblNoYWRvd1NoYWZ0U2hhbGxvd1NoYXJlU2hlZFNoZWxsU2hlcmlmZlNoaWVsZFNoaWZ0U2hpbmVTaGlwU2hpdmVyU2hvY2tTaG9lU2hvb3RTaG9wU2hvcnRTaG91bGRlclNob3ZlU2hyaW1wU2hydWdTaHVmZmxlU2h5U2libGluZ1NpY2tTaWRlU2llZ2VTaWdodFNpZ25TaWxlbnRTaWxrU2lsbHlTaWx2ZXJTaW1pbGFyU2ltcGxlU2luY2VTaW5nU2lyZW5TaXN0ZXJTaXR1YXRlU2l4U2l6ZVNrYXRlU2tldGNoU2tpU2tpbGxTa2luU2tpcnRTa3VsbFNsYWJTbGFtU2xlZXBTbGVuZGVyU2xpY2VTbGlkZVNsaWdodFNsaW1TbG9nYW5TbG90U2xvd1NsdXNoU21hbGxTbWFydFNtaWxlU21va2VTbW9vdGhTbmFja1NuYWtlU25hcFNuaWZmU25vd1NvYXBTb2NjZXJTb2NpYWxTb2NrU29kYVNvZnRTb2xhclNvbGRpZXJTb2xpZFNvbHV0aW9uU29sdmVTb21lb25lU29uZ1Nvb25Tb3JyeVNvcnRTb3VsU291bmRTb3VwU291cmNlU291dGhTcGFjZVNwYXJlU3BhdGlhbFNwYXduU3BlYWtTcGVjaWFsU3BlZWRTcGVsbFNwZW5kU3BoZXJlU3BpY2VTcGlkZXJTcGlrZVNwaW5TcGlyaXRTcGxpdFNwb2lsU3BvbnNvclNwb29uU3BvcnRTcG90U3ByYXlTcHJlYWRTcHJpbmdTcHlTcXVhcmVTcXVlZXplU3F1aXJyZWxTdGFibGVTdGFkaXVtU3RhZmZTdGFnZVN0YWlyc1N0YW1wU3RhbmRTdGFydFN0YXRlU3RheVN0ZWFrU3RlZWxTdGVtU3RlcFN0ZXJlb1N0aWNrU3RpbGxTdGluZ1N0b2NrU3RvbWFjaFN0b25lU3Rvb2xTdG9yeVN0b3ZlU3RyYXRlZ3lTdHJlZXRTdHJpa2VTdHJvbmdTdHJ1Z2dsZVN0dWRlbnRTdHVmZlN0dW1ibGVTdHlsZVN1YmplY3RTdWJtaXRTdWJ3YXlTdWNjZXNzU3VjaFN1ZGRlblN1ZmZlclN1Z2FyU3VnZ2VzdFN1aXRTdW1tZXJTdW5TdW5ueVN1bnNldFN1cGVyU3VwcGx5U3VwcmVtZVN1cmVTdXJmYWNlU3VyZ2VTdXJwcmlzZVN1cnJvdW5kU3VydmV5U3VzcGVjdFN1c3RhaW5Td2FsbG93U3dhbXBTd2FwU3dhcm1Td2VhclN3ZWV0U3dpZnRTd2ltU3dpbmdTd2l0Y2hTd29yZFN5bWJvbFN5bXB0b21TeXJ1cFN5c3RlbVRhYmxlVGFja2xlVGFnVGFpbFRhbGVudFRhbGtUYW5rVGFwZVRhcmdldFRhc2tUYXN0ZVRhdHRvb1RheGlUZWFjaFRlYW1UZWxsVGVuVGVuYW50VGVubmlzVGVudFRlcm1UZXN0VGV4dFRoYW5rVGhhdFRoZW1lVGhlblRoZW9yeVRoZXJlVGhleVRoaW5nVGhpc1Rob3VnaHRUaHJlZVRocml2ZVRocm93VGh1bWJUaHVuZGVyVGlja2V0VGlkZVRpZ2VyVGlsdFRpbWJlclRpbWVUaW55VGlwVGlyZWRUaXNzdWVUaXRsZVRvYXN0VG9iYWNjb1RvZGF5VG9kZGxlclRvZVRvZ2V0aGVyVG9pbGV0VG9rZW5Ub21hdG9Ub21vcnJvd1RvbmVUb25ndWVUb25pZ2h0VG9vbFRvb3RoVG9wVG9waWNUb3BwbGVUb3JjaFRvcm5hZG9Ub3J0b2lzZVRvc3NUb3RhbFRvdXJpc3RUb3dhcmRUb3dlclRvd25Ub3lUcmFja1RyYWRlVHJhZmZpY1RyYWdpY1RyYWluVHJhbnNmZXJUcmFwVHJhc2hUcmF2ZWxUcmF5VHJlYXRUcmVlVHJlbmRUcmlhbFRyaWJlVHJpY2tUcmlnZ2VyVHJpbVRyaXBUcm9waHlUcm91YmxlVHJ1Y2tUcnVlVHJ1bHlUcnVtcGV0VHJ1c3RUcnV0aFRyeVR1YmVUdWl0aW9uVHVtYmxlVHVuYVR1bm5lbFR1cmtleVR1cm5UdXJ0bGVUd2VsdmVUd2VudHlUd2ljZVR3aW5Ud2lzdFR3b1R5cGVUeXBpY2FsVWdseVVtYnJlbGxhVW5hYmxlVW5hd2FyZVVuY2xlVW5jb3ZlclVuZGVyVW5kb1VuZmFpclVuZm9sZFVuaGFwcHlVbmlmb3JtVW5pcXVlVW5pdFVuaXZlcnNlVW5rbm93blVubG9ja1VudGlsVW51c3VhbFVudmVpbFVwZGF0ZVVwZ3JhZGVVcGhvbGRVcG9uVXBwZXJVcHNldFVyYmFuVXJnZVVzYWdlVXNlVXNlZFVzZWZ1bFVzZWxlc3NVc3VhbFV0aWxpdHlWYWNhbnRWYWN1dW1WYWd1ZVZhbGlkVmFsbGV5VmFsdmVWYW5WYW5pc2hWYXBvclZhcmlvdXNWYXN0VmF1bHRWZWhpY2xlVmVsdmV0VmVuZG9yVmVudHVyZVZlbnVlVmVyYlZlcmlmeVZlcnNpb25WZXJ5VmVzc2VsVmV0ZXJhblZpYWJsZVZpYnJhbnRWaWNpb3VzVmljdG9yeVZpZGVvVmlld1ZpbGxhZ2VWaW50YWdlVmlvbGluVmlydHVhbFZpcnVzVmlzYVZpc2l0VmlzdWFsVml0YWxWaXZpZFZvY2FsVm9pY2VWb2lkVm9sY2Fub1ZvbHVtZVZvdGVWb3lhZ2VXYWdlV2Fnb25XYWl0V2Fsa1dhbGxXYWxudXRXYW50V2FyZmFyZVdhcm1XYXJyaW9yV2FzaFdhc3BXYXN0ZVdhdGVyV2F2ZVdheVdlYWx0aFdlYXBvbldlYXJXZWFzZWxXZWF0aGVyV2ViV2VkZGluZ1dlZWtlbmRXZWlyZFdlbGNvbWVXZXN0V2V0V2hhbGVXaGF0V2hlYXRXaGVlbFdoZW5XaGVyZVdoaXBXaGlzcGVyV2lkZVdpZHRoV2lmZVdpbGRXaWxsV2luV2luZG93V2luZVdpbmdXaW5rV2lubmVyV2ludGVyV2lyZVdpc2RvbVdpc2VXaXNoV2l0bmVzc1dvbGZXb21hbldvbmRlcldvb2RXb29sV29yZFdvcmtXb3JsZFdvcnJ5V29ydGhXcmFwV3JlY2tXcmVzdGxlV3Jpc3RXcml0ZVdyb25nWWFyZFllYXJZZWxsb3dZb3VZb3VuZ1lvdXRoWmVicmFaZXJvWm9uZVpvb1wiO1xuXHR2YXIgd29yZGxpc3QkMSA9IG51bGw7XG5cdGZ1bmN0aW9uIGxvYWRXb3JkcyhsYW5nKSB7XG5cdCAgICBpZiAod29yZGxpc3QkMSAhPSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgfVxuXHQgICAgd29yZGxpc3QkMSA9IHdvcmRzLnJlcGxhY2UoLyhbQS1aXSkvZywgXCIgJDFcIikudG9Mb3dlckNhc2UoKS5zdWJzdHJpbmcoMSkuc3BsaXQoXCIgXCIpO1xuXHQgICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3Rcblx0ICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgaWYgKHdvcmRsaXN0LldvcmRsaXN0LmNoZWNrKGxhbmcpICE9PSBcIjB4M2M4YWNjMWU3YjA4ZDhlNzZmOWZkYTAxNWVmNDhkYzhjNzEwYTczY2I3ZTBmNzdiMmMxOGE5YjVhN2FkZGU2MFwiKSB7XG5cdCAgICAgICAgd29yZGxpc3QkMSA9IG51bGw7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQklQMzkgV29yZGxpc3QgZm9yIGVuIChFbmdsaXNoKSBGQUlMRURcIik7XG5cdCAgICB9XG5cdH1cblx0dmFyIExhbmdFbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhMYW5nRW4sIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBMYW5nRW4oKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIFwiZW5cIikgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIExhbmdFbi5wcm90b3R5cGUuZ2V0V29yZCA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgIGxvYWRXb3Jkcyh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gd29yZGxpc3QkMVtpbmRleF07XG5cdCAgICB9O1xuXHQgICAgTGFuZ0VuLnByb3RvdHlwZS5nZXRXb3JkSW5kZXggPSBmdW5jdGlvbiAod29yZCkge1xuXHQgICAgICAgIGxvYWRXb3Jkcyh0aGlzKTtcblx0ICAgICAgICByZXR1cm4gd29yZGxpc3QkMS5pbmRleE9mKHdvcmQpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBMYW5nRW47XG5cdH0od29yZGxpc3QuV29yZGxpc3QpKTtcblx0dmFyIGxhbmdFbiA9IG5ldyBMYW5nRW4oKTtcblx0ZXhwb3J0cy5sYW5nRW4gPSBsYW5nRW47XG5cdHdvcmRsaXN0LldvcmRsaXN0LnJlZ2lzdGVyKGxhbmdFbik7XG5cblx0fSk7XG5cblx0dmFyIGxhbmdFbiA9IHVud3JhcEV4cG9ydHMobGFuZ0VuXzEpO1xuXHR2YXIgbGFuZ0VuXzIgPSBsYW5nRW5fMS5sYW5nRW47XG5cblx0dmFyIGJyb3dzZXIkNCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0Ly8gV29yZGxpc3RzXG5cdC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDAzOS9iaXAtMDAzOS13b3JkbGlzdHMubWRcblxuXHRleHBvcnRzLldvcmRsaXN0ID0gd29yZGxpc3QuV29yZGxpc3Q7XG5cblx0dmFyIHdvcmRsaXN0cyA9IHsgZW46IGxhbmdFbl8xLmxhbmdFbiB9O1xuXHRleHBvcnRzLndvcmRsaXN0cyA9IHdvcmRsaXN0cztcblxuXHR9KTtcblxuXHR2YXIgYnJvd3NlciQ1ID0gdW53cmFwRXhwb3J0cyhicm93c2VyJDQpO1xuXHR2YXIgYnJvd3Nlcl8xJDIgPSBicm93c2VyJDQuV29yZGxpc3Q7XG5cdHZhciBicm93c2VyXzIkMSA9IGJyb3dzZXIkNC53b3JkbGlzdHM7XG5cblx0dmFyIF92ZXJzaW9uJHcgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiaGRub2RlLzUuMC40XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHggPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJHcpO1xuXHR2YXIgX3ZlcnNpb25fMSRnID0gX3ZlcnNpb24kdy52ZXJzaW9uO1xuXG5cdHZhciBsaWIkaCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHcudmVyc2lvbik7XG5cdHZhciBOID0gbGliJDIuQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG5cdC8vIFwiQml0Y29pbiBzZWVkXCJcblx0dmFyIE1hc3RlclNlY3JldCA9IGxpYiQ4LnRvVXRmOEJ5dGVzKFwiQml0Y29pbiBzZWVkXCIpO1xuXHR2YXIgSGFyZGVuZWRCaXQgPSAweDgwMDAwMDAwO1xuXHQvLyBSZXR1cm5zIGEgYnl0ZSB3aXRoIHRoZSBNU0IgYml0cyBzZXRcblx0ZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcblx0ICAgIHJldHVybiAoKDEgPDwgYml0cykgLSAxKSA8PCAoOCAtIGJpdHMpO1xuXHR9XG5cdC8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIExTQiBiaXRzIHNldFxuXHRmdW5jdGlvbiBnZXRMb3dlck1hc2soYml0cykge1xuXHQgICAgcmV0dXJuICgxIDw8IGJpdHMpIC0gMTtcblx0fVxuXHRmdW5jdGlvbiBieXRlczMyKHZhbHVlKSB7XG5cdCAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChsaWIkMS5oZXhsaWZ5KHZhbHVlKSwgMzIpO1xuXHR9XG5cdGZ1bmN0aW9uIGJhc2U1OGNoZWNrKGRhdGEpIHtcblx0ICAgIHJldHVybiBsaWIkZS5CYXNlNTguZW5jb2RlKGxpYiQxLmNvbmNhdChbZGF0YSwgbGliJDEuaGV4RGF0YVNsaWNlKGJyb3dzZXIuc2hhMjU2KGJyb3dzZXIuc2hhMjU2KGRhdGEpKSwgMCwgNCldKSk7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0V29yZGxpc3Qod29yZGxpc3QpIHtcblx0ICAgIGlmICh3b3JkbGlzdCA9PSBudWxsKSB7XG5cdCAgICAgICAgcmV0dXJuIGJyb3dzZXIkNC53b3JkbGlzdHNbXCJlblwiXTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKHdvcmRsaXN0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIHZhciB3b3JkcyA9IGJyb3dzZXIkNC53b3JkbGlzdHNbd29yZGxpc3RdO1xuXHQgICAgICAgIGlmICh3b3JkcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmtub3duIGxvY2FsZVwiLCBcIndvcmRsaXN0XCIsIHdvcmRsaXN0KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHdvcmRzO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHdvcmRsaXN0O1xuXHR9XG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHRleHBvcnRzLmRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG5cdDtcblx0dmFyIEhETm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIC8qKlxuXHQgICAgICogIFRoaXMgY29uc3RydWN0b3Igc2hvdWxkIG5vdCBiZSBjYWxsZWQgZGlyZWN0bHkuXG5cdCAgICAgKlxuXHQgICAgICogIFBsZWFzZSB1c2U6XG5cdCAgICAgKiAgIC0gZnJvbU1uZW1vbmljXG5cdCAgICAgKiAgIC0gZnJvbVNlZWRcblx0ICAgICAqL1xuXHQgICAgZnVuY3Rpb24gSEROb2RlKGNvbnN0cnVjdG9yR3VhcmQsIHByaXZhdGVLZXksIHB1YmxpY0tleSwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgaW5kZXgsIGRlcHRoLCBtbmVtb25pY09yUGF0aCkge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSEROb2RlKTtcblx0ICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cblx0ICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSEROb2RlIGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgZGlyZWN0bHlcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduaW5nS2V5ID0gbmV3IGxpYiRmLlNpZ25pbmdLZXkocHJpdmF0ZUtleSk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJpdmF0ZUtleVwiLCBzaWduaW5nS2V5LnByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBzaWduaW5nS2V5LmNvbXByZXNzZWRQdWJsaWNLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcml2YXRlS2V5XCIsIG51bGwpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBsaWIkMS5oZXhsaWZ5KHB1YmxpY0tleSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInBhcmVudEZpbmdlcnByaW50XCIsIHBhcmVudEZpbmdlcnByaW50KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbmdlcnByaW50XCIsIGxpYiQxLmhleERhdGFTbGljZShicm93c2VyLnJpcGVtZDE2MChicm93c2VyLnNoYTI1Nih0aGlzLnB1YmxpY0tleSkpLCAwLCA0KSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGxpYiRnLmNvbXB1dGVBZGRyZXNzKHRoaXMucHVibGljS2V5KSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjaGFpbkNvZGVcIiwgY2hhaW5Db2RlKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImluZGV4XCIsIGluZGV4KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcHRoXCIsIGRlcHRoKTtcblx0ICAgICAgICBpZiAobW5lbW9uaWNPclBhdGggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAvLyBGcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3QgcHJlc2VydmUgdGhlIHBhdGggKGUuZy4gZXh0ZW5kZWQga2V5cylcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJtbmVtb25pY1wiLCBudWxsKTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwYXRoXCIsIG51bGwpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG1uZW1vbmljT3JQYXRoKSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICAvLyBGcm9tIGEgc291cmNlIHRoYXQgZG9lcyBub3QgcHJlc2VydmUgdGhlIG1uZW1vbmljIChlLmcuIG5ldXRlcmVkKVxuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIm1uZW1vbmljXCIsIG51bGwpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInBhdGhcIiwgbW5lbW9uaWNPclBhdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRnJvbSBhIGZ1bGx5IHF1YWxpZmllZCBzb3VyY2Vcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJtbmVtb25pY1wiLCBtbmVtb25pY09yUGF0aCk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicGF0aFwiLCBtbmVtb25pY09yUGF0aC5wYXRoKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSEROb2RlLnByb3RvdHlwZSwgXCJleHRlbmRlZEtleVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFdlIG9ubHkgc3VwcG9ydCB0aGUgbWFpbm5ldCB2YWx1ZXMgZm9yIG5vdywgYnV0IGlmIGFueW9uZSBuZWVkc1xuXHQgICAgICAgICAgICAvLyB0ZXN0bmV0IHZhbHVlcywgbGV0IG1lIGtub3cuIEkgYmVsaWV2ZSBjdXJyZW50IHNlbml0bWVudCBpcyB0aGF0XG5cdCAgICAgICAgICAgIC8vIHdlIHNob3VsZCBhbHdheXMgdXNlIG1haW5uZXQsIGFuZCB1c2UgQklQLTQ0IHRvIGRlcml2ZSB0aGUgbmV0d29ya1xuXHQgICAgICAgICAgICAvLyAgIC0gTWFpbm5ldDogcHVibGljPTB4MDQ4OEIyMUUsIHByaXZhdGU9MHgwNDg4QURFNFxuXHQgICAgICAgICAgICAvLyAgIC0gVGVzdG5ldDogcHVibGljPTB4MDQzNTg3Q0YsIHByaXZhdGU9MHgwNDM1ODM5NFxuXHQgICAgICAgICAgICBpZiAodGhpcy5kZXB0aCA+PSAyNTYpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRlcHRoIHRvbyBsYXJnZSFcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U1OGNoZWNrKGxpYiQxLmNvbmNhdChbXG5cdCAgICAgICAgICAgICAgICAoKHRoaXMucHJpdmF0ZUtleSAhPSBudWxsKSA/IFwiMHgwNDg4QURFNFwiIDogXCIweDA0ODhCMjFFXCIpLFxuXHQgICAgICAgICAgICAgICAgbGliJDEuaGV4bGlmeSh0aGlzLmRlcHRoKSxcblx0ICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RmluZ2VycHJpbnQsXG5cdCAgICAgICAgICAgICAgICBsaWIkMS5oZXhaZXJvUGFkKGxpYiQxLmhleGxpZnkodGhpcy5pbmRleCksIDQpLFxuXHQgICAgICAgICAgICAgICAgdGhpcy5jaGFpbkNvZGUsXG5cdCAgICAgICAgICAgICAgICAoKHRoaXMucHJpdmF0ZUtleSAhPSBudWxsKSA/IGxpYiQxLmNvbmNhdChbXCIweDAwXCIsIHRoaXMucHJpdmF0ZUtleV0pIDogdGhpcy5wdWJsaWNLZXkpLFxuXHQgICAgICAgICAgICBdKSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBIRE5vZGUucHJvdG90eXBlLm5ldXRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCwgbnVsbCwgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLnBhdGgpO1xuXHQgICAgfTtcblx0ICAgIEhETm9kZS5wcm90b3R5cGUuX2Rlcml2ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuXHQgICAgICAgIGlmIChpbmRleCA+IDB4ZmZmZmZmZmYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbmRleCAtIFwiICsgU3RyaW5nKGluZGV4KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIEJhc2UgcGF0aFxuXHQgICAgICAgIHZhciBwYXRoID0gdGhpcy5wYXRoO1xuXHQgICAgICAgIGlmIChwYXRoKSB7XG5cdCAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KDM3KTtcblx0ICAgICAgICBpZiAoaW5kZXggJiBIYXJkZW5lZEJpdCkge1xuXHQgICAgICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlcml2ZSBjaGlsZCBvZiBuZXV0ZXJlZCBub2RlXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIC8vIERhdGEgPSAweDAwIHx8IHNlcl8yNTYoa19wYXIpXG5cdCAgICAgICAgICAgIGRhdGEuc2V0KGxpYiQxLmFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSksIDEpO1xuXHQgICAgICAgICAgICAvLyBIYXJkZW5lZCBwYXRoXG5cdCAgICAgICAgICAgIGlmIChwYXRoKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRoICs9IFwiJ1wiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBEYXRhID0gc2VyX3AocG9pbnQoa19wYXIpKVxuXHQgICAgICAgICAgICBkYXRhLnNldChsaWIkMS5hcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEYXRhICs9IHNlcl8zMihpKVxuXHQgICAgICAgIGZvciAodmFyIGkgPSAyNDsgaSA+PSAwOyBpIC09IDgpIHtcblx0ICAgICAgICAgICAgZGF0YVszMyArIChpID4+IDMpXSA9ICgoaW5kZXggPj4gKDI0IC0gaSkpICYgMHhmZik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBJID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhicm93c2VyLlN1cHBvcnRlZEFsZ29yaXRobS5zaGE1MTIsIHRoaXMuY2hhaW5Db2RlLCBkYXRhKSk7XG5cdCAgICAgICAgdmFyIElMID0gSS5zbGljZSgwLCAzMik7XG5cdCAgICAgICAgdmFyIElSID0gSS5zbGljZSgzMik7XG5cdCAgICAgICAgLy8gVGhlIHByaXZhdGUga2V5XG5cdCAgICAgICAgdmFyIGtpID0gbnVsbDtcblx0ICAgICAgICAvLyBUaGUgcHVibGljIGtleVxuXHQgICAgICAgIHZhciBLaSA9IG51bGw7XG5cdCAgICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuXHQgICAgICAgICAgICBraSA9IGJ5dGVzMzIobGliJDIuQmlnTnVtYmVyLmZyb20oSUwpLmFkZCh0aGlzLnByaXZhdGVLZXkpLm1vZChOKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIgZWsgPSBuZXcgbGliJGYuU2lnbmluZ0tleShsaWIkMS5oZXhsaWZ5KElMKSk7XG5cdCAgICAgICAgICAgIEtpID0gZWsuX2FkZFBvaW50KHRoaXMucHVibGljS2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1uZW1vbmljT3JQYXRoID0gcGF0aDtcblx0ICAgICAgICB2YXIgc3JjTW5lbW9uaWMgPSB0aGlzLm1uZW1vbmljO1xuXHQgICAgICAgIGlmIChzcmNNbmVtb25pYykge1xuXHQgICAgICAgICAgICBtbmVtb25pY09yUGF0aCA9IE9iamVjdC5mcmVlemUoe1xuXHQgICAgICAgICAgICAgICAgcGhyYXNlOiBzcmNNbmVtb25pYy5waHJhc2UsXG5cdCAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICAgICAgbG9jYWxlOiAoc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIilcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBraSwgS2ksIHRoaXMuZmluZ2VycHJpbnQsIGJ5dGVzMzIoSVIpLCBpbmRleCwgdGhpcy5kZXB0aCArIDEsIG1uZW1vbmljT3JQYXRoKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUucHJvdG90eXBlLmRlcml2ZVBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuXHQgICAgICAgIHZhciBjb21wb25lbnRzID0gcGF0aC5zcGxpdChcIi9cIik7XG5cdCAgICAgICAgaWYgKGNvbXBvbmVudHMubGVuZ3RoID09PSAwIHx8IChjb21wb25lbnRzWzBdID09PSBcIm1cIiAmJiB0aGlzLmRlcHRoICE9PSAwKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggLSBcIiArIHBhdGgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoY29tcG9uZW50c1swXSA9PT0gXCJtXCIpIHtcblx0ICAgICAgICAgICAgY29tcG9uZW50cy5zaGlmdCgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcztcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG5cdCAgICAgICAgICAgIGlmIChjb21wb25lbnQubWF0Y2goL15bMC05XSsnJC8pKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQuc3Vic3RyaW5nKDAsIGNvbXBvbmVudC5sZW5ndGggLSAxKSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gSGFyZGVuZWRCaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggaW5kZXggLSBcIiArIGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuX2Rlcml2ZShIYXJkZW5lZEJpdCArIGluZGV4KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnQubWF0Y2goL15bMC05XSskLykpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gSGFyZGVuZWRCaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggaW5kZXggLSBcIiArIGNvbXBvbmVudCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuX2Rlcml2ZShpbmRleCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggY29tcG9uZW50IC0gXCIgKyBjb21wb25lbnQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgSEROb2RlLl9mcm9tU2VlZCA9IGZ1bmN0aW9uIChzZWVkLCBtbmVtb25pYykge1xuXHQgICAgICAgIHZhciBzZWVkQXJyYXkgPSBsaWIkMS5hcnJheWlmeShzZWVkKTtcblx0ICAgICAgICBpZiAoc2VlZEFycmF5Lmxlbmd0aCA8IDE2IHx8IHNlZWRBcnJheS5sZW5ndGggPiA2NCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBJID0gbGliJDEuYXJyYXlpZnkoYnJvd3Nlci5jb21wdXRlSG1hYyhicm93c2VyLlN1cHBvcnRlZEFsZ29yaXRobS5zaGE1MTIsIE1hc3RlclNlY3JldCwgc2VlZEFycmF5KSk7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIGJ5dGVzMzIoSS5zbGljZSgwLCAzMikpLCBudWxsLCBcIjB4MDAwMDAwMDBcIiwgYnl0ZXMzMihJLnNsaWNlKDMyKSksIDAsIDAsIG1uZW1vbmljKTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUuZnJvbU1uZW1vbmljID0gZnVuY3Rpb24gKG1uZW1vbmljLCBwYXNzd29yZCwgd29yZGxpc3QpIHtcblx0ICAgICAgICAvLyBJZiBhIGxvY2FsZSBuYW1lIHdhcyBwYXNzZWQgaW4sIGZpbmQgdGhlIGFzc29jaWF0ZWQgd29yZGxpc3Rcblx0ICAgICAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcblx0ICAgICAgICAvLyBOb3JtYWxpemUgdGhlIGNhc2UgYW5kIHNwYWNpbmcgaW4gdGhlIG1uZW1vbmljICh0aHJvd3MgaWYgdGhlIG1uZW1vbmljIGlzIGludmFsaWQpXG5cdCAgICAgICAgbW5lbW9uaWMgPSBlbnRyb3B5VG9NbmVtb25pYyhtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpLCB3b3JkbGlzdCk7XG5cdCAgICAgICAgcmV0dXJuIEhETm9kZS5fZnJvbVNlZWQobW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSwge1xuXHQgICAgICAgICAgICBwaHJhc2U6IG1uZW1vbmljLFxuXHQgICAgICAgICAgICBwYXRoOiBcIm1cIixcblx0ICAgICAgICAgICAgbG9jYWxlOiB3b3JkbGlzdC5sb2NhbGVcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBIRE5vZGUuZnJvbVNlZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuXHQgICAgICAgIHJldHVybiBIRE5vZGUuX2Zyb21TZWVkKHNlZWQsIG51bGwpO1xuXHQgICAgfTtcblx0ICAgIEhETm9kZS5mcm9tRXh0ZW5kZWRLZXkgPSBmdW5jdGlvbiAoZXh0ZW5kZWRLZXkpIHtcblx0ICAgICAgICB2YXIgYnl0ZXMgPSBsaWIkZS5CYXNlNTguZGVjb2RlKGV4dGVuZGVkS2V5KTtcblx0ICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSA4MiB8fCBiYXNlNThjaGVjayhieXRlcy5zbGljZSgwLCA3OCkpICE9PSBleHRlbmRlZEtleSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkZXB0aCA9IGJ5dGVzWzRdO1xuXHQgICAgICAgIHZhciBwYXJlbnRGaW5nZXJwcmludCA9IGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoNSwgOSkpO1xuXHQgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoOSwgMTMpKS5zdWJzdHJpbmcoMiksIDE2KTtcblx0ICAgICAgICB2YXIgY2hhaW5Db2RlID0gbGliJDEuaGV4bGlmeShieXRlcy5zbGljZSgxMywgNDUpKTtcblx0ICAgICAgICB2YXIga2V5ID0gYnl0ZXMuc2xpY2UoNDUsIDc4KTtcblx0ICAgICAgICBzd2l0Y2ggKGxpYiQxLmhleGxpZnkoYnl0ZXMuc2xpY2UoMCwgNCkpKSB7XG5cdCAgICAgICAgICAgIC8vIFB1YmxpYyBLZXlcblx0ICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGIyMWVcIjpcblx0ICAgICAgICAgICAgY2FzZSBcIjB4MDQzNTg3Y2ZcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBudWxsLCBsaWIkMS5oZXhsaWZ5KGtleSksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIGluZGV4LCBkZXB0aCwgbnVsbCk7XG5cdCAgICAgICAgICAgIC8vIFByaXZhdGUgS2V5XG5cdCAgICAgICAgICAgIGNhc2UgXCIweDA0ODhhZGU0XCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4Mzk0IFwiOlxuXHQgICAgICAgICAgICAgICAgaWYgKGtleVswXSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIGxpYiQxLmhleGxpZnkoa2V5LnNsaWNlKDEpKSwgbnVsbCwgcGFyZW50RmluZ2VycHJpbnQsIGNoYWluQ29kZSwgaW5kZXgsIGRlcHRoLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLCBcImV4dGVuZGVkS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSEROb2RlO1xuXHR9KCkpO1xuXHRleHBvcnRzLkhETm9kZSA9IEhETm9kZTtcblx0ZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSB7XG5cdCAgICBpZiAoIXBhc3N3b3JkKSB7XG5cdCAgICAgICAgcGFzc3dvcmQgPSBcIlwiO1xuXHQgICAgfVxuXHQgICAgdmFyIHNhbHQgPSBsaWIkOC50b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIgKyBwYXNzd29yZCwgbGliJDguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0QpO1xuXHQgICAgcmV0dXJuIGJyb3dzZXIkMi5wYmtkZjIobGliJDgudG9VdGY4Qnl0ZXMobW5lbW9uaWMsIGxpYiQ4LlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktEKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xuXHR9XG5cdGV4cG9ydHMubW5lbW9uaWNUb1NlZWQgPSBtbmVtb25pY1RvU2VlZDtcblx0ZnVuY3Rpb24gbW5lbW9uaWNUb0VudHJvcHkobW5lbW9uaWMsIHdvcmRsaXN0KSB7XG5cdCAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcblx0ICAgIGxvZ2dlci5jaGVja05vcm1hbGl6ZSgpO1xuXHQgICAgdmFyIHdvcmRzID0gd29yZGxpc3Quc3BsaXQobW5lbW9uaWMpO1xuXHQgICAgaWYgKCh3b3Jkcy5sZW5ndGggJSAzKSAhPT0gMCkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbW5lbW9uaWNcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgZW50cm9weSA9IGxpYiQxLmFycmF5aWZ5KG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCgxMSAqIHdvcmRzLmxlbmd0aCAvIDgpKSk7XG5cdCAgICB2YXIgb2Zmc2V0ID0gMDtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSB3b3JkbGlzdC5nZXRXb3JkSW5kZXgod29yZHNbaV0ubm9ybWFsaXplKFwiTkZLRFwiKSk7XG5cdCAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG1uZW1vbmljXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCAxMTsgYml0KyspIHtcblx0ICAgICAgICAgICAgaWYgKGluZGV4ICYgKDEgPDwgKDEwIC0gYml0KSkpIHtcblx0ICAgICAgICAgICAgICAgIGVudHJvcHlbb2Zmc2V0ID4+IDNdIHw9ICgxIDw8ICg3IC0gKG9mZnNldCAlIDgpKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb2Zmc2V0Kys7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGVudHJvcHlCaXRzID0gMzIgKiB3b3Jkcy5sZW5ndGggLyAzO1xuXHQgICAgdmFyIGNoZWNrc3VtQml0cyA9IHdvcmRzLmxlbmd0aCAvIDM7XG5cdCAgICB2YXIgY2hlY2tzdW1NYXNrID0gZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG5cdCAgICB2YXIgY2hlY2tzdW0gPSBsaWIkMS5hcnJheWlmeShicm93c2VyLnNoYTI1NihlbnRyb3B5LnNsaWNlKDAsIGVudHJvcHlCaXRzIC8gOCkpKVswXSAmIGNoZWNrc3VtTWFzaztcblx0ICAgIGlmIChjaGVja3N1bSAhPT0gKGVudHJvcHlbZW50cm9weS5sZW5ndGggLSAxXSAmIGNoZWNrc3VtTWFzaykpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNoZWNrc3VtXCIpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKTtcblx0fVxuXHRleHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gbW5lbW9uaWNUb0VudHJvcHk7XG5cdGZ1bmN0aW9uIGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIHdvcmRsaXN0KSB7XG5cdCAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcblx0ICAgIGVudHJvcHkgPSBsaWIkMS5hcnJheWlmeShlbnRyb3B5KTtcblx0ICAgIGlmICgoZW50cm9weS5sZW5ndGggJSA0KSAhPT0gMCB8fCBlbnRyb3B5Lmxlbmd0aCA8IDE2IHx8IGVudHJvcHkubGVuZ3RoID4gMzIpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVudHJvcHlcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgaW5kaWNlcyA9IFswXTtcblx0ICAgIHZhciByZW1haW5pbmdCaXRzID0gMTE7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJvcHkubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXG5cdCAgICAgICAgaWYgKHJlbWFpbmluZ0JpdHMgPiA4KSB7XG5cdCAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gODtcblx0ICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XG5cdCAgICAgICAgICAgIHJlbWFpbmluZ0JpdHMgLT0gODtcblx0ICAgICAgICAgICAgLy8gVGhpcyBieXRlIHdpbGwgY29tcGxldGUgYW4gMTEtYml0IGluZGV4XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBpbmRpY2VzW2luZGljZXMubGVuZ3RoIC0gMV0gPDw9IHJlbWFpbmluZ0JpdHM7XG5cdCAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XG5cdCAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSBuZXh0IHdvcmRcblx0ICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGVudHJvcHlbaV0gJiBnZXRMb3dlck1hc2soOCAtIHJlbWFpbmluZ0JpdHMpKTtcblx0ICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcblx0ICAgIHZhciBjaGVja3N1bUJpdHMgPSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG5cdCAgICB2YXIgY2hlY2tzdW0gPSBsaWIkMS5hcnJheWlmeShicm93c2VyLnNoYTI1NihlbnRyb3B5KSlbMF0gJiBnZXRVcHBlck1hc2soY2hlY2tzdW1CaXRzKTtcblx0ICAgIC8vIFNoaWZ0IHRoZSBjaGVja3N1bSBpbnRvIHRoZSB3b3JkIGluZGljZXNcblx0ICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gY2hlY2tzdW1CaXRzO1xuXHQgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IChjaGVja3N1bSA+PiAoOCAtIGNoZWNrc3VtQml0cykpO1xuXHQgICAgcmV0dXJuIHdvcmRsaXN0LmpvaW4oaW5kaWNlcy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiB3b3JkbGlzdC5nZXRXb3JkKGluZGV4KTsgfSkpO1xuXHR9XG5cdGV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSBlbnRyb3B5VG9NbmVtb25pYztcblx0ZnVuY3Rpb24gaXNWYWxpZE1uZW1vbmljKG1uZW1vbmljLCB3b3JkbGlzdCkge1xuXHQgICAgdHJ5IHtcblx0ICAgICAgICBtbmVtb25pY1RvRW50cm9weShtbmVtb25pYywgd29yZGxpc3QpO1xuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuXHRleHBvcnRzLmlzVmFsaWRNbmVtb25pYyA9IGlzVmFsaWRNbmVtb25pYztcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkaCA9IHVud3JhcEV4cG9ydHMobGliJGgpO1xuXHR2YXIgbGliXzEkaCA9IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHR2YXIgbGliXzIkZyA9IGxpYiRoLkhETm9kZTtcblx0dmFyIGxpYl8zJGQgPSBsaWIkaC5tbmVtb25pY1RvU2VlZDtcblx0dmFyIGxpYl80JGEgPSBsaWIkaC5tbmVtb25pY1RvRW50cm9weTtcblx0dmFyIGxpYl81JDkgPSBsaWIkaC5lbnRyb3B5VG9NbmVtb25pYztcblx0dmFyIGxpYl82JDUgPSBsaWIkaC5pc1ZhbGlkTW5lbW9uaWM7XG5cblx0dmFyIF92ZXJzaW9uJHkgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwicmFuZG9tLzUuMC4zXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJHogPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJHkpO1xuXHR2YXIgX3ZlcnNpb25fMSRoID0gX3ZlcnNpb24keS52ZXJzaW9uO1xuXG5cdHZhciBzaHVmZmxlID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRmdW5jdGlvbiBzaHVmZmxlZChhcnJheSkge1xuXHQgICAgYXJyYXkgPSBhcnJheS5zbGljZSgpO1xuXHQgICAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcblx0ICAgICAgICB2YXIgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuXHQgICAgICAgIHZhciB0bXAgPSBhcnJheVtpXTtcblx0ICAgICAgICBhcnJheVtpXSA9IGFycmF5W2pdO1xuXHQgICAgICAgIGFycmF5W2pdID0gdG1wO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGFycmF5O1xuXHR9XG5cdGV4cG9ydHMuc2h1ZmZsZWQgPSBzaHVmZmxlZDtcblxuXHR9KTtcblxuXHR2YXIgc2h1ZmZsZSQxID0gdW53cmFwRXhwb3J0cyhzaHVmZmxlKTtcblx0dmFyIHNodWZmbGVfMSA9IHNodWZmbGUuc2h1ZmZsZWQ7XG5cblx0dmFyIGJyb3dzZXIkNiA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJHkudmVyc2lvbik7XG5cblx0ZXhwb3J0cy5zaHVmZmxlZCA9IHNodWZmbGUuc2h1ZmZsZWQ7XG5cdHZhciBhbnlHbG9iYWwgPSBudWxsO1xuXHR0cnkge1xuXHQgICAgYW55R2xvYmFsID0gd2luZG93O1xuXHQgICAgaWYgKGFueUdsb2JhbCA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IG5leHRcIik7XG5cdCAgICB9XG5cdH1cblx0Y2F0Y2ggKGVycm9yKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGFueUdsb2JhbCA9IGNvbW1vbmpzR2xvYmFsO1xuXHQgICAgICAgIGlmIChhbnlHbG9iYWwgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgbmV4dFwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICBhbnlHbG9iYWwgPSB7fTtcblx0ICAgIH1cblx0fVxuXHR2YXIgY3J5cHRvID0gYW55R2xvYmFsLmNyeXB0byB8fCBhbnlHbG9iYWwubXNDcnlwdG87XG5cdGlmICghY3J5cHRvIHx8ICFjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XG5cdCAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IE1pc3Npbmcgc3Ryb25nIHJhbmRvbSBudW1iZXIgc291cmNlXCIpO1xuXHQgICAgY3J5cHRvID0ge1xuXHQgICAgICAgIGdldFJhbmRvbVZhbHVlczogZnVuY3Rpb24gKGJ1ZmZlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJubyBzZWN1cmUgcmFuZG9tIHNvdXJjZSBhdmFpYWxibGVcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiY3J5cHRvLmdldFJhbmRvbVZhbHVlc1wiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gcmFuZG9tQnl0ZXMobGVuZ3RoKSB7XG5cdCAgICBpZiAobGVuZ3RoIDw9IDAgfHwgbGVuZ3RoID4gMTAyNCB8fCAobGVuZ3RoICUgMSkpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGhcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcblx0ICAgIH1cblx0ICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhyZXN1bHQpO1xuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHJlc3VsdCk7XG5cdH1cblx0ZXhwb3J0cy5yYW5kb21CeXRlcyA9IHJhbmRvbUJ5dGVzO1xuXHQ7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXIkNyA9IHVud3JhcEV4cG9ydHMoYnJvd3NlciQ2KTtcblx0dmFyIGJyb3dzZXJfMSQzID0gYnJvd3NlciQ2LnNodWZmbGVkO1xuXHR2YXIgYnJvd3Nlcl8yJDIgPSBicm93c2VyJDYucmFuZG9tQnl0ZXM7XG5cblx0dmFyIGFlc0pzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHQoZnVuY3Rpb24ocm9vdCkge1xuXG5cdCAgICBmdW5jdGlvbiBjaGVja0ludCh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAocGFyc2VJbnQodmFsdWUpID09PSB2YWx1ZSk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNoZWNrSW50cyhhcnJheWlzaCkge1xuXHQgICAgICAgIGlmICghY2hlY2tJbnQoYXJyYXlpc2gubGVuZ3RoKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlpc2gubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKCFjaGVja0ludChhcnJheWlzaFtpXSkgfHwgYXJyYXlpc2hbaV0gPCAwIHx8IGFycmF5aXNoW2ldID4gMjU1KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY29lcmNlQXJyYXkoYXJnLCBjb3B5KSB7XG5cblx0ICAgICAgICAvLyBBcnJheUJ1ZmZlciB2aWV3XG5cdCAgICAgICAgaWYgKGFyZy5idWZmZXIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGFyZykgJiYgYXJnLm5hbWUgPT09ICdVaW50OEFycmF5Jykge1xuXG5cdCAgICAgICAgICAgIGlmIChjb3B5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYXJnLnNsaWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKCk7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGFyZyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYXJnO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEl0J3MgYW4gYXJyYXk7IGNoZWNrIGl0IGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBieXRlXG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHQgICAgICAgICAgICBpZiAoIWNoZWNrSW50cyhhcmcpKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGNvbnRhaW5zIGludmFsaWQgdmFsdWU6ICcgKyBhcmcpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGFyZyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gU29tZXRoaW5nIGVsc2UsIGJ1dCBiZWhhdmVzIGxpa2UgYW4gYXJyYXkgKG1heWJlIGEgQnVmZmVyPyBBcmd1bWVudHM/KVxuXHQgICAgICAgIGlmIChjaGVja0ludChhcmcubGVuZ3RoKSAmJiBjaGVja0ludHMoYXJnKSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkIGFycmF5LWxpa2Ugb2JqZWN0Jyk7XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIGNyZWF0ZUFycmF5KGxlbmd0aCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlQXJyYXksIHRhcmdldEFycmF5LCB0YXJnZXRTdGFydCwgc291cmNlU3RhcnQsIHNvdXJjZUVuZCkge1xuXHQgICAgICAgIGlmIChzb3VyY2VTdGFydCAhPSBudWxsIHx8IHNvdXJjZUVuZCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIGlmIChzb3VyY2VBcnJheS5zbGljZSkge1xuXHQgICAgICAgICAgICAgICAgc291cmNlQXJyYXkgPSBzb3VyY2VBcnJheS5zbGljZShzb3VyY2VTdGFydCwgc291cmNlRW5kKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc291cmNlQXJyYXksIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSwgdGFyZ2V0U3RhcnQpO1xuXHQgICAgfVxuXG5cblxuXHQgICAgdmFyIGNvbnZlcnRVdGY4ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW10sIGkgPSAwO1xuXHQgICAgICAgICAgICB0ZXh0ID0gZW5jb2RlVVJJKHRleHQpO1xuXHQgICAgICAgICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYyA9IHRleHQuY2hhckNvZGVBdChpKyspO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBhICUgc2lnbiwgZW5jb2RlIHRoZSBmb2xsb3dpbmcgMiBieXRlcyBhcyBhIGhleCB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgaWYgKGMgPT09IDM3KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwgMiksIDE2KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UsIGp1c3QgdGhlIGFjdHVhbCBieXRlXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNvZXJjZUFycmF5KHJlc3VsdCk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSA9IDA7XG5cblx0ICAgICAgICAgICAgd2hpbGUgKGkgPCBieXRlcy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjID0gYnl0ZXNbaV07XG5cblx0ICAgICAgICAgICAgICAgIGlmIChjIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMTkxICYmIGMgPCAyMjQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MWYpIDw8IDYpIHwgKGJ5dGVzW2kgKyAxXSAmIDB4M2YpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaSArPSAyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYyAmIDB4MGYpIDw8IDEyKSB8ICgoYnl0ZXNbaSArIDFdICYgMHgzZikgPDwgNikgfCAoYnl0ZXNbaSArIDJdICYgMHgzZikpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpICs9IDM7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIHRvQnl0ZXM6IHRvQnl0ZXMsXG5cdCAgICAgICAgICAgIGZyb21CeXRlczogZnJvbUJ5dGVzLFxuXHQgICAgICAgIH1cblx0ICAgIH0pKCk7XG5cblx0ICAgIHZhciBjb252ZXJ0SGV4ID0gKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQodGV4dC5zdWJzdHIoaSwgMiksIDE2KSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGh0dHA6Ly9peHRpLm5ldC9kZXZlbG9wbWVudC9qYXZhc2NyaXB0LzIwMTEvMTEvMTEvYmFzZTY0LWVuY29kZWRlY29kZS1vZi11dGY4LWluLWJyb3dzZXItd2l0aC1qcy5odG1sXG5cdCAgICAgICAgdmFyIEhleCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuXHQgICAgICAgIGZ1bmN0aW9uIGZyb21CeXRlcyhieXRlcykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB2ID0gYnl0ZXNbaV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goSGV4Wyh2ICYgMHhmMCkgPj4gNF0gKyBIZXhbdiAmIDB4MGZdKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdG9CeXRlczogdG9CeXRlcyxcblx0ICAgICAgICAgICAgZnJvbUJ5dGVzOiBmcm9tQnl0ZXMsXG5cdCAgICAgICAgfVxuXHQgICAgfSkoKTtcblxuXG5cdCAgICAvLyBOdW1iZXIgb2Ygcm91bmRzIGJ5IGtleXNpemVcblx0ICAgIHZhciBudW1iZXJPZlJvdW5kcyA9IHsxNjogMTAsIDI0OiAxMiwgMzI6IDE0fTtcblxuXHQgICAgLy8gUm91bmQgY29uc3RhbnQgd29yZHNcblx0ICAgIHZhciByY29uID0gWzB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzYsIDB4NmMsIDB4ZDgsIDB4YWIsIDB4NGQsIDB4OWEsIDB4MmYsIDB4NWUsIDB4YmMsIDB4NjMsIDB4YzYsIDB4OTcsIDB4MzUsIDB4NmEsIDB4ZDQsIDB4YjMsIDB4N2QsIDB4ZmEsIDB4ZWYsIDB4YzUsIDB4OTFdO1xuXG5cdCAgICAvLyBTLWJveCBhbmQgSW52ZXJzZSBTLWJveCAoUyBpcyBmb3IgU3Vic3RpdHV0aW9uKVxuXHQgICAgdmFyIFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG5cdCAgICB2YXIgU2kgPVsweDUyLCAweDA5LCAweDZhLCAweGQ1LCAweDMwLCAweDM2LCAweGE1LCAweDM4LCAweGJmLCAweDQwLCAweGEzLCAweDllLCAweDgxLCAweGYzLCAweGQ3LCAweGZiLCAweDdjLCAweGUzLCAweDM5LCAweDgyLCAweDliLCAweDJmLCAweGZmLCAweDg3LCAweDM0LCAweDhlLCAweDQzLCAweDQ0LCAweGM0LCAweGRlLCAweGU5LCAweGNiLCAweDU0LCAweDdiLCAweDk0LCAweDMyLCAweGE2LCAweGMyLCAweDIzLCAweDNkLCAweGVlLCAweDRjLCAweDk1LCAweDBiLCAweDQyLCAweGZhLCAweGMzLCAweDRlLCAweDA4LCAweDJlLCAweGExLCAweDY2LCAweDI4LCAweGQ5LCAweDI0LCAweGIyLCAweDc2LCAweDViLCAweGEyLCAweDQ5LCAweDZkLCAweDhiLCAweGQxLCAweDI1LCAweDcyLCAweGY4LCAweGY2LCAweDY0LCAweDg2LCAweDY4LCAweDk4LCAweDE2LCAweGQ0LCAweGE0LCAweDVjLCAweGNjLCAweDVkLCAweDY1LCAweGI2LCAweDkyLCAweDZjLCAweDcwLCAweDQ4LCAweDUwLCAweGZkLCAweGVkLCAweGI5LCAweGRhLCAweDVlLCAweDE1LCAweDQ2LCAweDU3LCAweGE3LCAweDhkLCAweDlkLCAweDg0LCAweDkwLCAweGQ4LCAweGFiLCAweDAwLCAweDhjLCAweGJjLCAweGQzLCAweDBhLCAweGY3LCAweGU0LCAweDU4LCAweDA1LCAweGI4LCAweGIzLCAweDQ1LCAweDA2LCAweGQwLCAweDJjLCAweDFlLCAweDhmLCAweGNhLCAweDNmLCAweDBmLCAweDAyLCAweGMxLCAweGFmLCAweGJkLCAweDAzLCAweDAxLCAweDEzLCAweDhhLCAweDZiLCAweDNhLCAweDkxLCAweDExLCAweDQxLCAweDRmLCAweDY3LCAweGRjLCAweGVhLCAweDk3LCAweGYyLCAweGNmLCAweGNlLCAweGYwLCAweGI0LCAweGU2LCAweDczLCAweDk2LCAweGFjLCAweDc0LCAweDIyLCAweGU3LCAweGFkLCAweDM1LCAweDg1LCAweGUyLCAweGY5LCAweDM3LCAweGU4LCAweDFjLCAweDc1LCAweGRmLCAweDZlLCAweDQ3LCAweGYxLCAweDFhLCAweDcxLCAweDFkLCAweDI5LCAweGM1LCAweDg5LCAweDZmLCAweGI3LCAweDYyLCAweDBlLCAweGFhLCAweDE4LCAweGJlLCAweDFiLCAweGZjLCAweDU2LCAweDNlLCAweDRiLCAweGM2LCAweGQyLCAweDc5LCAweDIwLCAweDlhLCAweGRiLCAweGMwLCAweGZlLCAweDc4LCAweGNkLCAweDVhLCAweGY0LCAweDFmLCAweGRkLCAweGE4LCAweDMzLCAweDg4LCAweDA3LCAweGM3LCAweDMxLCAweGIxLCAweDEyLCAweDEwLCAweDU5LCAweDI3LCAweDgwLCAweGVjLCAweDVmLCAweDYwLCAweDUxLCAweDdmLCAweGE5LCAweDE5LCAweGI1LCAweDRhLCAweDBkLCAweDJkLCAweGU1LCAweDdhLCAweDlmLCAweDkzLCAweGM5LCAweDljLCAweGVmLCAweGEwLCAweGUwLCAweDNiLCAweDRkLCAweGFlLCAweDJhLCAweGY1LCAweGIwLCAweGM4LCAweGViLCAweGJiLCAweDNjLCAweDgzLCAweDUzLCAweDk5LCAweDYxLCAweDE3LCAweDJiLCAweDA0LCAweDdlLCAweGJhLCAweDc3LCAweGQ2LCAweDI2LCAweGUxLCAweDY5LCAweDE0LCAweDYzLCAweDU1LCAweDIxLCAweDBjLCAweDdkXTtcblxuXHQgICAgLy8gVHJhbnNmb3JtYXRpb25zIGZvciBlbmNyeXB0aW9uXG5cdCAgICB2YXIgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG5cdCAgICB2YXIgVDIgPSBbMHhhNWM2NjM2MywgMHg4NGY4N2M3YywgMHg5OWVlNzc3NywgMHg4ZGY2N2I3YiwgMHgwZGZmZjJmMiwgMHhiZGQ2NmI2YiwgMHhiMWRlNmY2ZiwgMHg1NDkxYzVjNSwgMHg1MDYwMzAzMCwgMHgwMzAyMDEwMSwgMHhhOWNlNjc2NywgMHg3ZDU2MmIyYiwgMHgxOWU3ZmVmZSwgMHg2MmI1ZDdkNywgMHhlNjRkYWJhYiwgMHg5YWVjNzY3NiwgMHg0NThmY2FjYSwgMHg5ZDFmODI4MiwgMHg0MDg5YzljOSwgMHg4N2ZhN2Q3ZCwgMHgxNWVmZmFmYSwgMHhlYmIyNTk1OSwgMHhjOThlNDc0NywgMHgwYmZiZjBmMCwgMHhlYzQxYWRhZCwgMHg2N2IzZDRkNCwgMHhmZDVmYTJhMiwgMHhlYTQ1YWZhZiwgMHhiZjIzOWM5YywgMHhmNzUzYTRhNCwgMHg5NmU0NzI3MiwgMHg1YjliYzBjMCwgMHhjMjc1YjdiNywgMHgxY2UxZmRmZCwgMHhhZTNkOTM5MywgMHg2YTRjMjYyNiwgMHg1YTZjMzYzNiwgMHg0MTdlM2YzZiwgMHgwMmY1ZjdmNywgMHg0ZjgzY2NjYywgMHg1YzY4MzQzNCwgMHhmNDUxYTVhNSwgMHgzNGQxZTVlNSwgMHgwOGY5ZjFmMSwgMHg5M2UyNzE3MSwgMHg3M2FiZDhkOCwgMHg1MzYyMzEzMSwgMHgzZjJhMTUxNSwgMHgwYzA4MDQwNCwgMHg1Mjk1YzdjNywgMHg2NTQ2MjMyMywgMHg1ZTlkYzNjMywgMHgyODMwMTgxOCwgMHhhMTM3OTY5NiwgMHgwZjBhMDUwNSwgMHhiNTJmOWE5YSwgMHgwOTBlMDcwNywgMHgzNjI0MTIxMiwgMHg5YjFiODA4MCwgMHgzZGRmZTJlMiwgMHgyNmNkZWJlYiwgMHg2OTRlMjcyNywgMHhjZDdmYjJiMiwgMHg5ZmVhNzU3NSwgMHgxYjEyMDkwOSwgMHg5ZTFkODM4MywgMHg3NDU4MmMyYywgMHgyZTM0MWExYSwgMHgyZDM2MWIxYiwgMHhiMmRjNmU2ZSwgMHhlZWI0NWE1YSwgMHhmYjViYTBhMCwgMHhmNmE0NTI1MiwgMHg0ZDc2M2IzYiwgMHg2MWI3ZDZkNiwgMHhjZTdkYjNiMywgMHg3YjUyMjkyOSwgMHgzZWRkZTNlMywgMHg3MTVlMmYyZiwgMHg5NzEzODQ4NCwgMHhmNWE2NTM1MywgMHg2OGI5ZDFkMSwgMHgwMDAwMDAwMCwgMHgyY2MxZWRlZCwgMHg2MDQwMjAyMCwgMHgxZmUzZmNmYywgMHhjODc5YjFiMSwgMHhlZGI2NWI1YiwgMHhiZWQ0NmE2YSwgMHg0NjhkY2JjYiwgMHhkOTY3YmViZSwgMHg0YjcyMzkzOSwgMHhkZTk0NGE0YSwgMHhkNDk4NGM0YywgMHhlOGIwNTg1OCwgMHg0YTg1Y2ZjZiwgMHg2YmJiZDBkMCwgMHgyYWM1ZWZlZiwgMHhlNTRmYWFhYSwgMHgxNmVkZmJmYiwgMHhjNTg2NDM0MywgMHhkNzlhNGQ0ZCwgMHg1NTY2MzMzMywgMHg5NDExODU4NSwgMHhjZjhhNDU0NSwgMHgxMGU5ZjlmOSwgMHgwNjA0MDIwMiwgMHg4MWZlN2Y3ZiwgMHhmMGEwNTA1MCwgMHg0NDc4M2MzYywgMHhiYTI1OWY5ZiwgMHhlMzRiYThhOCwgMHhmM2EyNTE1MSwgMHhmZTVkYTNhMywgMHhjMDgwNDA0MCwgMHg4YTA1OGY4ZiwgMHhhZDNmOTI5MiwgMHhiYzIxOWQ5ZCwgMHg0ODcwMzgzOCwgMHgwNGYxZjVmNSwgMHhkZjYzYmNiYywgMHhjMTc3YjZiNiwgMHg3NWFmZGFkYSwgMHg2MzQyMjEyMSwgMHgzMDIwMTAxMCwgMHgxYWU1ZmZmZiwgMHgwZWZkZjNmMywgMHg2ZGJmZDJkMiwgMHg0YzgxY2RjZCwgMHgxNDE4MGMwYywgMHgzNTI2MTMxMywgMHgyZmMzZWNlYywgMHhlMWJlNWY1ZiwgMHhhMjM1OTc5NywgMHhjYzg4NDQ0NCwgMHgzOTJlMTcxNywgMHg1NzkzYzRjNCwgMHhmMjU1YTdhNywgMHg4MmZjN2U3ZSwgMHg0NzdhM2QzZCwgMHhhY2M4NjQ2NCwgMHhlN2JhNWQ1ZCwgMHgyYjMyMTkxOSwgMHg5NWU2NzM3MywgMHhhMGMwNjA2MCwgMHg5ODE5ODE4MSwgMHhkMTllNGY0ZiwgMHg3ZmEzZGNkYywgMHg2NjQ0MjIyMiwgMHg3ZTU0MmEyYSwgMHhhYjNiOTA5MCwgMHg4MzBiODg4OCwgMHhjYThjNDY0NiwgMHgyOWM3ZWVlZSwgMHhkMzZiYjhiOCwgMHgzYzI4MTQxNCwgMHg3OWE3ZGVkZSwgMHhlMmJjNWU1ZSwgMHgxZDE2MGIwYiwgMHg3NmFkZGJkYiwgMHgzYmRiZTBlMCwgMHg1NjY0MzIzMiwgMHg0ZTc0M2EzYSwgMHgxZTE0MGEwYSwgMHhkYjkyNDk0OSwgMHgwYTBjMDYwNiwgMHg2YzQ4MjQyNCwgMHhlNGI4NWM1YywgMHg1ZDlmYzJjMiwgMHg2ZWJkZDNkMywgMHhlZjQzYWNhYywgMHhhNmM0NjI2MiwgMHhhODM5OTE5MSwgMHhhNDMxOTU5NSwgMHgzN2QzZTRlNCwgMHg4YmYyNzk3OSwgMHgzMmQ1ZTdlNywgMHg0MzhiYzhjOCwgMHg1OTZlMzczNywgMHhiN2RhNmQ2ZCwgMHg4YzAxOGQ4ZCwgMHg2NGIxZDVkNSwgMHhkMjljNGU0ZSwgMHhlMDQ5YTlhOSwgMHhiNGQ4NmM2YywgMHhmYWFjNTY1NiwgMHgwN2YzZjRmNCwgMHgyNWNmZWFlYSwgMHhhZmNhNjU2NSwgMHg4ZWY0N2E3YSwgMHhlOTQ3YWVhZSwgMHgxODEwMDgwOCwgMHhkNTZmYmFiYSwgMHg4OGYwNzg3OCwgMHg2ZjRhMjUyNSwgMHg3MjVjMmUyZSwgMHgyNDM4MWMxYywgMHhmMTU3YTZhNiwgMHhjNzczYjRiNCwgMHg1MTk3YzZjNiwgMHgyM2NiZThlOCwgMHg3Y2ExZGRkZCwgMHg5Y2U4NzQ3NCwgMHgyMTNlMWYxZiwgMHhkZDk2NGI0YiwgMHhkYzYxYmRiZCwgMHg4NjBkOGI4YiwgMHg4NTBmOGE4YSwgMHg5MGUwNzA3MCwgMHg0MjdjM2UzZSwgMHhjNDcxYjViNSwgMHhhYWNjNjY2NiwgMHhkODkwNDg0OCwgMHgwNTA2MDMwMywgMHgwMWY3ZjZmNiwgMHgxMjFjMGUwZSwgMHhhM2MyNjE2MSwgMHg1ZjZhMzUzNSwgMHhmOWFlNTc1NywgMHhkMDY5YjliOSwgMHg5MTE3ODY4NiwgMHg1ODk5YzFjMSwgMHgyNzNhMWQxZCwgMHhiOTI3OWU5ZSwgMHgzOGQ5ZTFlMSwgMHgxM2ViZjhmOCwgMHhiMzJiOTg5OCwgMHgzMzIyMTExMSwgMHhiYmQyNjk2OSwgMHg3MGE5ZDlkOSwgMHg4OTA3OGU4ZSwgMHhhNzMzOTQ5NCwgMHhiNjJkOWI5YiwgMHgyMjNjMWUxZSwgMHg5MjE1ODc4NywgMHgyMGM5ZTllOSwgMHg0OTg3Y2VjZSwgMHhmZmFhNTU1NSwgMHg3ODUwMjgyOCwgMHg3YWE1ZGZkZiwgMHg4ZjAzOGM4YywgMHhmODU5YTFhMSwgMHg4MDA5ODk4OSwgMHgxNzFhMGQwZCwgMHhkYTY1YmZiZiwgMHgzMWQ3ZTZlNiwgMHhjNjg0NDI0MiwgMHhiOGQwNjg2OCwgMHhjMzgyNDE0MSwgMHhiMDI5OTk5OSwgMHg3NzVhMmQyZCwgMHgxMTFlMGYwZiwgMHhjYjdiYjBiMCwgMHhmY2E4NTQ1NCwgMHhkNjZkYmJiYiwgMHgzYTJjMTYxNl07XG5cdCAgICB2YXIgVDMgPSBbMHg2M2E1YzY2MywgMHg3Yzg0Zjg3YywgMHg3Nzk5ZWU3NywgMHg3YjhkZjY3YiwgMHhmMjBkZmZmMiwgMHg2YmJkZDY2YiwgMHg2ZmIxZGU2ZiwgMHhjNTU0OTFjNSwgMHgzMDUwNjAzMCwgMHgwMTAzMDIwMSwgMHg2N2E5Y2U2NywgMHgyYjdkNTYyYiwgMHhmZTE5ZTdmZSwgMHhkNzYyYjVkNywgMHhhYmU2NGRhYiwgMHg3NjlhZWM3NiwgMHhjYTQ1OGZjYSwgMHg4MjlkMWY4MiwgMHhjOTQwODljOSwgMHg3ZDg3ZmE3ZCwgMHhmYTE1ZWZmYSwgMHg1OWViYjI1OSwgMHg0N2M5OGU0NywgMHhmMDBiZmJmMCwgMHhhZGVjNDFhZCwgMHhkNDY3YjNkNCwgMHhhMmZkNWZhMiwgMHhhZmVhNDVhZiwgMHg5Y2JmMjM5YywgMHhhNGY3NTNhNCwgMHg3Mjk2ZTQ3MiwgMHhjMDViOWJjMCwgMHhiN2MyNzViNywgMHhmZDFjZTFmZCwgMHg5M2FlM2Q5MywgMHgyNjZhNGMyNiwgMHgzNjVhNmMzNiwgMHgzZjQxN2UzZiwgMHhmNzAyZjVmNywgMHhjYzRmODNjYywgMHgzNDVjNjgzNCwgMHhhNWY0NTFhNSwgMHhlNTM0ZDFlNSwgMHhmMTA4ZjlmMSwgMHg3MTkzZTI3MSwgMHhkODczYWJkOCwgMHgzMTUzNjIzMSwgMHgxNTNmMmExNSwgMHgwNDBjMDgwNCwgMHhjNzUyOTVjNywgMHgyMzY1NDYyMywgMHhjMzVlOWRjMywgMHgxODI4MzAxOCwgMHg5NmExMzc5NiwgMHgwNTBmMGEwNSwgMHg5YWI1MmY5YSwgMHgwNzA5MGUwNywgMHgxMjM2MjQxMiwgMHg4MDliMWI4MCwgMHhlMjNkZGZlMiwgMHhlYjI2Y2RlYiwgMHgyNzY5NGUyNywgMHhiMmNkN2ZiMiwgMHg3NTlmZWE3NSwgMHgwOTFiMTIwOSwgMHg4MzllMWQ4MywgMHgyYzc0NTgyYywgMHgxYTJlMzQxYSwgMHgxYjJkMzYxYiwgMHg2ZWIyZGM2ZSwgMHg1YWVlYjQ1YSwgMHhhMGZiNWJhMCwgMHg1MmY2YTQ1MiwgMHgzYjRkNzYzYiwgMHhkNjYxYjdkNiwgMHhiM2NlN2RiMywgMHgyOTdiNTIyOSwgMHhlMzNlZGRlMywgMHgyZjcxNWUyZiwgMHg4NDk3MTM4NCwgMHg1M2Y1YTY1MywgMHhkMTY4YjlkMSwgMHgwMDAwMDAwMCwgMHhlZDJjYzFlZCwgMHgyMDYwNDAyMCwgMHhmYzFmZTNmYywgMHhiMWM4NzliMSwgMHg1YmVkYjY1YiwgMHg2YWJlZDQ2YSwgMHhjYjQ2OGRjYiwgMHhiZWQ5NjdiZSwgMHgzOTRiNzIzOSwgMHg0YWRlOTQ0YSwgMHg0Y2Q0OTg0YywgMHg1OGU4YjA1OCwgMHhjZjRhODVjZiwgMHhkMDZiYmJkMCwgMHhlZjJhYzVlZiwgMHhhYWU1NGZhYSwgMHhmYjE2ZWRmYiwgMHg0M2M1ODY0MywgMHg0ZGQ3OWE0ZCwgMHgzMzU1NjYzMywgMHg4NTk0MTE4NSwgMHg0NWNmOGE0NSwgMHhmOTEwZTlmOSwgMHgwMjA2MDQwMiwgMHg3ZjgxZmU3ZiwgMHg1MGYwYTA1MCwgMHgzYzQ0NzgzYywgMHg5ZmJhMjU5ZiwgMHhhOGUzNGJhOCwgMHg1MWYzYTI1MSwgMHhhM2ZlNWRhMywgMHg0MGMwODA0MCwgMHg4ZjhhMDU4ZiwgMHg5MmFkM2Y5MiwgMHg5ZGJjMjE5ZCwgMHgzODQ4NzAzOCwgMHhmNTA0ZjFmNSwgMHhiY2RmNjNiYywgMHhiNmMxNzdiNiwgMHhkYTc1YWZkYSwgMHgyMTYzNDIyMSwgMHgxMDMwMjAxMCwgMHhmZjFhZTVmZiwgMHhmMzBlZmRmMywgMHhkMjZkYmZkMiwgMHhjZDRjODFjZCwgMHgwYzE0MTgwYywgMHgxMzM1MjYxMywgMHhlYzJmYzNlYywgMHg1ZmUxYmU1ZiwgMHg5N2EyMzU5NywgMHg0NGNjODg0NCwgMHgxNzM5MmUxNywgMHhjNDU3OTNjNCwgMHhhN2YyNTVhNywgMHg3ZTgyZmM3ZSwgMHgzZDQ3N2EzZCwgMHg2NGFjYzg2NCwgMHg1ZGU3YmE1ZCwgMHgxOTJiMzIxOSwgMHg3Mzk1ZTY3MywgMHg2MGEwYzA2MCwgMHg4MTk4MTk4MSwgMHg0ZmQxOWU0ZiwgMHhkYzdmYTNkYywgMHgyMjY2NDQyMiwgMHgyYTdlNTQyYSwgMHg5MGFiM2I5MCwgMHg4ODgzMGI4OCwgMHg0NmNhOGM0NiwgMHhlZTI5YzdlZSwgMHhiOGQzNmJiOCwgMHgxNDNjMjgxNCwgMHhkZTc5YTdkZSwgMHg1ZWUyYmM1ZSwgMHgwYjFkMTYwYiwgMHhkYjc2YWRkYiwgMHhlMDNiZGJlMCwgMHgzMjU2NjQzMiwgMHgzYTRlNzQzYSwgMHgwYTFlMTQwYSwgMHg0OWRiOTI0OSwgMHgwNjBhMGMwNiwgMHgyNDZjNDgyNCwgMHg1Y2U0Yjg1YywgMHhjMjVkOWZjMiwgMHhkMzZlYmRkMywgMHhhY2VmNDNhYywgMHg2MmE2YzQ2MiwgMHg5MWE4Mzk5MSwgMHg5NWE0MzE5NSwgMHhlNDM3ZDNlNCwgMHg3OThiZjI3OSwgMHhlNzMyZDVlNywgMHhjODQzOGJjOCwgMHgzNzU5NmUzNywgMHg2ZGI3ZGE2ZCwgMHg4ZDhjMDE4ZCwgMHhkNTY0YjFkNSwgMHg0ZWQyOWM0ZSwgMHhhOWUwNDlhOSwgMHg2Y2I0ZDg2YywgMHg1NmZhYWM1NiwgMHhmNDA3ZjNmNCwgMHhlYTI1Y2ZlYSwgMHg2NWFmY2E2NSwgMHg3YThlZjQ3YSwgMHhhZWU5NDdhZSwgMHgwODE4MTAwOCwgMHhiYWQ1NmZiYSwgMHg3ODg4ZjA3OCwgMHgyNTZmNGEyNSwgMHgyZTcyNWMyZSwgMHgxYzI0MzgxYywgMHhhNmYxNTdhNiwgMHhiNGM3NzNiNCwgMHhjNjUxOTdjNiwgMHhlODIzY2JlOCwgMHhkZDdjYTFkZCwgMHg3NDljZTg3NCwgMHgxZjIxM2UxZiwgMHg0YmRkOTY0YiwgMHhiZGRjNjFiZCwgMHg4Yjg2MGQ4YiwgMHg4YTg1MGY4YSwgMHg3MDkwZTA3MCwgMHgzZTQyN2MzZSwgMHhiNWM0NzFiNSwgMHg2NmFhY2M2NiwgMHg0OGQ4OTA0OCwgMHgwMzA1MDYwMywgMHhmNjAxZjdmNiwgMHgwZTEyMWMwZSwgMHg2MWEzYzI2MSwgMHgzNTVmNmEzNSwgMHg1N2Y5YWU1NywgMHhiOWQwNjliOSwgMHg4NjkxMTc4NiwgMHhjMTU4OTljMSwgMHgxZDI3M2ExZCwgMHg5ZWI5Mjc5ZSwgMHhlMTM4ZDllMSwgMHhmODEzZWJmOCwgMHg5OGIzMmI5OCwgMHgxMTMzMjIxMSwgMHg2OWJiZDI2OSwgMHhkOTcwYTlkOSwgMHg4ZTg5MDc4ZSwgMHg5NGE3MzM5NCwgMHg5YmI2MmQ5YiwgMHgxZTIyM2MxZSwgMHg4NzkyMTU4NywgMHhlOTIwYzllOSwgMHhjZTQ5ODdjZSwgMHg1NWZmYWE1NSwgMHgyODc4NTAyOCwgMHhkZjdhYTVkZiwgMHg4YzhmMDM4YywgMHhhMWY4NTlhMSwgMHg4OTgwMDk4OSwgMHgwZDE3MWEwZCwgMHhiZmRhNjViZiwgMHhlNjMxZDdlNiwgMHg0MmM2ODQ0MiwgMHg2OGI4ZDA2OCwgMHg0MWMzODI0MSwgMHg5OWIwMjk5OSwgMHgyZDc3NWEyZCwgMHgwZjExMWUwZiwgMHhiMGNiN2JiMCwgMHg1NGZjYTg1NCwgMHhiYmQ2NmRiYiwgMHgxNjNhMmMxNl07XG5cdCAgICB2YXIgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG5cblx0ICAgIC8vIFRyYW5zZm9ybWF0aW9ucyBmb3IgZGVjcnlwdGlvblxuXHQgICAgdmFyIFQ1ID0gWzB4NTFmNGE3NTAsIDB4N2U0MTY1NTMsIDB4MWExN2E0YzMsIDB4M2EyNzVlOTYsIDB4M2JhYjZiY2IsIDB4MWY5ZDQ1ZjEsIDB4YWNmYTU4YWIsIDB4NGJlMzAzOTMsIDB4MjAzMGZhNTUsIDB4YWQ3NjZkZjYsIDB4ODhjYzc2OTEsIDB4ZjUwMjRjMjUsIDB4NGZlNWQ3ZmMsIDB4YzUyYWNiZDcsIDB4MjYzNTQ0ODAsIDB4YjU2MmEzOGYsIDB4ZGViMTVhNDksIDB4MjViYTFiNjcsIDB4NDVlYTBlOTgsIDB4NWRmZWMwZTEsIDB4YzMyZjc1MDIsIDB4ODE0Y2YwMTIsIDB4OGQ0Njk3YTMsIDB4NmJkM2Y5YzYsIDB4MDM4ZjVmZTcsIDB4MTU5MjljOTUsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4ZDRiZTgzMmQsIDB4NTg3NDIxZDMsIDB4NDllMDY5MjksIDB4OGVjOWM4NDQsIDB4NzVjMjg5NmEsIDB4ZjQ4ZTc5NzgsIDB4OTk1ODNlNmIsIDB4MjdiOTcxZGQsIDB4YmVlMTRmYjYsIDB4ZjA4OGFkMTcsIDB4YzkyMGFjNjYsIDB4N2RjZTNhYjQsIDB4NjNkZjRhMTgsIDB4ZTUxYTMxODIsIDB4OTc1MTMzNjAsIDB4NjI1MzdmNDUsIDB4YjE2NDc3ZTAsIDB4YmI2YmFlODQsIDB4ZmU4MWEwMWMsIDB4ZjkwODJiOTQsIDB4NzA0ODY4NTgsIDB4OGY0NWZkMTksIDB4OTRkZTZjODcsIDB4NTI3YmY4YjcsIDB4YWI3M2QzMjMsIDB4NzI0YjAyZTIsIDB4ZTMxZjhmNTcsIDB4NjY1NWFiMmEsIDB4YjJlYjI4MDcsIDB4MmZiNWMyMDMsIDB4ODZjNTdiOWEsIDB4ZDMzNzA4YTUsIDB4MzAyODg3ZjIsIDB4MjNiZmE1YjIsIDB4MDIwMzZhYmEsIDB4ZWQxNjgyNWMsIDB4OGFjZjFjMmIsIDB4YTc3OWI0OTIsIDB4ZjMwN2YyZjAsIDB4NGU2OWUyYTEsIDB4NjVkYWY0Y2QsIDB4MDYwNWJlZDUsIDB4ZDEzNDYyMWYsIDB4YzRhNmZlOGEsIDB4MzQyZTUzOWQsIDB4YTJmMzU1YTAsIDB4MDU4YWUxMzIsIDB4YTRmNmViNzUsIDB4MGI4M2VjMzksIDB4NDA2MGVmYWEsIDB4NWU3MTlmMDYsIDB4YmQ2ZTEwNTEsIDB4M2UyMThhZjksIDB4OTZkZDA2M2QsIDB4ZGQzZTA1YWUsIDB4NGRlNmJkNDYsIDB4OTE1NDhkYjUsIDB4NzFjNDVkMDUsIDB4MDQwNmQ0NmYsIDB4NjA1MDE1ZmYsIDB4MTk5OGZiMjQsIDB4ZDZiZGU5OTcsIDB4ODk0MDQzY2MsIDB4NjdkOTllNzcsIDB4YjBlODQyYmQsIDB4MDc4OThiODgsIDB4ZTcxOTViMzgsIDB4NzljOGVlZGIsIDB4YTE3YzBhNDcsIDB4N2M0MjBmZTksIDB4Zjg4NDFlYzksIDB4MDAwMDAwMDAsIDB4MDk4MDg2ODMsIDB4MzIyYmVkNDgsIDB4MWUxMTcwYWMsIDB4NmM1YTcyNGUsIDB4ZmQwZWZmZmIsIDB4MGY4NTM4NTYsIDB4M2RhZWQ1MWUsIDB4MzYyZDM5MjcsIDB4MGEwZmQ5NjQsIDB4Njg1Y2E2MjEsIDB4OWI1YjU0ZDEsIDB4MjQzNjJlM2EsIDB4MGMwYTY3YjEsIDB4OTM1N2U3MGYsIDB4YjRlZTk2ZDIsIDB4MWI5YjkxOWUsIDB4ODBjMGM1NGYsIDB4NjFkYzIwYTIsIDB4NWE3NzRiNjksIDB4MWMxMjFhMTYsIDB4ZTI5M2JhMGEsIDB4YzBhMDJhZTUsIDB4M2MyMmUwNDMsIDB4MTIxYjE3MWQsIDB4MGUwOTBkMGIsIDB4ZjI4YmM3YWQsIDB4MmRiNmE4YjksIDB4MTQxZWE5YzgsIDB4NTdmMTE5ODUsIDB4YWY3NTA3NGMsIDB4ZWU5OWRkYmIsIDB4YTM3ZjYwZmQsIDB4ZjcwMTI2OWYsIDB4NWM3MmY1YmMsIDB4NDQ2NjNiYzUsIDB4NWJmYjdlMzQsIDB4OGI0MzI5NzYsIDB4Y2IyM2M2ZGMsIDB4YjZlZGZjNjgsIDB4YjhlNGYxNjMsIDB4ZDczMWRjY2EsIDB4NDI2Mzg1MTAsIDB4MTM5NzIyNDAsIDB4ODRjNjExMjAsIDB4ODU0YTI0N2QsIDB4ZDJiYjNkZjgsIDB4YWVmOTMyMTEsIDB4YzcyOWExNmQsIDB4MWQ5ZTJmNGIsIDB4ZGNiMjMwZjMsIDB4MGQ4NjUyZWMsIDB4NzdjMWUzZDAsIDB4MmJiMzE2NmMsIDB4YTk3MGI5OTksIDB4MTE5NDQ4ZmEsIDB4NDdlOTY0MjIsIDB4YThmYzhjYzQsIDB4YTBmMDNmMWEsIDB4NTY3ZDJjZDgsIDB4MjIzMzkwZWYsIDB4ODc0OTRlYzcsIDB4ZDkzOGQxYzEsIDB4OGNjYWEyZmUsIDB4OThkNDBiMzYsIDB4YTZmNTgxY2YsIDB4YTU3YWRlMjgsIDB4ZGFiNzhlMjYsIDB4M2ZhZGJmYTQsIDB4MmMzYTlkZTQsIDB4NTA3ODkyMGQsIDB4NmE1ZmNjOWIsIDB4NTQ3ZTQ2NjIsIDB4ZjY4ZDEzYzIsIDB4OTBkOGI4ZTgsIDB4MmUzOWY3NWUsIDB4ODJjM2FmZjUsIDB4OWY1ZDgwYmUsIDB4NjlkMDkzN2MsIDB4NmZkNTJkYTksIDB4Y2YyNTEyYjMsIDB4YzhhYzk5M2IsIDB4MTAxODdkYTcsIDB4ZTg5YzYzNmUsIDB4ZGIzYmJiN2IsIDB4Y2QyNjc4MDksIDB4NmU1OTE4ZjQsIDB4ZWM5YWI3MDEsIDB4ODM0ZjlhYTgsIDB4ZTY5NTZlNjUsIDB4YWFmZmU2N2UsIDB4MjFiY2NmMDgsIDB4ZWYxNWU4ZTYsIDB4YmFlNzliZDksIDB4NGE2ZjM2Y2UsIDB4ZWE5ZjA5ZDQsIDB4MjliMDdjZDYsIDB4MzFhNGIyYWYsIDB4MmEzZjIzMzEsIDB4YzZhNTk0MzAsIDB4MzVhMjY2YzAsIDB4NzQ0ZWJjMzcsIDB4ZmM4MmNhYTYsIDB4ZTA5MGQwYjAsIDB4MzNhN2Q4MTUsIDB4ZjEwNDk4NGEsIDB4NDFlY2RhZjcsIDB4N2ZjZDUwMGUsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4NDNlZmIwNGQsIDB4Y2NhYTRkNTQsIDB4ZTQ5NjA0ZGYsIDB4OWVkMWI1ZTMsIDB4NGM2YTg4MWIsIDB4YzEyYzFmYjgsIDB4NDY2NTUxN2YsIDB4OWQ1ZWVhMDQsIDB4MDE4YzM1NWQsIDB4ZmE4Nzc0NzMsIDB4ZmIwYjQxMmUsIDB4YjM2NzFkNWEsIDB4OTJkYmQyNTIsIDB4ZTkxMDU2MzMsIDB4NmRkNjQ3MTMsIDB4OWFkNzYxOGMsIDB4MzdhMTBjN2EsIDB4NTlmODE0OGUsIDB4ZWIxMzNjODksIDB4Y2VhOTI3ZWUsIDB4Yjc2MWM5MzUsIDB4ZTExY2U1ZWQsIDB4N2E0N2IxM2MsIDB4OWNkMmRmNTksIDB4NTVmMjczM2YsIDB4MTgxNGNlNzksIDB4NzNjNzM3YmYsIDB4NTNmN2NkZWEsIDB4NWZmZGFhNWIsIDB4ZGYzZDZmMTQsIDB4Nzg0NGRiODYsIDB4Y2FhZmYzODEsIDB4Yjk2OGM0M2UsIDB4MzgyNDM0MmMsIDB4YzJhMzQwNWYsIDB4MTYxZGMzNzIsIDB4YmNlMjI1MGMsIDB4MjgzYzQ5OGIsIDB4ZmYwZDk1NDEsIDB4MzlhODAxNzEsIDB4MDgwY2IzZGUsIDB4ZDhiNGU0OWMsIDB4NjQ1NmMxOTAsIDB4N2JjYjg0NjEsIDB4ZDUzMmI2NzAsIDB4NDg2YzVjNzQsIDB4ZDBiODU3NDJdO1xuXHQgICAgdmFyIFQ2ID0gWzB4NTA1MWY0YTcsIDB4NTM3ZTQxNjUsIDB4YzMxYTE3YTQsIDB4OTYzYTI3NWUsIDB4Y2IzYmFiNmIsIDB4ZjExZjlkNDUsIDB4YWJhY2ZhNTgsIDB4OTM0YmUzMDMsIDB4NTUyMDMwZmEsIDB4ZjZhZDc2NmQsIDB4OTE4OGNjNzYsIDB4MjVmNTAyNGMsIDB4ZmM0ZmU1ZDcsIDB4ZDdjNTJhY2IsIDB4ODAyNjM1NDQsIDB4OGZiNTYyYTMsIDB4NDlkZWIxNWEsIDB4NjcyNWJhMWIsIDB4OTg0NWVhMGUsIDB4ZTE1ZGZlYzAsIDB4MDJjMzJmNzUsIDB4MTI4MTRjZjAsIDB4YTM4ZDQ2OTcsIDB4YzY2YmQzZjksIDB4ZTcwMzhmNWYsIDB4OTUxNTkyOWMsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4MmRkNGJlODMsIDB4ZDM1ODc0MjEsIDB4Mjk0OWUwNjksIDB4NDQ4ZWM5YzgsIDB4NmE3NWMyODksIDB4NzhmNDhlNzksIDB4NmI5OTU4M2UsIDB4ZGQyN2I5NzEsIDB4YjZiZWUxNGYsIDB4MTdmMDg4YWQsIDB4NjZjOTIwYWMsIDB4YjQ3ZGNlM2EsIDB4MTg2M2RmNGEsIDB4ODJlNTFhMzEsIDB4NjA5NzUxMzMsIDB4NDU2MjUzN2YsIDB4ZTBiMTY0NzcsIDB4ODRiYjZiYWUsIDB4MWNmZTgxYTAsIDB4OTRmOTA4MmIsIDB4NTg3MDQ4NjgsIDB4MTk4ZjQ1ZmQsIDB4ODc5NGRlNmMsIDB4Yjc1MjdiZjgsIDB4MjNhYjczZDMsIDB4ZTI3MjRiMDIsIDB4NTdlMzFmOGYsIDB4MmE2NjU1YWIsIDB4MDdiMmViMjgsIDB4MDMyZmI1YzIsIDB4OWE4NmM1N2IsIDB4YTVkMzM3MDgsIDB4ZjIzMDI4ODcsIDB4YjIyM2JmYTUsIDB4YmEwMjAzNmEsIDB4NWNlZDE2ODIsIDB4MmI4YWNmMWMsIDB4OTJhNzc5YjQsIDB4ZjBmMzA3ZjIsIDB4YTE0ZTY5ZTIsIDB4Y2Q2NWRhZjQsIDB4ZDUwNjA1YmUsIDB4MWZkMTM0NjIsIDB4OGFjNGE2ZmUsIDB4OWQzNDJlNTMsIDB4YTBhMmYzNTUsIDB4MzIwNThhZTEsIDB4NzVhNGY2ZWIsIDB4MzkwYjgzZWMsIDB4YWE0MDYwZWYsIDB4MDY1ZTcxOWYsIDB4NTFiZDZlMTAsIDB4ZjkzZTIxOGEsIDB4M2Q5NmRkMDYsIDB4YWVkZDNlMDUsIDB4NDY0ZGU2YmQsIDB4YjU5MTU0OGQsIDB4MDU3MWM0NWQsIDB4NmYwNDA2ZDQsIDB4ZmY2MDUwMTUsIDB4MjQxOTk4ZmIsIDB4OTdkNmJkZTksIDB4Y2M4OTQwNDMsIDB4Nzc2N2Q5OWUsIDB4YmRiMGU4NDIsIDB4ODgwNzg5OGIsIDB4MzhlNzE5NWIsIDB4ZGI3OWM4ZWUsIDB4NDdhMTdjMGEsIDB4ZTk3YzQyMGYsIDB4YzlmODg0MWUsIDB4MDAwMDAwMDAsIDB4ODMwOTgwODYsIDB4NDgzMjJiZWQsIDB4YWMxZTExNzAsIDB4NGU2YzVhNzIsIDB4ZmJmZDBlZmYsIDB4NTYwZjg1MzgsIDB4MWUzZGFlZDUsIDB4MjczNjJkMzksIDB4NjQwYTBmZDksIDB4MjE2ODVjYTYsIDB4ZDE5YjViNTQsIDB4M2EyNDM2MmUsIDB4YjEwYzBhNjcsIDB4MGY5MzU3ZTcsIDB4ZDJiNGVlOTYsIDB4OWUxYjliOTEsIDB4NGY4MGMwYzUsIDB4YTI2MWRjMjAsIDB4Njk1YTc3NGIsIDB4MTYxYzEyMWEsIDB4MGFlMjkzYmEsIDB4ZTVjMGEwMmEsIDB4NDMzYzIyZTAsIDB4MWQxMjFiMTcsIDB4MGIwZTA5MGQsIDB4YWRmMjhiYzcsIDB4YjkyZGI2YTgsIDB4YzgxNDFlYTksIDB4ODU1N2YxMTksIDB4NGNhZjc1MDcsIDB4YmJlZTk5ZGQsIDB4ZmRhMzdmNjAsIDB4OWZmNzAxMjYsIDB4YmM1YzcyZjUsIDB4YzU0NDY2M2IsIDB4MzQ1YmZiN2UsIDB4NzY4YjQzMjksIDB4ZGNjYjIzYzYsIDB4NjhiNmVkZmMsIDB4NjNiOGU0ZjEsIDB4Y2FkNzMxZGMsIDB4MTA0MjYzODUsIDB4NDAxMzk3MjIsIDB4MjA4NGM2MTEsIDB4N2Q4NTRhMjQsIDB4ZjhkMmJiM2QsIDB4MTFhZWY5MzIsIDB4NmRjNzI5YTEsIDB4NGIxZDllMmYsIDB4ZjNkY2IyMzAsIDB4ZWMwZDg2NTIsIDB4ZDA3N2MxZTMsIDB4NmMyYmIzMTYsIDB4OTlhOTcwYjksIDB4ZmExMTk0NDgsIDB4MjI0N2U5NjQsIDB4YzRhOGZjOGMsIDB4MWFhMGYwM2YsIDB4ZDg1NjdkMmMsIDB4ZWYyMjMzOTAsIDB4Yzc4NzQ5NGUsIDB4YzFkOTM4ZDEsIDB4ZmU4Y2NhYTIsIDB4MzY5OGQ0MGIsIDB4Y2ZhNmY1ODEsIDB4MjhhNTdhZGUsIDB4MjZkYWI3OGUsIDB4YTQzZmFkYmYsIDB4ZTQyYzNhOWQsIDB4MGQ1MDc4OTIsIDB4OWI2YTVmY2MsIDB4NjI1NDdlNDYsIDB4YzJmNjhkMTMsIDB4ZTg5MGQ4YjgsIDB4NWUyZTM5ZjcsIDB4ZjU4MmMzYWYsIDB4YmU5ZjVkODAsIDB4N2M2OWQwOTMsIDB4YTk2ZmQ1MmQsIDB4YjNjZjI1MTIsIDB4M2JjOGFjOTksIDB4YTcxMDE4N2QsIDB4NmVlODljNjMsIDB4N2JkYjNiYmIsIDB4MDljZDI2NzgsIDB4ZjQ2ZTU5MTgsIDB4MDFlYzlhYjcsIDB4YTg4MzRmOWEsIDB4NjVlNjk1NmUsIDB4N2VhYWZmZTYsIDB4MDgyMWJjY2YsIDB4ZTZlZjE1ZTgsIDB4ZDliYWU3OWIsIDB4Y2U0YTZmMzYsIDB4ZDRlYTlmMDksIDB4ZDYyOWIwN2MsIDB4YWYzMWE0YjIsIDB4MzEyYTNmMjMsIDB4MzBjNmE1OTQsIDB4YzAzNWEyNjYsIDB4Mzc3NDRlYmMsIDB4YTZmYzgyY2EsIDB4YjBlMDkwZDAsIDB4MTUzM2E3ZDgsIDB4NGFmMTA0OTgsIDB4Zjc0MWVjZGEsIDB4MGU3ZmNkNTAsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4NGQ0M2VmYjAsIDB4NTRjY2FhNGQsIDB4ZGZlNDk2MDQsIDB4ZTM5ZWQxYjUsIDB4MWI0YzZhODgsIDB4YjhjMTJjMWYsIDB4N2Y0NjY1NTEsIDB4MDQ5ZDVlZWEsIDB4NWQwMThjMzUsIDB4NzNmYTg3NzQsIDB4MmVmYjBiNDEsIDB4NWFiMzY3MWQsIDB4NTI5MmRiZDIsIDB4MzNlOTEwNTYsIDB4MTM2ZGQ2NDcsIDB4OGM5YWQ3NjEsIDB4N2EzN2ExMGMsIDB4OGU1OWY4MTQsIDB4ODllYjEzM2MsIDB4ZWVjZWE5MjcsIDB4MzViNzYxYzksIDB4ZWRlMTFjZTUsIDB4M2M3YTQ3YjEsIDB4NTk5Y2QyZGYsIDB4M2Y1NWYyNzMsIDB4NzkxODE0Y2UsIDB4YmY3M2M3MzcsIDB4ZWE1M2Y3Y2QsIDB4NWI1ZmZkYWEsIDB4MTRkZjNkNmYsIDB4ODY3ODQ0ZGIsIDB4ODFjYWFmZjMsIDB4M2ViOTY4YzQsIDB4MmMzODI0MzQsIDB4NWZjMmEzNDAsIDB4NzIxNjFkYzMsIDB4MGNiY2UyMjUsIDB4OGIyODNjNDksIDB4NDFmZjBkOTUsIDB4NzEzOWE4MDEsIDB4ZGUwODBjYjMsIDB4OWNkOGI0ZTQsIDB4OTA2NDU2YzEsIDB4NjE3YmNiODQsIDB4NzBkNTMyYjYsIDB4NzQ0ODZjNWMsIDB4NDJkMGI4NTddO1xuXHQgICAgdmFyIFQ3ID0gWzB4YTc1MDUxZjQsIDB4NjU1MzdlNDEsIDB4YTRjMzFhMTcsIDB4NWU5NjNhMjcsIDB4NmJjYjNiYWIsIDB4NDVmMTFmOWQsIDB4NThhYmFjZmEsIDB4MDM5MzRiZTMsIDB4ZmE1NTIwMzAsIDB4NmRmNmFkNzYsIDB4NzY5MTg4Y2MsIDB4NGMyNWY1MDIsIDB4ZDdmYzRmZTUsIDB4Y2JkN2M1MmEsIDB4NDQ4MDI2MzUsIDB4YTM4ZmI1NjIsIDB4NWE0OWRlYjEsIDB4MWI2NzI1YmEsIDB4MGU5ODQ1ZWEsIDB4YzBlMTVkZmUsIDB4NzUwMmMzMmYsIDB4ZjAxMjgxNGMsIDB4OTdhMzhkNDYsIDB4ZjljNjZiZDMsIDB4NWZlNzAzOGYsIDB4OWM5NTE1OTIsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4ODMyZGQ0YmUsIDB4MjFkMzU4NzQsIDB4NjkyOTQ5ZTAsIDB4Yzg0NDhlYzksIDB4ODk2YTc1YzIsIDB4Nzk3OGY0OGUsIDB4M2U2Yjk5NTgsIDB4NzFkZDI3YjksIDB4NGZiNmJlZTEsIDB4YWQxN2YwODgsIDB4YWM2NmM5MjAsIDB4M2FiNDdkY2UsIDB4NGExODYzZGYsIDB4MzE4MmU1MWEsIDB4MzM2MDk3NTEsIDB4N2Y0NTYyNTMsIDB4NzdlMGIxNjQsIDB4YWU4NGJiNmIsIDB4YTAxY2ZlODEsIDB4MmI5NGY5MDgsIDB4Njg1ODcwNDgsIDB4ZmQxOThmNDUsIDB4NmM4Nzk0ZGUsIDB4ZjhiNzUyN2IsIDB4ZDMyM2FiNzMsIDB4MDJlMjcyNGIsIDB4OGY1N2UzMWYsIDB4YWIyYTY2NTUsIDB4MjgwN2IyZWIsIDB4YzIwMzJmYjUsIDB4N2I5YTg2YzUsIDB4MDhhNWQzMzcsIDB4ODdmMjMwMjgsIDB4YTViMjIzYmYsIDB4NmFiYTAyMDMsIDB4ODI1Y2VkMTYsIDB4MWMyYjhhY2YsIDB4YjQ5MmE3NzksIDB4ZjJmMGYzMDcsIDB4ZTJhMTRlNjksIDB4ZjRjZDY1ZGEsIDB4YmVkNTA2MDUsIDB4NjIxZmQxMzQsIDB4ZmU4YWM0YTYsIDB4NTM5ZDM0MmUsIDB4NTVhMGEyZjMsIDB4ZTEzMjA1OGEsIDB4ZWI3NWE0ZjYsIDB4ZWMzOTBiODMsIDB4ZWZhYTQwNjAsIDB4OWYwNjVlNzEsIDB4MTA1MWJkNmUsIDB4OGFmOTNlMjEsIDB4MDYzZDk2ZGQsIDB4MDVhZWRkM2UsIDB4YmQ0NjRkZTYsIDB4OGRiNTkxNTQsIDB4NWQwNTcxYzQsIDB4ZDQ2ZjA0MDYsIDB4MTVmZjYwNTAsIDB4ZmIyNDE5OTgsIDB4ZTk5N2Q2YmQsIDB4NDNjYzg5NDAsIDB4OWU3NzY3ZDksIDB4NDJiZGIwZTgsIDB4OGI4ODA3ODksIDB4NWIzOGU3MTksIDB4ZWVkYjc5YzgsIDB4MGE0N2ExN2MsIDB4MGZlOTdjNDIsIDB4MWVjOWY4ODQsIDB4MDAwMDAwMDAsIDB4ODY4MzA5ODAsIDB4ZWQ0ODMyMmIsIDB4NzBhYzFlMTEsIDB4NzI0ZTZjNWEsIDB4ZmZmYmZkMGUsIDB4Mzg1NjBmODUsIDB4ZDUxZTNkYWUsIDB4MzkyNzM2MmQsIDB4ZDk2NDBhMGYsIDB4YTYyMTY4NWMsIDB4NTRkMTliNWIsIDB4MmUzYTI0MzYsIDB4NjdiMTBjMGEsIDB4ZTcwZjkzNTcsIDB4OTZkMmI0ZWUsIDB4OTE5ZTFiOWIsIDB4YzU0ZjgwYzAsIDB4MjBhMjYxZGMsIDB4NGI2OTVhNzcsIDB4MWExNjFjMTIsIDB4YmEwYWUyOTMsIDB4MmFlNWMwYTAsIDB4ZTA0MzNjMjIsIDB4MTcxZDEyMWIsIDB4MGQwYjBlMDksIDB4YzdhZGYyOGIsIDB4YThiOTJkYjYsIDB4YTljODE0MWUsIDB4MTk4NTU3ZjEsIDB4MDc0Y2FmNzUsIDB4ZGRiYmVlOTksIDB4NjBmZGEzN2YsIDB4MjY5ZmY3MDEsIDB4ZjViYzVjNzIsIDB4M2JjNTQ0NjYsIDB4N2UzNDViZmIsIDB4Mjk3NjhiNDMsIDB4YzZkY2NiMjMsIDB4ZmM2OGI2ZWQsIDB4ZjE2M2I4ZTQsIDB4ZGNjYWQ3MzEsIDB4ODUxMDQyNjMsIDB4MjI0MDEzOTcsIDB4MTEyMDg0YzYsIDB4MjQ3ZDg1NGEsIDB4M2RmOGQyYmIsIDB4MzIxMWFlZjksIDB4YTE2ZGM3MjksIDB4MmY0YjFkOWUsIDB4MzBmM2RjYjIsIDB4NTJlYzBkODYsIDB4ZTNkMDc3YzEsIDB4MTY2YzJiYjMsIDB4Yjk5OWE5NzAsIDB4NDhmYTExOTQsIDB4NjQyMjQ3ZTksIDB4OGNjNGE4ZmMsIDB4M2YxYWEwZjAsIDB4MmNkODU2N2QsIDB4OTBlZjIyMzMsIDB4NGVjNzg3NDksIDB4ZDFjMWQ5MzgsIDB4YTJmZThjY2EsIDB4MGIzNjk4ZDQsIDB4ODFjZmE2ZjUsIDB4ZGUyOGE1N2EsIDB4OGUyNmRhYjcsIDB4YmZhNDNmYWQsIDB4OWRlNDJjM2EsIDB4OTIwZDUwNzgsIDB4Y2M5YjZhNWYsIDB4NDY2MjU0N2UsIDB4MTNjMmY2OGQsIDB4YjhlODkwZDgsIDB4Zjc1ZTJlMzksIDB4YWZmNTgyYzMsIDB4ODBiZTlmNWQsIDB4OTM3YzY5ZDAsIDB4MmRhOTZmZDUsIDB4MTJiM2NmMjUsIDB4OTkzYmM4YWMsIDB4N2RhNzEwMTgsIDB4NjM2ZWU4OWMsIDB4YmI3YmRiM2IsIDB4NzgwOWNkMjYsIDB4MThmNDZlNTksIDB4YjcwMWVjOWEsIDB4OWFhODgzNGYsIDB4NmU2NWU2OTUsIDB4ZTY3ZWFhZmYsIDB4Y2YwODIxYmMsIDB4ZThlNmVmMTUsIDB4OWJkOWJhZTcsIDB4MzZjZTRhNmYsIDB4MDlkNGVhOWYsIDB4N2NkNjI5YjAsIDB4YjJhZjMxYTQsIDB4MjMzMTJhM2YsIDB4OTQzMGM2YTUsIDB4NjZjMDM1YTIsIDB4YmMzNzc0NGUsIDB4Y2FhNmZjODIsIDB4ZDBiMGUwOTAsIDB4ZDgxNTMzYTcsIDB4OTg0YWYxMDQsIDB4ZGFmNzQxZWMsIDB4NTAwZTdmY2QsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4YjA0ZDQzZWYsIDB4NGQ1NGNjYWEsIDB4MDRkZmU0OTYsIDB4YjVlMzllZDEsIDB4ODgxYjRjNmEsIDB4MWZiOGMxMmMsIDB4NTE3ZjQ2NjUsIDB4ZWEwNDlkNWUsIDB4MzU1ZDAxOGMsIDB4NzQ3M2ZhODcsIDB4NDEyZWZiMGIsIDB4MWQ1YWIzNjcsIDB4ZDI1MjkyZGIsIDB4NTYzM2U5MTAsIDB4NDcxMzZkZDYsIDB4NjE4YzlhZDcsIDB4MGM3YTM3YTEsIDB4MTQ4ZTU5ZjgsIDB4M2M4OWViMTMsIDB4MjdlZWNlYTksIDB4YzkzNWI3NjEsIDB4ZTVlZGUxMWMsIDB4YjEzYzdhNDcsIDB4ZGY1OTljZDIsIDB4NzMzZjU1ZjIsIDB4Y2U3OTE4MTQsIDB4MzdiZjczYzcsIDB4Y2RlYTUzZjcsIDB4YWE1YjVmZmQsIDB4NmYxNGRmM2QsIDB4ZGI4Njc4NDQsIDB4ZjM4MWNhYWYsIDB4YzQzZWI5NjgsIDB4MzQyYzM4MjQsIDB4NDA1ZmMyYTMsIDB4YzM3MjE2MWQsIDB4MjUwY2JjZTIsIDB4NDk4YjI4M2MsIDB4OTU0MWZmMGQsIDB4MDE3MTM5YTgsIDB4YjNkZTA4MGMsIDB4ZTQ5Y2Q4YjQsIDB4YzE5MDY0NTYsIDB4ODQ2MTdiY2IsIDB4YjY3MGQ1MzIsIDB4NWM3NDQ4NmMsIDB4NTc0MmQwYjhdO1xuXHQgICAgdmFyIFQ4ID0gWzB4ZjRhNzUwNTEsIDB4NDE2NTUzN2UsIDB4MTdhNGMzMWEsIDB4Mjc1ZTk2M2EsIDB4YWI2YmNiM2IsIDB4OWQ0NWYxMWYsIDB4ZmE1OGFiYWMsIDB4ZTMwMzkzNGIsIDB4MzBmYTU1MjAsIDB4NzY2ZGY2YWQsIDB4Y2M3NjkxODgsIDB4MDI0YzI1ZjUsIDB4ZTVkN2ZjNGYsIDB4MmFjYmQ3YzUsIDB4MzU0NDgwMjYsIDB4NjJhMzhmYjUsIDB4YjE1YTQ5ZGUsIDB4YmExYjY3MjUsIDB4ZWEwZTk4NDUsIDB4ZmVjMGUxNWQsIDB4MmY3NTAyYzMsIDB4NGNmMDEyODEsIDB4NDY5N2EzOGQsIDB4ZDNmOWM2NmIsIDB4OGY1ZmU3MDMsIDB4OTI5Yzk1MTUsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4YmU4MzJkZDQsIDB4NzQyMWQzNTgsIDB4ZTA2OTI5NDksIDB4YzljODQ0OGUsIDB4YzI4OTZhNzUsIDB4OGU3OTc4ZjQsIDB4NTgzZTZiOTksIDB4Yjk3MWRkMjcsIDB4ZTE0ZmI2YmUsIDB4ODhhZDE3ZjAsIDB4MjBhYzY2YzksIDB4Y2UzYWI0N2QsIDB4ZGY0YTE4NjMsIDB4MWEzMTgyZTUsIDB4NTEzMzYwOTcsIDB4NTM3ZjQ1NjIsIDB4NjQ3N2UwYjEsIDB4NmJhZTg0YmIsIDB4ODFhMDFjZmUsIDB4MDgyYjk0ZjksIDB4NDg2ODU4NzAsIDB4NDVmZDE5OGYsIDB4ZGU2Yzg3OTQsIDB4N2JmOGI3NTIsIDB4NzNkMzIzYWIsIDB4NGIwMmUyNzIsIDB4MWY4ZjU3ZTMsIDB4NTVhYjJhNjYsIDB4ZWIyODA3YjIsIDB4YjVjMjAzMmYsIDB4YzU3YjlhODYsIDB4MzcwOGE1ZDMsIDB4Mjg4N2YyMzAsIDB4YmZhNWIyMjMsIDB4MDM2YWJhMDIsIDB4MTY4MjVjZWQsIDB4Y2YxYzJiOGEsIDB4NzliNDkyYTcsIDB4MDdmMmYwZjMsIDB4NjllMmExNGUsIDB4ZGFmNGNkNjUsIDB4MDViZWQ1MDYsIDB4MzQ2MjFmZDEsIDB4YTZmZThhYzQsIDB4MmU1MzlkMzQsIDB4ZjM1NWEwYTIsIDB4OGFlMTMyMDUsIDB4ZjZlYjc1YTQsIDB4ODNlYzM5MGIsIDB4NjBlZmFhNDAsIDB4NzE5ZjA2NWUsIDB4NmUxMDUxYmQsIDB4MjE4YWY5M2UsIDB4ZGQwNjNkOTYsIDB4M2UwNWFlZGQsIDB4ZTZiZDQ2NGQsIDB4NTQ4ZGI1OTEsIDB4YzQ1ZDA1NzEsIDB4MDZkNDZmMDQsIDB4NTAxNWZmNjAsIDB4OThmYjI0MTksIDB4YmRlOTk3ZDYsIDB4NDA0M2NjODksIDB4ZDk5ZTc3NjcsIDB4ZTg0MmJkYjAsIDB4ODk4Yjg4MDcsIDB4MTk1YjM4ZTcsIDB4YzhlZWRiNzksIDB4N2MwYTQ3YTEsIDB4NDIwZmU5N2MsIDB4ODQxZWM5ZjgsIDB4MDAwMDAwMDAsIDB4ODA4NjgzMDksIDB4MmJlZDQ4MzIsIDB4MTE3MGFjMWUsIDB4NWE3MjRlNmMsIDB4MGVmZmZiZmQsIDB4ODUzODU2MGYsIDB4YWVkNTFlM2QsIDB4MmQzOTI3MzYsIDB4MGZkOTY0MGEsIDB4NWNhNjIxNjgsIDB4NWI1NGQxOWIsIDB4MzYyZTNhMjQsIDB4MGE2N2IxMGMsIDB4NTdlNzBmOTMsIDB4ZWU5NmQyYjQsIDB4OWI5MTllMWIsIDB4YzBjNTRmODAsIDB4ZGMyMGEyNjEsIDB4Nzc0YjY5NWEsIDB4MTIxYTE2MWMsIDB4OTNiYTBhZTIsIDB4YTAyYWU1YzAsIDB4MjJlMDQzM2MsIDB4MWIxNzFkMTIsIDB4MDkwZDBiMGUsIDB4OGJjN2FkZjIsIDB4YjZhOGI5MmQsIDB4MWVhOWM4MTQsIDB4ZjExOTg1NTcsIDB4NzUwNzRjYWYsIDB4OTlkZGJiZWUsIDB4N2Y2MGZkYTMsIDB4MDEyNjlmZjcsIDB4NzJmNWJjNWMsIDB4NjYzYmM1NDQsIDB4ZmI3ZTM0NWIsIDB4NDMyOTc2OGIsIDB4MjNjNmRjY2IsIDB4ZWRmYzY4YjYsIDB4ZTRmMTYzYjgsIDB4MzFkY2NhZDcsIDB4NjM4NTEwNDIsIDB4OTcyMjQwMTMsIDB4YzYxMTIwODQsIDB4NGEyNDdkODUsIDB4YmIzZGY4ZDIsIDB4ZjkzMjExYWUsIDB4MjlhMTZkYzcsIDB4OWUyZjRiMWQsIDB4YjIzMGYzZGMsIDB4ODY1MmVjMGQsIDB4YzFlM2QwNzcsIDB4YjMxNjZjMmIsIDB4NzBiOTk5YTksIDB4OTQ0OGZhMTEsIDB4ZTk2NDIyNDcsIDB4ZmM4Y2M0YTgsIDB4ZjAzZjFhYTAsIDB4N2QyY2Q4NTYsIDB4MzM5MGVmMjIsIDB4NDk0ZWM3ODcsIDB4MzhkMWMxZDksIDB4Y2FhMmZlOGMsIDB4ZDQwYjM2OTgsIDB4ZjU4MWNmYTYsIDB4N2FkZTI4YTUsIDB4Yjc4ZTI2ZGEsIDB4YWRiZmE0M2YsIDB4M2E5ZGU0MmMsIDB4Nzg5MjBkNTAsIDB4NWZjYzliNmEsIDB4N2U0NjYyNTQsIDB4OGQxM2MyZjYsIDB4ZDhiOGU4OTAsIDB4MzlmNzVlMmUsIDB4YzNhZmY1ODIsIDB4NWQ4MGJlOWYsIDB4ZDA5MzdjNjksIDB4ZDUyZGE5NmYsIDB4MjUxMmIzY2YsIDB4YWM5OTNiYzgsIDB4MTg3ZGE3MTAsIDB4OWM2MzZlZTgsIDB4M2JiYjdiZGIsIDB4MjY3ODA5Y2QsIDB4NTkxOGY0NmUsIDB4OWFiNzAxZWMsIDB4NGY5YWE4ODMsIDB4OTU2ZTY1ZTYsIDB4ZmZlNjdlYWEsIDB4YmNjZjA4MjEsIDB4MTVlOGU2ZWYsIDB4ZTc5YmQ5YmEsIDB4NmYzNmNlNGEsIDB4OWYwOWQ0ZWEsIDB4YjA3Y2Q2MjksIDB4YTRiMmFmMzEsIDB4M2YyMzMxMmEsIDB4YTU5NDMwYzYsIDB4YTI2NmMwMzUsIDB4NGViYzM3NzQsIDB4ODJjYWE2ZmMsIDB4OTBkMGIwZTAsIDB4YTdkODE1MzMsIDB4MDQ5ODRhZjEsIDB4ZWNkYWY3NDEsIDB4Y2Q1MDBlN2YsIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4ZWZiMDRkNDMsIDB4YWE0ZDU0Y2MsIDB4OTYwNGRmZTQsIDB4ZDFiNWUzOWUsIDB4NmE4ODFiNGMsIDB4MmMxZmI4YzEsIDB4NjU1MTdmNDYsIDB4NWVlYTA0OWQsIDB4OGMzNTVkMDEsIDB4ODc3NDczZmEsIDB4MGI0MTJlZmIsIDB4NjcxZDVhYjMsIDB4ZGJkMjUyOTIsIDB4MTA1NjMzZTksIDB4ZDY0NzEzNmQsIDB4ZDc2MThjOWEsIDB4YTEwYzdhMzcsIDB4ZjgxNDhlNTksIDB4MTMzYzg5ZWIsIDB4YTkyN2VlY2UsIDB4NjFjOTM1YjcsIDB4MWNlNWVkZTEsIDB4NDdiMTNjN2EsIDB4ZDJkZjU5OWMsIDB4ZjI3MzNmNTUsIDB4MTRjZTc5MTgsIDB4YzczN2JmNzMsIDB4ZjdjZGVhNTMsIDB4ZmRhYTViNWYsIDB4M2Q2ZjE0ZGYsIDB4NDRkYjg2NzgsIDB4YWZmMzgxY2EsIDB4NjhjNDNlYjksIDB4MjQzNDJjMzgsIDB4YTM0MDVmYzIsIDB4MWRjMzcyMTYsIDB4ZTIyNTBjYmMsIDB4M2M0OThiMjgsIDB4MGQ5NTQxZmYsIDB4YTgwMTcxMzksIDB4MGNiM2RlMDgsIDB4YjRlNDljZDgsIDB4NTZjMTkwNjQsIDB4Y2I4NDYxN2IsIDB4MzJiNjcwZDUsIDB4NmM1Yzc0NDgsIDB4Yjg1NzQyZDBdO1xuXG5cdCAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuXHQgICAgdmFyIFUxID0gWzB4MDAwMDAwMDAsIDB4MGUwOTBkMGIsIDB4MWMxMjFhMTYsIDB4MTIxYjE3MWQsIDB4MzgyNDM0MmMsIDB4MzYyZDM5MjcsIDB4MjQzNjJlM2EsIDB4MmEzZjIzMzEsIDB4NzA0ODY4NTgsIDB4N2U0MTY1NTMsIDB4NmM1YTcyNGUsIDB4NjI1MzdmNDUsIDB4NDg2YzVjNzQsIDB4NDY2NTUxN2YsIDB4NTQ3ZTQ2NjIsIDB4NWE3NzRiNjksIDB4ZTA5MGQwYjAsIDB4ZWU5OWRkYmIsIDB4ZmM4MmNhYTYsIDB4ZjI4YmM3YWQsIDB4ZDhiNGU0OWMsIDB4ZDZiZGU5OTcsIDB4YzRhNmZlOGEsIDB4Y2FhZmYzODEsIDB4OTBkOGI4ZTgsIDB4OWVkMWI1ZTMsIDB4OGNjYWEyZmUsIDB4ODJjM2FmZjUsIDB4YThmYzhjYzQsIDB4YTZmNTgxY2YsIDB4YjRlZTk2ZDIsIDB4YmFlNzliZDksIDB4ZGIzYmJiN2IsIDB4ZDUzMmI2NzAsIDB4YzcyOWExNmQsIDB4YzkyMGFjNjYsIDB4ZTMxZjhmNTcsIDB4ZWQxNjgyNWMsIDB4ZmYwZDk1NDEsIDB4ZjEwNDk4NGEsIDB4YWI3M2QzMjMsIDB4YTU3YWRlMjgsIDB4Yjc2MWM5MzUsIDB4Yjk2OGM0M2UsIDB4OTM1N2U3MGYsIDB4OWQ1ZWVhMDQsIDB4OGY0NWZkMTksIDB4ODE0Y2YwMTIsIDB4M2JhYjZiY2IsIDB4MzVhMjY2YzAsIDB4MjdiOTcxZGQsIDB4MjliMDdjZDYsIDB4MDM4ZjVmZTcsIDB4MGQ4NjUyZWMsIDB4MWY5ZDQ1ZjEsIDB4MTE5NDQ4ZmEsIDB4NGJlMzAzOTMsIDB4NDVlYTBlOTgsIDB4NTdmMTE5ODUsIDB4NTlmODE0OGUsIDB4NzNjNzM3YmYsIDB4N2RjZTNhYjQsIDB4NmZkNTJkYTksIDB4NjFkYzIwYTIsIDB4YWQ3NjZkZjYsIDB4YTM3ZjYwZmQsIDB4YjE2NDc3ZTAsIDB4YmY2ZDdhZWIsIDB4OTU1MjU5ZGEsIDB4OWI1YjU0ZDEsIDB4ODk0MDQzY2MsIDB4ODc0OTRlYzcsIDB4ZGQzZTA1YWUsIDB4ZDMzNzA4YTUsIDB4YzEyYzFmYjgsIDB4Y2YyNTEyYjMsIDB4ZTUxYTMxODIsIDB4ZWIxMzNjODksIDB4ZjkwODJiOTQsIDB4ZjcwMTI2OWYsIDB4NGRlNmJkNDYsIDB4NDNlZmIwNGQsIDB4NTFmNGE3NTAsIDB4NWZmZGFhNWIsIDB4NzVjMjg5NmEsIDB4N2JjYjg0NjEsIDB4NjlkMDkzN2MsIDB4NjdkOTllNzcsIDB4M2RhZWQ1MWUsIDB4MzNhN2Q4MTUsIDB4MjFiY2NmMDgsIDB4MmZiNWMyMDMsIDB4MDU4YWUxMzIsIDB4MGI4M2VjMzksIDB4MTk5OGZiMjQsIDB4MTc5MWY2MmYsIDB4NzY0ZGQ2OGQsIDB4Nzg0NGRiODYsIDB4NmE1ZmNjOWIsIDB4NjQ1NmMxOTAsIDB4NGU2OWUyYTEsIDB4NDA2MGVmYWEsIDB4NTI3YmY4YjcsIDB4NWM3MmY1YmMsIDB4MDYwNWJlZDUsIDB4MDgwY2IzZGUsIDB4MWExN2E0YzMsIDB4MTQxZWE5YzgsIDB4M2UyMThhZjksIDB4MzAyODg3ZjIsIDB4MjIzMzkwZWYsIDB4MmMzYTlkZTQsIDB4OTZkZDA2M2QsIDB4OThkNDBiMzYsIDB4OGFjZjFjMmIsIDB4ODRjNjExMjAsIDB4YWVmOTMyMTEsIDB4YTBmMDNmMWEsIDB4YjJlYjI4MDcsIDB4YmNlMjI1MGMsIDB4ZTY5NTZlNjUsIDB4ZTg5YzYzNmUsIDB4ZmE4Nzc0NzMsIDB4ZjQ4ZTc5NzgsIDB4ZGViMTVhNDksIDB4ZDBiODU3NDIsIDB4YzJhMzQwNWYsIDB4Y2NhYTRkNTQsIDB4NDFlY2RhZjcsIDB4NGZlNWQ3ZmMsIDB4NWRmZWMwZTEsIDB4NTNmN2NkZWEsIDB4NzljOGVlZGIsIDB4NzdjMWUzZDAsIDB4NjVkYWY0Y2QsIDB4NmJkM2Y5YzYsIDB4MzFhNGIyYWYsIDB4M2ZhZGJmYTQsIDB4MmRiNmE4YjksIDB4MjNiZmE1YjIsIDB4MDk4MDg2ODMsIDB4MDc4OThiODgsIDB4MTU5MjljOTUsIDB4MWI5YjkxOWUsIDB4YTE3YzBhNDcsIDB4YWY3NTA3NGMsIDB4YmQ2ZTEwNTEsIDB4YjM2NzFkNWEsIDB4OTk1ODNlNmIsIDB4OTc1MTMzNjAsIDB4ODU0YTI0N2QsIDB4OGI0MzI5NzYsIDB4ZDEzNDYyMWYsIDB4ZGYzZDZmMTQsIDB4Y2QyNjc4MDksIDB4YzMyZjc1MDIsIDB4ZTkxMDU2MzMsIDB4ZTcxOTViMzgsIDB4ZjUwMjRjMjUsIDB4ZmIwYjQxMmUsIDB4OWFkNzYxOGMsIDB4OTRkZTZjODcsIDB4ODZjNTdiOWEsIDB4ODhjYzc2OTEsIDB4YTJmMzU1YTAsIDB4YWNmYTU4YWIsIDB4YmVlMTRmYjYsIDB4YjBlODQyYmQsIDB4ZWE5ZjA5ZDQsIDB4ZTQ5NjA0ZGYsIDB4ZjY4ZDEzYzIsIDB4Zjg4NDFlYzksIDB4ZDJiYjNkZjgsIDB4ZGNiMjMwZjMsIDB4Y2VhOTI3ZWUsIDB4YzBhMDJhZTUsIDB4N2E0N2IxM2MsIDB4NzQ0ZWJjMzcsIDB4NjY1NWFiMmEsIDB4Njg1Y2E2MjEsIDB4NDI2Mzg1MTAsIDB4NGM2YTg4MWIsIDB4NWU3MTlmMDYsIDB4NTA3ODkyMGQsIDB4MGEwZmQ5NjQsIDB4MDQwNmQ0NmYsIDB4MTYxZGMzNzIsIDB4MTgxNGNlNzksIDB4MzIyYmVkNDgsIDB4M2MyMmUwNDMsIDB4MmUzOWY3NWUsIDB4MjAzMGZhNTUsIDB4ZWM5YWI3MDEsIDB4ZTI5M2JhMGEsIDB4ZjA4OGFkMTcsIDB4ZmU4MWEwMWMsIDB4ZDRiZTgzMmQsIDB4ZGFiNzhlMjYsIDB4YzhhYzk5M2IsIDB4YzZhNTk0MzAsIDB4OWNkMmRmNTksIDB4OTJkYmQyNTIsIDB4ODBjMGM1NGYsIDB4OGVjOWM4NDQsIDB4YTRmNmViNzUsIDB4YWFmZmU2N2UsIDB4YjhlNGYxNjMsIDB4YjZlZGZjNjgsIDB4MGMwYTY3YjEsIDB4MDIwMzZhYmEsIDB4MTAxODdkYTcsIDB4MWUxMTcwYWMsIDB4MzQyZTUzOWQsIDB4M2EyNzVlOTYsIDB4MjgzYzQ5OGIsIDB4MjYzNTQ0ODAsIDB4N2M0MjBmZTksIDB4NzI0YjAyZTIsIDB4NjA1MDE1ZmYsIDB4NmU1OTE4ZjQsIDB4NDQ2NjNiYzUsIDB4NGE2ZjM2Y2UsIDB4NTg3NDIxZDMsIDB4NTY3ZDJjZDgsIDB4MzdhMTBjN2EsIDB4MzlhODAxNzEsIDB4MmJiMzE2NmMsIDB4MjViYTFiNjcsIDB4MGY4NTM4NTYsIDB4MDE4YzM1NWQsIDB4MTM5NzIyNDAsIDB4MWQ5ZTJmNGIsIDB4NDdlOTY0MjIsIDB4NDllMDY5MjksIDB4NWJmYjdlMzQsIDB4NTVmMjczM2YsIDB4N2ZjZDUwMGUsIDB4NzFjNDVkMDUsIDB4NjNkZjRhMTgsIDB4NmRkNjQ3MTMsIDB4ZDczMWRjY2EsIDB4ZDkzOGQxYzEsIDB4Y2IyM2M2ZGMsIDB4YzUyYWNiZDcsIDB4ZWYxNWU4ZTYsIDB4ZTExY2U1ZWQsIDB4ZjMwN2YyZjAsIDB4ZmQwZWZmZmIsIDB4YTc3OWI0OTIsIDB4YTk3MGI5OTksIDB4YmI2YmFlODQsIDB4YjU2MmEzOGYsIDB4OWY1ZDgwYmUsIDB4OTE1NDhkYjUsIDB4ODM0ZjlhYTgsIDB4OGQ0Njk3YTNdO1xuXHQgICAgdmFyIFUyID0gWzB4MDAwMDAwMDAsIDB4MGIwZTA5MGQsIDB4MTYxYzEyMWEsIDB4MWQxMjFiMTcsIDB4MmMzODI0MzQsIDB4MjczNjJkMzksIDB4M2EyNDM2MmUsIDB4MzEyYTNmMjMsIDB4NTg3MDQ4NjgsIDB4NTM3ZTQxNjUsIDB4NGU2YzVhNzIsIDB4NDU2MjUzN2YsIDB4NzQ0ODZjNWMsIDB4N2Y0NjY1NTEsIDB4NjI1NDdlNDYsIDB4Njk1YTc3NGIsIDB4YjBlMDkwZDAsIDB4YmJlZTk5ZGQsIDB4YTZmYzgyY2EsIDB4YWRmMjhiYzcsIDB4OWNkOGI0ZTQsIDB4OTdkNmJkZTksIDB4OGFjNGE2ZmUsIDB4ODFjYWFmZjMsIDB4ZTg5MGQ4YjgsIDB4ZTM5ZWQxYjUsIDB4ZmU4Y2NhYTIsIDB4ZjU4MmMzYWYsIDB4YzRhOGZjOGMsIDB4Y2ZhNmY1ODEsIDB4ZDJiNGVlOTYsIDB4ZDliYWU3OWIsIDB4N2JkYjNiYmIsIDB4NzBkNTMyYjYsIDB4NmRjNzI5YTEsIDB4NjZjOTIwYWMsIDB4NTdlMzFmOGYsIDB4NWNlZDE2ODIsIDB4NDFmZjBkOTUsIDB4NGFmMTA0OTgsIDB4MjNhYjczZDMsIDB4MjhhNTdhZGUsIDB4MzViNzYxYzksIDB4M2ViOTY4YzQsIDB4MGY5MzU3ZTcsIDB4MDQ5ZDVlZWEsIDB4MTk4ZjQ1ZmQsIDB4MTI4MTRjZjAsIDB4Y2IzYmFiNmIsIDB4YzAzNWEyNjYsIDB4ZGQyN2I5NzEsIDB4ZDYyOWIwN2MsIDB4ZTcwMzhmNWYsIDB4ZWMwZDg2NTIsIDB4ZjExZjlkNDUsIDB4ZmExMTk0NDgsIDB4OTM0YmUzMDMsIDB4OTg0NWVhMGUsIDB4ODU1N2YxMTksIDB4OGU1OWY4MTQsIDB4YmY3M2M3MzcsIDB4YjQ3ZGNlM2EsIDB4YTk2ZmQ1MmQsIDB4YTI2MWRjMjAsIDB4ZjZhZDc2NmQsIDB4ZmRhMzdmNjAsIDB4ZTBiMTY0NzcsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4ZDE5YjViNTQsIDB4Y2M4OTQwNDMsIDB4Yzc4NzQ5NGUsIDB4YWVkZDNlMDUsIDB4YTVkMzM3MDgsIDB4YjhjMTJjMWYsIDB4YjNjZjI1MTIsIDB4ODJlNTFhMzEsIDB4ODllYjEzM2MsIDB4OTRmOTA4MmIsIDB4OWZmNzAxMjYsIDB4NDY0ZGU2YmQsIDB4NGQ0M2VmYjAsIDB4NTA1MWY0YTcsIDB4NWI1ZmZkYWEsIDB4NmE3NWMyODksIDB4NjE3YmNiODQsIDB4N2M2OWQwOTMsIDB4Nzc2N2Q5OWUsIDB4MWUzZGFlZDUsIDB4MTUzM2E3ZDgsIDB4MDgyMWJjY2YsIDB4MDMyZmI1YzIsIDB4MzIwNThhZTEsIDB4MzkwYjgzZWMsIDB4MjQxOTk4ZmIsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4ODY3ODQ0ZGIsIDB4OWI2YTVmY2MsIDB4OTA2NDU2YzEsIDB4YTE0ZTY5ZTIsIDB4YWE0MDYwZWYsIDB4Yjc1MjdiZjgsIDB4YmM1YzcyZjUsIDB4ZDUwNjA1YmUsIDB4ZGUwODBjYjMsIDB4YzMxYTE3YTQsIDB4YzgxNDFlYTksIDB4ZjkzZTIxOGEsIDB4ZjIzMDI4ODcsIDB4ZWYyMjMzOTAsIDB4ZTQyYzNhOWQsIDB4M2Q5NmRkMDYsIDB4MzY5OGQ0MGIsIDB4MmI4YWNmMWMsIDB4MjA4NGM2MTEsIDB4MTFhZWY5MzIsIDB4MWFhMGYwM2YsIDB4MDdiMmViMjgsIDB4MGNiY2UyMjUsIDB4NjVlNjk1NmUsIDB4NmVlODljNjMsIDB4NzNmYTg3NzQsIDB4NzhmNDhlNzksIDB4NDlkZWIxNWEsIDB4NDJkMGI4NTcsIDB4NWZjMmEzNDAsIDB4NTRjY2FhNGQsIDB4Zjc0MWVjZGEsIDB4ZmM0ZmU1ZDcsIDB4ZTE1ZGZlYzAsIDB4ZWE1M2Y3Y2QsIDB4ZGI3OWM4ZWUsIDB4ZDA3N2MxZTMsIDB4Y2Q2NWRhZjQsIDB4YzY2YmQzZjksIDB4YWYzMWE0YjIsIDB4YTQzZmFkYmYsIDB4YjkyZGI2YTgsIDB4YjIyM2JmYTUsIDB4ODMwOTgwODYsIDB4ODgwNzg5OGIsIDB4OTUxNTkyOWMsIDB4OWUxYjliOTEsIDB4NDdhMTdjMGEsIDB4NGNhZjc1MDcsIDB4NTFiZDZlMTAsIDB4NWFiMzY3MWQsIDB4NmI5OTU4M2UsIDB4NjA5NzUxMzMsIDB4N2Q4NTRhMjQsIDB4NzY4YjQzMjksIDB4MWZkMTM0NjIsIDB4MTRkZjNkNmYsIDB4MDljZDI2NzgsIDB4MDJjMzJmNzUsIDB4MzNlOTEwNTYsIDB4MzhlNzE5NWIsIDB4MjVmNTAyNGMsIDB4MmVmYjBiNDEsIDB4OGM5YWQ3NjEsIDB4ODc5NGRlNmMsIDB4OWE4NmM1N2IsIDB4OTE4OGNjNzYsIDB4YTBhMmYzNTUsIDB4YWJhY2ZhNTgsIDB4YjZiZWUxNGYsIDB4YmRiMGU4NDIsIDB4ZDRlYTlmMDksIDB4ZGZlNDk2MDQsIDB4YzJmNjhkMTMsIDB4YzlmODg0MWUsIDB4ZjhkMmJiM2QsIDB4ZjNkY2IyMzAsIDB4ZWVjZWE5MjcsIDB4ZTVjMGEwMmEsIDB4M2M3YTQ3YjEsIDB4Mzc3NDRlYmMsIDB4MmE2NjU1YWIsIDB4MjE2ODVjYTYsIDB4MTA0MjYzODUsIDB4MWI0YzZhODgsIDB4MDY1ZTcxOWYsIDB4MGQ1MDc4OTIsIDB4NjQwYTBmZDksIDB4NmYwNDA2ZDQsIDB4NzIxNjFkYzMsIDB4NzkxODE0Y2UsIDB4NDgzMjJiZWQsIDB4NDMzYzIyZTAsIDB4NWUyZTM5ZjcsIDB4NTUyMDMwZmEsIDB4MDFlYzlhYjcsIDB4MGFlMjkzYmEsIDB4MTdmMDg4YWQsIDB4MWNmZTgxYTAsIDB4MmRkNGJlODMsIDB4MjZkYWI3OGUsIDB4M2JjOGFjOTksIDB4MzBjNmE1OTQsIDB4NTk5Y2QyZGYsIDB4NTI5MmRiZDIsIDB4NGY4MGMwYzUsIDB4NDQ4ZWM5YzgsIDB4NzVhNGY2ZWIsIDB4N2VhYWZmZTYsIDB4NjNiOGU0ZjEsIDB4NjhiNmVkZmMsIDB4YjEwYzBhNjcsIDB4YmEwMjAzNmEsIDB4YTcxMDE4N2QsIDB4YWMxZTExNzAsIDB4OWQzNDJlNTMsIDB4OTYzYTI3NWUsIDB4OGIyODNjNDksIDB4ODAyNjM1NDQsIDB4ZTk3YzQyMGYsIDB4ZTI3MjRiMDIsIDB4ZmY2MDUwMTUsIDB4ZjQ2ZTU5MTgsIDB4YzU0NDY2M2IsIDB4Y2U0YTZmMzYsIDB4ZDM1ODc0MjEsIDB4ZDg1NjdkMmMsIDB4N2EzN2ExMGMsIDB4NzEzOWE4MDEsIDB4NmMyYmIzMTYsIDB4NjcyNWJhMWIsIDB4NTYwZjg1MzgsIDB4NWQwMThjMzUsIDB4NDAxMzk3MjIsIDB4NGIxZDllMmYsIDB4MjI0N2U5NjQsIDB4Mjk0OWUwNjksIDB4MzQ1YmZiN2UsIDB4M2Y1NWYyNzMsIDB4MGU3ZmNkNTAsIDB4MDU3MWM0NWQsIDB4MTg2M2RmNGEsIDB4MTM2ZGQ2NDcsIDB4Y2FkNzMxZGMsIDB4YzFkOTM4ZDEsIDB4ZGNjYjIzYzYsIDB4ZDdjNTJhY2IsIDB4ZTZlZjE1ZTgsIDB4ZWRlMTFjZTUsIDB4ZjBmMzA3ZjIsIDB4ZmJmZDBlZmYsIDB4OTJhNzc5YjQsIDB4OTlhOTcwYjksIDB4ODRiYjZiYWUsIDB4OGZiNTYyYTMsIDB4YmU5ZjVkODAsIDB4YjU5MTU0OGQsIDB4YTg4MzRmOWEsIDB4YTM4ZDQ2OTddO1xuXHQgICAgdmFyIFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuXHQgICAgdmFyIFU0ID0gWzB4MDAwMDAwMDAsIDB4MDkwZDBiMGUsIDB4MTIxYTE2MWMsIDB4MWIxNzFkMTIsIDB4MjQzNDJjMzgsIDB4MmQzOTI3MzYsIDB4MzYyZTNhMjQsIDB4M2YyMzMxMmEsIDB4NDg2ODU4NzAsIDB4NDE2NTUzN2UsIDB4NWE3MjRlNmMsIDB4NTM3ZjQ1NjIsIDB4NmM1Yzc0NDgsIDB4NjU1MTdmNDYsIDB4N2U0NjYyNTQsIDB4Nzc0YjY5NWEsIDB4OTBkMGIwZTAsIDB4OTlkZGJiZWUsIDB4ODJjYWE2ZmMsIDB4OGJjN2FkZjIsIDB4YjRlNDljZDgsIDB4YmRlOTk3ZDYsIDB4YTZmZThhYzQsIDB4YWZmMzgxY2EsIDB4ZDhiOGU4OTAsIDB4ZDFiNWUzOWUsIDB4Y2FhMmZlOGMsIDB4YzNhZmY1ODIsIDB4ZmM4Y2M0YTgsIDB4ZjU4MWNmYTYsIDB4ZWU5NmQyYjQsIDB4ZTc5YmQ5YmEsIDB4M2JiYjdiZGIsIDB4MzJiNjcwZDUsIDB4MjlhMTZkYzcsIDB4MjBhYzY2YzksIDB4MWY4ZjU3ZTMsIDB4MTY4MjVjZWQsIDB4MGQ5NTQxZmYsIDB4MDQ5ODRhZjEsIDB4NzNkMzIzYWIsIDB4N2FkZTI4YTUsIDB4NjFjOTM1YjcsIDB4NjhjNDNlYjksIDB4NTdlNzBmOTMsIDB4NWVlYTA0OWQsIDB4NDVmZDE5OGYsIDB4NGNmMDEyODEsIDB4YWI2YmNiM2IsIDB4YTI2NmMwMzUsIDB4Yjk3MWRkMjcsIDB4YjA3Y2Q2MjksIDB4OGY1ZmU3MDMsIDB4ODY1MmVjMGQsIDB4OWQ0NWYxMWYsIDB4OTQ0OGZhMTEsIDB4ZTMwMzkzNGIsIDB4ZWEwZTk4NDUsIDB4ZjExOTg1NTcsIDB4ZjgxNDhlNTksIDB4YzczN2JmNzMsIDB4Y2UzYWI0N2QsIDB4ZDUyZGE5NmYsIDB4ZGMyMGEyNjEsIDB4NzY2ZGY2YWQsIDB4N2Y2MGZkYTMsIDB4NjQ3N2UwYjEsIDB4NmQ3YWViYmYsIDB4NTI1OWRhOTUsIDB4NWI1NGQxOWIsIDB4NDA0M2NjODksIDB4NDk0ZWM3ODcsIDB4M2UwNWFlZGQsIDB4MzcwOGE1ZDMsIDB4MmMxZmI4YzEsIDB4MjUxMmIzY2YsIDB4MWEzMTgyZTUsIDB4MTMzYzg5ZWIsIDB4MDgyYjk0ZjksIDB4MDEyNjlmZjcsIDB4ZTZiZDQ2NGQsIDB4ZWZiMDRkNDMsIDB4ZjRhNzUwNTEsIDB4ZmRhYTViNWYsIDB4YzI4OTZhNzUsIDB4Y2I4NDYxN2IsIDB4ZDA5MzdjNjksIDB4ZDk5ZTc3NjcsIDB4YWVkNTFlM2QsIDB4YTdkODE1MzMsIDB4YmNjZjA4MjEsIDB4YjVjMjAzMmYsIDB4OGFlMTMyMDUsIDB4ODNlYzM5MGIsIDB4OThmYjI0MTksIDB4OTFmNjJmMTcsIDB4NGRkNjhkNzYsIDB4NDRkYjg2NzgsIDB4NWZjYzliNmEsIDB4NTZjMTkwNjQsIDB4NjllMmExNGUsIDB4NjBlZmFhNDAsIDB4N2JmOGI3NTIsIDB4NzJmNWJjNWMsIDB4MDViZWQ1MDYsIDB4MGNiM2RlMDgsIDB4MTdhNGMzMWEsIDB4MWVhOWM4MTQsIDB4MjE4YWY5M2UsIDB4Mjg4N2YyMzAsIDB4MzM5MGVmMjIsIDB4M2E5ZGU0MmMsIDB4ZGQwNjNkOTYsIDB4ZDQwYjM2OTgsIDB4Y2YxYzJiOGEsIDB4YzYxMTIwODQsIDB4ZjkzMjExYWUsIDB4ZjAzZjFhYTAsIDB4ZWIyODA3YjIsIDB4ZTIyNTBjYmMsIDB4OTU2ZTY1ZTYsIDB4OWM2MzZlZTgsIDB4ODc3NDczZmEsIDB4OGU3OTc4ZjQsIDB4YjE1YTQ5ZGUsIDB4Yjg1NzQyZDAsIDB4YTM0MDVmYzIsIDB4YWE0ZDU0Y2MsIDB4ZWNkYWY3NDEsIDB4ZTVkN2ZjNGYsIDB4ZmVjMGUxNWQsIDB4ZjdjZGVhNTMsIDB4YzhlZWRiNzksIDB4YzFlM2QwNzcsIDB4ZGFmNGNkNjUsIDB4ZDNmOWM2NmIsIDB4YTRiMmFmMzEsIDB4YWRiZmE0M2YsIDB4YjZhOGI5MmQsIDB4YmZhNWIyMjMsIDB4ODA4NjgzMDksIDB4ODk4Yjg4MDcsIDB4OTI5Yzk1MTUsIDB4OWI5MTllMWIsIDB4N2MwYTQ3YTEsIDB4NzUwNzRjYWYsIDB4NmUxMDUxYmQsIDB4NjcxZDVhYjMsIDB4NTgzZTZiOTksIDB4NTEzMzYwOTcsIDB4NGEyNDdkODUsIDB4NDMyOTc2OGIsIDB4MzQ2MjFmZDEsIDB4M2Q2ZjE0ZGYsIDB4MjY3ODA5Y2QsIDB4MmY3NTAyYzMsIDB4MTA1NjMzZTksIDB4MTk1YjM4ZTcsIDB4MDI0YzI1ZjUsIDB4MGI0MTJlZmIsIDB4ZDc2MThjOWEsIDB4ZGU2Yzg3OTQsIDB4YzU3YjlhODYsIDB4Y2M3NjkxODgsIDB4ZjM1NWEwYTIsIDB4ZmE1OGFiYWMsIDB4ZTE0ZmI2YmUsIDB4ZTg0MmJkYjAsIDB4OWYwOWQ0ZWEsIDB4OTYwNGRmZTQsIDB4OGQxM2MyZjYsIDB4ODQxZWM5ZjgsIDB4YmIzZGY4ZDIsIDB4YjIzMGYzZGMsIDB4YTkyN2VlY2UsIDB4YTAyYWU1YzAsIDB4NDdiMTNjN2EsIDB4NGViYzM3NzQsIDB4NTVhYjJhNjYsIDB4NWNhNjIxNjgsIDB4NjM4NTEwNDIsIDB4NmE4ODFiNGMsIDB4NzE5ZjA2NWUsIDB4Nzg5MjBkNTAsIDB4MGZkOTY0MGEsIDB4MDZkNDZmMDQsIDB4MWRjMzcyMTYsIDB4MTRjZTc5MTgsIDB4MmJlZDQ4MzIsIDB4MjJlMDQzM2MsIDB4MzlmNzVlMmUsIDB4MzBmYTU1MjAsIDB4OWFiNzAxZWMsIDB4OTNiYTBhZTIsIDB4ODhhZDE3ZjAsIDB4ODFhMDFjZmUsIDB4YmU4MzJkZDQsIDB4Yjc4ZTI2ZGEsIDB4YWM5OTNiYzgsIDB4YTU5NDMwYzYsIDB4ZDJkZjU5OWMsIDB4ZGJkMjUyOTIsIDB4YzBjNTRmODAsIDB4YzljODQ0OGUsIDB4ZjZlYjc1YTQsIDB4ZmZlNjdlYWEsIDB4ZTRmMTYzYjgsIDB4ZWRmYzY4YjYsIDB4MGE2N2IxMGMsIDB4MDM2YWJhMDIsIDB4MTg3ZGE3MTAsIDB4MTE3MGFjMWUsIDB4MmU1MzlkMzQsIDB4Mjc1ZTk2M2EsIDB4M2M0OThiMjgsIDB4MzU0NDgwMjYsIDB4NDIwZmU5N2MsIDB4NGIwMmUyNzIsIDB4NTAxNWZmNjAsIDB4NTkxOGY0NmUsIDB4NjYzYmM1NDQsIDB4NmYzNmNlNGEsIDB4NzQyMWQzNTgsIDB4N2QyY2Q4NTYsIDB4YTEwYzdhMzcsIDB4YTgwMTcxMzksIDB4YjMxNjZjMmIsIDB4YmExYjY3MjUsIDB4ODUzODU2MGYsIDB4OGMzNTVkMDEsIDB4OTcyMjQwMTMsIDB4OWUyZjRiMWQsIDB4ZTk2NDIyNDcsIDB4ZTA2OTI5NDksIDB4ZmI3ZTM0NWIsIDB4ZjI3MzNmNTUsIDB4Y2Q1MDBlN2YsIDB4YzQ1ZDA1NzEsIDB4ZGY0YTE4NjMsIDB4ZDY0NzEzNmQsIDB4MzFkY2NhZDcsIDB4MzhkMWMxZDksIDB4MjNjNmRjY2IsIDB4MmFjYmQ3YzUsIDB4MTVlOGU2ZWYsIDB4MWNlNWVkZTEsIDB4MDdmMmYwZjMsIDB4MGVmZmZiZmQsIDB4NzliNDkyYTcsIDB4NzBiOTk5YTksIDB4NmJhZTg0YmIsIDB4NjJhMzhmYjUsIDB4NWQ4MGJlOWYsIDB4NTQ4ZGI1OTEsIDB4NGY5YWE4ODMsIDB4NDY5N2EzOGRdO1xuXG5cdCAgICBmdW5jdGlvbiBjb252ZXJ0VG9JbnQzMihieXRlcykge1xuXHQgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgICAgXSA8PCAyNCkgfFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKyAxXSA8PCAxNikgfFxuXHQgICAgICAgICAgICAgICAgKGJ5dGVzW2kgKyAyXSA8PCAgOCkgfFxuXHQgICAgICAgICAgICAgICAgIGJ5dGVzW2kgKyAzXVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICB2YXIgQUVTID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFFUykpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdrZXknLCB7XG5cdCAgICAgICAgICAgIHZhbHVlOiBjb2VyY2VBcnJheShrZXksIHRydWUpXG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICB0aGlzLl9wcmVwYXJlKCk7XG5cdCAgICB9O1xuXG5cblx0ICAgIEFFUy5wcm90b3R5cGUuX3ByZXBhcmUgPSBmdW5jdGlvbigpIHtcblxuXHQgICAgICAgIHZhciByb3VuZHMgPSBudW1iZXJPZlJvdW5kc1t0aGlzLmtleS5sZW5ndGhdO1xuXHQgICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQga2V5IHNpemUgKG11c3QgYmUgMTYsIDI0IG9yIDMyIGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGVuY3J5cHRpb24gcm91bmQga2V5c1xuXHQgICAgICAgIHRoaXMuX0tlID0gW107XG5cblx0ICAgICAgICAvLyBkZWNyeXB0aW9uIHJvdW5kIGtleXNcblx0ICAgICAgICB0aGlzLl9LZCA9IFtdO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gcm91bmRzOyBpKyspIHtcblx0ICAgICAgICAgICAgdGhpcy5fS2UucHVzaChbMCwgMCwgMCwgMF0pO1xuXHQgICAgICAgICAgICB0aGlzLl9LZC5wdXNoKFswLCAwLCAwLCAwXSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJvdW5kS2V5Q291bnQgPSAocm91bmRzICsgMSkgKiA0O1xuXHQgICAgICAgIHZhciBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IHRoZSBrZXkgaW50byBpbnRzXG5cdCAgICAgICAgdmFyIHRrID0gY29udmVydFRvSW50MzIodGhpcy5rZXkpO1xuXG5cdCAgICAgICAgLy8gY29weSB2YWx1ZXMgaW50byByb3VuZCBrZXkgYXJyYXlzXG5cdCAgICAgICAgdmFyIGluZGV4O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgS0M7IGkrKykge1xuXHQgICAgICAgICAgICBpbmRleCA9IGkgPj4gMjtcblx0ICAgICAgICAgICAgdGhpcy5fS2VbaW5kZXhdW2kgJSA0XSA9IHRrW2ldO1xuXHQgICAgICAgICAgICB0aGlzLl9LZFtyb3VuZHMgLSBpbmRleF1baSAlIDRdID0gdGtbaV07XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiAoZmlwcy0xOTcgc2VjdGlvbiA1LjIpXG5cdCAgICAgICAgdmFyIHJjb25wb2ludGVyID0gMDtcblx0ICAgICAgICB2YXIgdCA9IEtDLCB0dDtcblx0ICAgICAgICB3aGlsZSAodCA8IHJvdW5kS2V5Q291bnQpIHtcblx0ICAgICAgICAgICAgdHQgPSB0a1tLQyAtIDFdO1xuXHQgICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgMTYpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgIChTWyB0dCAgICAgICAgJiAweEZGXSA8PCAgOCkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdICAgICAgICBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAocmNvbltyY29ucG9pbnRlcl0gPDwgMjQpKTtcblx0ICAgICAgICAgICAgcmNvbnBvaW50ZXIgKz0gMTtcblxuXHQgICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXG5cdCAgICAgICAgICAgIGlmIChLQyAhPSA4KSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IEtDOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8ga2V5IGV4cGFuc2lvbiBmb3IgMjU2LWJpdCBrZXlzIGlzIFwic2xpZ2h0bHkgZGlmZmVyZW50XCIgKGZpcHMtMTk3KVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCAoS0MgLyAyKTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGtbaV0gXj0gdGtbaSAtIDFdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdHQgPSB0a1soS0MgLyAyKSAtIDFdO1xuXG5cdCAgICAgICAgICAgICAgICB0a1tLQyAvIDJdIF49IChTWyB0dCAgICAgICAgJiAweEZGXSAgICAgICAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgIDgpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDE2KSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAyNCkgJiAweEZGXSA8PCAyNCkpO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gKEtDIC8gMikgKyAxOyBpIDwgS0M7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHRrW2ldIF49IHRrW2kgLSAxXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIGNvcHkgdmFsdWVzIGludG8gcm91bmQga2V5IGFycmF5c1xuXHQgICAgICAgICAgICB2YXIgaSA9IDAsIHIsIGM7XG5cdCAgICAgICAgICAgIHdoaWxlIChpIDwgS0MgJiYgdCA8IHJvdW5kS2V5Q291bnQpIHtcblx0ICAgICAgICAgICAgICAgIHIgPSB0ID4+IDI7XG5cdCAgICAgICAgICAgICAgICBjID0gdCAlIDQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtjXSA9IHRrW2ldO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fS2Rbcm91bmRzIC0gcl1bY10gPSB0a1tpKytdO1xuXHQgICAgICAgICAgICAgICAgdCsrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gaW52ZXJzZS1jaXBoZXItaWZ5IHRoZSBkZWNyeXB0aW9uIHJvdW5kIGtleSAoZmlwcy0xOTcgc2VjdGlvbiA1LjMpXG5cdCAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDQ7IGMrKykge1xuXHQgICAgICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyXVtjXTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVMlsodHQgPj4gMTYpICYgMHhGRl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVTNbKHR0ID4+ICA4KSAmIDB4RkZdIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFU0WyB0dCAgICAgICAgJiAweEZGXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICBBRVMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBpZiAocGxhaW50ZXh0Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJvdW5kcyA9IHRoaXMuX0tlLmxlbmd0aCAtIDE7XG5cdCAgICAgICAgdmFyIGEgPSBbMCwgMCwgMCwgMF07XG5cblx0ICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcblx0ICAgICAgICB2YXIgdCA9IGNvbnZlcnRUb0ludDMyKHBsYWludGV4dCk7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdFtpXSBePSB0aGlzLl9LZVswXVtpXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG5cdCAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgYVtpXSA9IChUMVsodFsgaSAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUM1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUNFsgdFsoaSArIDMpICUgNF0gICAgICAgICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KDE2KSwgdHQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdHQgPSB0aGlzLl9LZVtyb3VuZHNdW2ldO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgICAgXSA9IChTWyh0WyBpICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeICh0dCA+PiAyNCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDJdID0gKFNbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTWyB0WyhpICsgMykgJSA0XSAgICAgICAgJiAweGZmXSBeICB0dCAgICAgICApICYgMHhmZjtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblxuXHQgICAgQUVTLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuXHQgICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciByb3VuZHMgPSB0aGlzLl9LZC5sZW5ndGggLSAxO1xuXHQgICAgICAgIHZhciBhID0gWzAsIDAsIDAsIDBdO1xuXG5cdCAgICAgICAgLy8gY29udmVydCBwbGFpbnRleHQgdG8gKGludHMgXiBrZXkpXG5cdCAgICAgICAgdmFyIHQgPSBjb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHQgICAgICAgICAgICB0W2ldIF49IHRoaXMuX0tkWzBdW2ldO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcblx0ICAgICAgICBmb3IgKHZhciByID0gMTsgciA8IHJvdW5kczsgcisrKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICBhW2ldID0gKFQ1Wyh0WyBpICAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUNlsodFsoaSArIDMpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUN1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBUOFsgdFsoaSArIDEpICUgNF0gICAgICAgICYgMHhmZl0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZFtyXVtpXSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdCA9IGEuc2xpY2UoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KDE2KSwgdHQ7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyb3VuZHNdW2ldO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgICAgXSA9IChTaVsodFsgaSAgICAgICAgIF0gPj4gMjQpICYgMHhmZl0gXiAodHQgPj4gMjQpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDFdID0gKFNpWyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeICh0dCA+PiAxNikpICYgMHhmZjtcblx0ICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAzXSA9IChTaVsgdFsoaSArIDEpICUgNF0gICAgICAgICYgMHhmZl0gXiAgdHQgICAgICAgKSAmIDB4ZmY7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBFbGVjdG9uaWMgQ29kZWJvb2sgKEVDQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkVDQiA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25FQ0IpKSB7XG5cdCAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkVsZWN0cm9uaWMgQ29kZSBCbG9ja1wiO1xuXHQgICAgICAgIHRoaXMubmFtZSA9IFwiZWNiXCI7XG5cblx0ICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBwbGFpbnRleHQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChwbGFpbnRleHQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNyZWF0ZUFycmF5KHBsYWludGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkocGxhaW50ZXh0LCBibG9jaywgMCwgaSwgaSArIDE2KTtcblx0ICAgICAgICAgICAgYmxvY2sgPSB0aGlzLl9hZXMuZW5jcnlwdChibG9jayk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShibG9jaywgY2lwaGVydGV4dCwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgY2lwaGVydGV4dCA9IGNvZXJjZUFycmF5KGNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHZhciBwbGFpbnRleHQgPSBjcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG5cdCAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaXBoZXJ0ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cdCAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO1xuXHQgICAgICAgICAgICBjb3B5QXJyYXkoYmxvY2ssIHBsYWludGV4dCwgaSk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgKENCQylcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNCQyA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ0JDKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDaXBoZXIgQmxvY2sgQ2hhaW5pbmdcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcImNiY1wiO1xuXG5cdCAgICAgICAgaWYgKCFpdikge1xuXHQgICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbGFzdENpcGhlcmJsb2NrID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuXG5cdCAgICAgICAgdGhpcy5fYWVzID0gbmV3IEFFUyhrZXkpO1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG5cdCAgICAgICAgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkocGxhaW50ZXh0KTtcblxuXHQgICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcGxhaW50ZXh0IHNpemUgKG11c3QgYmUgbXVsdGlwbGUgb2YgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjcmVhdGVBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcblx0ICAgICAgICB2YXIgYmxvY2sgPSBjcmVhdGVBcnJheSgxNik7XG5cblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcblx0ICAgICAgICAgICAgY29weUFycmF5KHBsYWludGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICBibG9ja1tqXSBePSB0aGlzLl9sYXN0Q2lwaGVyYmxvY2tbal07XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICB0aGlzLl9sYXN0Q2lwaGVyYmxvY2sgPSB0aGlzLl9hZXMuZW5jcnlwdChibG9jayk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIGNpcGhlcnRleHQsIGkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuXHQgICAgfTtcblxuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuXHQgICAgICAgIGNpcGhlcnRleHQgPSBjb2VyY2VBcnJheShjaXBoZXJ0ZXh0KTtcblxuXHQgICAgICAgIGlmICgoY2lwaGVydGV4dC5sZW5ndGggJSAxNikgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY3JlYXRlQXJyYXkoY2lwaGVydGV4dC5sZW5ndGgpO1xuXHQgICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcblx0ICAgICAgICAgICAgY29weUFycmF5KGNpcGhlcnRleHQsIGJsb2NrLCAwLCBpLCBpICsgMTYpO1xuXHQgICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5kZWNyeXB0KGJsb2NrKTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gPSBibG9ja1tqXSBeIHRoaXMuX2xhc3RDaXBoZXJibG9ja1tqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIDAsIGksIGkgKyAxNik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDaXBoZXIgRmVlZGJhY2sgKENGQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNGQiA9IGZ1bmN0aW9uKGtleSwgaXYsIHNlZ21lbnRTaXplKSB7XG5cdCAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkNGQikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiQ2lwaGVyIEZlZWRiYWNrXCI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJjZmJcIjtcblxuXHQgICAgICAgIGlmICghaXYpIHtcblx0ICAgICAgICAgICAgaXYgPSBjcmVhdGVBcnJheSgxNik7XG5cblx0ICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IHNpemUpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgaWYgKCFzZWdtZW50U2l6ZSkgeyBzZWdtZW50U2l6ZSA9IDE7IH1cblxuXHQgICAgICAgIHRoaXMuc2VnbWVudFNpemUgPSBzZWdtZW50U2l6ZTtcblxuXHQgICAgICAgIHRoaXMuX3NoaWZ0UmVnaXN0ZXIgPSBjb2VyY2VBcnJheShpdiwgdHJ1ZSk7XG5cblx0ICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DRkIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcblx0ICAgICAgICBpZiAoKHBsYWludGV4dC5sZW5ndGggJSB0aGlzLnNlZ21lbnRTaXplKSAhPSAwKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgZW5jcnlwdGVkID0gY29lcmNlQXJyYXkocGxhaW50ZXh0LCB0cnVlKTtcblxuXHQgICAgICAgIHZhciB4b3JTZWdtZW50O1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jcnlwdGVkLmxlbmd0aDsgaSArPSB0aGlzLnNlZ21lbnRTaXplKSB7XG5cdCAgICAgICAgICAgIHhvclNlZ21lbnQgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9zaGlmdFJlZ2lzdGVyKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIGVuY3J5cHRlZFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuXHQgICAgICAgICAgICBjb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3RlciwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMCwgdGhpcy5zZWdtZW50U2l6ZSk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShlbmNyeXB0ZWQsIHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIDE2IC0gdGhpcy5zZWdtZW50U2l6ZSwgaSwgaSArIHRoaXMuc2VnbWVudFNpemUpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG5cdCAgICB9O1xuXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25DRkIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG5cdCAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCwgdHJ1ZSk7XG5cblx0ICAgICAgICB2YXIgeG9yU2VnbWVudDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gdGhpcy5zZWdtZW50U2l6ZSkge1xuXHQgICAgICAgICAgICB4b3JTZWdtZW50ID0gdGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fc2hpZnRSZWdpc3Rlcik7XG5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgIHBsYWludGV4dFtpICsgal0gXj0geG9yU2VnbWVudFtqXTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuXHQgICAgICAgICAgICBjb3B5QXJyYXkodGhpcy5fc2hpZnRSZWdpc3RlciwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMCwgdGhpcy5zZWdtZW50U2l6ZSk7XG5cdCAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAxNiAtIHRoaXMuc2VnbWVudFNpemUsIGksIGkgKyB0aGlzLnNlZ21lbnRTaXplKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBPdXRwdXQgRmVlZGJhY2sgKE9GQilcblx0ICAgICAqL1xuXHQgICAgdmFyIE1vZGVPZk9wZXJhdGlvbk9GQiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uT0ZCKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJPdXRwdXQgRmVlZGJhY2tcIjtcblx0ICAgICAgICB0aGlzLm5hbWUgPSBcIm9mYlwiO1xuXG5cdCAgICAgICAgaWYgKCFpdikge1xuXHQgICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuXHQgICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fbGFzdFByZWNpcGhlciA9IGNvZXJjZUFycmF5KGl2LCB0cnVlKTtcblx0ICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXggPSAxNjtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbk9GQi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNyeXB0ZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCA9PT0gMTYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXJJbmRleCA9IDA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZW5jcnlwdGVkW2ldIF49IHRoaXMuX2xhc3RQcmVjaXBoZXJbdGhpcy5fbGFzdFByZWNpcGhlckluZGV4KytdO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBlbmNyeXB0ZWQ7XG5cdCAgICB9O1xuXG5cdCAgICAvLyBEZWNyeXB0aW9uIGlzIHN5bWV0cmljXG5cdCAgICBNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmRlY3J5cHQgPSBNb2RlT2ZPcGVyYXRpb25PRkIucHJvdG90eXBlLmVuY3J5cHQ7XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgQ291bnRlciBvYmplY3QgZm9yIENUUiBjb21tb24gbW9kZSBvZiBvcGVyYXRpb25cblx0ICAgICAqL1xuXHQgICAgdmFyIENvdW50ZXIgPSBmdW5jdGlvbihpbml0aWFsVmFsdWUpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ291bnRlcikpIHtcblx0ICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NvdW50ZXIgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdlIGFsbG93IDAsIGJ1dCBhbnl0aGluZyBmYWxzZS1pc2ggdXNlcyB0aGUgZGVmYXVsdCAxXG5cdCAgICAgICAgaWYgKGluaXRpYWxWYWx1ZSAhPT0gMCAmJiAhaW5pdGlhbFZhbHVlKSB7IGluaXRpYWxWYWx1ZSA9IDE7IH1cblxuXHQgICAgICAgIGlmICh0eXBlb2YoaW5pdGlhbFZhbHVlKSA9PT0gJ251bWJlcicpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IGNyZWF0ZUFycmF5KDE2KTtcblx0ICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShpbml0aWFsVmFsdWUpO1xuXG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgdGhpcy5zZXRCeXRlcyhpbml0aWFsVmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIENvdW50ZXIucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcblx0ICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSAhPT0gJ251bWJlcicgfHwgcGFyc2VJbnQodmFsdWUpICE9IHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjb3VudGVyIHZhbHVlIChtdXN0IGJlIGFuIGludGVnZXIpJyk7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxNTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuXHQgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2luZGV4XSA9IHZhbHVlICUgMjU2O1xuXHQgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4+IDg7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgQ291bnRlci5wcm90b3R5cGUuc2V0Qnl0ZXMgPSBmdW5jdGlvbihieXRlcykge1xuXHQgICAgICAgIGJ5dGVzID0gY29lcmNlQXJyYXkoYnl0ZXMsIHRydWUpO1xuXG5cdCAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPSAxNikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY291bnRlciBieXRlcyBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHRoaXMuX2NvdW50ZXIgPSBieXRlcztcblx0ICAgIH07XG5cblx0ICAgIENvdW50ZXIucHJvdG90eXBlLmluY3JlbWVudCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX2NvdW50ZXJbaV0gPT09IDI1NSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fY291bnRlcltpXSA9IDA7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2ldKys7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblxuXHQgICAgLyoqXG5cdCAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDb3VudGVyIChDVFIpXG5cdCAgICAgKi9cblx0ICAgIHZhciBNb2RlT2ZPcGVyYXRpb25DVFIgPSBmdW5jdGlvbihrZXksIGNvdW50ZXIpIHtcblx0ICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ1RSKSkge1xuXHQgICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDb3VudGVyXCI7XG5cdCAgICAgICAgdGhpcy5uYW1lID0gXCJjdHJcIjtcblxuXHQgICAgICAgIGlmICghKGNvdW50ZXIgaW5zdGFuY2VvZiBDb3VudGVyKSkge1xuXHQgICAgICAgICAgICBjb3VudGVyID0gbmV3IENvdW50ZXIoY291bnRlcik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhpcy5fY291bnRlciA9IGNvdW50ZXI7XG5cblx0ICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVyID0gbnVsbDtcblx0ICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXggPSAxNjtcblxuXHQgICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcblx0ICAgIH07XG5cblx0ICAgIE1vZGVPZk9wZXJhdGlvbkNUUi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuXHQgICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNyeXB0ZWQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCA9PT0gMTYpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9jb3VudGVyLl9jb3VudGVyKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCA9IDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyLmluY3JlbWVudCgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVuY3J5cHRlZFtpXSBePSB0aGlzLl9yZW1haW5pbmdDb3VudGVyW3RoaXMuX3JlbWFpbmluZ0NvdW50ZXJJbmRleCsrXTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xuXHQgICAgfTtcblxuXHQgICAgLy8gRGVjcnlwdGlvbiBpcyBzeW1ldHJpY1xuXHQgICAgTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5kZWNyeXB0ID0gTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5lbmNyeXB0O1xuXG5cblx0ICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdCAgICAvLyBQYWRkaW5nXG5cblx0ICAgIC8vIFNlZTpodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMjMxNVxuXHQgICAgZnVuY3Rpb24gcGtjczdwYWQoZGF0YSkge1xuXHQgICAgICAgIGRhdGEgPSBjb2VyY2VBcnJheShkYXRhLCB0cnVlKTtcblx0ICAgICAgICB2YXIgcGFkZGVyID0gMTYgLSAoZGF0YS5sZW5ndGggJSAxNik7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcblx0ICAgICAgICBjb3B5QXJyYXkoZGF0YSwgcmVzdWx0KTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5sZW5ndGg7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFkZGVyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBwa2NzN3N0cmlwKGRhdGEpIHtcblx0ICAgICAgICBkYXRhID0gY29lcmNlQXJyYXkoZGF0YSwgdHJ1ZSk7XG5cdCAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTsgfVxuXG5cdCAgICAgICAgdmFyIHBhZGRlciA9IGRhdGFbZGF0YS5sZW5ndGggLSAxXTtcblx0ICAgICAgICBpZiAocGFkZGVyID4gMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgcGFkZGluZyBieXRlIG91dCBvZiByYW5nZScpOyB9XG5cblx0ICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBwYWRkZXI7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRkZXI7IGkrKykge1xuXHQgICAgICAgICAgICBpZiAoZGF0YVtsZW5ndGggKyBpXSAhPT0gcGFkZGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGxlbmd0aCk7XG5cdCAgICAgICAgY29weUFycmF5KGRhdGEsIHJlc3VsdCwgMCwgMCwgbGVuZ3RoKTtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfVxuXG5cdCAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQgICAgLy8gRXhwb3J0aW5nXG5cblxuXHQgICAgLy8gVGhlIGJsb2NrIGNpcGhlclxuXHQgICAgdmFyIGFlc2pzID0ge1xuXHQgICAgICAgIEFFUzogQUVTLFxuXHQgICAgICAgIENvdW50ZXI6IENvdW50ZXIsXG5cblx0ICAgICAgICBNb2RlT2ZPcGVyYXRpb246IHtcblx0ICAgICAgICAgICAgZWNiOiBNb2RlT2ZPcGVyYXRpb25FQ0IsXG5cdCAgICAgICAgICAgIGNiYzogTW9kZU9mT3BlcmF0aW9uQ0JDLFxuXHQgICAgICAgICAgICBjZmI6IE1vZGVPZk9wZXJhdGlvbkNGQixcblx0ICAgICAgICAgICAgb2ZiOiBNb2RlT2ZPcGVyYXRpb25PRkIsXG5cdCAgICAgICAgICAgIGN0cjogTW9kZU9mT3BlcmF0aW9uQ1RSXG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIHV0aWxzOiB7XG5cdCAgICAgICAgICAgIGhleDogY29udmVydEhleCxcblx0ICAgICAgICAgICAgdXRmODogY29udmVydFV0Zjhcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgcGFkZGluZzoge1xuXHQgICAgICAgICAgICBwa2NzNzoge1xuXHQgICAgICAgICAgICAgICAgcGFkOiBwa2NzN3BhZCxcblx0ICAgICAgICAgICAgICAgIHN0cmlwOiBwa2NzN3N0cmlwXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2FycmF5VGVzdDoge1xuXHQgICAgICAgICAgICBjb2VyY2VBcnJheTogY29lcmNlQXJyYXksXG5cdCAgICAgICAgICAgIGNyZWF0ZUFycmF5OiBjcmVhdGVBcnJheSxcblx0ICAgICAgICAgICAgY29weUFycmF5OiBjb3B5QXJyYXksXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXG5cdCAgICAvLyBub2RlLmpzXG5cdCAgICBpZiAoJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhZXNqcztcblxuXHQgICAgLy8gUmVxdWlyZUpTL0FNRFxuXHQgICAgLy8gaHR0cDovL3d3dy5yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWxcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTURcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mKHVuZGVmaW5lZCkgPT09ICdmdW5jdGlvbicgJiYgdW5kZWZpbmVkLmFtZCkge1xuXHQgICAgICAgIHVuZGVmaW5lZChhZXNqcyk7XG5cblx0ICAgIC8vIFdlYiBCcm93c2Vyc1xuXHQgICAgfSBlbHNlIHtcblxuXHQgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBleGlzdGluZyBsaWJyYXJ5IGF0IFwiYWVzanNcIiBtYWtlIHN1cmUgaXQncyBzdGlsbCBhdmFpbGFibGVcblx0ICAgICAgICBpZiAocm9vdC5hZXNqcykge1xuXHQgICAgICAgICAgICBhZXNqcy5fYWVzanMgPSByb290LmFlc2pzO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJvb3QuYWVzanMgPSBhZXNqcztcblx0ICAgIH1cblxuXG5cdH0pKGNvbW1vbmpzR2xvYmFsKTtcblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEEgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwianNvbi13YWxsZXRzLzUuMC42XCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEIgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJEEpO1xuXHR2YXIgX3ZlcnNpb25fMSRpID0gX3ZlcnNpb24kQS52ZXJzaW9uO1xuXG5cdHZhciB1dGlscyQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblx0ZnVuY3Rpb24gbG9vc2VBcnJheWlmeShoZXhTdHJpbmcpIHtcblx0ICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09ICdzdHJpbmcnICYmIGhleFN0cmluZy5zdWJzdHJpbmcoMCwgMikgIT09ICcweCcpIHtcblx0ICAgICAgICBoZXhTdHJpbmcgPSAnMHgnICsgaGV4U3RyaW5nO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KGhleFN0cmluZyk7XG5cdH1cblx0ZXhwb3J0cy5sb29zZUFycmF5aWZ5ID0gbG9vc2VBcnJheWlmeTtcblx0ZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG5cdCAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSk7XG5cdCAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgbGVuZ3RoKSB7XG5cdCAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB2YWx1ZTtcblx0fVxuXHRleHBvcnRzLnpwYWQgPSB6cGFkO1xuXHRmdW5jdGlvbiBnZXRQYXNzd29yZChwYXNzd29yZCkge1xuXHQgICAgaWYgKHR5cGVvZiAocGFzc3dvcmQpID09PSAnc3RyaW5nJykge1xuXHQgICAgICAgIHJldHVybiBsaWIkOC50b1V0ZjhCeXRlcyhwYXNzd29yZCwgbGliJDguVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHBhc3N3b3JkKTtcblx0fVxuXHRleHBvcnRzLmdldFBhc3N3b3JkID0gZ2V0UGFzc3dvcmQ7XG5cdGZ1bmN0aW9uIHNlYXJjaFBhdGgob2JqZWN0LCBwYXRoKSB7XG5cdCAgICB2YXIgY3VycmVudENoaWxkID0gb2JqZWN0O1xuXHQgICAgdmFyIGNvbXBzID0gcGF0aC50b0xvd2VyQ2FzZSgpLnNwbGl0KCcvJyk7XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgLy8gU2VhcmNoIGZvciBhIGNoaWxkIG9iamVjdCB3aXRoIGEgY2FzZS1pbnNlbnNpdGl2ZSBtYXRjaGluZyBrZXlcblx0ICAgICAgICB2YXIgbWF0Y2hpbmdDaGlsZCA9IG51bGw7XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGN1cnJlbnRDaGlsZCkge1xuXHQgICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXBzW2ldKSB7XG5cdCAgICAgICAgICAgICAgICBtYXRjaGluZ0NoaWxkID0gY3VycmVudENoaWxkW2tleV07XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBEaWRuJ3QgZmluZCBvbmUuIDonKFxuXHQgICAgICAgIGlmIChtYXRjaGluZ0NoaWxkID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBOb3cgY2hlY2sgdGhpcyBjaGlsZC4uLlxuXHQgICAgICAgIGN1cnJlbnRDaGlsZCA9IG1hdGNoaW5nQ2hpbGQ7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gY3VycmVudENoaWxkO1xuXHR9XG5cdGV4cG9ydHMuc2VhcmNoUGF0aCA9IHNlYXJjaFBhdGg7XG5cdC8vIFNlZTogaHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0IChTZWN0aW9uIDQuNClcblx0ZnVuY3Rpb24gdXVpZFY0KHJhbmRvbUJ5dGVzKSB7XG5cdCAgICB2YXIgYnl0ZXMgPSBsaWIkMS5hcnJheWlmeShyYW5kb21CeXRlcyk7XG5cdCAgICAvLyBTZWN0aW9uOiA0LjEuMzpcblx0ICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcblx0ICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuXHQgICAgLy8gU2VjdGlvbiA0LjRcblx0ICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuXHQgICAgLy8gLSBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkWzddID0gMGIxXG5cdCAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcblx0ICAgIHZhciB2YWx1ZSA9IGxpYiQxLmhleGxpZnkoYnl0ZXMpO1xuXHQgICAgcmV0dXJuIFtcblx0ICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMiwgMTApLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygxMCwgMTQpLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygxOCwgMjIpLFxuXHQgICAgICAgIHZhbHVlLnN1YnN0cmluZygyMiwgMzQpLFxuXHQgICAgXS5qb2luKFwiLVwiKTtcblx0fVxuXHRleHBvcnRzLnV1aWRWNCA9IHV1aWRWNDtcblxuXHR9KTtcblxuXHR2YXIgdXRpbHMkMiA9IHVud3JhcEV4cG9ydHModXRpbHMkMSk7XG5cdHZhciB1dGlsc18xJDIgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnk7XG5cdHZhciB1dGlsc18yID0gdXRpbHMkMS56cGFkO1xuXHR2YXIgdXRpbHNfMyA9IHV0aWxzJDEuZ2V0UGFzc3dvcmQ7XG5cdHZhciB1dGlsc180ID0gdXRpbHMkMS5zZWFyY2hQYXRoO1xuXHR2YXIgdXRpbHNfNSA9IHV0aWxzJDEudXVpZFY0O1xuXG5cdHZhciBjcm93ZHNhbGUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19pbXBvcnREZWZhdWx0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGFlc19qc18xID0gX19pbXBvcnREZWZhdWx0KGFlc0pzKTtcblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRBLnZlcnNpb24pO1xuXG5cdHZhciBDcm93ZHNhbGVBY2NvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKENyb3dkc2FsZUFjY291bnQsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBDcm93ZHNhbGVBY2NvdW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIENyb3dkc2FsZUFjY291bnQucHJvdG90eXBlLmlzQ3Jvd2RzYWxlQWNjb3VudCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNDcm93ZHNhbGVBY2NvdW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQ3Jvd2RzYWxlQWNjb3VudDtcblx0fShsaWIkMy5EZXNjcmlwdGlvbikpO1xuXHRleHBvcnRzLkNyb3dkc2FsZUFjY291bnQgPSBDcm93ZHNhbGVBY2NvdW50O1xuXHQvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9weWV0aHNhbGV0b29sXG5cdGZ1bmN0aW9uIGRlY3J5cHQoanNvbiwgcGFzc3dvcmQpIHtcblx0ICAgIHZhciBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblx0ICAgIHBhc3N3b3JkID0gdXRpbHMkMS5nZXRQYXNzd29yZChwYXNzd29yZCk7XG5cdCAgICAvLyBFdGhlcmV1bSBBZGRyZXNzXG5cdCAgICB2YXIgZXRoYWRkciA9IGxpYiQ2LmdldEFkZHJlc3ModXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiZXRoYWRkclwiKSk7XG5cdCAgICAvLyBFbmNyeXB0ZWQgU2VlZFxuXHQgICAgdmFyIGVuY3NlZWQgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiZW5jc2VlZFwiKSk7XG5cdCAgICBpZiAoIWVuY3NlZWQgfHwgKGVuY3NlZWQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZW5jc2VlZFwiLCBcImpzb25cIiwganNvbik7XG5cdCAgICB9XG5cdCAgICB2YXIga2V5ID0gbGliJDEuYXJyYXlpZnkoYnJvd3NlciQyLnBia2RmMihwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xuXHQgICAgdmFyIGl2ID0gZW5jc2VlZC5zbGljZSgwLCAxNik7XG5cdCAgICB2YXIgZW5jcnlwdGVkU2VlZCA9IGVuY3NlZWQuc2xpY2UoMTYpO1xuXHQgICAgLy8gRGVjcnlwdCB0aGUgc2VlZFxuXHQgICAgdmFyIGFlc0NiYyA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jYmMoa2V5LCBpdik7XG5cdCAgICB2YXIgc2VlZCA9IGFlc19qc18xLmRlZmF1bHQucGFkZGluZy5wa2NzNy5zdHJpcChsaWIkMS5hcnJheWlmeShhZXNDYmMuZGVjcnlwdChlbmNyeXB0ZWRTZWVkKSkpO1xuXHQgICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cblx0ICAgIHZhciBzZWVkSGV4ID0gXCJcIjtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VlZC5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcblx0ICAgIH1cblx0ICAgIHZhciBzZWVkSGV4Qnl0ZXMgPSBsaWIkOC50b1V0ZjhCeXRlcyhzZWVkSGV4KTtcblx0ICAgIHZhciBwcml2YXRlS2V5ID0gbGliJDQua2VjY2FrMjU2KHNlZWRIZXhCeXRlcyk7XG5cdCAgICByZXR1cm4gbmV3IENyb3dkc2FsZUFjY291bnQoe1xuXHQgICAgICAgIF9pc0Nyb3dkc2FsZUFjY291bnQ6IHRydWUsXG5cdCAgICAgICAgYWRkcmVzczogZXRoYWRkcixcblx0ICAgICAgICBwcml2YXRlS2V5OiBwcml2YXRlS2V5XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuXG5cdH0pO1xuXG5cdHZhciBjcm93ZHNhbGUkMSA9IHVud3JhcEV4cG9ydHMoY3Jvd2RzYWxlKTtcblx0dmFyIGNyb3dkc2FsZV8xID0gY3Jvd2RzYWxlLkNyb3dkc2FsZUFjY291bnQ7XG5cdHZhciBjcm93ZHNhbGVfMiA9IGNyb3dkc2FsZS5kZWNyeXB0O1xuXG5cdHZhciBpbnNwZWN0ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGZ1bmN0aW9uIGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pIHtcblx0ICAgIHZhciBkYXRhID0gbnVsbDtcblx0ICAgIHRyeSB7XG5cdCAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICB9XG5cdCAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEuZW5jc2VlZCAmJiBkYXRhLmV0aGFkZHIpO1xuXHR9XG5cdGV4cG9ydHMuaXNDcm93ZHNhbGVXYWxsZXQgPSBpc0Nyb3dkc2FsZVdhbGxldDtcblx0ZnVuY3Rpb24gaXNLZXlzdG9yZVdhbGxldChqc29uKSB7XG5cdCAgICB2YXIgZGF0YSA9IG51bGw7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGVycm9yKSB7XG5cdCAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgfVxuXHQgICAgaWYgKCFkYXRhLnZlcnNpb24gfHwgcGFyc2VJbnQoZGF0YS52ZXJzaW9uKSAhPT0gZGF0YS52ZXJzaW9uIHx8IHBhcnNlSW50KGRhdGEudmVyc2lvbikgIT09IDMpIHtcblx0ICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICB9XG5cdCAgICAvLyBAVE9ETzogUHV0IG1vcmUgY2hlY2tzIHRvIG1ha2Ugc3VyZSBpdCBoYXMga2RmLCBpdiBhbmQgYWxsIHRoYXQgZ29vZCBzdHVmZlxuXHQgICAgcmV0dXJuIHRydWU7XG5cdH1cblx0ZXhwb3J0cy5pc0tleXN0b3JlV2FsbGV0ID0gaXNLZXlzdG9yZVdhbGxldDtcblx0Ly9leHBvcnQgZnVuY3Rpb24gaXNKc29uV2FsbGV0KGpzb246IHN0cmluZyk6IGJvb2xlYW4ge1xuXHQvLyAgICByZXR1cm4gKGlzU2VjcmV0U3RvcmFnZVdhbGxldChqc29uKSB8fCBpc0Nyb3dkc2FsZVdhbGxldChqc29uKSk7XG5cdC8vfVxuXHRmdW5jdGlvbiBnZXRKc29uV2FsbGV0QWRkcmVzcyhqc29uKSB7XG5cdCAgICBpZiAoaXNDcm93ZHNhbGVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmV0aGFkZHIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgaWYgKGlzS2V5c3RvcmVXYWxsZXQoanNvbikpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDYuZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmFkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZXhwb3J0cy5nZXRKc29uV2FsbGV0QWRkcmVzcyA9IGdldEpzb25XYWxsZXRBZGRyZXNzO1xuXG5cdH0pO1xuXG5cdHZhciBpbnNwZWN0JDEgPSB1bndyYXBFeHBvcnRzKGluc3BlY3QpO1xuXHR2YXIgaW5zcGVjdF8xID0gaW5zcGVjdC5pc0Nyb3dkc2FsZVdhbGxldDtcblx0dmFyIGluc3BlY3RfMiA9IGluc3BlY3QuaXNLZXlzdG9yZVdhbGxldDtcblx0dmFyIGluc3BlY3RfMyA9IGluc3BlY3QuZ2V0SnNvbldhbGxldEFkZHJlc3M7XG5cblx0dmFyIHNjcnlwdCA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cblx0KGZ1bmN0aW9uKHJvb3QpIHtcblx0ICAgIGNvbnN0IE1BWF9WQUxVRSA9IDB4N2ZmZmZmZmY7XG5cblx0ICAgIC8vIFRoZSBTSEEyNTYgYW5kIFBCS0RGMiBpbXBsZW1lbnRhdGlvbiBhcmUgZnJvbSBzY3J5cHQtYXN5bmMtanM6XG5cdCAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9kY2hlc3Qvc2NyeXB0LWFzeW5jLWpzXG5cdCAgICBmdW5jdGlvbiBTSEEyNTYobSkge1xuXHQgICAgICAgIGNvbnN0IEsgPSBuZXcgVWludDMyQXJyYXkoW1xuXHQgICAgICAgICAgIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsIDB4Mzk1NmMyNWIsXG5cdCAgICAgICAgICAgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSwgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSxcblx0ICAgICAgICAgICAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LFxuXHQgICAgICAgICAgIDB4YzE5YmYxNzQsIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG5cdCAgICAgICAgICAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSwgMHg5ODNlNTE1Mixcblx0ICAgICAgICAgICAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LFxuXHQgICAgICAgICAgIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsXG5cdCAgICAgICAgICAgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcblx0ICAgICAgICAgICAweGEyYmZlOGExLCAweGE4MWE2NjRiLCAweGMyNGI4YjcwLCAweGM3NmM1MWEzLCAweGQxOTJlODE5LFxuXHQgICAgICAgICAgIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsXG5cdCAgICAgICAgICAgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0Zixcblx0ICAgICAgICAgICAweDY4MmU2ZmYzLCAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LFxuXHQgICAgICAgICAgIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcblx0ICAgICAgIF0pO1xuXG5cdCAgICAgICAgbGV0IGgwID0gMHg2YTA5ZTY2NywgaDEgPSAweGJiNjdhZTg1LCBoMiA9IDB4M2M2ZWYzNzIsIGgzID0gMHhhNTRmZjUzYTtcblx0ICAgICAgICBsZXQgaDQgPSAweDUxMGU1MjdmLCBoNSA9IDB4OWIwNTY4OGMsIGg2ID0gMHgxZjgzZDlhYiwgaDcgPSAweDViZTBjZDE5O1xuXHQgICAgICAgIGNvbnN0IHcgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuXG5cdCAgICAgICAgZnVuY3Rpb24gYmxvY2tzKHApIHtcblx0ICAgICAgICAgICAgbGV0IG9mZiA9IDAsIGxlbiA9IHAubGVuZ3RoO1xuXHQgICAgICAgICAgICB3aGlsZSAobGVuID49IDY0KSB7XG5cdCAgICAgICAgICAgICAgICBsZXQgYSA9IGgwLCBiID0gaDEsIGMgPSBoMiwgZCA9IGgzLCBlID0gaDQsIGYgPSBoNSwgZyA9IGg2LCBoID0gaDcsIHUsIGksIGosIHQxLCB0MjtcblxuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBqID0gb2ZmICsgaSo0O1xuXHQgICAgICAgICAgICAgICAgICAgIHdbaV0gPSAoKHBbal0gJiAweGZmKTw8MjQpIHwgKChwW2orMV0gJiAweGZmKTw8MTYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKHBbaisyXSAmIDB4ZmYpPDw4KSB8IChwW2orM10gJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZm9yIChpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdSA9IHdbaS0yXTtcblx0ICAgICAgICAgICAgICAgICAgICB0MSA9ICgodT4+PjE3KSB8ICh1PDwoMzItMTcpKSkgXiAoKHU+Pj4xOSkgfCAodTw8KDMyLTE5KSkpIF4gKHU+Pj4xMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB1ID0gd1tpLTE1XTtcblx0ICAgICAgICAgICAgICAgICAgICB0MiA9ICgodT4+PjcpIHwgKHU8PCgzMi03KSkpIF4gKCh1Pj4+MTgpIHwgKHU8PCgzMi0xOCkpKSBeICh1Pj4+Myk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB3W2ldID0gKCgodDEgKyB3W2ktN10pIHwgMCkgKyAoKHQyICsgd1tpLTE2XSkgfCAwKSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHQxID0gKCgoKCgoZT4+PjYpIHwgKGU8PCgzMi02KSkpIF4gKChlPj4+MTEpIHwgKGU8PCgzMi0xMSkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChlPj4+MjUpIHwgKGU8PCgzMi0yNSkpKSkgKyAoKGUgJiBmKSBeICh+ZSAmIGcpKSkgfCAwKSArXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgKChoICsgKChLW2ldICsgd1tpXSkgfCAwKSkgfCAwKSkgfCAwO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdDIgPSAoKCgoYT4+PjIpIHwgKGE8PCgzMi0yKSkpIF4gKChhPj4+MTMpIHwgKGE8PCgzMi0xMykpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICgoYT4+PjIyKSB8IChhPDwoMzItMjIpKSkpICsgKChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKSkpIHwgMDtcblxuXHQgICAgICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgICAgIGYgPSBlO1xuXHQgICAgICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICAgICAgYyA9IGI7XG5cdCAgICAgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGgwID0gKGgwICsgYSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDEgPSAoaDEgKyBiKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoMiA9IChoMiArIGMpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGgzID0gKGgzICsgZCkgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDQgPSAoaDQgKyBlKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBoNSA9IChoNSArIGYpIHwgMDtcblx0ICAgICAgICAgICAgICAgIGg2ID0gKGg2ICsgZykgfCAwO1xuXHQgICAgICAgICAgICAgICAgaDcgPSAoaDcgKyBoKSB8IDA7XG5cblx0ICAgICAgICAgICAgICAgIG9mZiArPSA2NDtcblx0ICAgICAgICAgICAgICAgIGxlbiAtPSA2NDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGJsb2NrcyhtKTtcblxuXHQgICAgICAgIGxldCBpLCBieXRlc0xlZnQgPSBtLmxlbmd0aCAlIDY0LFxuXHQgICAgICAgIGJpdExlbkhpID0gKG0ubGVuZ3RoIC8gMHgyMDAwMDAwMCkgfCAwLFxuXHQgICAgICAgIGJpdExlbkxvID0gbS5sZW5ndGggPDwgMyxcblx0ICAgICAgICBudW1aZXJvcyA9IChieXRlc0xlZnQgPCA1NikgPyA1NiA6IDEyMCxcblx0ICAgICAgICBwID0gbS5zbGljZShtLmxlbmd0aCAtIGJ5dGVzTGVmdCwgbS5sZW5ndGgpO1xuXG5cdCAgICAgICAgcC5wdXNoKDB4ODApO1xuXHQgICAgICAgIGZvciAoaSA9IGJ5dGVzTGVmdCArIDE7IGkgPCBudW1aZXJvczsgaSsrKSB7IHAucHVzaCgwKTsgfVxuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDI0KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDE2KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDgpICAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDApICAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDI0KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDE2KSAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDgpICAmIDB4ZmYpO1xuXHQgICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDApICAmIDB4ZmYpO1xuXG5cdCAgICAgICAgYmxvY2tzKHApO1xuXG5cdCAgICAgICAgcmV0dXJuIFtcblx0ICAgICAgICAgICAgKGgwID4+PiAyNCkgJiAweGZmLCAoaDAgPj4+IDE2KSAmIDB4ZmYsIChoMCA+Pj4gOCkgJiAweGZmLCAoaDAgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGgxID4+PiAyNCkgJiAweGZmLCAoaDEgPj4+IDE2KSAmIDB4ZmYsIChoMSA+Pj4gOCkgJiAweGZmLCAoaDEgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGgyID4+PiAyNCkgJiAweGZmLCAoaDIgPj4+IDE2KSAmIDB4ZmYsIChoMiA+Pj4gOCkgJiAweGZmLCAoaDIgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGgzID4+PiAyNCkgJiAweGZmLCAoaDMgPj4+IDE2KSAmIDB4ZmYsIChoMyA+Pj4gOCkgJiAweGZmLCAoaDMgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg0ID4+PiAyNCkgJiAweGZmLCAoaDQgPj4+IDE2KSAmIDB4ZmYsIChoNCA+Pj4gOCkgJiAweGZmLCAoaDQgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg1ID4+PiAyNCkgJiAweGZmLCAoaDUgPj4+IDE2KSAmIDB4ZmYsIChoNSA+Pj4gOCkgJiAweGZmLCAoaDUgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg2ID4+PiAyNCkgJiAweGZmLCAoaDYgPj4+IDE2KSAmIDB4ZmYsIChoNiA+Pj4gOCkgJiAweGZmLCAoaDYgPj4+IDApICYgMHhmZixcblx0ICAgICAgICAgICAgKGg3ID4+PiAyNCkgJiAweGZmLCAoaDcgPj4+IDE2KSAmIDB4ZmYsIChoNyA+Pj4gOCkgJiAweGZmLCAoaDcgPj4+IDApICYgMHhmZlxuXHQgICAgICAgIF07XG5cdCAgICB9XG5cblx0ICAgIGZ1bmN0aW9uIFBCS0RGMl9ITUFDX1NIQTI1Nl9PbmVJdGVyKHBhc3N3b3JkLCBzYWx0LCBka0xlbikge1xuXHQgICAgICAgIC8vIGNvbXByZXNzIHBhc3N3b3JkIGlmIGl0J3MgbG9uZ2VyIHRoYW4gaGFzaCBibG9jayBsZW5ndGhcblx0ICAgICAgICBwYXNzd29yZCA9IChwYXNzd29yZC5sZW5ndGggPD0gNjQpID8gcGFzc3dvcmQgOiBTSEEyNTYocGFzc3dvcmQpO1xuXG5cdCAgICAgICAgY29uc3QgaW5uZXJMZW4gPSA2NCArIHNhbHQubGVuZ3RoICsgNDtcblx0ICAgICAgICBjb25zdCBpbm5lciA9IG5ldyBBcnJheShpbm5lckxlbik7XG5cdCAgICAgICAgY29uc3Qgb3V0ZXJLZXkgPSBuZXcgQXJyYXkoNjQpO1xuXG5cdCAgICAgICAgbGV0IGk7XG5cdCAgICAgICAgbGV0IGRrID0gW107XG5cblx0ICAgICAgICAvLyBpbm5lciA9IChwYXNzd29yZCBeIGlwYWQpIHx8IHNhbHQgfHwgY291bnRlclxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7IGlubmVyW2ldID0gMHgzNjsgfVxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXNzd29yZC5sZW5ndGg7IGkrKykgeyBpbm5lcltpXSBePSBwYXNzd29yZFtpXTsgfVxuXHQgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzYWx0Lmxlbmd0aDsgaSsrKSB7IGlubmVyWzY0ICsgaV0gPSBzYWx0W2ldOyB9XG5cdCAgICAgICAgZm9yIChpID0gaW5uZXJMZW4gLSA0OyBpIDwgaW5uZXJMZW47IGkrKykgeyBpbm5lcltpXSA9IDA7IH1cblxuXHQgICAgICAgIC8vIG91dGVyS2V5ID0gcGFzc3dvcmQgXiBvcGFkXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IDY0OyBpKyspIG91dGVyS2V5W2ldID0gMHg1Yztcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIG91dGVyS2V5W2ldIF49IHBhc3N3b3JkW2ldO1xuXG5cdCAgICAgICAgLy8gaW5jcmVtZW50cyBjb3VudGVyIGluc2lkZSBpbm5lclxuXHQgICAgICAgIGZ1bmN0aW9uIGluY3JlbWVudENvdW50ZXIoKSB7XG5cdCAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbm5lckxlbiAtIDE7IGkgPj0gaW5uZXJMZW4gLSA0OyBpLS0pIHtcblx0ICAgICAgICAgICAgICAgIGlubmVyW2ldKys7XG5cdCAgICAgICAgICAgICAgICBpZiAoaW5uZXJbaV0gPD0gMHhmZikgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgaW5uZXJbaV0gPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgLy8gb3V0cHV0IGJsb2NrcyA9IFNIQTI1NihvdXRlcktleSB8fCBTSEEyNTYoaW5uZXIpKSAuLi5cblx0ICAgICAgICB3aGlsZSAoZGtMZW4gPj0gMzIpIHtcblx0ICAgICAgICAgICAgaW5jcmVtZW50Q291bnRlcigpO1xuXHQgICAgICAgICAgICBkayA9IGRrLmNvbmNhdChTSEEyNTYob3V0ZXJLZXkuY29uY2F0KFNIQTI1Nihpbm5lcikpKSk7XG5cdCAgICAgICAgICAgIGRrTGVuIC09IDMyO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoZGtMZW4gPiAwKSB7XG5cdCAgICAgICAgICAgIGluY3JlbWVudENvdW50ZXIoKTtcblx0ICAgICAgICAgICAgZGsgPSBkay5jb25jYXQoU0hBMjU2KG91dGVyS2V5LmNvbmNhdChTSEEyNTYoaW5uZXIpKSkuc2xpY2UoMCwgZGtMZW4pKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gZGs7XG5cdCAgICB9XG5cblx0ICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYW4gYWRhcHRhdGlvbiBvZiBzY3J5cHRzeVxuXHQgICAgLy8gU2VlOiBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9zY3J5cHRzeVxuXHQgICAgZnVuY3Rpb24gYmxvY2ttaXhfc2Fsc2E4KEJZLCBZaSwgciwgeCwgX1gpIHtcblx0ICAgICAgICBsZXQgaTtcblxuXHQgICAgICAgIGFycmF5Y29weShCWSwgKDIgKiByIC0gMSkgKiAxNiwgX1gsIDAsIDE2KTtcblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMiAqIHI7IGkrKykge1xuXHQgICAgICAgICAgICBibG9ja3hvcihCWSwgaSAqIDE2LCBfWCwgMTYpO1xuXHQgICAgICAgICAgICBzYWxzYTIwXzgoX1gsIHgpO1xuXHQgICAgICAgICAgICBhcnJheWNvcHkoX1gsIDAsIEJZLCBZaSArIChpICogMTYpLCAxNik7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuXHQgICAgICAgICAgICBhcnJheWNvcHkoQlksIFlpICsgKGkgKiAyKSAqIDE2LCBCWSwgKGkgKiAxNiksIDE2KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGFycmF5Y29weShCWSwgWWkgKyAoaSAqIDIgKyAxKSAqIDE2LCBCWSwgKGkgKyByKSAqIDE2LCAxNik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBSKGEsIGIpIHtcblx0ICAgICAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBzYWxzYTIwXzgoQiwgeCkge1xuXHQgICAgICAgIGFycmF5Y29weShCLCAwLCB4LCAwLCAxNik7XG5cblx0ICAgICAgICBmb3IgKGxldCBpID0gODsgaSA+IDA7IGkgLT0gMikge1xuXHQgICAgICAgICAgICB4WyA0XSBePSBSKHhbIDBdICsgeFsxMl0sIDcpO1xuXHQgICAgICAgICAgICB4WyA4XSBePSBSKHhbIDRdICsgeFsgMF0sIDkpO1xuXHQgICAgICAgICAgICB4WzEyXSBePSBSKHhbIDhdICsgeFsgNF0sIDEzKTtcblx0ICAgICAgICAgICAgeFsgMF0gXj0gUih4WzEyXSArIHhbIDhdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbIDldIF49IFIoeFsgNV0gKyB4WyAxXSwgNyk7XG5cdCAgICAgICAgICAgIHhbMTNdIF49IFIoeFsgOV0gKyB4WyA1XSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDFdIF49IFIoeFsxM10gKyB4WyA5XSwgMTMpO1xuXHQgICAgICAgICAgICB4WyA1XSBePSBSKHhbIDFdICsgeFsxM10sIDE4KTtcblx0ICAgICAgICAgICAgeFsxNF0gXj0gUih4WzEwXSArIHhbIDZdLCA3KTtcblx0ICAgICAgICAgICAgeFsgMl0gXj0gUih4WzE0XSArIHhbMTBdLCA5KTtcblx0ICAgICAgICAgICAgeFsgNl0gXj0gUih4WyAyXSArIHhbMTRdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbMTBdIF49IFIoeFsgNl0gKyB4WyAyXSwgMTgpO1xuXHQgICAgICAgICAgICB4WyAzXSBePSBSKHhbMTVdICsgeFsxMV0sIDcpO1xuXHQgICAgICAgICAgICB4WyA3XSBePSBSKHhbIDNdICsgeFsxNV0sIDkpO1xuXHQgICAgICAgICAgICB4WzExXSBePSBSKHhbIDddICsgeFsgM10sIDEzKTtcblx0ICAgICAgICAgICAgeFsxNV0gXj0gUih4WzExXSArIHhbIDddLCAxOCk7XG5cdCAgICAgICAgICAgIHhbIDFdIF49IFIoeFsgMF0gKyB4WyAzXSwgNyk7XG5cdCAgICAgICAgICAgIHhbIDJdIF49IFIoeFsgMV0gKyB4WyAwXSwgOSk7XG5cdCAgICAgICAgICAgIHhbIDNdIF49IFIoeFsgMl0gKyB4WyAxXSwgMTMpO1xuXHQgICAgICAgICAgICB4WyAwXSBePSBSKHhbIDNdICsgeFsgMl0sIDE4KTtcblx0ICAgICAgICAgICAgeFsgNl0gXj0gUih4WyA1XSArIHhbIDRdLCA3KTtcblx0ICAgICAgICAgICAgeFsgN10gXj0gUih4WyA2XSArIHhbIDVdLCA5KTtcblx0ICAgICAgICAgICAgeFsgNF0gXj0gUih4WyA3XSArIHhbIDZdLCAxMyk7XG5cdCAgICAgICAgICAgIHhbIDVdIF49IFIoeFsgNF0gKyB4WyA3XSwgMTgpO1xuXHQgICAgICAgICAgICB4WzExXSBePSBSKHhbMTBdICsgeFsgOV0sIDcpO1xuXHQgICAgICAgICAgICB4WyA4XSBePSBSKHhbMTFdICsgeFsxMF0sIDkpO1xuXHQgICAgICAgICAgICB4WyA5XSBePSBSKHhbIDhdICsgeFsxMV0sIDEzKTtcblx0ICAgICAgICAgICAgeFsxMF0gXj0gUih4WyA5XSArIHhbIDhdLCAxOCk7XG5cdCAgICAgICAgICAgIHhbMTJdIF49IFIoeFsxNV0gKyB4WzE0XSwgNyk7XG5cdCAgICAgICAgICAgIHhbMTNdIF49IFIoeFsxMl0gKyB4WzE1XSwgOSk7XG5cdCAgICAgICAgICAgIHhbMTRdIF49IFIoeFsxM10gKyB4WzEyXSwgMTMpO1xuXHQgICAgICAgICAgICB4WzE1XSBePSBSKHhbMTRdICsgeFsxM10sIDE4KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcblx0ICAgICAgICAgICAgQltpXSArPSB4W2ldO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gbmFpdmUgYXBwcm9hY2guLi4gZ29pbmcgYmFjayB0byBsb29wIHVucm9sbGluZyBtYXkgeWllbGQgYWRkaXRpb25hbCBwZXJmb3JtYW5jZVxuXHQgICAgZnVuY3Rpb24gYmxvY2t4b3IoUywgU2ksIEQsIGxlbikge1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0ICAgICAgICAgICAgRFtpXSBePSBTW1NpICsgaV07XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBhcnJheWNvcHkoc3JjLCBzcmNQb3MsIGRlc3QsIGRlc3RQb3MsIGxlbmd0aCkge1xuXHQgICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuXHQgICAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gY2hlY2tCdWZmZXJpc2gobykge1xuXHQgICAgICAgIGlmICghbyB8fCB0eXBlb2Yoby5sZW5ndGgpICE9PSAnbnVtYmVyJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb25zdCB2ID0gb1tpXTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZih2KSAhPT0gJ251bWJlcicgfHwgdiAlIDEgfHwgdiA8IDAgfHwgdiA+PSAyNTYpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgfVxuXG5cdCAgICBmdW5jdGlvbiBlbnN1cmVJbnRlZ2VyKHZhbHVlLCBuYW1lKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgIT09IFwibnVtYmVyXCIgfHwgKHZhbHVlICUgMSkpIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkICcgKyBuYW1lKTsgfVxuXHQgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgIH1cblxuXHQgICAgLy8gTiA9IENwdSBjb3N0LCByID0gTWVtb3J5IGNvc3QsIHAgPSBwYXJhbGxlbGl6YXRpb24gY29zdFxuXHQgICAgLy8gY2FsbGJhY2soZXJyb3IsIHByb2dyZXNzLCBrZXkpXG5cdCAgICBmdW5jdGlvbiBfc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgY2FsbGJhY2spIHtcblxuXHQgICAgICAgIE4gPSBlbnN1cmVJbnRlZ2VyKE4sICdOJyk7XG5cdCAgICAgICAgciA9IGVuc3VyZUludGVnZXIociwgJ3InKTtcblx0ICAgICAgICBwID0gZW5zdXJlSW50ZWdlcihwLCAncCcpO1xuXG5cdCAgICAgICAgZGtMZW4gPSBlbnN1cmVJbnRlZ2VyKGRrTGVuLCAnZGtMZW4nKTtcblxuXHQgICAgICAgIGlmIChOID09PSAwIHx8IChOICYgKE4gLSAxKSkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOIG11c3QgYmUgcG93ZXIgb2YgMicpOyB9XG5cblx0ICAgICAgICBpZiAoTiA+IE1BWF9WQUxVRSAvIDEyOCAvIHIpIHsgdGhyb3cgbmV3IEVycm9yKCdOIHRvbyBsYXJnZScpOyB9XG5cdCAgICAgICAgaWYgKHIgPiBNQVhfVkFMVUUgLyAxMjggLyBwKSB7IHRocm93IG5ldyBFcnJvcignciB0b28gbGFyZ2UnKTsgfVxuXG5cdCAgICAgICAgaWYgKCFjaGVja0J1ZmZlcmlzaChwYXNzd29yZCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXNzd29yZCBtdXN0IGJlIGFuIGFycmF5IG9yIGJ1ZmZlcicpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBwYXNzd29yZCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHBhc3N3b3JkKTtcblxuXHQgICAgICAgIGlmICghY2hlY2tCdWZmZXJpc2goc2FsdCkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYWx0IG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyJyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHNhbHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChzYWx0KTtcblxuXHQgICAgICAgIGxldCBiID0gUEJLREYyX0hNQUNfU0hBMjU2X09uZUl0ZXIocGFzc3dvcmQsIHNhbHQsIHAgKiAxMjggKiByKTtcblx0ICAgICAgICBjb25zdCBCID0gbmV3IFVpbnQzMkFycmF5KHAgKiAzMiAqIHIpO1xuXHQgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgQi5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICBjb25zdCBqID0gaSAqIDQ7XG5cdCAgICAgICAgICAgIEJbaV0gPSAoKGJbaiArIDNdICYgMHhmZikgPDwgMjQpIHxcblx0ICAgICAgICAgICAgICAgICAgICgoYltqICsgMl0gJiAweGZmKSA8PCAxNikgfFxuXHQgICAgICAgICAgICAgICAgICAgKChiW2ogKyAxXSAmIDB4ZmYpIDw8IDgpIHxcblx0ICAgICAgICAgICAgICAgICAgICgoYltqICsgMF0gJiAweGZmKSA8PCAwKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBjb25zdCBYWSA9IG5ldyBVaW50MzJBcnJheSg2NCAqIHIpO1xuXHQgICAgICAgIGNvbnN0IFYgPSBuZXcgVWludDMyQXJyYXkoMzIgKiByICogTik7XG5cblx0ICAgICAgICBjb25zdCBZaSA9IDMyICogcjtcblxuXHQgICAgICAgIC8vIHNjcmF0Y2ggc3BhY2Vcblx0ICAgICAgICBjb25zdCB4ID0gbmV3IFVpbnQzMkFycmF5KDE2KTsgICAgICAgLy8gc2Fsc2EyMF84XG5cdCAgICAgICAgY29uc3QgX1ggPSBuZXcgVWludDMyQXJyYXkoMTYpOyAgICAgIC8vIGJsb2NrbWl4X3NhbHNhOFxuXG5cdCAgICAgICAgY29uc3QgdG90YWxPcHMgPSBwICogTiAqIDI7XG5cdCAgICAgICAgbGV0IGN1cnJlbnRPcCA9IDA7XG5cdCAgICAgICAgbGV0IGxhc3RQZXJjZW50MTAgPSBudWxsO1xuXG5cdCAgICAgICAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSB0byBhYmFuZG9uIHRoZSBzY3J5cHQgb24gdGhlIG5leHQgc3RlcFxuXHQgICAgICAgIGxldCBzdG9wID0gZmFsc2U7XG5cblx0ICAgICAgICAvLyBTdGF0ZSBpbmZvcm1hdGlvblxuXHQgICAgICAgIGxldCBzdGF0ZSA9IDA7XG5cdCAgICAgICAgbGV0IGkwID0gMCwgaTE7XG5cdCAgICAgICAgbGV0IEJpO1xuXG5cdCAgICAgICAgLy8gSG93IG1hbnkgYmxvY2ttaXhfc2Fsc2E4IGNhbiB3ZSBkbyBwZXIgc3RlcD9cblx0ICAgICAgICBjb25zdCBsaW1pdCA9IGNhbGxiYWNrID8gcGFyc2VJbnQoMTAwMCAvIHIpOiAweGZmZmZmZmZmO1xuXG5cdCAgICAgICAgLy8gVHJpY2sgZnJvbSBzY3J5cHQtYXN5bmM7IGlmIHRoZXJlIGlzIGEgc2V0SW1tZWRpYXRlIHNoaW0gaW4gcGxhY2UsIHVzZSBpdFxuXHQgICAgICAgIGNvbnN0IG5leHRUaWNrID0gKHR5cGVvZihzZXRJbW1lZGlhdGUpICE9PSAndW5kZWZpbmVkJykgPyBzZXRJbW1lZGlhdGUgOiBzZXRUaW1lb3V0O1xuXG5cdCAgICAgICAgLy8gVGhpcyBpcyByZWFsbHkgYWxsIEkgY2hhbmdlZDsgbWFraW5nIHNjcnlwdHN5IGEgc3RhdGUgbWFjaGluZSBzbyB3ZSBvY2Nhc2lvbmFsbHlcblx0ICAgICAgICAvLyBzdG9wIGFuZCBnaXZlIG90aGVyIGV2bnRzIG9uIHRoZSBldm50IGxvb3AgYSBjaGFuY2UgdG8gcnVuLiB+UmljTW9vXG5cdCAgICAgICAgY29uc3QgaW5jcmVtZW50YWxTTWl4ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGlmIChzdG9wKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobmV3IEVycm9yKCdjYW5jZWxsZWQnKSwgY3VycmVudE9wIC8gdG90YWxPcHMpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgbGV0IHN0ZXBzO1xuXG5cdCAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHA7IGkrKykuLi5cblx0ICAgICAgICAgICAgICAgICAgICBCaSA9IGkwICogMzIgKiByO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgYXJyYXljb3B5KEIsIEJpLCBYWSwgMCwgWWkpOyAgICAgICAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSAxXG5cblx0ICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIFJPTWl4IDJcblx0ICAgICAgICAgICAgICAgICAgICBpMSA9IDA7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBGYWxsIHRocm91Z2hcblxuXHQgICAgICAgICAgICAgICAgY2FzZSAxOlxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUnVuIHVwIHRvIDEwMDAgc3RlcHMgb2YgdGhlIGZpcnN0IGlubmVyIHNtaXggbG9vcFxuXHQgICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gTiAtIGkxO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGVwcyA+IGxpbWl0KSB7IHN0ZXBzID0gbGltaXQ7IH1cblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzOyBpKyspIHsgICAgICAgICAgICAgICAgICAvLyBST01peCAtIDJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXJyYXljb3B5KFhZLCAwLCBWLCAoaTEgKyBpKSAqIFlpLCBZaSk7ICAgICAgICAgLy8gUk9NaXggLSAzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrbWl4X3NhbHNhOChYWSwgWWksIHIsIHgsIF9YKTsgICAgICAgICAgICAgLy8gUk9NaXggLSA0XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspXG5cdCAgICAgICAgICAgICAgICAgICAgaTEgKz0gc3RlcHM7XG5cdCAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wICs9IHN0ZXBzO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrIHdpdGggdGhlIHByb2dyZXNzIChvcHRpb25hbGx5IHN0b3BwaW5nIHVzKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50MTAgPSBwYXJzZUludCgxMDAwICogY3VycmVudE9wIC8gdG90YWxPcHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGVyY2VudDEwICE9PSBsYXN0UGVyY2VudDEwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0gY2FsbGJhY2sobnVsbCwgY3VycmVudE9wIC8gdG90YWxPcHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQZXJjZW50MTAgPSBwZXJjZW50MTA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaTEgPCBOKSB7IGJyZWFrOyB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBpMSA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBST01peCA2XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cblx0ICAgICAgICAgICAgICAgIGNhc2UgMjpcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byAxMDAwIHN0ZXBzIG9mIHRoZSBzZWNvbmQgaW5uZXIgc21peCBsb29wXG5cdCAgICAgICAgICAgICAgICAgICAgc3RlcHMgPSBOIC0gaTE7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXBzID4gbGltaXQpIHsgc3RlcHMgPSBsaW1pdDsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykgeyAgICAgICAgICAgICAgICAvLyBST01peCAtIDZcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gKDIgKiByIC0gMSkgKiAxNjsgICAgICAgICAgICAgLy8gUk9NaXggLSA3XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGogPSBYWVtvZmZzZXRdICYgKE4gLSAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2t4b3IoViwgaiAqIFlpLCBYWSwgWWkpOyAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSA4IChpbm5lcilcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2ttaXhfc2Fsc2E4KFhZLCBZaSwgciwgeCwgX1gpOyAgICAgICAgICAgLy8gUk9NaXggLSA5IChvdXRlcilcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykuLi5cblx0ICAgICAgICAgICAgICAgICAgICBpMSArPSBzdGVwcztcblx0ICAgICAgICAgICAgICAgICAgICBjdXJyZW50T3AgKz0gc3RlcHM7XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcm9ncmVzcyAob3B0aW9uYWxseSBzdG9wcGluZyB1cylcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudDEwID0gcGFyc2VJbnQoMTAwMCAqIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQxMCAhPT0gbGFzdFBlcmNlbnQxMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGNhbGxiYWNrKG51bGwsIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGVyY2VudDEwID0gcGVyY2VudDEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkxIDwgTikgeyBicmVhazsgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAgYXJyYXljb3B5KFhZLCAwLCBCLCBCaSwgWWkpOyAgICAgICAgICAgICAgICAgICAgIC8vIFJPTWl4IC0gMTBcblxuXHQgICAgICAgICAgICAgICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgcDsgaSsrKS4uLlxuXHQgICAgICAgICAgICAgICAgICAgIGkwKys7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGkwIDwgcCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGIgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEIubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKChCW2ldID4+ICAwKSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBiLnB1c2goKEJbaV0gPj4gIDgpICYgMHhmZik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAxNikgJiAweGZmKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYi5wdXNoKChCW2ldID4+IDI0KSAmIDB4ZmYpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBQQktERjJfSE1BQ19TSEEyNTZfT25lSXRlcihwYXNzd29yZCwgYiwgZGtMZW4pO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCB0aGUgcmVzdWx0IHRvIHRoZSBjYWxsYmFja1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhudWxsLCAxLjAsIGRlcml2ZWRLZXkpOyB9XG5cblx0ICAgICAgICAgICAgICAgICAgICAvLyBEb25lOyBkb24ndCBicmVhayAod2hpY2ggd291bGQgcmVzY2hlZHVsZSlcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBuZXh0IHN0ZXBzXG5cdCAgICAgICAgICAgIGlmIChjYWxsYmFjaykgeyBuZXh0VGljayhpbmNyZW1lbnRhbFNNaXgpOyB9XG5cdCAgICAgICAgfTtcblxuXHQgICAgICAgIC8vIFJ1biB0aGUgc21peCBzdGF0ZSBtYWNoaW5lIHVudGlsIGNvbXBsZXRpb25cblx0ICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG5cdCAgICAgICAgICAgICAgICBjb25zdCBkZXJpdmVkS2V5ID0gaW5jcmVtZW50YWxTTWl4KCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZGVyaXZlZEtleSAhPSB1bmRlZmluZWQpIHsgcmV0dXJuIGRlcml2ZWRLZXk7IH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgYXN5bmMgaW5jcmVtZW50YWwgc21peFxuXHQgICAgICAgIGluY3JlbWVudGFsU01peCgpO1xuXHQgICAgfVxuXG5cdCAgICBjb25zdCBsaWIgPSB7XG5cdCAgICAgICAgc2NyeXB0OiBmdW5jdGlvbihwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4sIHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgbGV0IGxhc3RQcm9ncmVzcyA9IDA7XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjaykgeyBwcm9ncmVzc0NhbGxiYWNrKDApOyB9XG5cdCAgICAgICAgICAgICAgICBfc2NyeXB0KHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbiwgZnVuY3Rpb24oZXJyb3IsIHByb2dyZXNzLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAmJiBsYXN0UHJvZ3Jlc3MgIT09IDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShrZXkpKTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHByb2dyZXNzQ2FsbGJhY2sgJiYgcHJvZ3Jlc3MgIT09IGxhc3RQcm9ncmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UHJvZ3Jlc3MgPSBwcm9ncmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzQ2FsbGJhY2socHJvZ3Jlc3MpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHN5bmNTY3J5cHQ6IGZ1bmN0aW9uKHBhc3N3b3JkLCBzYWx0LCBOLCByLCBwLCBka0xlbikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX3NjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvLyBub2RlLmpzXG5cdCAgICBpZiAoJ29iamVjdCcgIT09ICd1bmRlZmluZWQnKSB7XG5cdCAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuXHQgICAgLy8gUmVxdWlyZUpTL0FNRFxuXHQgICAgLy8gaHR0cDovL3d3dy5yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWxcblx0ICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTURcblx0ICAgIH0gZWxzZSBpZiAodHlwZW9mKHVuZGVmaW5lZCkgPT09ICdmdW5jdGlvbicgJiYgdW5kZWZpbmVkLmFtZCkge1xuXHQgICAgICAgIHVuZGVmaW5lZChsaWIpO1xuXG5cdCAgICAvLyBXZWIgQnJvd3NlcnNcblx0ICAgIH0gZWxzZSBpZiAocm9vdCkge1xuXG5cdCAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGxpYnJhcnkgXCJzY3J5cHRcIiwgbWFrZSBzdXJlIGl0IGlzIHN0aWxsIGF2YWlsYWJsZVxuXHQgICAgICAgIGlmIChyb290LnNjcnlwdCkge1xuXHQgICAgICAgICAgICByb290Ll9zY3J5cHQgPSByb290LnNjcnlwdDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICByb290LnNjcnlwdCA9IGxpYjtcblx0ICAgIH1cblxuXHR9KShjb21tb25qc0dsb2JhbCk7XG5cdH0pO1xuXHR2YXIgc2NyeXB0XzEgPSBzY3J5cHQuc2NyeXB0O1xuXHR2YXIgc2NyeXB0XzIgPSBzY3J5cHQuc3luY1NjcnlwdDtcblxuXHR2YXIga2V5c3RvcmUgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdHZhciBfX2ltcG9ydERlZmF1bHQgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcblx0fTtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIGFlc19qc18xID0gX19pbXBvcnREZWZhdWx0KGFlc0pzKTtcblx0dmFyIHNjcnlwdCQxID0gX19pbXBvcnRTdGFyKHNjcnlwdCk7XG5cblxuXG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kQS52ZXJzaW9uKTtcblx0Ly8gRXhwb3J0ZWQgVHlwZXNcblx0ZnVuY3Rpb24gaGFzTW5lbW9uaWModmFsdWUpIHtcblx0ICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5tbmVtb25pYyAmJiB2YWx1ZS5tbmVtb25pYy5waHJhc2UpO1xuXHR9XG5cdHZhciBLZXlzdG9yZUFjY291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoS2V5c3RvcmVBY2NvdW50LCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gS2V5c3RvcmVBY2NvdW50KCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEtleXN0b3JlQWNjb3VudC5wcm90b3R5cGUuaXNLZXlzdG9yZUFjY291bnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzS2V5c3RvcmVBY2NvdW50KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gS2V5c3RvcmVBY2NvdW50O1xuXHR9KGxpYiQzLkRlc2NyaXB0aW9uKSk7XG5cdGV4cG9ydHMuS2V5c3RvcmVBY2NvdW50ID0gS2V5c3RvcmVBY2NvdW50O1xuXHRmdW5jdGlvbiBfZGVjcnlwdChkYXRhLCBrZXksIGNpcGhlcnRleHQpIHtcblx0ICAgIHZhciBjaXBoZXIgPSB1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vY2lwaGVyXCIpO1xuXHQgICAgaWYgKGNpcGhlciA9PT0gXCJhZXMtMTI4LWN0clwiKSB7XG5cdCAgICAgICAgdmFyIGl2ID0gdXRpbHMkMS5sb29zZUFycmF5aWZ5KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9jaXBoZXJwYXJhbXMvaXZcIikpO1xuXHQgICAgICAgIHZhciBjb3VudGVyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuQ291bnRlcihpdik7XG5cdCAgICAgICAgdmFyIGFlc0N0ciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIoa2V5LCBjb3VudGVyKTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkoYWVzQ3RyLmRlY3J5cHQoY2lwaGVydGV4dCkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG51bGw7XG5cdH1cblx0ZnVuY3Rpb24gX2dldEFjY291bnQoZGF0YSwga2V5KSB7XG5cdCAgICB2YXIgY2lwaGVydGV4dCA9IHV0aWxzJDEubG9vc2VBcnJheWlmeSh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vY2lwaGVydGV4dFwiKSk7XG5cdCAgICB2YXIgY29tcHV0ZWRNQUMgPSBsaWIkMS5oZXhsaWZ5KGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW2tleS5zbGljZSgxNiwgMzIpLCBjaXBoZXJ0ZXh0XSkpKS5zdWJzdHJpbmcoMik7XG5cdCAgICBpZiAoY29tcHV0ZWRNQUMgIT09IHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9tYWNcIikudG9Mb3dlckNhc2UoKSkge1xuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGFzc3dvcmRcIik7XG5cdCAgICB9XG5cdCAgICB2YXIgcHJpdmF0ZUtleSA9IF9kZWNyeXB0KGRhdGEsIGtleS5zbGljZSgwLCAxNiksIGNpcGhlcnRleHQpO1xuXHQgICAgaWYgKCFwcml2YXRlS2V5KSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBjaXBoZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJkZWNyeXB0XCJcblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHZhciBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuXHQgICAgdmFyIGFkZHJlc3MgPSBsaWIkZy5jb21wdXRlQWRkcmVzcyhwcml2YXRlS2V5KTtcblx0ICAgIGlmIChkYXRhLmFkZHJlc3MpIHtcblx0ICAgICAgICB2YXIgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBpZiAoY2hlY2suc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgY2hlY2sgPSBcIjB4XCIgKyBjaGVjaztcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGxpYiQ2LmdldEFkZHJlc3MoY2hlY2spICE9PSBhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZHJlc3MgbWlzbWF0Y2hcIik7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgdmFyIGFjY291bnQgPSB7XG5cdCAgICAgICAgX2lzS2V5c3RvcmVBY2NvdW50OiB0cnVlLFxuXHQgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG5cdCAgICAgICAgcHJpdmF0ZUtleTogbGliJDEuaGV4bGlmeShwcml2YXRlS2V5KVxuXHQgICAgfTtcblx0ICAgIC8vIFZlcnNpb24gMC4xIHgtZXRoZXJzIG1ldGFkYXRhIG11c3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbW5lbW9uaWMgcGhyYXNlXG5cdCAgICBpZiAodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwieC1ldGhlcnMvdmVyc2lvblwiKSA9PT0gXCIwLjFcIikge1xuXHQgICAgICAgIHZhciBtbmVtb25pY0NpcGhlcnRleHQgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwieC1ldGhlcnMvbW5lbW9uaWNDaXBoZXJ0ZXh0XCIpKTtcblx0ICAgICAgICB2YXIgbW5lbW9uaWNJdiA9IHV0aWxzJDEubG9vc2VBcnJheWlmeSh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9tbmVtb25pY0NvdW50ZXJcIikpO1xuXHQgICAgICAgIHZhciBtbmVtb25pY0NvdW50ZXIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Db3VudGVyKG1uZW1vbmljSXYpO1xuXHQgICAgICAgIHZhciBtbmVtb25pY0Flc0N0ciA9IG5ldyBhZXNfanNfMS5kZWZhdWx0Lk1vZGVPZk9wZXJhdGlvbi5jdHIobW5lbW9uaWNLZXksIG1uZW1vbmljQ291bnRlcik7XG5cdCAgICAgICAgdmFyIHBhdGggPSB1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9wYXRoXCIpIHx8IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHQgICAgICAgIHZhciBsb2NhbGUgPSB1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9sb2NhbGVcIikgfHwgXCJlblwiO1xuXHQgICAgICAgIHZhciBlbnRyb3B5ID0gbGliJDEuYXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZGVjcnlwdChtbmVtb25pY0NpcGhlcnRleHQpKTtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWMgPSBsaWIkaC5lbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCBsb2NhbGUpO1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG51bGwsIGxvY2FsZSkuZGVyaXZlUGF0aChwYXRoKTtcblx0ICAgICAgICAgICAgaWYgKG5vZGUucHJpdmF0ZUtleSAhPSBhY2NvdW50LnByaXZhdGVLZXkpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1uZW1vbmljIG1pc21hdGNoXCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGFjY291bnQubW5lbW9uaWMgPSBub2RlLm1uZW1vbmljO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSB0aGUgbG9jYWxlIHdvcmRsaXN0IGluc3RhbGxlZCB0b1xuXHQgICAgICAgICAgICAvLyByZWFkIHRoaXMgbW5lbW9uaWMsIGp1c3QgYmFpbCBhbmQgZG9uJ3Qgc2V0IHRoZVxuXHQgICAgICAgICAgICAvLyBtbmVtb25pY1xuXHQgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gbGliLkxvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCB8fCBlcnJvci5hcmd1bWVudCAhPT0gXCJ3b3JkbGlzdFwiKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBuZXcgS2V5c3RvcmVBY2NvdW50KGFjY291bnQpO1xuXHR9XG5cdGZ1bmN0aW9uIHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSB7XG5cdCAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkoYnJvd3NlciQyLnBia2RmMihwYXNzd29yZEJ5dGVzLCBzYWx0LCBjb3VudCwgZGtMZW4sIHByZkZ1bmMpKTtcblx0fVxuXHRmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSB7XG5cdCAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSk7XG5cdH1cblx0ZnVuY3Rpb24gX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMkZ1bmMsIHNjcnlwdEZ1bmMsIHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgIHZhciBwYXNzd29yZEJ5dGVzID0gdXRpbHMkMS5nZXRQYXNzd29yZChwYXNzd29yZCk7XG5cdCAgICB2YXIga2RmID0gdXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZlwiKTtcblx0ICAgIGlmIChrZGYgJiYgdHlwZW9mIChrZGYpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIHRocm93RXJyb3IgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIiwgbmFtZSwgdmFsdWUpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInNjcnlwdFwiKSB7XG5cdCAgICAgICAgICAgIHZhciBzYWx0ID0gdXRpbHMkMS5sb29zZUFycmF5aWZ5KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvc2FsdFwiKSk7XG5cdCAgICAgICAgICAgIHZhciBOID0gcGFyc2VJbnQodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9uXCIpKTtcblx0ICAgICAgICAgICAgdmFyIHIgPSBwYXJzZUludCh1dGlscyQxLnNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3JcIikpO1xuXHQgICAgICAgICAgICB2YXIgcCA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvcFwiKSk7XG5cdCAgICAgICAgICAgIC8vIENoZWNrIGZvciBhbGwgcmVxdWlyZWQgcGFyYW1ldGVyc1xuXHQgICAgICAgICAgICBpZiAoIU4gfHwgIXIgfHwgIXApIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJrZGZcIiwga2RmKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgTiBpcyBhIHBvd2VyIG9mIDJcblx0ICAgICAgICAgICAgaWYgKChOICYgKE4gLSAxKSkgIT09IDApIHtcblx0ICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJOXCIsIE4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBka0xlbiA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvZGtsZW5cIikpO1xuXHQgICAgICAgICAgICBpZiAoZGtMZW4gIT09IDMyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiZGtsZW5cIiwgZGtMZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBzY3J5cHRGdW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIE4sIHIsIHAsIDY0LCBwcm9ncmVzc0NhbGxiYWNrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwicGJrZGYyXCIpIHtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSB1dGlscyQxLmxvb3NlQXJyYXlpZnkodXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9zYWx0XCIpKTtcblx0ICAgICAgICAgICAgdmFyIHByZkZ1bmMgPSBudWxsO1xuXHQgICAgICAgICAgICB2YXIgcHJmID0gdXRpbHMkMS5zZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9wcmZcIik7XG5cdCAgICAgICAgICAgIGlmIChwcmYgPT09IFwiaG1hYy1zaGEyNTZcIikge1xuXHQgICAgICAgICAgICAgICAgcHJmRnVuYyA9IFwic2hhMjU2XCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocHJmID09PSBcImhtYWMtc2hhNTEyXCIpIHtcblx0ICAgICAgICAgICAgICAgIHByZkZ1bmMgPSBcInNoYTUxMlwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcInByZlwiLCBwcmYpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBjb3VudCA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvY1wiKSk7XG5cdCAgICAgICAgICAgIHZhciBka0xlbiA9IHBhcnNlSW50KHV0aWxzJDEuc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvZGtsZW5cIikpO1xuXHQgICAgICAgICAgICBpZiAoZGtMZW4gIT09IDMyKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiZGtsZW5cIiwgZGtMZW4pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwYmtkZjJGdW5jKHBhc3N3b3JkQnl0ZXMsIHNhbHQsIGNvdW50LCBka0xlbiwgcHJmRnVuYyk7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBrZXktZGVyaXZhdGlvbiBmdW5jdGlvblwiLCBcImtkZlwiLCBrZGYpO1xuXHR9XG5cdGZ1bmN0aW9uIGRlY3J5cHRTeW5jKGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG5cdCAgICB2YXIga2V5ID0gX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMlN5bmMsIHNjcnlwdCQxLnN5bmNTY3J5cHQpO1xuXHQgICAgcmV0dXJuIF9nZXRBY2NvdW50KGRhdGEsIGtleSk7XG5cdH1cblx0ZXhwb3J0cy5kZWNyeXB0U3luYyA9IGRlY3J5cHRTeW5jO1xuXHRmdW5jdGlvbiBkZWNyeXB0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIGRhdGEsIGtleTtcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfY29tcHV0ZUtkZktleShkYXRhLCBwYXNzd29yZCwgcGJrZGYyLCBzY3J5cHQkMS5zY3J5cHQsIHByb2dyZXNzQ2FsbGJhY2spXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICBrZXkgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9nZXRBY2NvdW50KGRhdGEsIGtleSldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cdCAgICB9KTtcblx0fVxuXHRleHBvcnRzLmRlY3J5cHQgPSBkZWNyeXB0O1xuXHRmdW5jdGlvbiBlbmNyeXB0KGFjY291bnQsIHBhc3N3b3JkLCBvcHRpb25zLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICB0cnkge1xuXHQgICAgICAgIC8vIENoZWNrIHRoZSBhZGRyZXNzIG1hdGNoZXMgdGhlIHByaXZhdGUga2V5XG5cdCAgICAgICAgaWYgKGxpYiQ2LmdldEFkZHJlc3MoYWNjb3VudC5hZGRyZXNzKSAhPT0gbGliJGcuY29tcHV0ZUFkZHJlc3MoYWNjb3VudC5wcml2YXRlS2V5KSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIENoZWNrIHRoZSBtbmVtb25pYyAoaWYgYW55KSBtYXRjaGVzIHRoZSBwcml2YXRlIGtleVxuXHQgICAgICAgIGlmIChoYXNNbmVtb25pYyhhY2NvdW50KSkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWMgPSBhY2NvdW50Lm1uZW1vbmljO1xuXHQgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLCBudWxsLCBtbmVtb25pYy5sb2NhbGUpLmRlcml2ZVBhdGgobW5lbW9uaWMucGF0aCB8fCBsaWIkaC5kZWZhdWx0UGF0aCk7XG5cdCAgICAgICAgICAgIGlmIChub2RlLnByaXZhdGVLZXkgIT0gYWNjb3VudC5wcml2YXRlS2V5KSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtbmVtb25pYyBtaXNtYXRjaFwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpO1xuXHQgICAgfVxuXHQgICAgLy8gVGhlIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBzbyBhZGp1c3QgdGhlIGNhbGwgYXMgbmVlZGVkXG5cdCAgICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gXCJmdW5jdGlvblwiICYmICFwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgcHJvZ3Jlc3NDYWxsYmFjayA9IG9wdGlvbnM7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgaWYgKCFvcHRpb25zKSB7XG5cdCAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgfVxuXHQgICAgdmFyIHByaXZhdGVLZXkgPSBsaWIkMS5hcnJheWlmeShhY2NvdW50LnByaXZhdGVLZXkpO1xuXHQgICAgdmFyIHBhc3N3b3JkQnl0ZXMgPSB1dGlscyQxLmdldFBhc3N3b3JkKHBhc3N3b3JkKTtcblx0ICAgIHZhciBlbnRyb3B5ID0gbnVsbDtcblx0ICAgIHZhciBwYXRoID0gbnVsbDtcblx0ICAgIHZhciBsb2NhbGUgPSBudWxsO1xuXHQgICAgaWYgKGhhc01uZW1vbmljKGFjY291bnQpKSB7XG5cdCAgICAgICAgdmFyIHNyY01uZW1vbmljID0gYWNjb3VudC5tbmVtb25pYztcblx0ICAgICAgICBlbnRyb3B5ID0gbGliJDEuYXJyYXlpZnkobGliJGgubW5lbW9uaWNUb0VudHJvcHkoc3JjTW5lbW9uaWMucGhyYXNlLCBzcmNNbmVtb25pYy5sb2NhbGUgfHwgXCJlblwiKSk7XG5cdCAgICAgICAgcGF0aCA9IHNyY01uZW1vbmljLnBhdGggfHwgbGliJGguZGVmYXVsdFBhdGg7XG5cdCAgICAgICAgbG9jYWxlID0gc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIjtcblx0ICAgIH1cblx0ICAgIHZhciBjbGllbnQgPSBvcHRpb25zLmNsaWVudDtcblx0ICAgIGlmICghY2xpZW50KSB7XG5cdCAgICAgICAgY2xpZW50ID0gXCJldGhlcnMuanNcIjtcblx0ICAgIH1cblx0ICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XG5cdCAgICB2YXIgc2FsdCA9IG51bGw7XG5cdCAgICBpZiAob3B0aW9ucy5zYWx0KSB7XG5cdCAgICAgICAgc2FsdCA9IGxpYiQxLmFycmF5aWZ5KG9wdGlvbnMuc2FsdCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBzYWx0ID0gYnJvd3NlciQ2LnJhbmRvbUJ5dGVzKDMyKTtcblx0ICAgICAgICA7XG5cdCAgICB9XG5cdCAgICAvLyBPdmVycmlkZSBpbml0aWFsaXphdGlvbiB2ZWN0b3Jcblx0ICAgIHZhciBpdiA9IG51bGw7XG5cdCAgICBpZiAob3B0aW9ucy5pdikge1xuXHQgICAgICAgIGl2ID0gbGliJDEuYXJyYXlpZnkob3B0aW9ucy5pdik7XG5cdCAgICAgICAgaWYgKGl2Lmxlbmd0aCAhPT0gMTYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpdlwiKTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICBpdiA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcygxNik7XG5cdCAgICB9XG5cdCAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxuXHQgICAgdmFyIHV1aWRSYW5kb20gPSBudWxsO1xuXHQgICAgaWYgKG9wdGlvbnMudXVpZCkge1xuXHQgICAgICAgIHV1aWRSYW5kb20gPSBsaWIkMS5hcnJheWlmeShvcHRpb25zLnV1aWQpO1xuXHQgICAgICAgIGlmICh1dWlkUmFuZG9tLmxlbmd0aCAhPT0gMTYpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dWlkXCIpO1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHQgICAgICAgIHV1aWRSYW5kb20gPSBicm93c2VyJDYucmFuZG9tQnl0ZXMoMTYpO1xuXHQgICAgfVxuXHQgICAgLy8gT3ZlcnJpZGUgdGhlIHNjcnlwdCBwYXNzd29yZC1iYXNlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBwYXJhbWV0ZXJzXG5cdCAgICB2YXIgTiA9ICgxIDw8IDE3KSwgciA9IDgsIHAgPSAxO1xuXHQgICAgaWYgKG9wdGlvbnMuc2NyeXB0KSB7XG5cdCAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0Lk4pIHtcblx0ICAgICAgICAgICAgTiA9IG9wdGlvbnMuc2NyeXB0Lk47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5yKSB7XG5cdCAgICAgICAgICAgIHIgPSBvcHRpb25zLnNjcnlwdC5yO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucCkge1xuXHQgICAgICAgICAgICBwID0gb3B0aW9ucy5zY3J5cHQucDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBXZSB0YWtlIDY0IGJ5dGVzOlxuXHQgICAgLy8gICAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxuXHQgICAgLy8gICAtIDMyIGJ5dGVzICAgQUVTIGtleSB0byBlbmNyeXB0IG1uZW1vbmljIHdpdGggKHJlcXVpcmVkIGhlcmUgdG8gYmUgRXRoZXJzIFdhbGxldClcblx0ICAgIHJldHVybiBzY3J5cHQkMS5zY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgTiwgciwgcCwgNjQsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIGtleSA9IGxpYiQxLmFycmF5aWZ5KGtleSk7XG5cdCAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZW5jcnlwdCB0aGUgd2FsbGV0IChhcyBwZXIgV2ViMyBzZWNyZXQgc3RvcmFnZSlcblx0ICAgICAgICB2YXIgZGVyaXZlZEtleSA9IGtleS5zbGljZSgwLCAxNik7XG5cdCAgICAgICAgdmFyIG1hY1ByZWZpeCA9IGtleS5zbGljZSgxNiwgMzIpO1xuXHQgICAgICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIG1uZW1vbmljIHBocmFzZSAoaWYgYW55KVxuXHQgICAgICAgIHZhciBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuXHQgICAgICAgIC8vIEVuY3J5cHQgdGhlIHByaXZhdGUga2V5XG5cdCAgICAgICAgdmFyIGNvdW50ZXIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Db3VudGVyKGl2KTtcblx0ICAgICAgICB2YXIgYWVzQ3RyID0gbmV3IGFlc19qc18xLmRlZmF1bHQuTW9kZU9mT3BlcmF0aW9uLmN0cihkZXJpdmVkS2V5LCBjb3VudGVyKTtcblx0ICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGxpYiQxLmFycmF5aWZ5KGFlc0N0ci5lbmNyeXB0KHByaXZhdGVLZXkpKTtcblx0ICAgICAgICAvLyBDb21wdXRlIHRoZSBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUsIHVzZWQgdG8gY2hlY2sgdGhlIHBhc3N3b3JkXG5cdCAgICAgICAgdmFyIG1hYyA9IGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcblx0ICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvV2ViMy1TZWNyZXQtU3RvcmFnZS1EZWZpbml0aW9uXG5cdCAgICAgICAgdmFyIGRhdGEgPSB7XG5cdCAgICAgICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSxcblx0ICAgICAgICAgICAgaWQ6IHV0aWxzJDEudXVpZFY0KHV1aWRSYW5kb20pLFxuXHQgICAgICAgICAgICB2ZXJzaW9uOiAzLFxuXHQgICAgICAgICAgICBDcnlwdG86IHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcjogXCJhZXMtMTI4LWN0clwiLFxuXHQgICAgICAgICAgICAgICAgY2lwaGVycGFyYW1zOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaXY6IGxpYiQxLmhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBsaWIkMS5oZXhsaWZ5KGNpcGhlcnRleHQpLnN1YnN0cmluZygyKSxcblx0ICAgICAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcblx0ICAgICAgICAgICAgICAgIGtkZnBhcmFtczoge1xuXHQgICAgICAgICAgICAgICAgICAgIHNhbHQ6IGxpYiQxLmhleGxpZnkoc2FsdCkuc3Vic3RyaW5nKDIpLFxuXHQgICAgICAgICAgICAgICAgICAgIG46IE4sXG5cdCAgICAgICAgICAgICAgICAgICAgZGtsZW46IDMyLFxuXHQgICAgICAgICAgICAgICAgICAgIHA6IHAsXG5cdCAgICAgICAgICAgICAgICAgICAgcjogclxuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIG1hYzogbWFjLnN1YnN0cmluZygyKVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbW5lbW9uaWMsIGVuY3J5cHQgaXQgaW50byB0aGUgSlNPTiB3YWxsZXRcblx0ICAgICAgICBpZiAoZW50cm9weSkge1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNJdiA9IGJyb3dzZXIkNi5yYW5kb21CeXRlcygxNik7XG5cdCAgICAgICAgICAgIHZhciBtbmVtb25pY0NvdW50ZXIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Db3VudGVyKG1uZW1vbmljSXYpO1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNBZXNDdHIgPSBuZXcgYWVzX2pzXzEuZGVmYXVsdC5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LCBtbmVtb25pY0NvdW50ZXIpO1xuXHQgICAgICAgICAgICB2YXIgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gbGliJDEuYXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XG5cdCAgICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpO1xuXHQgICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENNb250aCgpICsgMSwgMikgKyBcIi1cIiArXG5cdCAgICAgICAgICAgICAgICB1dGlscyQxLnpwYWQobm93LmdldFVUQ0RhdGUoKSwgMikgKyBcIlRcIiArXG5cdCAgICAgICAgICAgICAgICB1dGlscyQxLnpwYWQobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENNaW51dGVzKCksIDIpICsgXCItXCIgK1xuXHQgICAgICAgICAgICAgICAgdXRpbHMkMS56cGFkKG5vdy5nZXRVVENTZWNvbmRzKCksIDIpICsgXCIuMFpcIik7XG5cdCAgICAgICAgICAgIGRhdGFbXCJ4LWV0aGVyc1wiXSA9IHtcblx0ICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuXHQgICAgICAgICAgICAgICAgZ2V0aEZpbGVuYW1lOiAoXCJVVEMtLVwiICsgdGltZXN0YW1wICsgXCItLVwiICsgZGF0YS5hZGRyZXNzKSxcblx0ICAgICAgICAgICAgICAgIG1uZW1vbmljQ291bnRlcjogbGliJDEuaGV4bGlmeShtbmVtb25pY0l2KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBtbmVtb25pY0NpcGhlcnRleHQ6IGxpYiQxLmhleGxpZnkobW5lbW9uaWNDaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG5cdCAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuXHQgICAgICAgICAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG5cdCAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjAuMVwiXG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcblx0ICAgIH0pO1xuXHR9XG5cdGV4cG9ydHMuZW5jcnlwdCA9IGVuY3J5cHQ7XG5cblx0fSk7XG5cblx0dmFyIGtleXN0b3JlJDEgPSB1bndyYXBFeHBvcnRzKGtleXN0b3JlKTtcblx0dmFyIGtleXN0b3JlXzEgPSBrZXlzdG9yZS5LZXlzdG9yZUFjY291bnQ7XG5cdHZhciBrZXlzdG9yZV8yID0ga2V5c3RvcmUuZGVjcnlwdFN5bmM7XG5cdHZhciBrZXlzdG9yZV8zID0ga2V5c3RvcmUuZGVjcnlwdDtcblx0dmFyIGtleXN0b3JlXzQgPSBrZXlzdG9yZS5lbmNyeXB0O1xuXG5cdHZhciBsaWIkaSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLmRlY3J5cHRDcm93ZHNhbGUgPSBjcm93ZHNhbGUuZGVjcnlwdDtcblxuXHRleHBvcnRzLmdldEpzb25XYWxsZXRBZGRyZXNzID0gaW5zcGVjdC5nZXRKc29uV2FsbGV0QWRkcmVzcztcblx0ZXhwb3J0cy5pc0Nyb3dkc2FsZVdhbGxldCA9IGluc3BlY3QuaXNDcm93ZHNhbGVXYWxsZXQ7XG5cdGV4cG9ydHMuaXNLZXlzdG9yZVdhbGxldCA9IGluc3BlY3QuaXNLZXlzdG9yZVdhbGxldDtcblxuXHRleHBvcnRzLmRlY3J5cHRLZXlzdG9yZSA9IGtleXN0b3JlLmRlY3J5cHQ7XG5cdGV4cG9ydHMuZGVjcnlwdEtleXN0b3JlU3luYyA9IGtleXN0b3JlLmRlY3J5cHRTeW5jO1xuXHRleHBvcnRzLmVuY3J5cHRLZXlzdG9yZSA9IGtleXN0b3JlLmVuY3J5cHQ7XG5cdGZ1bmN0aW9uIGRlY3J5cHRKc29uV2FsbGV0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICBpZiAoaW5zcGVjdC5pc0Nyb3dkc2FsZVdhbGxldChqc29uKSkge1xuXHQgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhY2NvdW50ID0gY3Jvd2RzYWxlLmRlY3J5cHQoanNvbiwgcGFzc3dvcmQpO1xuXHQgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoYWNjb3VudCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaW5zcGVjdC5pc0tleXN0b3JlV2FsbGV0KGpzb24pKSB7XG5cdCAgICAgICAgcmV0dXJuIGtleXN0b3JlLmRlY3J5cHQoanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImludmFsaWQgSlNPTiB3YWxsZXRcIikpO1xuXHR9XG5cdGV4cG9ydHMuZGVjcnlwdEpzb25XYWxsZXQgPSBkZWNyeXB0SnNvbldhbGxldDtcblx0ZnVuY3Rpb24gZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICBpZiAoaW5zcGVjdC5pc0Nyb3dkc2FsZVdhbGxldChqc29uKSkge1xuXHQgICAgICAgIHJldHVybiBjcm93ZHNhbGUuZGVjcnlwdChqc29uLCBwYXNzd29yZCk7XG5cdCAgICB9XG5cdCAgICBpZiAoaW5zcGVjdC5pc0tleXN0b3JlV2FsbGV0KGpzb24pKSB7XG5cdCAgICAgICAgcmV0dXJuIGtleXN0b3JlLmRlY3J5cHRTeW5jKGpzb24sIHBhc3N3b3JkKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgSlNPTiB3YWxsZXRcIik7XG5cdH1cblx0ZXhwb3J0cy5kZWNyeXB0SnNvbldhbGxldFN5bmMgPSBkZWNyeXB0SnNvbldhbGxldFN5bmM7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JGkgPSB1bndyYXBFeHBvcnRzKGxpYiRpKTtcblx0dmFyIGxpYl8xJGkgPSBsaWIkaS5kZWNyeXB0Q3Jvd2RzYWxlO1xuXHR2YXIgbGliXzIkaCA9IGxpYiRpLmdldEpzb25XYWxsZXRBZGRyZXNzO1xuXHR2YXIgbGliXzMkZSA9IGxpYiRpLmlzQ3Jvd2RzYWxlV2FsbGV0O1xuXHR2YXIgbGliXzQkYiA9IGxpYiRpLmlzS2V5c3RvcmVXYWxsZXQ7XG5cdHZhciBsaWJfNSRhID0gbGliJGkuZGVjcnlwdEtleXN0b3JlO1xuXHR2YXIgbGliXzYkNiA9IGxpYiRpLmRlY3J5cHRLZXlzdG9yZVN5bmM7XG5cdHZhciBsaWJfNyQ1ID0gbGliJGkuZW5jcnlwdEtleXN0b3JlO1xuXHR2YXIgbGliXzgkNCA9IGxpYiRpLmRlY3J5cHRKc29uV2FsbGV0O1xuXHR2YXIgbGliXzkkNCA9IGxpYiRpLmRlY3J5cHRKc29uV2FsbGV0U3luYztcblxuXHR2YXIgX3ZlcnNpb24kQyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ3YWxsZXQvNS4wLjRcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kRCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kQyk7XG5cdHZhciBfdmVyc2lvbl8xJGogPSBfdmVyc2lvbiRDLnZlcnNpb247XG5cblx0dmFyIGxpYiRqID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEMudmVyc2lvbik7XG5cdGZ1bmN0aW9uIGlzQWNjb3VudCh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmIGxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlLnByaXZhdGVLZXksIDMyKSAmJiB2YWx1ZS5hZGRyZXNzICE9IG51bGwpO1xuXHR9XG5cdGZ1bmN0aW9uIGhhc01uZW1vbmljKHZhbHVlKSB7XG5cdCAgICB2YXIgbW5lbW9uaWMgPSB2YWx1ZS5tbmVtb25pYztcblx0ICAgIHJldHVybiAobW5lbW9uaWMgJiYgbW5lbW9uaWMucGhyYXNlKTtcblx0fVxuXHR2YXIgV2FsbGV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKFdhbGxldCwgX3N1cGVyKTtcblx0ICAgIGZ1bmN0aW9uIFdhbGxldChwcml2YXRlS2V5LCBwcm92aWRlcikge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBXYWxsZXQpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblx0ICAgICAgICBpZiAoaXNBY2NvdW50KHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgIHZhciBzaWduaW5nS2V5XzEgPSBuZXcgbGliJGYuU2lnbmluZ0tleShwcml2YXRlS2V5LnByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfc2lnbmluZ0tleVwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBzaWduaW5nS2V5XzE7IH0pO1xuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJhZGRyZXNzXCIsIGxpYiRnLmNvbXB1dGVBZGRyZXNzKF90aGlzLnB1YmxpY0tleSkpO1xuXHQgICAgICAgICAgICBpZiAoX3RoaXMuYWRkcmVzcyAhPT0gbGliJDYuZ2V0QWRkcmVzcyhwcml2YXRlS2V5LmFkZHJlc3MpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJpdmF0ZUtleS9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGhhc01uZW1vbmljKHByaXZhdGVLZXkpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc3JjTW5lbW9uaWNfMSA9IHByaXZhdGVLZXkubW5lbW9uaWM7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcblx0ICAgICAgICAgICAgICAgICAgICBwaHJhc2U6IHNyY01uZW1vbmljXzEucGhyYXNlLFxuXHQgICAgICAgICAgICAgICAgICAgIHBhdGg6IHNyY01uZW1vbmljXzEucGF0aCB8fCBsaWIkaC5kZWZhdWx0UGF0aCxcblx0ICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IHNyY01uZW1vbmljXzEubG9jYWxlIHx8IFwiZW5cIlxuXHQgICAgICAgICAgICAgICAgfSk7IH0pO1xuXHQgICAgICAgICAgICAgICAgdmFyIG1uZW1vbmljID0gX3RoaXMubW5lbW9uaWM7XG5cdCAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IGxpYiRoLkhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLCBudWxsLCBtbmVtb25pYy5sb2NhbGUpLmRlcml2ZVBhdGgobW5lbW9uaWMucGF0aCk7XG5cdCAgICAgICAgICAgICAgICBpZiAobGliJGcuY29tcHV0ZUFkZHJlc3Mobm9kZS5wcml2YXRlS2V5KSAhPT0gX3RoaXMuYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtbmVtb25pYy9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGlmIChsaWIkZi5TaWduaW5nS2V5LmlzU2lnbmluZ0tleShwcml2YXRlS2V5KSkge1xuXHQgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cdCAgICAgICAgICAgICAgICBpZiAocHJpdmF0ZUtleS5jdXJ2ZSAhPT0gXCJzZWNwMjU2azFcIikge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBjdXJ2ZTsgbXVzdCBiZSBzZWNwMjU2azFcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9zaWduaW5nS2V5XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByaXZhdGVLZXk7IH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNpZ25pbmdLZXlfMiA9IG5ldyBsaWIkZi5TaWduaW5nS2V5KHByaXZhdGVLZXkpO1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX3NpZ25pbmdLZXlcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gc2lnbmluZ0tleV8yOyB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbW5lbW9uaWNcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFkZHJlc3NcIiwgbGliJGcuY29tcHV0ZUFkZHJlc3MoX3RoaXMucHVibGljS2V5KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuXHQgICAgICAgIGlmIChwcm92aWRlciAmJiAhbGliJGIuUHJvdmlkZXIuaXNQcm92aWRlcihwcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyIHx8IG51bGwpO1xuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXYWxsZXQucHJvdG90eXBlLCBcIm1uZW1vbmljXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX21uZW1vbmljKCk7IH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdhbGxldC5wcm90b3R5cGUsIFwicHJpdmF0ZUtleVwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9zaWduaW5nS2V5KCkucHJpdmF0ZUtleTsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2FsbGV0LnByb3RvdHlwZSwgXCJwdWJsaWNLZXlcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2lnbmluZ0tleSgpLnB1YmxpY0tleTsgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFkZHJlc3MpO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChwcm92aWRlcikge1xuXHQgICAgICAgIHJldHVybiBuZXcgV2FsbGV0KHRoaXMsIHByb3ZpZGVyKTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLnNpZ25UcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uICh0eCkge1xuXHQgICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobGliJDYuZ2V0QWRkcmVzcyh0eC5mcm9tKSAhPT0gX3RoaXMuYWRkcmVzcykge1xuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbiBmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvbi5mcm9tXCIsIHRyYW5zYWN0aW9uLmZyb20pO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZGVsZXRlIHR4LmZyb207XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNpZ25hdHVyZSA9IF90aGlzLl9zaWduaW5nS2V5KCkuc2lnbkRpZ2VzdChsaWIkNC5rZWNjYWsyNTYobGliJGcuc2VyaWFsaXplKHR4KSkpO1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJGcuc2VyaWFsaXplKHR4LCBzaWduYXR1cmUpO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5wcm90b3R5cGUuc2lnbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHQgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobGliJDEuam9pblNpZ25hdHVyZSh0aGlzLl9zaWduaW5nS2V5KCkuc2lnbkRpZ2VzdChsaWIkOS5oYXNoTWVzc2FnZShtZXNzYWdlKSkpKTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbiAocGFzc3dvcmQsIG9wdGlvbnMsIHByb2dyZXNzQ2FsbGJhY2spIHtcblx0ICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gXCJmdW5jdGlvblwiICYmICFwcm9ncmVzc0NhbGxiYWNrKSB7XG5cdCAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2sgPSBvcHRpb25zO1xuXHQgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrICYmIHR5cGVvZiAocHJvZ3Jlc3NDYWxsYmFjaykgIT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGNhbGxiYWNrXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJGkuZW5jcnlwdEtleXN0b3JlKHRoaXMsIHBhc3N3b3JkLCBvcHRpb25zLCBwcm9ncmVzc0NhbGxiYWNrKTtcblx0ICAgIH07XG5cdCAgICAvKipcblx0ICAgICAqICBTdGF0aWMgbWV0aG9kcyB0byBjcmVhdGUgV2FsbGV0IGluc3RhbmNlcy5cblx0ICAgICAqL1xuXHQgICAgV2FsbGV0LmNyZWF0ZVJhbmRvbSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdCAgICAgICAgdmFyIGVudHJvcHkgPSBicm93c2VyJDYucmFuZG9tQnl0ZXMoMTYpO1xuXHQgICAgICAgIGlmICghb3B0aW9ucykge1xuXHQgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChvcHRpb25zLmV4dHJhRW50cm9weSkge1xuXHQgICAgICAgICAgICBlbnRyb3B5ID0gbGliJDEuYXJyYXlpZnkobGliJDEuaGV4RGF0YVNsaWNlKGxpYiQ0LmtlY2NhazI1NihsaWIkMS5jb25jYXQoW2VudHJvcHksIG9wdGlvbnMuZXh0cmFFbnRyb3B5XSkpLCAwLCAxNikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgbW5lbW9uaWMgPSBsaWIkaC5lbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCBvcHRpb25zLmxvY2FsZSk7XG5cdCAgICAgICAgcmV0dXJuIFdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG9wdGlvbnMucGF0aCwgb3B0aW9ucy5sb2NhbGUpO1xuXHQgICAgfTtcblx0ICAgIFdhbGxldC5mcm9tRW5jcnlwdGVkSnNvbiA9IGZ1bmN0aW9uIChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykge1xuXHQgICAgICAgIHJldHVybiBsaWIkaS5kZWNyeXB0SnNvbldhbGxldChqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjaykudGhlbihmdW5jdGlvbiAoYWNjb3VudCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldChhY2NvdW50KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBXYWxsZXQuZnJvbUVuY3J5cHRlZEpzb25TeW5jID0gZnVuY3Rpb24gKGpzb24sIHBhc3N3b3JkKSB7XG5cdCAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQobGliJGkuZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24sIHBhc3N3b3JkKSk7XG5cdCAgICB9O1xuXHQgICAgV2FsbGV0LmZyb21NbmVtb25pYyA9IGZ1bmN0aW9uIChtbmVtb25pYywgcGF0aCwgd29yZGxpc3QpIHtcblx0ICAgICAgICBpZiAoIXBhdGgpIHtcblx0ICAgICAgICAgICAgcGF0aCA9IGxpYiRoLmRlZmF1bHRQYXRoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV3IFdhbGxldChsaWIkaC5IRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBudWxsLCB3b3JkbGlzdCkuZGVyaXZlUGF0aChwYXRoKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdhbGxldDtcblx0fShsaWIkYy5TaWduZXIpKTtcblx0ZXhwb3J0cy5XYWxsZXQgPSBXYWxsZXQ7XG5cdGZ1bmN0aW9uIHZlcmlmeU1lc3NhZ2UobWVzc2FnZSwgc2lnbmF0dXJlKSB7XG5cdCAgICByZXR1cm4gbGliJGcucmVjb3ZlckFkZHJlc3MobGliJDkuaGFzaE1lc3NhZ2UobWVzc2FnZSksIHNpZ25hdHVyZSk7XG5cdH1cblx0ZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gdmVyaWZ5TWVzc2FnZTtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkaiA9IHVud3JhcEV4cG9ydHMobGliJGopO1xuXHR2YXIgbGliXzEkaiA9IGxpYiRqLldhbGxldDtcblx0dmFyIGxpYl8yJGkgPSBsaWIkai52ZXJpZnlNZXNzYWdlO1xuXG5cdHZhciBfdmVyc2lvbiRFID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcIm5ldHdvcmtzLzUuMC4zXCI7XG5cblx0fSk7XG5cblx0dmFyIF92ZXJzaW9uJEYgPSB1bndyYXBFeHBvcnRzKF92ZXJzaW9uJEUpO1xuXHR2YXIgX3ZlcnNpb25fMSRrID0gX3ZlcnNpb24kRS52ZXJzaW9uO1xuXG5cdHZhciBsaWIkayA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRFLnZlcnNpb24pO1xuXHQ7XG5cdGZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuXHQgICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLnJlbmV0d29yaykgPT09IFwiZnVuY3Rpb25cIik7XG5cdH1cblx0ZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcblx0ICAgIHZhciBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuXHQgICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcblx0ICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvdmlkZXJMaXN0ID0gW107XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmluZnVyYSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5ldGhlcnNjYW4pKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkFsY2hlbXlQcm92aWRlcikge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbGNoZW15KSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5DbG91ZGZsYXJlUHJvdmlkZXIpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuQ2xvdWRmbGFyZVByb3ZpZGVyKG5ldHdvcmspKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAocHJvdmlkZXJMaXN0Lmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKSB7XG5cdCAgICAgICAgICAgIHZhciBxdW9ydW0gPSAxO1xuXHQgICAgICAgICAgICBpZiAob3B0aW9ucy5xdW9ydW0gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcXVvcnVtID0gb3B0aW9ucy5xdW9ydW07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAobmV0d29yayA9PT0gXCJob21lc3RlYWRcIikge1xuXHQgICAgICAgICAgICAgICAgcXVvcnVtID0gMjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVycy5GYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVyTGlzdCwgcXVvcnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHByb3ZpZGVyTGlzdFswXTtcblx0ICAgIH07XG5cdCAgICBmdW5jLnJlbmV0d29yayA9IGZ1bmN0aW9uIChuZXR3b3JrKSB7XG5cdCAgICAgICAgcmV0dXJuIGV0aERlZmF1bHRQcm92aWRlcihuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuYztcblx0fVxuXHRmdW5jdGlvbiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKSB7XG5cdCAgICB2YXIgZnVuYyA9IGZ1bmN0aW9uIChwcm92aWRlcnMsIG9wdGlvbnMpIHtcblx0ICAgICAgICBpZiAocHJvdmlkZXJzLkpzb25ScGNQcm92aWRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgZnVuYy5yZW5ldHdvcmsgPSBmdW5jdGlvbiAobmV0d29yaykge1xuXHQgICAgICAgIHJldHVybiBldGNEZWZhdWx0UHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuYztcblx0fVxuXHR2YXIgaG9tZXN0ZWFkID0ge1xuXHQgICAgY2hhaW5JZDogMSxcblx0ICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICBuYW1lOiBcImhvbWVzdGVhZFwiLFxuXHQgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwiaG9tZXN0ZWFkXCIpXG5cdH07XG5cdHZhciByb3BzdGVuID0ge1xuXHQgICAgY2hhaW5JZDogMyxcblx0ICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICBuYW1lOiBcInJvcHN0ZW5cIixcblx0ICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcInJvcHN0ZW5cIilcblx0fTtcblx0dmFyIGNsYXNzaWNNb3Jkb3IgPSB7XG5cdCAgICBjaGFpbklkOiA2Myxcblx0ICAgIG5hbWU6IFwiY2xhc3NpY01vcmRvclwiLFxuXHQgICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6Ly93d3cuZXRoZXJjbHVzdGVyLmNvbS9tb3Jkb3JcIiwgXCJjbGFzc2ljTW9yZG9yXCIpXG5cdH07XG5cdHZhciBuZXR3b3JrcyA9IHtcblx0ICAgIHVuc3BlY2lmaWVkOiB7XG5cdCAgICAgICAgY2hhaW5JZDogMCxcblx0ICAgICAgICBuYW1lOiBcInVuc3BlY2lmaWVkXCJcblx0ICAgIH0sXG5cdCAgICBob21lc3RlYWQ6IGhvbWVzdGVhZCxcblx0ICAgIG1haW5uZXQ6IGhvbWVzdGVhZCxcblx0ICAgIG1vcmRlbjoge1xuXHQgICAgICAgIGNoYWluSWQ6IDIsXG5cdCAgICAgICAgbmFtZTogXCJtb3JkZW5cIlxuXHQgICAgfSxcblx0ICAgIHJvcHN0ZW46IHJvcHN0ZW4sXG5cdCAgICB0ZXN0bmV0OiByb3BzdGVuLFxuXHQgICAgcmlua2VieToge1xuXHQgICAgICAgIGNoYWluSWQ6IDQsXG5cdCAgICAgICAgZW5zQWRkcmVzczogXCIweDAwMDAwMDAwMDAwQzJFMDc0ZUM2OUEwZEZiMjk5N0JBNkM3ZDJlMWVcIixcblx0ICAgICAgICBuYW1lOiBcInJpbmtlYnlcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJyaW5rZWJ5XCIpXG5cdCAgICB9LFxuXHQgICAga292YW46IHtcblx0ICAgICAgICBjaGFpbklkOiA0Mixcblx0ICAgICAgICBuYW1lOiBcImtvdmFuXCIsXG5cdCAgICAgICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwia292YW5cIilcblx0ICAgIH0sXG5cdCAgICBnb2VybGk6IHtcblx0ICAgICAgICBjaGFpbklkOiA1LFxuXHQgICAgICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG5cdCAgICAgICAgbmFtZTogXCJnb2VybGlcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJnb2VybGlcIilcblx0ICAgIH0sXG5cdCAgICAvLyBFVEMgKFNlZTogIzM1MSlcblx0ICAgIGNsYXNzaWM6IHtcblx0ICAgICAgICBjaGFpbklkOiA2MSxcblx0ICAgICAgICBuYW1lOiBcImNsYXNzaWNcIixcblx0ICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGNEZWZhdWx0UHJvdmlkZXIoXCJodHRwczovL3d3dy5ldGhlcmNsdXN0ZXIuY29tL2V0Y1wiLCBcImNsYXNzaWNcIilcblx0ICAgIH0sXG5cdCAgICBjbGFzc2ljTW9yZGVuOiB7XG5cdCAgICAgICAgY2hhaW5JZDogNjIsXG5cdCAgICAgICAgbmFtZTogXCJjbGFzc2ljTW9yZGVuXCIsXG5cdCAgICB9LFxuXHQgICAgY2xhc3NpY01vcmRvcjogY2xhc3NpY01vcmRvcixcblx0ICAgIGNsYXNzaWNUZXN0bmV0OiBjbGFzc2ljTW9yZG9yLFxuXHQgICAgY2xhc3NpY0tvdHRpOiB7XG5cdCAgICAgICAgY2hhaW5JZDogNixcblx0ICAgICAgICBuYW1lOiBcImNsYXNzaWNLb3R0aVwiLFxuXHQgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi8vd3d3LmV0aGVyY2x1c3Rlci5jb20va290dGlcIiwgXCJjbGFzc2ljS290dGlcIilcblx0ICAgIH0sXG5cdH07XG5cdC8qKlxuXHQgKiAgZ2V0TmV0d29ya1xuXHQgKlxuXHQgKiAgQ29udmVydHMgYSBuYW1lZCBjb21tb24gbmV0d29ya3Mgb3IgY2hhaW4gSUQgKG5ldHdvcmsgSUQpIHRvIGEgTmV0d29ya1xuXHQgKiAgYW5kIHZlcmlmaWVzIGEgbmV0d29yayBpcyBhIHZhbGlkIE5ldHdvcmsuLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0TmV0d29yayhuZXR3b3JrKSB7XG5cdCAgICAvLyBObyBuZXR3b3JrIChudWxsKVxuXHQgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICBmb3IgKHZhciBuYW1lXzEgaW4gbmV0d29ya3MpIHtcblx0ICAgICAgICAgICAgdmFyIHN0YW5kYXJkXzEgPSBuZXR3b3Jrc1tuYW1lXzFdO1xuXHQgICAgICAgICAgICBpZiAoc3RhbmRhcmRfMS5jaGFpbklkID09PSBuZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0YW5kYXJkXzEubmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZF8xLmNoYWluSWQsXG5cdCAgICAgICAgICAgICAgICAgICAgZW5zQWRkcmVzczogKHN0YW5kYXJkXzEuZW5zQWRkcmVzcyB8fCBudWxsKSxcblx0ICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmRfMS5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGwpXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIGNoYWluSWQ6IG5ldHdvcmssXG5cdCAgICAgICAgICAgIG5hbWU6IFwidW5rbm93blwiXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIHN0YW5kYXJkXzIgPSBuZXR3b3Jrc1tuZXR3b3JrXTtcblx0ICAgICAgICBpZiAoc3RhbmRhcmRfMiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICBuYW1lOiBzdGFuZGFyZF8yLm5hbWUsXG5cdCAgICAgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkXzIuY2hhaW5JZCxcblx0ICAgICAgICAgICAgZW5zQWRkcmVzczogc3RhbmRhcmRfMi5lbnNBZGRyZXNzLFxuXHQgICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmRfMi5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGwpXG5cdCAgICAgICAgfTtcblx0ICAgIH1cblx0ICAgIHZhciBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmsubmFtZV07XG5cdCAgICAvLyBOb3QgYSBzdGFuZGFyZCBuZXR3b3JrOyBjaGVjayB0aGF0IGl0IGlzIGEgdmFsaWQgbmV0d29yayBpbiBnZW5lcmFsXG5cdCAgICBpZiAoIXN0YW5kYXJkKSB7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAobmV0d29yay5jaGFpbklkKSAhPT0gXCJudW1iZXJcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbmV0d29yaztcblx0ICAgIH1cblx0ICAgIC8vIE1ha2Ugc3VyZSB0aGUgY2hhaW5JZCBtYXRjaGVzIHRoZSBleHBlY3RlZCBuZXR3b3JrIGNoYWluSWQgKG9yIGlzIDA7IGRpc2FibGUgRUlQLTE1NSlcblx0ICAgIGlmIChuZXR3b3JrLmNoYWluSWQgIT09IDAgJiYgbmV0d29yay5jaGFpbklkICE9PSBzdGFuZGFyZC5jaGFpbklkKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5ldHdvcmsgY2hhaW5JZCBtaXNtYXRjaFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG5cdCAgICB9XG5cdCAgICAvLyBAVE9ETzogSW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBhZGQgYW4gYXR0YWNoIGZ1bmN0aW9uIHRvIGEgZGVmYXVsdFByb3ZpZGVyXG5cdCAgICAvLyBjbGFzcyBhbmQgbW92ZSB0aGUgX2RlZmF1bHRQcm92aWRlciBpbnRlcm5hbCB0byB0aGlzIGZpbGUgKGV4dGVuZCBOZXR3b3JrKVxuXHQgICAgdmFyIGRlZmF1bHRQcm92aWRlciA9IG5ldHdvcmsuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsO1xuXHQgICAgaWYgKGRlZmF1bHRQcm92aWRlciA9PSBudWxsICYmIHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpIHtcblx0ICAgICAgICBpZiAoaXNSZW5ldHdvcmthYmxlKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpKSB7XG5cdCAgICAgICAgICAgIGRlZmF1bHRQcm92aWRlciA9IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIucmVuZXR3b3JrKG5ldHdvcmspO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgZGVmYXVsdFByb3ZpZGVyID0gc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcjtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICAvLyBTdGFuZGFyZCBOZXR3b3JrIChhbGxvdyBvdmVycmlkaW5nIHRoZSBFTlMgYWRkcmVzcylcblx0ICAgIHJldHVybiB7XG5cdCAgICAgICAgbmFtZTogbmV0d29yay5uYW1lLFxuXHQgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkLmNoYWluSWQsXG5cdCAgICAgICAgZW5zQWRkcmVzczogKG5ldHdvcmsuZW5zQWRkcmVzcyB8fCBzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuXHQgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGRlZmF1bHRQcm92aWRlclxuXHQgICAgfTtcblx0fVxuXHRleHBvcnRzLmdldE5ldHdvcmsgPSBnZXROZXR3b3JrO1xuXG5cdH0pO1xuXG5cdHZhciBpbmRleCRrID0gdW53cmFwRXhwb3J0cyhsaWIkayk7XG5cdHZhciBsaWJfMSRrID0gbGliJGsuZ2V0TmV0d29yaztcblxuXHR2YXIgYnJvd3NlciQ4ID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cdGZ1bmN0aW9uIGRlY29kZSh0ZXh0RGF0YSkge1xuXHQgICAgdGV4dERhdGEgPSBhdG9iKHRleHREYXRhKTtcblx0ICAgIHZhciBkYXRhID0gW107XG5cdCAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHREYXRhLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KGRhdGEpO1xuXHR9XG5cdGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuXHRmdW5jdGlvbiBlbmNvZGUoZGF0YSkge1xuXHQgICAgZGF0YSA9IGxpYiQxLmFycmF5aWZ5KGRhdGEpO1xuXHQgICAgdmFyIHRleHREYXRhID0gXCJcIjtcblx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHRleHREYXRhICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoZGF0YVtpXSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gYnRvYSh0ZXh0RGF0YSk7XG5cdH1cblx0ZXhwb3J0cy5lbmNvZGUgPSBlbmNvZGU7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXIkOSA9IHVud3JhcEV4cG9ydHMoYnJvd3NlciQ4KTtcblx0dmFyIGJyb3dzZXJfMSQ0ID0gYnJvd3NlciQ4LmRlY29kZTtcblx0dmFyIGJyb3dzZXJfMiQzID0gYnJvd3NlciQ4LmVuY29kZTtcblxuXHR2YXIgX3ZlcnNpb24kRyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ3ZWIvNS4wLjdcIjtcblxuXHR9KTtcblxuXHR2YXIgX3ZlcnNpb24kSCA9IHVud3JhcEV4cG9ydHMoX3ZlcnNpb24kRyk7XG5cdHZhciBfdmVyc2lvbl8xJGwgPSBfdmVyc2lvbiRHLnZlcnNpb247XG5cblx0dmFyIGJyb3dzZXJHZXR1cmwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRmdW5jdGlvbiBnZXRVcmwoaHJlZiwgb3B0aW9ucykge1xuXHQgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHZhciByZXF1ZXN0LCByZXNwb25zZSwgYm9keSwgaGVhZGVycztcblx0ICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCA9IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIiksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IChvcHRpb25zLmhlYWRlcnMgfHwge30pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAob3B0aW9ucy5ib2R5IHx8IHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IFwiY29yc1wiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZTogXCJuby1jYWNoZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJyZXI6IFwiY2xpZW50XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaChocmVmLCByZXF1ZXN0KV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgYm9keSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgKChyZXNwb25zZS5oZWFkZXJzKS5rZXlzKSgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSByZXNwb25zZS5oZWFkZXJzLmdldChrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNNZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogbGliJDEuYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoYm9keSkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5nZXRVcmwgPSBnZXRVcmw7XG5cblx0fSk7XG5cblx0dmFyIGJyb3dzZXJHZXR1cmwkMSA9IHVud3JhcEV4cG9ydHMoYnJvd3NlckdldHVybCk7XG5cdHZhciBicm93c2VyR2V0dXJsXzEgPSBicm93c2VyR2V0dXJsLmdldFVybDtcblxuXHR2YXIgbGliJGwgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEcudmVyc2lvbik7XG5cblx0ZnVuY3Rpb24gc3RhbGxlcihkdXJhdGlvbikge1xuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdCAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBib2R5aWZ5KHZhbHVlLCB0eXBlKSB7XG5cdCAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfVxuXHQgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgfVxuXHQgICAgaWYgKGxpYiQxLmlzQnl0ZXNMaWtlKHZhbHVlKSkge1xuXHQgICAgICAgIGlmICh0eXBlICYmICh0eXBlLnNwbGl0KFwiL1wiKVswXSA9PT0gXCJ0ZXh0XCIgfHwgdHlwZS5zcGxpdChcIjtcIilbMF0udHJpbSgpID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBsaWIkOC50b1V0ZjhTdHJpbmcodmFsdWUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgICAgIDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLmhleGxpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdC8vIFRoaXMgQVBJIGlzIHN0aWxsIGEgd29yayBpbiBwcm9ncmVzczsgdGhlIGZ1dHVyZSBjaGFuZ2VzIHdpbGwgbGlrZWx5IGJlOlxuXHQvLyAtIENvbm5lY3Rpb25JbmZvID0+IEZldGNoRGF0YVJlcXVlc3Q8VCA9IGFueT5cblx0Ly8gLSBGZXRjaERhdGFSZXF1ZXN0LmJvZHk/ID0gc3RyaW5nIHwgVWludDhBcnJheSB8IHsgY29udGVudFR5cGU6IHN0cmluZywgZGF0YTogc3RyaW5nIHwgVWludDhBcnJheSB9XG5cdC8vICAgLSBJZiBzdHJpbmcgPT4gdGV4dC9wbGFpbiwgVWludDhBcnJheSA9PiBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0gKGlmIGNvbnRlbnQtdHlwZSB1bnNwZWNpZmllZClcblx0Ly8gLSBGZXRjaERhdGFSZXF1ZXN0LnByb2Nlc3NGdW5jID0gKGJvZHk6IFVpbnQ4QXJyYXksIHJlc3BvbnNlOiBGZXRjaERhdGFSZXNwb25zZSkgPT4gVFxuXHQvLyBGb3IgdGhpcyByZWFzb24sIGl0IHNob3VsZCBiZSBjb25zaWRlcmVkIGludGVybmFsIHVudGlsIHRoZSBBUEkgaXMgZmluYWxpemVkXG5cdGZ1bmN0aW9uIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0Z1bmMpIHtcblx0ICAgIC8vIEhvdyBtYW55IHRpbWVzIHRvIHJldHJ5IGluIHRoZSBldmVudCBvZiBhIHRocm90dGxlXG5cdCAgICB2YXIgYXR0ZW1wdExpbWl0ID0gKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwib2JqZWN0XCIgJiYgY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0ICE9IG51bGwpID8gY29ubmVjdGlvbi50aHJvdHRsZUxpbWl0IDogMTI7XG5cdCAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKGF0dGVtcHRMaW1pdCA+IDAgJiYgKGF0dGVtcHRMaW1pdCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgbGltaXRcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlTGltaXRcIiwgYXR0ZW1wdExpbWl0KTtcblx0ICAgIHZhciB0aHJvdHRsZUNhbGxiYWNrID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVDYWxsYmFjayA6IG51bGwpO1xuXHQgICAgdmFyIHRocm90dGxlU2xvdEludGVydmFsID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAoY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpID8gY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbCA6IDEwMCk7XG5cdCAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHRocm90dGxlU2xvdEludGVydmFsID4gMCAmJiAodGhyb3R0bGVTbG90SW50ZXJ2YWwgJSAxKSA9PT0gMCksIFwiaW52YWxpZCBjb25uZWN0aW9uIHRocm90dGxlIHNsb3QgaW50ZXJ2YWxcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlU2xvdEludGVydmFsXCIsIHRocm90dGxlU2xvdEludGVydmFsKTtcblx0ICAgIHZhciBoZWFkZXJzID0ge307XG5cdCAgICB2YXIgdXJsID0gbnVsbDtcblx0ICAgIC8vIEBUT0RPOiBBbGxvdyBDb25uZWN0aW9uSW5mbyB0byBvdmVycmlkZSBzb21lIG9mIHRoZXNlIHZhbHVlc1xuXHQgICAgdmFyIG9wdGlvbnMgPSB7XG5cdCAgICAgICAgbWV0aG9kOiBcIkdFVFwiLFxuXHQgICAgfTtcblx0ICAgIHZhciBhbGxvdzMwNCA9IGZhbHNlO1xuXHQgICAgdmFyIHRpbWVvdXQgPSAyICogNjAgKiAxMDAwO1xuXHQgICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbikgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB1cmwgPSBjb25uZWN0aW9uO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIikge1xuXHQgICAgICAgIGlmIChjb25uZWN0aW9uID09IG51bGwgfHwgY29ubmVjdGlvbi51cmwgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBVUkxcIiwgXCJjb25uZWN0aW9uLnVybFwiLCBjb25uZWN0aW9uKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdXJsID0gY29ubmVjdGlvbi51cmw7XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoY29ubmVjdGlvbi50aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiBjb25uZWN0aW9uLnRpbWVvdXQgPiAwKSB7XG5cdCAgICAgICAgICAgIHRpbWVvdXQgPSBjb25uZWN0aW9uLnRpbWVvdXQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb25uZWN0aW9uLmhlYWRlcnMpIHtcblx0ICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGNvbm5lY3Rpb24uaGVhZGVycykge1xuXHQgICAgICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB7IGtleToga2V5LCB2YWx1ZTogU3RyaW5nKGNvbm5lY3Rpb24uaGVhZGVyc1trZXldKSB9O1xuXHQgICAgICAgICAgICAgICAgaWYgKFtcImlmLW5vbmUtbWF0Y2hcIiwgXCJpZi1tb2RpZmllZC1zaW5jZVwiXS5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWxsb3czMDQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChjb25uZWN0aW9uLnVzZXIgIT0gbnVsbCAmJiBjb25uZWN0aW9uLnBhc3N3b3JkICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgaWYgKHVybC5zdWJzdHJpbmcoMCwgNikgIT09IFwiaHR0cHM6XCIgJiYgY29ubmVjdGlvbi5hbGxvd0luc2VjdXJlQXV0aGVudGljYXRpb24gIT09IHRydWUpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFzaWMgYXV0aGVudGljYXRpb24gcmVxdWlyZXMgYSBzZWN1cmUgaHR0cHMgdXJsXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHsgYXJndW1lbnQ6IFwidXJsXCIsIHVybDogdXJsLCB1c2VyOiBjb25uZWN0aW9uLnVzZXIsIHBhc3N3b3JkOiBcIltSRURBQ1RFRF1cIiB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgYXV0aG9yaXphdGlvbiA9IGNvbm5lY3Rpb24udXNlciArIFwiOlwiICsgY29ubmVjdGlvbi5wYXNzd29yZDtcblx0ICAgICAgICAgICAgaGVhZGVyc1tcImF1dGhvcml6YXRpb25cIl0gPSB7XG5cdCAgICAgICAgICAgICAgICBrZXk6IFwiQXV0aG9yaXphdGlvblwiLFxuXHQgICAgICAgICAgICAgICAgdmFsdWU6IFwiQmFzaWMgXCIgKyBicm93c2VyJDguZW5jb2RlKGxpYiQ4LnRvVXRmOEJ5dGVzKGF1dGhvcml6YXRpb24pKVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIGlmIChib2R5KSB7XG5cdCAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBcIlBPU1RcIjtcblx0ICAgICAgICBvcHRpb25zLmJvZHkgPSBib2R5O1xuXHQgICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC10eXBlXCJdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHsga2V5OiBcIkNvbnRlbnQtVHlwZVwiLCB2YWx1ZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID09IG51bGwpIHtcblx0ICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0geyBrZXk6IFwiQ29udGVudC1MZW5ndGhcIiwgdmFsdWU6IFN0cmluZyhib2R5Lmxlbmd0aCkgfTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICB2YXIgZmxhdEhlYWRlcnMgPSB7fTtcblx0ICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIHZhciBoZWFkZXIgPSBoZWFkZXJzW2tleV07XG5cdCAgICAgICAgZmxhdEhlYWRlcnNbaGVhZGVyLmtleV0gPSBoZWFkZXIudmFsdWU7XG5cdCAgICB9KTtcblx0ICAgIG9wdGlvbnMuaGVhZGVycyA9IGZsYXRIZWFkZXJzO1xuXHQgICAgdmFyIHJ1bm5pbmdUaW1lb3V0ID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuXHQgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICBpZiAodGltZW91dCkge1xuXHQgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVElNRU9VVCwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgICAgICB2YXIgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBpZiAodGltZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIHJldHVybiB7IHByb21pc2U6IHByb21pc2UsIGNhbmNlbDogY2FuY2VsIH07XG5cdCAgICB9KSgpO1xuXHQgICAgdmFyIHJ1bm5pbmdGZXRjaCA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYXR0ZW1wdCwgcmVzcG9uc2UsIHRyeUFnYWluLCBzdGFsbCwgcmV0cnlBZnRlciwgZXJyb3JfMSwgYm9keV8xLCByZXN1bHQsIGVycm9yXzIsIHRyeUFnYWluLCB0aW1lb3V0XzE7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHQgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhdHRlbXB0IDwgYXR0ZW1wdExpbWl0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMiwgOCwgLCA5XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJyb3dzZXJHZXR1cmwuZ2V0VXJsKHVybCwgb3B0aW9ucyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSAmJiBhdHRlbXB0IDwgYXR0ZW1wdExpbWl0KSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aHJvdHRsZUNhbGxiYWNrKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyeUFnYWluKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXRyeUFmdGVyID0gcmVzcG9uc2UuaGVhZGVyc1tcInJldHJ5LWFmdGVyXCJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXRyeUFmdGVyKSA9PT0gXCJzdHJpbmdcIiAmJiByZXRyeUFmdGVyLm1hdGNoKC9eWzEtOV1bMC05XSokLykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gcGFyc2VJbnQocmV0cnlBZnRlcikgKiAxMDAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhbGwgPSB0aHJvdHRsZVNsb3RJbnRlcnZhbCAqIHBhcnNlSW50KFN0cmluZyhNYXRoLnJhbmRvbSgpICogTWF0aC5wb3coMiwgYXR0ZW1wdCkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgNDI5XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdGFsbGVyKHN0YWxsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgNDI5XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBlcnJvcl8xLnJlc3BvbnNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVubmluZ1RpbWVvdXQuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmVzcG9uc2VcIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRXJyb3I6IGVycm9yXzEsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYm9keV8xID0gcmVzcG9uc2UuYm9keTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93MzA0ICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keV8xID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gMzAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFkIHJlc3BvbnNlXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZS5oZWFkZXJzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlpZnkoYm9keV8xLCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcm9jZXNzRnVuYykgcmV0dXJuIFszIC8qYnJlYWsqLywgMTddO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDEwO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMTAsIDEyLCAsIDE3XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHByb2Nlc3NGdW5jKGJvZHlfMSwgcmVzcG9uc2UpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDExOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlcnJvcl8yLnRocm90dGxlUmV0cnkgJiYgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDE2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QWdhaW4gPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRocm90dGxlQ2FsbGJhY2spIHJldHVybiBbMyAvKmJyZWFrKi8sIDE0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnlBZ2FpbiA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxNDtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRyeUFnYWluKSByZXR1cm4gWzMgLypicmVhayovLCAxNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXRfMSA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgY2FsbGJhY2tcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWxsZXIodGltZW91dF8xKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIGNhbGxiYWNrXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE4XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShib2R5XzEsICgocmVzcG9uc2UuaGVhZGVycykgPyByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIDogbnVsbCkpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXzIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Qm9keTogYm9keWlmeShvcHRpb25zLmJvZHksIGZsYXRIZWFkZXJzW1wiY29udGVudC10eXBlXCJdKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RNZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDE3XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UgaGFkIGEgcHJvY2Vzc0Z1bmMsIGl0IGVpdGVociByZXR1cm5lZCBhIFQgb3IgdGhyZXcgYWJvdmUuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImJvZHlcIiBpcyBub3cgYSBVaW50OEFycmF5LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYm9keV8xXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0Kys7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6IHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImZhaWxlZCByZXNwb25zZVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfSkoKTtcblx0ICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3J1bm5pbmdUaW1lb3V0LnByb21pc2UsIHJ1bm5pbmdGZXRjaF0pO1xuXHR9XG5cdGV4cG9ydHMuX2ZldGNoRGF0YSA9IF9mZXRjaERhdGE7XG5cdGZ1bmN0aW9uIGZldGNoSnNvbihjb25uZWN0aW9uLCBqc29uLCBwcm9jZXNzRnVuYykge1xuXHQgICAgdmFyIHByb2Nlc3NKc29uRnVuYyA9IGZ1bmN0aW9uICh2YWx1ZSwgcmVzcG9uc2UpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcblx0ICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShsaWIkOC50b1V0ZjhTdHJpbmcodmFsdWUpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBKU09OXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgIGJvZHk6IHZhbHVlLFxuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHByb2Nlc3NGdW5jKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IHByb2Nlc3NGdW5jKHJlc3VsdCwgcmVzcG9uc2UpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIElmIHdlIGhhdmUganNvbiB0byBzZW5kLCB3ZSBtdXN0XG5cdCAgICAvLyAtIGFkZCBjb250ZW50LXR5cGUgb2YgYXBwbGljYXRpb24vanNvbiAodW5sZXNzIGFscmVhZHkgb3ZlcnJpZGRlbilcblx0ICAgIC8vIC0gY29udmVydCB0aGUganNvbiB0byBieXRlc1xuXHQgICAgdmFyIGJvZHkgPSBudWxsO1xuXHQgICAgaWYgKGpzb24gIT0gbnVsbCkge1xuXHQgICAgICAgIGJvZHkgPSBsaWIkOC50b1V0ZjhCeXRlcyhqc29uKTtcblx0ICAgICAgICAvLyBDcmVhdGUgYSBjb25uZWN0aW9uIHdpdGggdGhlIGNvbnRlbnQtdHlwZSBzZXQgZm9yIEpTT05cblx0ICAgICAgICB2YXIgdXBkYXRlZCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSA/ICh7IHVybDogY29ubmVjdGlvbiB9KSA6IGxpYiQzLnNoYWxsb3dDb3B5KGNvbm5lY3Rpb24pO1xuXHQgICAgICAgIGlmICh1cGRhdGVkLmhlYWRlcnMpIHtcblx0ICAgICAgICAgICAgdmFyIGhhc0NvbnRlbnRUeXBlID0gKE9iamVjdC5rZXlzKHVwZGF0ZWQuaGVhZGVycykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7IHJldHVybiAoay50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiKTsgfSkubGVuZ3RoKSAhPT0gMDtcblx0ICAgICAgICAgICAgaWYgKCFoYXNDb250ZW50VHlwZSkge1xuXHQgICAgICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0gbGliJDMuc2hhbGxvd0NvcHkodXBkYXRlZC5oZWFkZXJzKTtcblx0ICAgICAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IFwiYXBwbGljYXRpb24vanNvblwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnMgPSB7IFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH07XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNvbm5lY3Rpb24gPSB1cGRhdGVkO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0pzb25GdW5jKTtcblx0fVxuXHRleHBvcnRzLmZldGNoSnNvbiA9IGZldGNoSnNvbjtcblx0ZnVuY3Rpb24gcG9sbChmdW5jLCBvcHRpb25zKSB7XG5cdCAgICBpZiAoIW9wdGlvbnMpIHtcblx0ICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICB9XG5cdCAgICBvcHRpb25zID0gbGliJDMuc2hhbGxvd0NvcHkob3B0aW9ucyk7XG5cdCAgICBpZiAob3B0aW9ucy5mbG9vciA9PSBudWxsKSB7XG5cdCAgICAgICAgb3B0aW9ucy5mbG9vciA9IDA7XG5cdCAgICB9XG5cdCAgICBpZiAob3B0aW9ucy5jZWlsaW5nID09IG51bGwpIHtcblx0ICAgICAgICBvcHRpb25zLmNlaWxpbmcgPSAxMDAwMDtcblx0ICAgIH1cblx0ICAgIGlmIChvcHRpb25zLmludGVydmFsID09IG51bGwpIHtcblx0ICAgICAgICBvcHRpb25zLmludGVydmFsID0gMjUwO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICB2YXIgdGltZXIgPSBudWxsO1xuXHQgICAgICAgIHZhciBkb25lID0gZmFsc2U7XG5cdCAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGNhbmNlbCB3YXMgc3VjY2Vzc2Z1bC4gVW5zdWNjZXNzZnVsIGNhbmNlbCBtZWFucyB3ZSdyZSBhbHJlYWR5IGRvbmUuXG5cdCAgICAgICAgdmFyIGNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG5cdCAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKG9wdGlvbnMudGltZW91dCkge1xuXHQgICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInRpbWVvdXRcIikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LCBvcHRpb25zLnRpbWVvdXQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmV0cnlMaW1pdCA9IG9wdGlvbnMucmV0cnlMaW1pdDtcblx0ICAgICAgICB2YXIgYXR0ZW1wdCA9IDA7XG5cdCAgICAgICAgZnVuY3Rpb24gY2hlY2soKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVzdWx0LCBvciBhcmUgYWxsb3dlZCBudWxsIHRoZW4gd2UncmUgZG9uZVxuXHQgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VQb2xsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlUG9sbC5vbmNlKFwicG9sbFwiLCBjaGVjayk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VCbG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZUJsb2NrLm9uY2UoXCJibG9ja1wiLCBjaGVjayk7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBleHBvbmVudGlhbCBiYWNrLW9mZiAodXAgdG8gMTBzKSBvdXIgbmV4dCByZXF1ZXN0XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIGlmICghZG9uZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGF0dGVtcHQrKztcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IHJldHJ5TGltaXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwicmV0cnkgbGltaXQgcmVhY2hlZFwiKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dCA9IG9wdGlvbnMuaW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPCBvcHRpb25zLmZsb29yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmZsb29yO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dCA+IG9wdGlvbnMuY2VpbGluZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gb3B0aW9ucy5jZWlsaW5nO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGNoZWNrLCB0aW1lb3V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBjaGVjaygpO1xuXHQgICAgfSk7XG5cdH1cblx0ZXhwb3J0cy5wb2xsID0gcG9sbDtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkbCA9IHVud3JhcEV4cG9ydHMobGliJGwpO1xuXHR2YXIgbGliXzEkbCA9IGxpYiRsLl9mZXRjaERhdGE7XG5cdHZhciBsaWJfMiRqID0gbGliJGwuZmV0Y2hKc29uO1xuXHR2YXIgbGliXzMkZiA9IGxpYiRsLnBvbGw7XG5cblx0J3VzZSBzdHJpY3QnO1xuXHR2YXIgQUxQSEFCRVQgPSAncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnO1xuXG5cdC8vIHByZS1jb21wdXRlIGxvb2t1cCB0YWJsZVxuXHR2YXIgQUxQSEFCRVRfTUFQID0ge307XG5cdGZvciAodmFyIHogPSAwOyB6IDwgQUxQSEFCRVQubGVuZ3RoOyB6KyspIHtcblx0ICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdCh6KTtcblxuXHQgIGlmIChBTFBIQUJFVF9NQVBbeF0gIT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKVxuXHQgIEFMUEhBQkVUX01BUFt4XSA9IHo7XG5cdH1cblxuXHRmdW5jdGlvbiBwb2x5bW9kU3RlcCAocHJlKSB7XG5cdCAgdmFyIGIgPSBwcmUgPj4gMjU7XG5cdCAgcmV0dXJuICgocHJlICYgMHgxRkZGRkZGKSA8PCA1KSBeXG5cdCAgICAoLSgoYiA+PiAwKSAmIDEpICYgMHgzYjZhNTdiMikgXlxuXHQgICAgKC0oKGIgPj4gMSkgJiAxKSAmIDB4MjY1MDhlNmQpIF5cblx0ICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG5cdCAgICAoLSgoYiA+PiAzKSAmIDEpICYgMHgzZDQyMzNkZCkgXlxuXHQgICAgKC0oKGIgPj4gNCkgJiAxKSAmIDB4MmExNDYyYjMpXG5cdH1cblxuXHRmdW5jdGlvbiBwcmVmaXhDaGsgKHByZWZpeCkge1xuXHQgIHZhciBjaGsgPSAxO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YXIgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuXHQgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KSByZXR1cm4gJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknXG5cblx0ICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiAoYyA+PiA1KTtcblx0ICB9XG5cdCAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKTtcblxuXHQgIGZvciAoaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciB2ID0gcHJlZml4LmNoYXJDb2RlQXQoaSk7XG5cdCAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKHYgJiAweDFmKTtcblx0ICB9XG5cdCAgcmV0dXJuIGNoa1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlIChwcmVmaXgsIHdvcmRzLCBMSU1JVCkge1xuXHQgIExJTUlUID0gTElNSVQgfHwgOTA7XG5cdCAgaWYgKChwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aCkgPiBMSU1JVCkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjZWVkcyBsZW5ndGggbGltaXQnKVxuXG5cdCAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG5cblx0ICAvLyBkZXRlcm1pbmUgY2hrIG1vZFxuXHQgIHZhciBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcblx0ICBpZiAodHlwZW9mIGNoayA9PT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcihjaGspXG5cblx0ICB2YXIgcmVzdWx0ID0gcHJlZml4ICsgJzEnO1xuXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcblx0ICAgIHZhciB4ID0gd29yZHNbaV07XG5cdCAgICBpZiAoKHggPj4gNSkgIT09IDApIHRocm93IG5ldyBFcnJvcignTm9uIDUtYml0IHdvcmQnKVxuXG5cdCAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4geDtcblx0ICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQoeCk7XG5cdCAgfVxuXG5cdCAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xuXHQgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKTtcblx0ICB9XG5cdCAgY2hrIF49IDE7XG5cblx0ICBmb3IgKGkgPSAwOyBpIDwgNjsgKytpKSB7XG5cdCAgICB2YXIgdiA9IChjaGsgPj4gKCg1IC0gaSkgKiA1KSkgJiAweDFmO1xuXHQgICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh2KTtcblx0ICB9XG5cblx0ICByZXR1cm4gcmVzdWx0XG5cdH1cblxuXHRmdW5jdGlvbiBfX2RlY29kZSAoc3RyLCBMSU1JVCkge1xuXHQgIExJTUlUID0gTElNSVQgfHwgOTA7XG5cdCAgaWYgKHN0ci5sZW5ndGggPCA4KSByZXR1cm4gc3RyICsgJyB0b28gc2hvcnQnXG5cdCAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVCkgcmV0dXJuICdFeGNlZWRzIGxlbmd0aCBsaW1pdCdcblxuXHQgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2Vcblx0ICB2YXIgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuXHQgIHZhciB1cHBlcmVkID0gc3RyLnRvVXBwZXJDYXNlKCk7XG5cdCAgaWYgKHN0ciAhPT0gbG93ZXJlZCAmJiBzdHIgIT09IHVwcGVyZWQpIHJldHVybiAnTWl4ZWQtY2FzZSBzdHJpbmcgJyArIHN0clxuXHQgIHN0ciA9IGxvd2VyZWQ7XG5cblx0ICB2YXIgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcblx0ICBpZiAoc3BsaXQgPT09IC0xKSByZXR1cm4gJ05vIHNlcGFyYXRvciBjaGFyYWN0ZXIgZm9yICcgKyBzdHJcblx0ICBpZiAoc3BsaXQgPT09IDApIHJldHVybiAnTWlzc2luZyBwcmVmaXggZm9yICcgKyBzdHJcblxuXHQgIHZhciBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc3BsaXQpO1xuXHQgIHZhciB3b3JkQ2hhcnMgPSBzdHIuc2xpY2Uoc3BsaXQgKyAxKTtcblx0ICBpZiAod29yZENoYXJzLmxlbmd0aCA8IDYpIHJldHVybiAnRGF0YSB0b28gc2hvcnQnXG5cblx0ICB2YXIgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG5cdCAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKSByZXR1cm4gY2hrXG5cblx0ICB2YXIgd29yZHMgPSBbXTtcblx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7ICsraSkge1xuXHQgICAgdmFyIGMgPSB3b3JkQ2hhcnMuY2hhckF0KGkpO1xuXHQgICAgdmFyIHYgPSBBTFBIQUJFVF9NQVBbY107XG5cdCAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJ1Vua25vd24gY2hhcmFjdGVyICcgKyBjXG5cdCAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gdjtcblxuXHQgICAgLy8gbm90IGluIHRoZSBjaGVja3N1bT9cblx0ICAgIGlmIChpICsgNiA+PSB3b3JkQ2hhcnMubGVuZ3RoKSBjb250aW51ZVxuXHQgICAgd29yZHMucHVzaCh2KTtcblx0ICB9XG5cblx0ICBpZiAoY2hrICE9PSAxKSByZXR1cm4gJ0ludmFsaWQgY2hlY2tzdW0gZm9yICcgKyBzdHJcblx0ICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCwgd29yZHM6IHdvcmRzIH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoKSB7XG5cdCAgdmFyIHJlcyA9IF9fZGVjb2RlLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG5cdCAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKSByZXR1cm4gcmVzXG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGUgKHN0cikge1xuXHQgIHZhciByZXMgPSBfX2RlY29kZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHQgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JykgcmV0dXJuIHJlc1xuXG5cdCAgdGhyb3cgbmV3IEVycm9yKHJlcylcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbnZlcnQgKGRhdGEsIGluQml0cywgb3V0Qml0cywgcGFkKSB7XG5cdCAgdmFyIHZhbHVlID0gMDtcblx0ICB2YXIgYml0cyA9IDA7XG5cdCAgdmFyIG1heFYgPSAoMSA8PCBvdXRCaXRzKSAtIDE7XG5cblx0ICB2YXIgcmVzdWx0ID0gW107XG5cdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG5cdCAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBpbkJpdHMpIHwgZGF0YVtpXTtcblx0ICAgIGJpdHMgKz0gaW5CaXRzO1xuXG5cdCAgICB3aGlsZSAoYml0cyA+PSBvdXRCaXRzKSB7XG5cdCAgICAgIGJpdHMgLT0gb3V0Qml0cztcblx0ICAgICAgcmVzdWx0LnB1c2goKHZhbHVlID4+IGJpdHMpICYgbWF4Vik7XG5cdCAgICB9XG5cdCAgfVxuXG5cdCAgaWYgKHBhZCkge1xuXHQgICAgaWYgKGJpdHMgPiAwKSB7XG5cdCAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA8PCAob3V0Qml0cyAtIGJpdHMpKSAmIG1heFYpO1xuXHQgICAgfVxuXHQgIH0gZWxzZSB7XG5cdCAgICBpZiAoYml0cyA+PSBpbkJpdHMpIHJldHVybiAnRXhjZXNzIHBhZGRpbmcnXG5cdCAgICBpZiAoKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4VikgcmV0dXJuICdOb24temVybyBwYWRkaW5nJ1xuXHQgIH1cblxuXHQgIHJldHVybiByZXN1bHRcblx0fVxuXG5cdGZ1bmN0aW9uIHRvV29yZHNVbnNhZmUgKGJ5dGVzKSB7XG5cdCAgdmFyIHJlcyA9IGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpO1xuXHQgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcblx0fVxuXG5cdGZ1bmN0aW9uIHRvV29yZHMgKGJ5dGVzKSB7XG5cdCAgdmFyIHJlcyA9IGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpO1xuXHQgIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcblxuXHQgIHRocm93IG5ldyBFcnJvcihyZXMpXG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tV29yZHNVbnNhZmUgKHdvcmRzKSB7XG5cdCAgdmFyIHJlcyA9IGNvbnZlcnQod29yZHMsIDUsIDgsIGZhbHNlKTtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSByZXR1cm4gcmVzXG5cdH1cblxuXHRmdW5jdGlvbiBmcm9tV29yZHMgKHdvcmRzKSB7XG5cdCAgdmFyIHJlcyA9IGNvbnZlcnQod29yZHMsIDUsIDgsIGZhbHNlKTtcblx0ICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKSByZXR1cm4gcmVzXG5cblx0ICB0aHJvdyBuZXcgRXJyb3IocmVzKVxuXHR9XG5cblx0dmFyIGJlY2gzMiA9IHtcblx0ICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcblx0ICBkZWNvZGU6IGRlY29kZSxcblx0ICBlbmNvZGU6IGVuY29kZSxcblx0ICB0b1dvcmRzVW5zYWZlOiB0b1dvcmRzVW5zYWZlLFxuXHQgIHRvV29yZHM6IHRvV29yZHMsXG5cdCAgZnJvbVdvcmRzVW5zYWZlOiBmcm9tV29yZHNVbnNhZmUsXG5cdCAgZnJvbVdvcmRzOiBmcm9tV29yZHNcblx0fTtcblx0dmFyIGJlY2gzMl8xID0gYmVjaDMyLmRlY29kZVVuc2FmZTtcblx0dmFyIGJlY2gzMl8yID0gYmVjaDMyLmRlY29kZTtcblx0dmFyIGJlY2gzMl8zID0gYmVjaDMyLmVuY29kZTtcblx0dmFyIGJlY2gzMl80ID0gYmVjaDMyLnRvV29yZHNVbnNhZmU7XG5cdHZhciBiZWNoMzJfNSA9IGJlY2gzMi50b1dvcmRzO1xuXHR2YXIgYmVjaDMyXzYgPSBiZWNoMzIuZnJvbVdvcmRzVW5zYWZlO1xuXHR2YXIgYmVjaDMyXzcgPSBiZWNoMzIuZnJvbVdvcmRzO1xuXG5cdHZhciBfdmVyc2lvbiRJID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHRleHBvcnRzLnZlcnNpb24gPSBcInByb3ZpZGVycy81LjAuOVwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRKID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRJKTtcblx0dmFyIF92ZXJzaW9uXzEkbSA9IF92ZXJzaW9uJEkudmVyc2lvbjtcblxuXHR2YXIgZm9ybWF0dGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdHZhciBGb3JtYXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBGb3JtYXR0ZXIoKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBGb3JtYXR0ZXIpO1xuXHQgICAgICAgIHRoaXMuZm9ybWF0cyA9IHRoaXMuZ2V0RGVmYXVsdEZvcm1hdHMoKTtcblx0ICAgIH1cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZ2V0RGVmYXVsdEZvcm1hdHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgZm9ybWF0cyA9ICh7fSk7XG5cdCAgICAgICAgdmFyIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3MuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgYmlnTnVtYmVyID0gdGhpcy5iaWdOdW1iZXIuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgYmxvY2tUYWcgPSB0aGlzLmJsb2NrVGFnLmJpbmQodGhpcyk7XG5cdCAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEuYmluZCh0aGlzKTtcblx0ICAgICAgICB2YXIgaGFzaCA9IHRoaXMuaGFzaC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBoZXggPSB0aGlzLmhleC5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBudW1iZXIgPSB0aGlzLm51bWJlci5iaW5kKHRoaXMpO1xuXHQgICAgICAgIHZhciBzdHJpY3REYXRhID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLmRhdGEodiwgdHJ1ZSk7IH07XG5cdCAgICAgICAgZm9ybWF0cy50cmFuc2FjdGlvbiA9IHtcblx0ICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIG51bGwpLFxuXHQgICAgICAgICAgICBibG9ja051bWJlcjogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciwgbnVsbCksXG5cdCAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcblx0ICAgICAgICAgICAgZ2FzUHJpY2U6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHZhbHVlOiBiaWdOdW1iZXIsXG5cdCAgICAgICAgICAgIG5vbmNlOiBudW1iZXIsXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIHI6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy51aW50MjU2KSxcblx0ICAgICAgICAgICAgczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnVpbnQyNTYpLFxuXHQgICAgICAgICAgICB2OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGNyZWF0ZXM6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHJhdzogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMudHJhbnNhY3Rpb25SZXF1ZXN0ID0ge1xuXHQgICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuXHQgICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuXHQgICAgICAgICAgICBnYXNMaW1pdDogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICBnYXNQcmljZTogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuXHQgICAgICAgICAgICB0bzogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzKSxcblx0ICAgICAgICAgICAgdmFsdWU6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93TnVsbChzdHJpY3REYXRhKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdExvZyA9IHtcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG5cdCAgICAgICAgICAgIGRhdGE6IGRhdGEsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMucmVjZWlwdCA9IHtcblx0ICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hZGRyZXNzLCBudWxsKSxcblx0ICAgICAgICAgICAgZnJvbTogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFkZHJlc3MsIG51bGwpLFxuXHQgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcywgbnVsbCksXG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcblx0ICAgICAgICAgICAgcm9vdDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcblx0ICAgICAgICAgICAgZ2FzVXNlZDogYmlnTnVtYmVyLFxuXHQgICAgICAgICAgICBsb2dzQmxvb206IEZvcm1hdHRlci5hbGxvd051bGwoZGF0YSksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuXHQgICAgICAgICAgICBsb2dzOiBGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnJlY2VpcHRMb2cuYmluZCh0aGlzKSksXG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBudW1iZXIsXG5cdCAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcblx0ICAgICAgICAgICAgY3VtdWxhdGl2ZUdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgc3RhdHVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlcilcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMuYmxvY2sgPSB7XG5cdCAgICAgICAgICAgIGhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIHBhcmVudEhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxuXHQgICAgICAgICAgICB0aW1lc3RhbXA6IG51bWJlcixcblx0ICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwoaGV4KSxcblx0ICAgICAgICAgICAgZGlmZmljdWx0eTogdGhpcy5kaWZmaWN1bHR5LmJpbmQodGhpcyksXG5cdCAgICAgICAgICAgIGdhc0xpbWl0OiBiaWdOdW1iZXIsXG5cdCAgICAgICAgICAgIGdhc1VzZWQ6IGJpZ051bWJlcixcblx0ICAgICAgICAgICAgbWluZXI6IGFkZHJlc3MsXG5cdCAgICAgICAgICAgIGV4dHJhRGF0YTogZGF0YSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKEZvcm1hdHRlci5hcnJheU9mKGhhc2gpKSxcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zID0gbGliJDMuc2hhbGxvd0NvcHkoZm9ybWF0cy5ibG9jayk7XG5cdCAgICAgICAgZm9ybWF0cy5ibG9ja1dpdGhUcmFuc2FjdGlvbnMudHJhbnNhY3Rpb25zID0gRm9ybWF0dGVyLmFsbG93TnVsbChGb3JtYXR0ZXIuYXJyYXlPZih0aGlzLnRyYW5zYWN0aW9uUmVzcG9uc2UuYmluZCh0aGlzKSkpO1xuXHQgICAgICAgIGZvcm1hdHMuZmlsdGVyID0ge1xuXHQgICAgICAgICAgICBmcm9tQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoLCB1bmRlZmluZWQpLFxuXHQgICAgICAgICAgICBhZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIHVuZGVmaW5lZCksXG5cdCAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnRvcGljcy5iaW5kKHRoaXMpLCB1bmRlZmluZWQpLFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgZm9ybWF0cy5maWx0ZXJMb2cgPSB7XG5cdCAgICAgICAgICAgIGJsb2NrTnVtYmVyOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG5cdCAgICAgICAgICAgIGJsb2NrSGFzaDogRm9ybWF0dGVyLmFsbG93TnVsbChoYXNoKSxcblx0ICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuXHQgICAgICAgICAgICByZW1vdmVkOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKHRoaXMuYm9vbGVhbi5iaW5kKHRoaXMpKSxcblx0ICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcblx0ICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93RmFsc2lzaChkYXRhLCBcIjB4XCIpLFxuXHQgICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hcnJheU9mKGhhc2gpLFxuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IGhhc2gsXG5cdCAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gZm9ybWF0cztcblx0ICAgIH07XG5cdCAgICAvLyBSZXF1aXJlcyBhIEJpZ051bWJlcmlzaCB0aGF0IGlzIHdpdGhpbiB0aGUgSUVFRTc1NCBzYWZlIGludGVnZXIgcmFuZ2U7IHJldHVybnMgYSBudW1iZXJcblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUubnVtYmVyID0gZnVuY3Rpb24gKG51bWJlcikge1xuXHQgICAgICAgIHJldHVybiBsaWIkMi5CaWdOdW1iZXIuZnJvbShudW1iZXIpLnRvTnVtYmVyKCk7XG5cdCAgICB9O1xuXHQgICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5iaWdOdW1iZXIgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8vIFJlcXVpcmVzIGEgYm9vbGVhbiwgXCJ0cnVlXCIgb3IgIFwiZmFsc2VcIjsgcmV0dXJucyBhIGJvb2xlYW5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwidHJ1ZVwiKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZmFsc2VcIikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9vbGVhbiAtIFwiICsgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcblx0ICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgaWYgKCFzdHJpY3QgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlKSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvTG93ZXJDYXNlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhhc2hcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKHZhbHVlLCBzdHJpY3QpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG5cdCAgICAgICAgaWYgKChyZXN1bHQubGVuZ3RoICUgMikgIT09IDApIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhOyBvZGQtbGVuZ3RoIC0gXCIgKyB2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYW4gYWRkcmVzc1xuXHQgICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5hZGRyZXNzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQ2LmdldEFkZHJlc3ModmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuY2FsbEFkZHJlc3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICBpZiAoIWxpYiQxLmlzSGV4U3RyaW5nKHZhbHVlLCAzMikpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBhZGRyZXNzID0gbGliJDYuZ2V0QWRkcmVzcyhsaWIkMS5oZXhEYXRhU2xpY2UodmFsdWUsIDEyKSk7XG5cdCAgICAgICAgcmV0dXJuIChhZGRyZXNzID09PSBsaWIkNy5BZGRyZXNzWmVybykgPyBudWxsIDogYWRkcmVzcztcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmNvbnRyYWN0QWRkcmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBsaWIkNi5nZXRDb250cmFjdEFkZHJlc3ModmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2tUYWcgPSBmdW5jdGlvbiAoYmxvY2tUYWcpIHtcblx0ICAgICAgICBpZiAoYmxvY2tUYWcgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImVhcmxpZXN0XCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChibG9ja1RhZyA9PT0gXCJsYXRlc3RcIiB8fCBibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgfHwgbGliJDEuaXNIZXhTdHJpbmcoYmxvY2tUYWcpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkMS5oZXhWYWx1ZShibG9ja1RhZyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmxvY2tUYWdcIik7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYSBoYXNoLCBvcHRpb25hbGx5IHJlcXVpcmVzIDB4IHByZWZpeDsgcmV0dXJucyBwcmVmaXhlZCBsb3dlcmNhc2UgaGFzaC5cblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICh2YWx1ZSwgc3RyaWN0KSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuXHQgICAgICAgIGlmIChsaWIkMS5oZXhEYXRhTGVuZ3RoKHJlc3VsdCkgIT09IDMyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoYXNoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIFJldHVybnMgdGhlIGRpZmZpY3VsdHkgYXMgYSBudW1iZXIsIG9yIGlmIHRvbyBsYXJnZSAoaS5lLiBQb0EgbmV0d29yaykgbnVsbFxuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5kaWZmaWN1bHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciB2ID0gbGliJDIuQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuXHQgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2LnRvTnVtYmVyKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS51aW50MjU2ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyh2YWx1ZSkpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZCh2YWx1ZSwgMzIpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuX2Jsb2NrID0gZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXQpIHtcblx0ICAgICAgICBpZiAodmFsdWUuYXV0aG9yICE9IG51bGwgJiYgdmFsdWUubWluZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB2YWx1ZS5taW5lciA9IHZhbHVlLmF1dGhvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayhmb3JtYXQsIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLmJsb2NrID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2spO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuYmxvY2tXaXRoVHJhbnNhY3Rpb25zID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKTtcblx0ICAgIH07XG5cdCAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uUmVxdWVzdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnRyYW5zYWN0aW9uUmVxdWVzdCwgdmFsdWUpO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUudHJhbnNhY3Rpb25SZXNwb25zZSA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIC8vIFJlbmFtZSBnYXMgdG8gZ2FzTGltaXRcblx0ICAgICAgICBpZiAodHJhbnNhY3Rpb24uZ2FzICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZ2FzTGltaXQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRyYW5zYWN0aW9uLmdhcztcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gU29tZSBjbGllbnRzIChUZXN0UlBDKSBkbyBzdHJhbmdlIHRoaW5ncyBsaWtlIHJldHVybiAweDAgZm9yIHRoZVxuXHQgICAgICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICYmIGxpYiQyLkJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLnRvKS5pc1plcm8oKSkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi50byA9IFwiMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFJlbmFtZSBpbnB1dCB0byBkYXRhXG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmlucHV0ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24uZGF0YSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSB0cmFuc2FjdGlvbi5pbnB1dDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gSWYgdG8gYW5kIGNyZWF0ZXMgYXJlIGVtcHR5LCBwb3B1bGF0ZSB0aGUgY3JlYXRlcyBmcm9tIHRoZSB0cmFuc2FjdGlvblxuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi50byA9PSBudWxsICYmIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5jcmVhdGVzID0gdGhpcy5jb250cmFjdEFkZHJlc3ModHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBAVE9ETzogdXNlIHRyYW5zYWN0aW9uLnNlcmlhbGl6ZT8gSGF2ZSB0byBhZGQgc3VwcG9ydCBmb3IgaW5jbHVkaW5nIHYsIHIsIGFuZCBzLi4uXG5cdCAgICAgICAgLypcblx0ICAgICAgICBpZiAoIXRyYW5zYWN0aW9uLnJhdykge1xuXHQgXG5cdCAgICAgICAgICAgICAvLyBWZXJ5IGxvb3NlIHByb3ZpZGVycyAoZS5nLiBUZXN0UlBDKSBkbyBub3QgcHJvdmlkZSBhIHNpZ25hdHVyZSBvciByYXdcblx0ICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi52ICYmIHRyYW5zYWN0aW9uLnIgJiYgdHJhbnNhY3Rpb24ucykge1xuXHQgICAgICAgICAgICAgICAgIGxldCByYXcgPSBbXG5cdCAgICAgICAgICAgICAgICAgICAgIHN0cmlwWmVyb3MoaGV4bGlmeSh0cmFuc2FjdGlvbi5ub25jZSkpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24uZ2FzUHJpY2UpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLmdhc0xpbWl0KSksXG5cdCAgICAgICAgICAgICAgICAgICAgICh0cmFuc2FjdGlvbi50byB8fCBcIjB4XCIpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24udmFsdWUgfHwgXCIweFwiKSksXG5cdCAgICAgICAgICAgICAgICAgICAgIGhleGxpZnkodHJhbnNhY3Rpb24uZGF0YSB8fCBcIjB4XCIpLFxuXHQgICAgICAgICAgICAgICAgICAgICBzdHJpcFplcm9zKGhleGxpZnkodHJhbnNhY3Rpb24udiB8fCBcIjB4XCIpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLnIpKSxcblx0ICAgICAgICAgICAgICAgICAgICAgc3RyaXBaZXJvcyhoZXhsaWZ5KHRyYW5zYWN0aW9uLnMpKSxcblx0ICAgICAgICAgICAgICAgICBdO1xuXHQgXG5cdCAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmF3ID0gcmxwRW5jb2RlKHJhdyk7XG5cdCAgICAgICAgICAgICB9XG5cdCAgICAgICAgIH1cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24pO1xuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi5jaGFpbklkICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIGNoYWluSWQgPSB0cmFuc2FjdGlvbi5jaGFpbklkO1xuXHQgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFpbklkID0gdHJhbnNhY3Rpb24ubmV0d29ya0lkO1xuXHQgICAgICAgICAgICAvLyBnZXRoLWV0YyByZXR1cm5zIGNoYWluSWRcblx0ICAgICAgICAgICAgaWYgKGNoYWluSWQgPT0gbnVsbCAmJiByZXN1bHQudiA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAobGliJDEuaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgKGNoYWluSWQpICE9PSBcIm51bWJlclwiICYmIHJlc3VsdC52ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgPCAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IDA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBjaGFpbklkID0gcGFyc2VJbnQoY2hhaW5JZCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQgPSAwO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gMHgwMDAwLi4uIHNob3VsZCBhY3R1YWxseSBiZSBudWxsXG5cdCAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgcmVzdWx0LmJsb2NrSGFzaC5yZXBsYWNlKC8wL2csIFwiXCIpID09PSBcInhcIikge1xuXHQgICAgICAgICAgICByZXN1bHQuYmxvY2tIYXNoID0gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIGxpYiRnLnBhcnNlKHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnJlY2VpcHRMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5yZWNlaXB0TG9nLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5yZWNlaXB0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgdmFyIHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMucmVjZWlwdCwgdmFsdWUpO1xuXHQgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXN1bHQuYnl6YW50aXVtID0gdHJ1ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIucHJvdG90eXBlLnRvcGljcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIF90aGlzLnRvcGljcyh2KTsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaCh2YWx1ZSwgdHJ1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEZvcm1hdHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyLCB2YWx1ZSk7XG5cdCAgICB9O1xuXHQgICAgRm9ybWF0dGVyLnByb3RvdHlwZS5maWx0ZXJMb2cgPSBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy5maWx0ZXJMb2csIHZhbHVlKTtcblx0ICAgIH07XG5cdCAgICBGb3JtYXR0ZXIuY2hlY2sgPSBmdW5jdGlvbiAoZm9ybWF0LCBvYmplY3QpIHtcblx0ICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgZm9yICh2YXIga2V5IGluIGZvcm1hdCkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZm9ybWF0W2tleV0ob2JqZWN0W2tleV0pO1xuXHQgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgZXJyb3IuY2hlY2tLZXkgPSBrZXk7XG5cdCAgICAgICAgICAgICAgICBlcnJvci5jaGVja1ZhbHVlID0gb2JqZWN0W2tleV07XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgfTtcblx0ICAgIC8vIGlmIHZhbHVlIGlzIG51bGwtaXNoLCBudWxsVmFsdWUgaXMgcmV0dXJuZWRcblx0ICAgIEZvcm1hdHRlci5hbGxvd051bGwgPSBmdW5jdGlvbiAoZm9ybWF0LCBudWxsVmFsdWUpIHtcblx0ICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG51bGxWYWx1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBJZiB2YWx1ZSBpcyBmYWxzZS1pc2gsIHJlcGxhY2VWYWx1ZSBpcyByZXR1cm5lZFxuXHQgICAgRm9ybWF0dGVyLmFsbG93RmFsc2lzaCA9IGZ1bmN0aW9uIChmb3JtYXQsIHJlcGxhY2VWYWx1ZSkge1xuXHQgICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIGlmICghdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCh2YWx1ZSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmVxdWlyZXMgYW4gQXJyYXkgc2F0aXNmeWluZyBjaGVja1xuXHQgICAgRm9ybWF0dGVyLmFycmF5T2YgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG5cdCAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoYXJyYXkpIHtcblx0ICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGFuIGFycmF5XCIpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZvcm1hdCh2YWx1ZSkpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRm9ybWF0dGVyO1xuXHR9KCkpO1xuXHRleHBvcnRzLkZvcm1hdHRlciA9IEZvcm1hdHRlcjtcblx0Ly8gU2hvdyB0aGUgdGhyb3R0bGUgbWVzc2FnZSBvbmx5IG9uY2Vcblx0dmFyIHRocm90dGxlTWVzc2FnZSA9IGZhbHNlO1xuXHRmdW5jdGlvbiBzaG93VGhyb3R0bGVNZXNzYWdlKCkge1xuXHQgICAgaWYgKHRocm90dGxlTWVzc2FnZSkge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblx0ICAgIHRocm90dGxlTWVzc2FnZSA9IHRydWU7XG5cdCAgICBjb25zb2xlLmxvZyhcIj09PT09PT09PSBOT1RJQ0UgPT09PT09PT09XCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJSZXF1ZXN0LVJhdGUgRXhjZWVkZWQgICh0aGlzIG1lc3NhZ2Ugd2lsbCBub3QgYmUgcmVwZWF0ZWQpXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJcIik7XG5cdCAgICBjb25zb2xlLmxvZyhcIlRoZSBkZWZhdWx0IEFQSSBrZXlzIGZvciBlYWNoIHNlcnZpY2UgYXJlIHByb3ZpZGVkIGFzIGEgaGlnaGx5LXRocm90dGxlZCxcIik7XG5cdCAgICBjb25zb2xlLmxvZyhcImNvbW11bml0eSByZXNvdXJjZSBmb3IgbG93LXRyYWZmaWMgcHJvamVjdHMgYW5kIGVhcmx5IHByb3RvdHlwaW5nLlwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuXHQgICAgY29uc29sZS5sb2coXCJXaGlsZSB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgY29udGludWUgdG8gZnVuY3Rpb24sIHdlIGhpZ2hseSByZWNvbW1lbmRlZFwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwic2lnbmluZyB1cCBmb3IgeW91ciBvd24gQVBJIGtleXMgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaW5jcmVhc2UgeW91clwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwicmVxdWVzdCByYXRlL2xpbWl0IGFuZCBlbmFibGUgb3RoZXIgcGVya3MsIHN1Y2ggYXMgbWV0cmljcyBhbmQgYWR2YW5jZWQgQVBJcy5cIik7XG5cdCAgICBjb25zb2xlLmxvZyhcIlwiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiRm9yIG1vcmUgZGV0YWlsczogaHR0cHM6L1xcL2RvY3MuZXRoZXJzLmlvL2FwaS1rZXlzL1wiKTtcblx0ICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XG5cdH1cblx0ZXhwb3J0cy5zaG93VGhyb3R0bGVNZXNzYWdlID0gc2hvd1Rocm90dGxlTWVzc2FnZTtcblxuXHR9KTtcblxuXHR2YXIgZm9ybWF0dGVyJDEgPSB1bndyYXBFeHBvcnRzKGZvcm1hdHRlcik7XG5cdHZhciBmb3JtYXR0ZXJfMSA9IGZvcm1hdHRlci5Gb3JtYXR0ZXI7XG5cdHZhciBmb3JtYXR0ZXJfMiA9IGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlO1xuXG5cdHZhciBiYXNlUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBFdmVudCBTZXJpYWxpemVpbmdcblx0ZnVuY3Rpb24gY2hlY2tUb3BpYyh0b3BpYykge1xuXHQgICAgaWYgKHRvcGljID09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gXCJudWxsXCI7XG5cdCAgICB9XG5cdCAgICBpZiAobGliJDEuaGV4RGF0YUxlbmd0aCh0b3BpYykgIT09IDMyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdG9waWNcIiwgXCJ0b3BpY1wiLCB0b3BpYyk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gdG9waWMudG9Mb3dlckNhc2UoKTtcblx0fVxuXHRmdW5jdGlvbiBzZXJpYWxpemVUb3BpY3ModG9waWNzKSB7XG5cdCAgICAvLyBSZW1vdmUgdHJhaWxpbmcgbnVsbCBBTkQtdG9waWNzOyB0aGV5IGFyZSByZWR1bmRhbnRcblx0ICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuXHQgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggPiAwICYmIHRvcGljc1t0b3BpY3MubGVuZ3RoIC0gMV0gPT0gbnVsbCkge1xuXHQgICAgICAgIHRvcGljcy5wb3AoKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiB0b3BpY3MubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuXHQgICAgICAgICAgICAvLyBPbmx5IHRyYWNrIHVuaXF1ZSBPUi10b3BpY3Ncblx0ICAgICAgICAgICAgdmFyIHVuaXF1ZV8xID0ge307XG5cdCAgICAgICAgICAgIHRvcGljLmZvckVhY2goZnVuY3Rpb24gKHRvcGljKSB7XG5cdCAgICAgICAgICAgICAgICB1bmlxdWVfMVtjaGVja1RvcGljKHRvcGljKV0gPSB0cnVlO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgLy8gVGhlIG9yZGVyIG9mIE9SLXRvcGljcyBkb2VzIG5vdCBtYXR0ZXJcblx0ICAgICAgICAgICAgdmFyIHNvcnRlZCA9IE9iamVjdC5rZXlzKHVuaXF1ZV8xKTtcblx0ICAgICAgICAgICAgc29ydGVkLnNvcnQoKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNvcnRlZC5qb2luKFwifFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjaGVja1RvcGljKHRvcGljKTtcblx0ICAgICAgICB9XG5cdCAgICB9KS5qb2luKFwiJlwiKTtcblx0fVxuXHRmdW5jdGlvbiBkZXNlcmlhbGl6ZVRvcGljcyhkYXRhKSB7XG5cdCAgICBpZiAoZGF0YSA9PT0gXCJcIikge1xuXHQgICAgICAgIHJldHVybiBbXTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBkYXRhLnNwbGl0KC8mL2cpLm1hcChmdW5jdGlvbiAodG9waWMpIHtcblx0ICAgICAgICBpZiAodG9waWMgPT09IFwiXCIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgY29tcHMgPSB0b3BpYy5zcGxpdChcInxcIikubWFwKGZ1bmN0aW9uICh0b3BpYykge1xuXHQgICAgICAgICAgICByZXR1cm4gKCh0b3BpYyA9PT0gXCJudWxsXCIpID8gbnVsbCA6IHRvcGljKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gKChjb21wcy5sZW5ndGggPT09IDEpID8gY29tcHNbMF0gOiBjb21wcyk7XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBnZXRFdmVudFRhZyhldmVudE5hbWUpIHtcblx0ICAgIGlmICh0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICBpZiAobGliJDEuaGV4RGF0YUxlbmd0aChldmVudE5hbWUpID09PSAzMikge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJ0eDpcIiArIGV2ZW50TmFtZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV2ZW50TmFtZSkpIHtcblx0ICAgICAgICByZXR1cm4gXCJmaWx0ZXI6KjpcIiArIHNlcmlhbGl6ZVRvcGljcyhldmVudE5hbWUpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAobGliJGIuRm9ya0V2ZW50LmlzRm9ya0V2ZW50KGV2ZW50TmFtZSkpIHtcblx0ICAgICAgICBsb2dnZXIud2FybihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChldmVudE5hbWUgJiYgdHlwZW9mIChldmVudE5hbWUpID09PSBcIm9iamVjdFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIFwiZmlsdGVyOlwiICsgKGV2ZW50TmFtZS5hZGRyZXNzIHx8IFwiKlwiKSArIFwiOlwiICsgc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZS50b3BpY3MgfHwgW10pO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBldmVudCAtIFwiICsgZXZlbnROYW1lKTtcblx0fVxuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gSGVscGVyIE9iamVjdFxuXHRmdW5jdGlvbiBnZXRUaW1lKCkge1xuXHQgICAgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cdH1cblx0ZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pO1xuXHQgICAgfSk7XG5cdH1cblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIFByb3ZpZGVyIE9iamVjdFxuXHQvKipcblx0ICogIEV2ZW50VHlwZVxuXHQgKiAgIC0gXCJibG9ja1wiXG5cdCAqICAgLSBcInBvbGxcIlxuXHQgKiAgIC0gXCJkaWRQb2xsXCJcblx0ICogICAtIFwicGVuZGluZ1wiXG5cdCAqICAgLSBcImVycm9yXCJcblx0ICogICAtIFwibmV0d29ya1wiXG5cdCAqICAgLSBmaWx0ZXJcblx0ICogICAtIHRvcGljcyBhcnJheVxuXHQgKiAgIC0gdHJhbnNhY3Rpb24gaGFzaFxuXHQgKi9cblx0dmFyIFBvbGxhYmxlRXZlbnRzID0gW1wiYmxvY2tcIiwgXCJuZXR3b3JrXCIsIFwicGVuZGluZ1wiLCBcInBvbGxcIl07XG5cdHZhciBFdmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcblx0ICAgIGZ1bmN0aW9uIEV2ZW50KHRhZywgbGlzdGVuZXIsIG9uY2UpIHtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcInRhZ1wiLCB0YWcpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwibGlzdGVuZXJcIiwgbGlzdGVuZXIpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwib25jZVwiLCBvbmNlKTtcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiZXZlbnRcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaDtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgXCJ0eXBlXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiaGFzaFwiLCB7XG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcblx0ICAgICAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcInR4XCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBjb21wc1sxXTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsIFwiZmlsdGVyXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuXHQgICAgICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwiZmlsdGVyXCIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBhZGRyZXNzID0gY29tcHNbMV07XG5cdCAgICAgICAgICAgIHZhciB0b3BpY3MgPSBkZXNlcmlhbGl6ZVRvcGljcyhjb21wc1syXSk7XG5cdCAgICAgICAgICAgIHZhciBmaWx0ZXIgPSB7fTtcblx0ICAgICAgICAgICAgaWYgKHRvcGljcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIudG9waWNzID0gdG9waWNzO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChhZGRyZXNzICYmIGFkZHJlc3MgIT09IFwiKlwiKSB7XG5cdCAgICAgICAgICAgICAgICBmaWx0ZXIuYWRkcmVzcyA9IGFkZHJlc3M7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIEV2ZW50LnByb3RvdHlwZS5wb2xsYWJsZSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gKHRoaXMudGFnLmluZGV4T2YoXCI6XCIpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMCk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEV2ZW50O1xuXHR9KCkpO1xuXHRleHBvcnRzLkV2ZW50ID0gRXZlbnQ7XG5cdDtcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZFxuXHR2YXIgY29pbkluZm9zID0ge1xuXHQgICAgXCIwXCI6IHsgc3ltYm9sOiBcImJ0Y1wiLCBwMnBraDogMHgwMCwgcDJzaDogMHgwNSwgcHJlZml4OiBcImJjXCIgfSxcblx0ICAgIFwiMlwiOiB7IHN5bWJvbDogXCJsdGNcIiwgcDJwa2g6IDB4MzAsIHAyc2g6IDB4MzIsIHByZWZpeDogXCJsdGNcIiB9LFxuXHQgICAgXCIzXCI6IHsgc3ltYm9sOiBcImRvZ2VcIiwgcDJwa2g6IDB4MWUsIHAyc2g6IDB4MTYgfSxcblx0ICAgIFwiNjBcIjogeyBzeW1ib2w6IFwiZXRoXCIsIGlsazogXCJldGhcIiB9LFxuXHQgICAgXCI2MVwiOiB7IHN5bWJvbDogXCJldGNcIiwgaWxrOiBcImV0aFwiIH0sXG5cdCAgICBcIjcwMFwiOiB7IHN5bWJvbDogXCJ4ZGFpXCIsIGlsazogXCJldGhcIiB9LFxuXHR9O1xuXHRmdW5jdGlvbiBieXRlczMyaWZ5KHZhbHVlKSB7XG5cdCAgICByZXR1cm4gbGliJDEuaGV4WmVyb1BhZChsaWIkMi5CaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSwgMzIpO1xuXHR9XG5cdC8vIENvbXB1dGUgdGhlIEJhc2U1OENoZWNrIGVuY29kZWQgZGF0YSAoY2hlY2tzdW0gaXMgZmlyc3QgNCBieXRlcyBvZiBzaGEyNTZkKVxuXHRmdW5jdGlvbiBiYXNlNThFbmNvZGUoZGF0YSkge1xuXHQgICAgcmV0dXJuIGxpYiRlLkJhc2U1OC5lbmNvZGUobGliJDEuY29uY2F0KFtkYXRhLCBsaWIkMS5oZXhEYXRhU2xpY2UoYnJvd3Nlci5zaGEyNTYoYnJvd3Nlci5zaGEyNTYoZGF0YSkpLCAwLCA0KV0pKTtcblx0fVxuXHR2YXIgUmVzb2x2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG5cdCAgICBmdW5jdGlvbiBSZXNvbHZlcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSkge1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KHRoaXMsIFwibmFtZVwiLCBuYW1lKTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgcHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzcykpO1xuXHQgICAgfVxuXHQgICAgUmVzb2x2ZXIucHJvdG90eXBlLl9mZXRjaEJ5dGVzID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBwYXJhbWV0ZXJzKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24sIHJlc3VsdCwgb2Zmc2V0LCBsZW5ndGg7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGxpYiQxLmhleENvbmNhdChbc2VsZWN0b3IsIGxpYiQ5Lm5hbWVoYXNoKHRoaXMubmFtZSksIChwYXJhbWV0ZXJzIHx8IFwiMHhcIildKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnByb3ZpZGVyLmNhbGwodHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGliJDIuQmlnTnVtYmVyLmZyb20obGliJDEuaGV4RGF0YVNsaWNlKHJlc3VsdCwgMCwgMzIpKS50b051bWJlcigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShsaWIkMS5oZXhEYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxpYiQxLmhleERhdGFTbGljZShyZXN1bHQsIG9mZnNldCArIDMyLCBvZmZzZXQgKyAzMiArIGxlbmd0aCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBSZXNvbHZlci5wcm90b3R5cGUuX2dldEFkZHJlc3MgPSBmdW5jdGlvbiAoY29pblR5cGUsIGhleEJ5dGVzKSB7XG5cdCAgICAgICAgdmFyIGNvaW5JbmZvID0gY29pbkluZm9zW1N0cmluZyhjb2luVHlwZSldO1xuXHQgICAgICAgIGlmIChjb2luSW5mbyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgY29pbiB0eXBlOiBcIiArIGNvaW5UeXBlLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRBZGRyZXNzKFwiICsgY29pblR5cGUgKyBcIilcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKGNvaW5JbmZvLmlsayA9PT0gXCJldGhcIikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhoZXhCeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBieXRlcyA9IGxpYiQxLmFycmF5aWZ5KGhleEJ5dGVzKTtcblx0ICAgICAgICAvLyBQMlBLSDogT1BfRFVQIE9QX0hBU0gxNjAgPHB1YktleUhhc2g+IE9QX0VRVUFMVkVSSUZZIE9QX0NIRUNLU0lHXG5cdCAgICAgICAgaWYgKGNvaW5JbmZvLnAycGtoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgdmFyIHAycGtoID0gaGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7XG5cdCAgICAgICAgICAgIGlmIChwMnBraCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGxlbmd0aF8xID0gcGFyc2VJbnQocDJwa2hbMV0sIDE2KTtcblx0ICAgICAgICAgICAgICAgIGlmIChwMnBraFsyXS5sZW5ndGggPT09IGxlbmd0aF8xICogMiAmJiBsZW5ndGhfMSA+PSAxICYmIGxlbmd0aF8xIDw9IDc1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZShsaWIkMS5jb25jYXQoW1tjb2luSW5mby5wMnBraF0sIChcIjB4XCIgKyBwMnBraFsyXSldKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gUDJTSDogT1BfSEFTSDE2MCA8c2NyaXB0SGFzaD4gT1BfRVFVQUxcblx0ICAgICAgICBpZiAoY29pbkluZm8ucDJzaCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciBwMnNoID0gaGV4Qnl0ZXMubWF0Y2goL14weGE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4NyQvKTtcblx0ICAgICAgICAgICAgaWYgKHAyc2gpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMiA9IHBhcnNlSW50KHAyc2hbMV0sIDE2KTtcblx0ICAgICAgICAgICAgICAgIGlmIChwMnNoWzJdLmxlbmd0aCA9PT0gbGVuZ3RoXzIgKiAyICYmIGxlbmd0aF8yID49IDEgJiYgbGVuZ3RoXzIgPD0gNzUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmFzZTU4RW5jb2RlKGxpYiQxLmNvbmNhdChbW2NvaW5JbmZvLnAyc2hdLCAoXCIweFwiICsgcDJzaFsyXSldKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQmVjaDMyXG5cdCAgICAgICAgaWYgKGNvaW5JbmZvLnByZWZpeCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciBsZW5ndGhfMyA9IGJ5dGVzWzFdO1xuXHQgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMTQxLm1lZGlhd2lraSN3aXRuZXNzLXByb2dyYW1cblx0ICAgICAgICAgICAgdmFyIHZlcnNpb25fMSA9IGJ5dGVzWzBdO1xuXHQgICAgICAgICAgICBpZiAodmVyc2lvbl8xID09PSAweDAwKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobGVuZ3RoXzMgIT09IDIwICYmIGxlbmd0aF8zICE9PSAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgIHZlcnNpb25fMSA9IC0xO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdmVyc2lvbl8xID0gLTE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKHZlcnNpb25fMSA+PSAwICYmIGJ5dGVzLmxlbmd0aCA9PT0gMiArIGxlbmd0aF8zICYmIGxlbmd0aF8zID49IDEgJiYgbGVuZ3RoXzMgPD0gNzUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3b3JkcyA9IGJlY2gzMi50b1dvcmRzKGJ5dGVzLnNsaWNlKDIpKTtcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnVuc2hpZnQodmVyc2lvbl8xKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBiZWNoMzIuZW5jb2RlKGNvaW5JbmZvLnByZWZpeCwgd29yZHMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIFJlc29sdmVyLnByb3RvdHlwZS5nZXRBZGRyZXNzID0gZnVuY3Rpb24gKGNvaW5UeXBlKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24sIGhleEJ5dGVzXzEsIGhleEJ5dGVzLCBhZGRyZXNzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29pblR5cGUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29pblR5cGUgPSA2MDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjb2luVHlwZSA9PT0gNjApKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogdGhpcy5hZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgzYjNiNTdkZVwiICsgbGliJDkubmFtZWhhc2godGhpcy5uYW1lKS5zdWJzdHJpbmcoMikpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucHJvdmlkZXIuY2FsbCh0cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGV4Qnl0ZXNfMSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGV4Qnl0ZXNfMSA9PT0gXCIweFwiIHx8IGhleEJ5dGVzXzEgPT09IGxpYiQ3Lkhhc2haZXJvKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKGhleEJ5dGVzXzEpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2ZldGNoQnl0ZXMoXCIweGYxY2I3ZTA2XCIsIGJ5dGVzMzJpZnkoY29pblR5cGUpKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gYWRkcmVzc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IHRoaXMuX2dldEFkZHJlc3MoY29pblR5cGUsIGhleEJ5dGVzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvaW4gZGF0YVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzcyhcIiArIGNvaW5UeXBlICsgXCIpXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29pblR5cGU6IGNvaW5UeXBlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFJlc29sdmVyLnByb3RvdHlwZS5nZXRDb250ZW50SGFzaCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoZXhCeXRlcywgaXBmcywgbGVuZ3RoXzQsIHN3YXJtO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhiYzFjNThkMVwiKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZXhCeXRlcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm8gY29udGVudGhhc2hcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlwZnMgPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTMwMTAxNzAoKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKikpJC8pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmcykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoXzQgPSBwYXJzZUludChpcGZzWzNdLCAxNik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXBmc1s0XS5sZW5ndGggPT09IGxlbmd0aF80ICogMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBcImlwZnM6L1xcL1wiICsgbGliJGUuQmFzZTU4LmVuY29kZShcIjB4XCIgKyBpcGZzWzFdKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dhcm0gPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN3YXJtKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3dhcm1bMV0ubGVuZ3RoID09PSAoMzIgKiAyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBcImJ6ejovXFwvXCIgKyBzd2FybVsxXV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiaW52YWxpZCBvciB1bnN1cHBvcnRlZCBjb250ZW50IGhhc2ggZGF0YVwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0Q29udGVudEhhc2goKVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGhleEJ5dGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFJlc29sdmVyLnByb3RvdHlwZS5nZXRUZXh0ID0gZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGtleUJ5dGVzLCBoZXhCeXRlcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSBsaWIkOC50b1V0ZjhCeXRlcyhrZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm9kZWhhc2ggY29uc3VtZXMgdGhlIGZpcnN0IHNsb3QsIHNvIHRoZSBzdHJpbmcgcG9pbnRlciB0YXJnZXRzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcblx0ICAgICAgICAgICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSBsaWIkMS5jb25jYXQoW2J5dGVzMzJpZnkoNjQpLCBieXRlczMyaWZ5KGtleUJ5dGVzLmxlbmd0aCksIGtleUJ5dGVzXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhZCB0byB3b3JkLXNpemUgKDMyIGJ5dGVzKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGtleUJ5dGVzLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5Qnl0ZXMgPSBsaWIkMS5jb25jYXQoW2tleUJ5dGVzLCBsaWIkMS5oZXhaZXJvUGFkKFwiMHhcIiwgMzIgLSAoa2V5Lmxlbmd0aCAlIDMyKSldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHg1OWQxZDQzY1wiLCBsaWIkMS5oZXhsaWZ5KGtleUJ5dGVzKSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGV4Qnl0ZXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJDgudG9VdGY4U3RyaW5nKGhleEJ5dGVzKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBSZXNvbHZlcjtcblx0fSgpKTtcblx0ZXhwb3J0cy5SZXNvbHZlciA9IFJlc29sdmVyO1xuXHR2YXIgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5cdHZhciBuZXh0UG9sbElkID0gMTtcblx0dmFyIEJhc2VQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhCYXNlUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICAvKipcblx0ICAgICAqICByZWFkeVxuXHQgICAgICpcblx0ICAgICAqICBBIFByb21pc2U8TmV0d29yaz4gdGhhdCByZXNvbHZlcyBvbmx5IG9uY2UgdGhlIHByb3ZpZGVyIGlzIHJlYWR5LlxuXHQgICAgICpcblx0ICAgICAqICBTdWItY2xhc3NlcyB0aGF0IGNhbGwgdGhlIHN1cGVyIHdpdGggYSBuZXR3b3JrIHdpdGhvdXQgYSBjaGFpbklkXG5cdCAgICAgKiAgTVVTVCBzZXQgdGhpcy4gU3RhbmRhcmQgbmFtZWQgbmV0d29ya3MgaGF2ZSBhIGtub3duIGNoYWluSWQuXG5cdCAgICAgKlxuXHQgICAgICovXG5cdCAgICBmdW5jdGlvbiBCYXNlUHJvdmlkZXIobmV0d29yaykge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBsaWIkYi5Qcm92aWRlcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXHQgICAgICAgIC8vIEV2ZW50cyBiZWluZyBsaXN0ZW5lZCB0b1xuXHQgICAgICAgIF90aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICBfdGhpcy5fZW1pdHRlZCA9IHsgYmxvY2s6IC0yIH07XG5cdCAgICAgICAgX3RoaXMuZm9ybWF0dGVyID0gX25ld1RhcmdldC5nZXRGb3JtYXR0ZXIoKTtcblx0ICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcblx0ICAgICAgICAvLyBuZXR3b3JrIHRvIGNoYW5nZSBkeW5hbWljYWxseSwgYW5kIHdlIGF1dG8tZGV0ZWN0IHRoZVxuXHQgICAgICAgIC8vIGN1cnJlbnQgbmV0d29ya1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFueU5ldHdvcmtcIiwgKG5ldHdvcmsgPT09IFwiYW55XCIpKTtcblx0ICAgICAgICBpZiAoX3RoaXMuYW55TmV0d29yaykge1xuXHQgICAgICAgICAgICBuZXR3b3JrID0gX3RoaXMuZGV0ZWN0TmV0d29yaygpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAobmV0d29yayBpbnN0YW5jZW9mIFByb21pc2UpIHtcblx0ICAgICAgICAgICAgX3RoaXMuX25ldHdvcmtQcm9taXNlID0gbmV0d29yaztcblx0ICAgICAgICAgICAgLy8gU3F1YXNoIGFueSBcInVuaGFuZGxlZCBwcm9taXNlXCIgZXJyb3JzOyB0aGF0IGRvIG5vdCBuZWVkIHRvIGJlIGhhbmRsZWRcblx0ICAgICAgICAgICAgbmV0d29yay5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5pdGlhbCBuZXR3b3JrIHNldHRpbmcgKGFzeW5jKVxuXHQgICAgICAgICAgICBfdGhpcy5fcmVhZHkoKS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICB2YXIga25vd25OZXR3b3JrID0gbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuXHQgICAgICAgICAgICBpZiAoa25vd25OZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfbmV0d29ya1wiLCBrbm93bk5ldHdvcmspO1xuXHQgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChcIm5ldHdvcmtcIiwga25vd25OZXR3b3JrLCBudWxsKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG5cdCAgICAgICAgX3RoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuXHQgICAgICAgIF90aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSA0MDAwO1xuXHQgICAgICAgIF90aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9yZWFkeSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXR3b3JrLCBlcnJvcl8xO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9uZXR3b3JrID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbmV0d29ya1Byb21pc2UpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9uZXR3b3JrUHJvbWlzZV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yayA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZGV0ZWN0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjsgZXZlcnkgUHJvdmlkZXIgc3ViLWNsYXNzIHNob3VsZCBoYXZlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3RlZCBhIG5ldHdvcmsgYnkgaGVyZSAob3IgaGF2ZSB0aHJvd24pLlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9zc2libGUgdGhpcyBjYWxsIHN0YWNrZWQgc28gZG8gbm90IGNhbGwgZGVmaW5lUmVhZE9ubHkgYWdhaW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX25ldHdvcmsgPSBuZXR3b3JrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgbmV0d29yaywgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA3O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuX25ldHdvcmtdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJyZWFkeVwiLCB7XG5cdCAgICAgICAgLy8gVGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIG1vc3QgcmVjZW50bHkgZXN0YWJsaXNoZWQgbmV0d29yay5cblx0ICAgICAgICAvLyBGb3IgXCJhbnlcIiwgdGhpcyBjYW4gY2hhbmdlIChhIFwibmV0d29ya1wiIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlXG5cdCAgICAgICAgLy8gYW55IGNoYW5nZSBpcyByZWZlbGN0ZWQpOyBvdGhlcndpc2UgdGhpcyBjYW5ub3QgY2hhbmdlXG5cdCAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkbC5wb2xsKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVhZHkoKS50aGVuKGZ1bmN0aW9uIChuZXR3b3JrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldHdvcms7XG5cdCAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbmV0d29yayBpc24ndCBydW5uaW5nIHlldCwgd2Ugd2lsbCB3YWl0XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IgJiYgZXJyb3IuZXZlbnQgPT09IFwibm9OZXR3b3JrXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgY3JlYXRlIGEgc2luZ2xldG9uIGZvcm1hdHRlclxuXHQgICAgQmFzZVByb3ZpZGVyLmdldEZvcm1hdHRlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoZGVmYXVsdEZvcm1hdHRlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGRlZmF1bHRGb3JtYXR0ZXIgPSBuZXcgZm9ybWF0dGVyLkZvcm1hdHRlcigpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcjtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzogUmVtb3ZlIHRoaXMgYW5kIGp1c3QgdXNlIGdldE5ldHdvcmtcblx0ICAgIEJhc2VQcm92aWRlci5nZXROZXR3b3JrID0gZnVuY3Rpb24gKG5ldHdvcmspIHtcblx0ICAgICAgICByZXR1cm4gbGliJGsuZ2V0TmV0d29yaygobmV0d29yayA9PSBudWxsKSA/IFwiaG9tZXN0ZWFkXCIgOiBuZXR3b3JrKTtcblx0ICAgIH07XG5cdCAgICAvLyBGZXRjaGVzIHRoZSBibG9ja051bWJlciwgYnV0IHdpbGwgcmV1c2UgYW55IHJlc3VsdCB0aGF0IGlzIGxlc3Ncblx0ICAgIC8vIHRoYW4gbWF4QWdlIG9sZCBvciBoYXMgYmVlbiByZXF1ZXN0ZWQgc2luY2UgdGhlIGxhc3QgcmVxdWVzdFxuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0SW50ZXJuYWxCbG9ja051bWJlciA9IGZ1bmN0aW9uIChtYXhBZ2UpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBpbnRlcm5hbEJsb2NrTnVtYmVyLCByZXN1bHQsIHJlcVRpbWUsIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcmVhZHkoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsQmxvY2tOdW1iZXIgPSB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShtYXhBZ2UgPiAwICYmIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIpKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgaW50ZXJuYWxCbG9ja051bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZ2V0VGltZSgpIC0gcmVzdWx0LnJlc3BUaW1lKSA8PSBtYXhBZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHQuYmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcVRpbWUgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSW50ZXJuYWxCbG9ja051bWJlciA9IGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyOiB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja051bWJlclwiLCB7fSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHsgcmV0dXJuIChudWxsKTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiAoZXJyb3IpOyB9KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gX2EuYmxvY2tOdW1iZXIsIG5ldHdvcmtFcnJvciA9IF9hLm5ldHdvcmtFcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrRXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBVbnJlbWVtYmVyIHRoaXMgYmFkIGludGVybmFsIGJsb2NrIG51bWJlclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV0d29ya0Vycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BUaW1lID0gZ2V0VGltZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBsaWIkMi5CaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc2V0RmFzdEJsb2NrTnVtYmVyKGJsb2NrTnVtYmVyKTsgLy8gQFRPRE86IFN0aWxsIG5lZWQgdGhpcz9cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGJsb2NrTnVtYmVyOiBibG9ja051bWJlciwgcmVxVGltZTogcmVxVGltZSwgcmVzcFRpbWU6IHJlc3BUaW1lIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIChfYS5zZW50KCkpLmJsb2NrTnVtYmVyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBvbGxJZCwgcnVubmVycywgYmxvY2tOdW1iZXIsIGk7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBvbGxJZCA9IG5leHRQb2xsSWQrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcnVubmVycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVtaXQgYSBwb2xsIGV2ZW50IGFmdGVyIHdlIGhhdmUgdGhlIGxhdGVzdCAoZmFzdCkgYmxvY2sgbnVtYmVyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInBvbGxcIiwgcG9sbElkLCBibG9ja051bWJlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBibG9jayBoYXMgbm90IGNoYW5nZWQsIG1laC5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09PSB0aGlzLl9sYXN0QmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlLCB0cmlnZ2VyIGEgXCJibG9ja1wiIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayA9PT0gLTIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlciAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKCh0aGlzLl9lbWl0dGVkLmJsb2NrKSAtIGJsb2NrTnVtYmVyKSA+IDEwMDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkOyBza2lwcGluZyBibG9jayBldmVudHNcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBsb2dnZXIubWFrZUVycm9yKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogYmxvY2tOdW1iZXIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiYmxvY2tTa2V3XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNCbG9ja051bWJlcjogdGhpcy5fZW1pdHRlZC5ibG9ja1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90aWZ5IGFsbCBsaXN0ZW5lciBmb3IgZWFjaCBibG9jayB0aGF0IGhhcyBwYXNzZWRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IHRoaXMuX2VtaXR0ZWQuYmxvY2sgKyAxOyBpIDw9IGJsb2NrTnVtYmVyOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgZW1pdHRlZCBibG9jayB3YXMgdXBkYXRlZCwgY2hlY2sgZm9yIG9ic29sZXRlIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZC5ibG9jayAhPT0gYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2VtaXR0ZWQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBibG9jayBldmVudCBkb2VzIG5vdCBleHBpcmVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgd2Ugd2VyZSBhdCB3aGVuIHdlIGVtaXR0ZWQgdGhpcyBldmVudFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBldmVudEJsb2NrTnVtYmVyID0gX3RoaXMuX2VtaXR0ZWRba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgZ2FyYmFnZSBjb2xsZWN0IHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIGJsb2NrcyBoZXJlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhleSBzaG91bGQgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYnkgdGhlIFByb3ZpZGVyIHdoZW4gc2V0dGluZ1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwicGVuZGluZ1wiIGV2ZW50c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEJsb2NrTnVtYmVyID09PSBcInBlbmRpbmdcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV2aWN0IGFueSB0cmFuc2FjdGlvbiBoYXNoZXMgb3IgYmxvY2sgaGFzaGVzIG92ZXIgMTIgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb2xkLCBzaW5jZSB0aGV5IHNob3VsZCBub3QgcmV0dXJuIG51bGwgYW55d2F5c1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciAtIGV2ZW50QmxvY2tOdW1iZXIgPiAxMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2VtaXR0ZWRba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPT09IC0yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlciAtIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBhbGwgdHJhbnNhY3Rpb24gaGFzaGVzIHdlIGFyZSB3YWl0aW5nIG9uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2hfMiA9IGV2ZW50Lmhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW5uZXIgPSBfdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaF8yKS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlY2VpcHQgfHwgcmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoXzJdID0gcmVjZWlwdC5ibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoaGFzaF8yLCByZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZpbHRlclwiOiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWx0ZXJfMSA9IGV2ZW50LmZpbHRlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyXzEuZnJvbUJsb2NrID0gX3RoaXMuX2xhc3RCbG9ja051bWJlciArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbHRlcl8xLnRvQmxvY2sgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJ1bm5lciA9IF90aGlzLmdldExvZ3MoZmlsdGVyXzEpLnRoZW4oZnVuY3Rpb24gKGxvZ3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaChmdW5jdGlvbiAobG9nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJiOlwiICsgbG9nLmJsb2NrSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdChmaWx0ZXJfMSwgbG9nKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgX3RoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChydW5uZXJzKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkaWRQb2xsXCIsIHBvbGxJZCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIC8vIERlcHJlY2F0ZWQ7IGRvIG5vdCB1c2UgdGhpc1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5yZXNldEV2ZW50c0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXIgLSAxO1xuXHQgICAgICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcblx0ICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcIm5ldHdvcmtcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIC8vIFRoaXMgbWV0aG9kIHNob3VsZCBxdWVyeSB0aGUgbmV0d29yayBpZiB0aGUgdW5kZXJseWluZyBuZXR3b3JrXG5cdCAgICAvLyBjYW4gY2hhbmdlLCBzdWNoIGFzIHdoZW4gY29ubmVjdGVkIHRvIGEgSlNPTi1SUEMgYmFja2VuZFxuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwicHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBuZXR3b3JrIGRldGVjdGlvblwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInByb3ZpZGVyLmRldGVjdE5ldHdvcmtcIlxuXHQgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmssIGN1cnJlbnROZXR3b3JrLCBlcnJvcjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fcmVhZHkoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRldGVjdE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TmV0d29yayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5hbnlOZXR3b3JrKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbmV0d29yayA9IGN1cnJlbnROZXR3b3JrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBhbGwgaW50ZXJuYWwgYmxvY2sgbnVtYmVyIGd1YXJkcyBhbmQgY2FjaGVzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IC0yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSAtMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIFwibmV0d29ya1wiIGV2ZW50IE1VU1QgaGFwcGVuIGJlZm9yZSB0aGlzIG1ldGhvZCByZXNvbHZlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBhbnkgZXZlbnRzIGhhdmUgYSBjaGFuY2UgdG8gdW5yZWdpc3Rlciwgc28gd2Ugc3RhbGwgYW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbCBldmVudCBsb29wIGJlZm9yZSByZXR1cm5pbmcgZnJvbSAvdGhpcy8gY2FsbFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJuZXR3b3JrXCIsIGN1cnJlbnROZXR3b3JrLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc3RhbGwoMCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fbmV0d29ya107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IGxvZ2dlci5tYWtlRXJyb3IoXCJ1bmRlcmx5aW5nIG5ldHdvcmsgY2hhbmdlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV0ZWN0ZWROZXR3b3JrOiBjdXJyZW50TmV0d29ya1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBuZXR3b3JrXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VQcm92aWRlci5wcm90b3R5cGUsIFwiYmxvY2tOdW1iZXJcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIHRoaXMucG9sbGluZ0ludGVydmFsIC8gMikudGhlbihmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCkgPyB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgOiAtMTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlUHJvdmlkZXIucHJvdG90eXBlLCBcInBvbGxpbmdcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIGlmICh2YWx1ZSAmJiAhdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBzZXRJbnRlcnZhbCh0aGlzLnBvbGwuYmluZCh0aGlzKSwgdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ib290c3RyYXBQb2xsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wb2xsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHBvbGxpbmcgd2FzIGRpc2FibGVkLCBzb21ldGhpbmcgbWF5IHJlcXVpcmUgYSBwb2tlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5jZSBzdGFydGluZyB0aGUgYm9vdHN0cmFwIHBvbGwgYW5kIGl0IHdhcyBkaXNhYmxlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucG9sbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ib290c3RyYXBQb2xsID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMucG9sbGluZ0ludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmICghdmFsdWUgJiYgdGhpcy5fcG9sbGVyKSB7XG5cdCAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3BvbGxlcik7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wb2xsZXIgPSBudWxsO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXHQgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHQgICAgfSk7XG5cdCAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZVByb3ZpZGVyLnByb3RvdHlwZSwgXCJwb2xsaW5nSW50ZXJ2YWxcIiwge1xuXHQgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcIm51bWJlclwiIHx8IHZhbHVlIDw9IDAgfHwgcGFyc2VJbnQoU3RyaW5nKHZhbHVlKSkgIT0gdmFsdWUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9sbGluZyBpbnRlcnZhbFwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSB2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3BvbGxlcikge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkgeyBfdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEZhc3RCbG9ja051bWJlciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBub3cgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgLy8gU3RhbGUgYmxvY2sgbnVtYmVyLCByZXF1ZXN0IGEgbmV3ZXIgdmFsdWVcblx0ICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gbm93O1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gdGhpcy5nZXRCbG9ja051bWJlcigpLnRoZW4oZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gX3RoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fZmFzdEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2U7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fc2V0RmFzdEJsb2NrTnVtYmVyID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgLy8gT2xkZXIgYmxvY2ssIG1heWJlIGEgc3RhbGUgcmVxdWVzdFxuXHQgICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgfVxuXHQgICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuXHQgICAgICAgIHRoaXMuX2Zhc3RRdWVyeURhdGUgPSBnZXRUaW1lKCk7XG5cdCAgICAgICAgLy8gTmV3ZXIgYmxvY2sgbnVtYmVyLCB1c2UgIGl0XG5cdCAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXJQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGJsb2NrTnVtYmVyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS53YWl0Rm9yVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb25IYXNoLCBjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcmVjZWlwdDtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWNlaXB0IGlzIGFscmVhZHkgZ29vZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlY2VpcHQgPyByZWNlaXB0LmNvbmZpcm1hdGlvbnMgOiAwKSA+PSBjb25maXJtYXRpb25zKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUG9sbCB1bnRpbCB0aGUgcmVjZWlwdCBpcyBnb29kLi4uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKHJlY2VpcHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlTGlzdGVuZXIodHJhbnNhY3Rpb25IYXNoLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZWNlaXB0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgdGltZW91dCA+IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcih0cmFuc2FjdGlvbkhhc2gsIGhhbmRsZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJ0aW1lb3V0IGV4Y2VlZGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHsgdGltZW91dDogdGltZW91dCB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGltZXIudW5yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLnVucmVmKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigwKV07XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0R2FzUHJpY2UgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgX2EsIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRHYXNQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJhbGFuY2UgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRCYWxhbmNlXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uQ291bnQgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hLCBfYjtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYy5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gbGliJDIuQmlnTnVtYmVyKS5mcm9tO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9iLmFwcGx5KF9hLCBbX2Muc2VudCgpXSkudG9OdW1iZXIoKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0Q29kZSA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2E7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuX2dldEFkZHJlc3MoYWRkcmVzc09yTmFtZSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGxpYiQxLmhleGxpZnk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFN0b3JhZ2VBdCA9IGZ1bmN0aW9uIChhZGRyZXNzT3JOYW1lLCBwb3NpdGlvbiwgYmxvY2tUYWcpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXMsIF9hO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFByb21pc2UucmVzb2x2ZShwb3NpdGlvbikudGhlbihmdW5jdGlvbiAocCkgeyByZXR1cm4gbGliJDEuaGV4VmFsdWUocCk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hID0gbGliJDEuaGV4bGlmeTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZ2V0U3RvcmFnZUF0XCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgLy8gVGhpcyBzaG91bGQgYmUgY2FsbGVkIGJ5IGFueSBzdWJjbGFzcyB3cmFwcGluZyBhIFRyYW5zYWN0aW9uUmVzcG9uc2Vcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX3dyYXBUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0eCwgaGFzaCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiBsaWIkMS5oZXhEYXRhTGVuZ3RoKGhhc2gpICE9PSAzMikge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlIC0gc2VuZFRyYW5zYWN0aW9uXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gdHg7XG5cdCAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcblx0ICAgICAgICBpZiAoaGFzaCAhPSBudWxsICYmIHR4Lmhhc2ggIT09IGhhc2gpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJUcmFuc2FjdGlvbiBoYXNoIG1pc21hdGNoIGZyb20gUHJvdmlkZXIuc2VuZFRyYW5zYWN0aW9uLlwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7IGV4cGVjdGVkSGFzaDogdHguaGFzaCwgcmV0dXJuZWRIYXNoOiBoYXNoIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBAVE9ETzogKGNvbmZpcm1hdGlvbnM/IG51bWJlciwgdGltZW91dD8gbnVtYmVyKVxuXHQgICAgICAgIHJlc3VsdC53YWl0ID0gZnVuY3Rpb24gKGNvbmZpcm1hdGlvbnMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlY2VpcHQ7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGtub3cgdGhpcyB0cmFuc2FjdGlvbiAqbXVzdCogZXhpc3QgKHdoZXRoZXIgaXQgZ2V0cyBtaW5lZCBpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBhbm90aGVyIHN0b3J5KSwgc28gc2V0dGluZyBhbiBlbWl0dGVkIHZhbHVlIGZvcmNlcyB1cyB0b1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyB3YWl0IGV2ZW4gaWYgdGhlIG5vZGUgcmV0dXJucyBudWxsIGZvciB0aGUgcmVjZWlwdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyAhPT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0eC5oYXNoXSA9IFwicGVuZGluZ1wiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMud2FpdEZvclRyYW5zYWN0aW9uKHR4Lmhhc2gsIGNvbmZpcm1hdGlvbnMpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXB0ID09IG51bGwgJiYgY29uZmlybWF0aW9ucyA9PT0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vIGxvbmdlciBwZW5kaW5nLCBhbGxvdyB0aGUgcG9sbGluZyBsb29wIHRvIGdhcmJhZ2UgY29sbGVjdCB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5zdGF0dXMgPT09IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidHJhbnNhY3Rpb24gZmFpbGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiB0eC5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0OiByZWNlaXB0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVjZWlwdF07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pOyB9O1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAoc2lnbmVkVHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBoZXhUeCwgdHgsIGhhc2gsIGVycm9yXzI7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgUHJvbWlzZS5yZXNvbHZlKHNpZ25lZFRyYW5zYWN0aW9uKS50aGVuKGZ1bmN0aW9uICh0KSB7IHJldHVybiBsaWIkMS5oZXhsaWZ5KHQpOyB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoZXhUeCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHggPSB0aGlzLmZvcm1hdHRlci50cmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMywgNSwgLCA2XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcInNlbmRUcmFuc2FjdGlvblwiLCB7IHNpZ25lZFRyYW5zYWN0aW9uOiBoZXhUeCB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yLnRyYW5zYWN0aW9uID0gdHg7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yXzIudHJhbnNhY3Rpb25IYXNoID0gdHguaGFzaDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3JfMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0ID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgdmFsdWVzLCB0eCwgX2EsIF9iO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0cmFuc2FjdGlvbl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImZyb21cIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBfdGhpcy5fZ2V0QWRkcmVzcyh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbihmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgPyBsaWIkMi5CaWdOdW1iZXIuZnJvbSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIFtcImRhdGFcIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oZnVuY3Rpb24gKHYpIHsgcmV0dXJuICh2ID8gbGliJDEuaGV4bGlmeSh2KSA6IG51bGwpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdGhpcy5mb3JtYXR0ZXIpLnRyYW5zYWN0aW9uUmVxdWVzdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXModHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fZ2V0RmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCwgX2EsIF9iO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBmaWx0ZXJdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7fTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgW1wiYmxvY2tIYXNoXCIsIFwidG9waWNzXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgW1wiZnJvbUJsb2NrXCIsIFwidG9CbG9ja1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBfdGhpcy5fZ2V0QmxvY2tUYWcoZmlsdGVyW2tleV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2IgPSAoX2EgPSB0aGlzLmZvcm1hdHRlcikuZmlsdGVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsaWIkMy5yZXNvbHZlUHJvcGVydGllcyhyZXN1bHQpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2E7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0aGlzLl9nZXRUcmFuc2FjdGlvblJlcXVlc3QodHJhbnNhY3Rpb24pLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBsaWIkMS5oZXhsaWZ5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLmFwcGx5KHZvaWQgMCwgW19iLnNlbnQoKV0pXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5lc3RpbWF0ZUdhcyA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHBhcmFtcywgX2EsIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IGxpYiQyLkJpZ051bWJlcikuZnJvbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5wZXJmb3JtKFwiZXN0aW1hdGVHYXNcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzc09yTmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGFkZHJlc3M7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucmVzb2x2ZU5hbWUoYWRkcmVzc09yTmFtZSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJFTlMgbmFtZSBub3QgY29uZmlndXJlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWUoXCIgKyBKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKSArIFwiKVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYWRkcmVzc107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldEJsb2NrID0gZnVuY3Rpb24gKGJsb2NrSGFzaE9yQmxvY2tUYWcsIGluY2x1ZGVUcmFuc2FjdGlvbnMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9ja051bWJlciwgcGFyYW1zLCBfYSwgX2IsIF9jLCBlcnJvcl8zO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9kKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZC5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGJsb2NrSGFzaE9yQmxvY2tUYWddO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tIYXNoT3JCbG9ja1RhZyA9IF9kLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSAtMTI4O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdWRlVHJhbnNhY3Rpb25zOiAhIWluY2x1ZGVUcmFuc2FjdGlvbnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFsaWIkMS5pc0hleFN0cmluZyhibG9ja0hhc2hPckJsb2NrVGFnLCAzMikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoT3JCbG9ja1RhZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfZC50cnlzLnB1c2goWzMsIDUsICwgNl0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHBhcmFtcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSAoX2IgPSB0aGlzLmZvcm1hdHRlcikuYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrSGFzaE9yQmxvY2tUYWcpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmJsb2NrVGFnID0gX2MuYXBwbHkoX2IsIFtfZC5zZW50KCldKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gcGFyc2VJbnQocGFyYW1zLmJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDZdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMyA9IF9kLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYmxvY2sgaGFzaCBvciBibG9jayB0YWdcIiwgXCJibG9ja0hhc2hPckJsb2NrVGFnXCIsIGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDY6IHJldHVybiBbMiAvKnJldHVybiovLCBsaWIkbC5wb2xsKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBibG9jaywgYmxvY2tOdW1iZXJfMSwgaSwgdHgsIGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldEJsb2NrXCIsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEJsb2NrIHdhcyBub3QgZm91bmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRm9yIGJsb2NraGFzaGVzLCBpZiB3ZSBkaWRuJ3Qgc2F5IGl0IGV4aXN0ZWQsIHRoYXQgYmxvY2toYXNoIG1heVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vdCBleGlzdC4gSWYgd2UgZGlkIHNlZSBpdCB0aG91Z2gsIHBlcmhhcHMgZnJvbSBhIGxvZywgd2Uga25vd1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGV4aXN0cywgYW5kIHRoaXMgbm9kZSBpcyBqdXN0IG5vdCBjYXVnaHQgdXAgeWV0LlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tIYXNoICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJiOlwiICsgcGFyYW1zLmJsb2NrSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9jayB0YWdzLCBpZiB3ZSBhcmUgYXNraW5nIGZvciBhIGZ1dHVyZSBibG9jaywgd2UgcmV0dXJuIG51bGxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID4gdGhpcy5fZW1pdHRlZC5ibG9jaykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHJ5IG9uIHRoZSBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVuZGVmaW5lZF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWluY2x1ZGVUcmFuc2FjdGlvbnMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDhdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXJfMSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA3XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gYmxvY2sudHJhbnNhY3Rpb25zW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShibG9ja051bWJlcl8xID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyXzEgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXJfMSAtIHR4LmJsb2NrTnVtYmVyKSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMuZm9ybWF0dGVyLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9jayldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9jayhibG9jayldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTsgfSwgeyBvbmNlUG9sbDogdGhpcyB9KV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuZ2V0QmxvY2sgPSBmdW5jdGlvbiAoYmxvY2tIYXNoT3JCbG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgZmFsc2UpKTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyA9IGZ1bmN0aW9uIChibG9ja0hhc2hPckJsb2NrVGFnKSB7XG5cdCAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCB0cnVlKSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJGwucG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgdHgsIGJsb2NrTnVtYmVyLCBjb25maXJtYXRpb25zO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnBlcmZvcm0oXCJnZXRUcmFuc2FjdGlvblwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UocmVzdWx0KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0eC5ibG9ja051bWJlciA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gKGJsb2NrTnVtYmVyIC0gdHguYmxvY2tOdW1iZXIpICsgMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLl93cmFwVHJhbnNhY3Rpb24odHgpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IGZ1bmN0aW9uICh0cmFuc2FjdGlvbkhhc2gpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBwYXJhbXM7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuZ2V0TmV0d29yaygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdHJhbnNhY3Rpb25IYXNoXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbGliJGwucG9sbChmdW5jdGlvbiAoKSB7IHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCwgcmVjZWlwdCwgYmxvY2tOdW1iZXIsIGNvbmZpcm1hdGlvbnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkW1widDpcIiArIHRyYW5zYWN0aW9uSGFzaF0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBcImdldGgtZXRjXCIgcmV0dXJucyByZWNlaXB0cyBiZWZvcmUgdGhleSBhcmUgcmVhZHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmJsb2NrSGFzaCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB1bmRlZmluZWRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNlaXB0ID0gdGhpcy5mb3JtYXR0ZXIucmVjZWlwdChyZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVjZWlwdC5jb25maXJtYXRpb25zID09IG51bGwpKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCldO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvbnMgPD0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWlwdC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHJldHVybiBbMiAvKnJldHVybiovLCByZWNlaXB0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7IH0sIHsgb25jZVBvbGw6IHRoaXMgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldExvZ3MgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgcGFyYW1zLCBsb2dzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiQzLnJlc29sdmVQcm9wZXJ0aWVzKHsgZmlsdGVyOiB0aGlzLl9nZXRGaWx0ZXIoZmlsdGVyKSB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMucGVyZm9ybShcImdldExvZ3NcIiwgcGFyYW1zKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2dzLmZvckVhY2goZnVuY3Rpb24gKGxvZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5yZW1vdmVkID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2cucmVtb3ZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGZvcm1hdHRlci5Gb3JtYXR0ZXIuYXJyYXlPZih0aGlzLmZvcm1hdHRlci5maWx0ZXJMb2cuYmluZCh0aGlzLmZvcm1hdHRlcikpKGxvZ3MpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5nZXRFdGhlclByaWNlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5nZXROZXR3b3JrKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5wZXJmb3JtKFwiZ2V0RXRoZXJQcmljZVwiLCB7fSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9nZXRCbG9ja1RhZyA9IGZ1bmN0aW9uIChibG9ja1RhZykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBibG9ja1RhZ107XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgJiYgYmxvY2tUYWcgPCAwKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja1RhZyAlIDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEJsb2NrVGFnXCIsIFwiYmxvY2tUYWdcIiwgYmxvY2tUYWcpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgKz0gYmxvY2tUYWc7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzLmZvcm1hdHRlci5ibG9ja1RhZyhibG9ja1RhZyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmdldFJlc29sdmVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBhZGRyZXNzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLl9nZXRSZXNvbHZlcihuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBSZXNvbHZlcih0aGlzLCBhZGRyZXNzLCBuYW1lKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUuX2dldFJlc29sdmVyID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBuZXR3b3JrLCB0cmFuc2FjdGlvbiwgX2EsIF9iO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldE5ldHdvcmsoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBObyBFTlMuLi5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXR3b3JrLmVuc0FkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IEVOU1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcIkVOU1wiLCBuZXR3b3JrOiBuZXR3b3JrLm5hbWUgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogbmV0d29yay5lbnNBZGRyZXNzLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHgwMTc4YjhiZlwiICsgbGliJDkubmFtZWhhc2gobmFtZSkuc3Vic3RyaW5nKDIpKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IHRoaXMuZm9ybWF0dGVyKS5jYWxsQWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5jYWxsKHRyYW5zYWN0aW9uKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUucmVzb2x2ZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJlc29sdmVyO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGlzIGFscmVhZHkgYW4gYWRkcmVzcywgbm90aGluZyB0byByZXNvbHZlXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgUHJvbWlzZS5yZXNvbHZlKHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MobmFtZSkpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGlzIGlzIGEgaGV4c3RyaW5nLCB0aGUgYWRkcmVzcyBpcyBiYWQgKFNlZSAjNjk0KVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxpYiQxLmlzSGV4U3RyaW5nKG5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobmFtZSkgIT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJlc29sdmVyKG5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmxvb2t1cEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHJldmVyc2VOYW1lLCByZXNvbHZlckFkZHJlc3MsIGJ5dGVzLCBfYSwgbGVuZ3RoLCBuYW1lLCBhZGRyO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBhZGRyZXNzXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTmFtZSA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCkgKyBcIi5hZGRyLnJldmVyc2VcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5fZ2V0UmVzb2x2ZXIocmV2ZXJzZU5hbWUpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVyQWRkcmVzcyA9IF9iLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlckFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IGxpYiQxLmFycmF5aWZ5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmNhbGwoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvOiByZXNvbHZlckFkZHJlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogKFwiMHg2OTFmMzQzMVwiICsgbGliJDkubmFtZWhhc2gocmV2ZXJzZU5hbWUpLnN1YnN0cmluZygyKSlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gX2EuYXBwbHkodm9pZCAwLCBbX2Iuc2VudCgpXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgZHluYW1pYyBzdHJpbmcgcG9pbnRlciAoMHgyMClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8IDMyIHx8ICFsaWIkMi5CaWdOdW1iZXIuZnJvbShieXRlcy5zbGljZSgwLCAzMikpLmVxKDMyKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMzIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYSBsZW5ndGgtcHJlZml4ZWQgc3RyaW5nXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG51bGxdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGxpYiQyLkJpZ051bWJlci5mcm9tKGJ5dGVzLnNsaWNlKDAsIDMyKSkudG9OdW1iZXIoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZSgzMik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIExlbmd0aCBsb25nZXIgdGhhbiBhdmFpbGFibGUgZGF0YVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gYnl0ZXMubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZSA9IGxpYiQ4LnRvVXRmOFN0cmluZyhieXRlcy5zbGljZSgwLCBsZW5ndGgpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXNvbHZlTmFtZShuYW1lKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBhZGRyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRkciAhPSBhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbnVsbF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5hbWVdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwgeyBvcGVyYXRpb246IG1ldGhvZCB9KTtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLl9zdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucG9sbGFibGUoKTsgfSkubGVuZ3RoID4gMCk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fc3RvcEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdGhpcy5wb2xsaW5nID0gKHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHsgcmV0dXJuIGUucG9sbGFibGUoKTsgfSkubGVuZ3RoID4gMCk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5fYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKSB7XG5cdCAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KGdldEV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcblx0ICAgICAgICB0aGlzLl9ldmVudHMucHVzaChldmVudCk7XG5cdCAgICAgICAgdGhpcy5fc3RhcnRFdmVudChldmVudCk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIGFyZ3MgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuXHQgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cdCAgICAgICAgdmFyIHN0b3BwZWQgPSBbXTtcblx0ICAgICAgICB2YXIgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuXHQgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIGV2ZW50Lmxpc3RlbmVyLmFwcGx5KF90aGlzLCBhcmdzKTtcblx0ICAgICAgICAgICAgfSwgMCk7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IHRydWU7XG5cdCAgICAgICAgICAgIGlmIChldmVudC5vbmNlKSB7XG5cdCAgICAgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHN0b3BwZWQuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHsgX3RoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuXHQgICAgICAgIGlmICghZXZlbnROYW1lKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubGVuZ3RoO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgICAgICByZXR1cm4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpO1xuXHQgICAgICAgIH0pLmxlbmd0aDtcblx0ICAgIH07XG5cdCAgICBCYXNlUHJvdmlkZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChldmVudE5hbWUpIHtcblx0ICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50cy5tYXAoZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBldmVudC5saXN0ZW5lcjsgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuX2V2ZW50c1xuXHQgICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gKGV2ZW50LnRhZyA9PT0gZXZlbnRUYWcpOyB9KVxuXHQgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZXZlbnQubGlzdGVuZXI7IH0pO1xuXHQgICAgfTtcblx0ICAgIEJhc2VQcm92aWRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGlmIChsaXN0ZW5lciA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3RvcHBlZCA9IFtdO1xuXHQgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXHQgICAgICAgIHZhciBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG5cdCAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcgfHwgZXZlbnQubGlzdGVuZXIgIT0gbGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChmb3VuZCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuXHQgICAgICAgICAgICBzdG9wcGVkLnB1c2goZXZlbnQpO1xuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgc3RvcHBlZC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkgeyBfdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICB9O1xuXHQgICAgQmFzZVByb3ZpZGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgc3RvcHBlZCA9IFtdO1xuXHQgICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBzdG9wcGVkID0gdGhpcy5fZXZlbnRzO1xuXHQgICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHZhciBldmVudFRhZ18xID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcblx0ICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnXzEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBzdG9wcGVkLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7IF90aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcblx0ICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgIH07XG5cdCAgICByZXR1cm4gQmFzZVByb3ZpZGVyO1xuXHR9KGxpYiRiLlByb3ZpZGVyKSk7XG5cdGV4cG9ydHMuQmFzZVByb3ZpZGVyID0gQmFzZVByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBiYXNlUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMoYmFzZVByb3ZpZGVyKTtcblx0dmFyIGJhc2VQcm92aWRlcl8xID0gYmFzZVByb3ZpZGVyLkV2ZW50O1xuXHR2YXIgYmFzZVByb3ZpZGVyXzIgPSBiYXNlUHJvdmlkZXIuUmVzb2x2ZXI7XG5cdHZhciBiYXNlUHJvdmlkZXJfMyA9IGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXI7XG5cblx0dmFyIGJyb3dzZXJXcyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cdHZhciBXUyA9IG51bGw7XG5cdHRyeSB7XG5cdCAgICBXUyA9IFdlYlNvY2tldDtcblx0ICAgIGlmIChXUyA9PSBudWxsKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5qZWN0IHBsZWFzZVwiKTtcblx0ICAgIH1cblx0fVxuXHRjYXRjaCAoZXJyb3IpIHtcblx0ICAgIHZhciBsb2dnZXJfMiA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdCAgICBXUyA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBsb2dnZXJfMi50aHJvd0Vycm9yKFwiV2ViU29ja2V0cyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgV2ViU29ja2V0KClcIlxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG5cdH0pO1xuXG5cdHZhciBicm93c2VyV3MkMSA9IHVud3JhcEV4cG9ydHMoYnJvd3NlcldzKTtcblxuXHR2YXIganNvblJwY1Byb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHR2YXIgZXJyb3JHYXMgPSBbXCJjYWxsXCIsIFwiZXN0aW1hdGVHYXNcIl07XG5cdGZ1bmN0aW9uIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKSB7XG5cdCAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG5cdCAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SICYmIGVycm9yLmVycm9yICYmIHR5cGVvZiAoZXJyb3IuZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IuYm9keSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IucmVzcG9uc2VUZXh0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG5cdCAgICB9XG5cdCAgICBtZXNzYWdlID0gKG1lc3NhZ2UgfHwgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0ICAgIHZhciB0cmFuc2FjdGlvbiA9IHBhcmFtcy50cmFuc2FjdGlvbiB8fCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb247XG5cdCAgICAvLyBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgZ2FzICogcHJpY2UgKyB2YWx1ZSArIGNvc3QoZGF0YSlcIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuXHQgICAgICAgICAgICBlcnJvcjogZXJyb3IsIG1ldGhvZDogbWV0aG9kLCB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8vIFwibm9uY2UgdG9vIGxvd1wiXG5cdCAgICBpZiAobWVzc2FnZS5tYXRjaCgvbm9uY2UgdG9vIGxvdy8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCwge1xuXHQgICAgICAgICAgICBlcnJvcjogZXJyb3IsIG1ldGhvZDogbWV0aG9kLCB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8vIFwicmVwbGFjZW1lbnQgdHJhbnNhY3Rpb24gdW5kZXJwcmljZWRcIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkLykpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG5cdCAgICAgICAgICAgIGVycm9yOiBlcnJvciwgbWV0aG9kOiBtZXRob2QsIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgaWYgKGVycm9yR2FzLmluZGV4T2YobWV0aG9kKSA+PSAwICYmIG1lc3NhZ2UubWF0Y2goL2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZXxhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWQvKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGVzdGltYXRlIGdhczsgdHJhbnNhY3Rpb24gbWF5IGZhaWwgb3IgbWF5IHJlcXVpcmUgbWFudWFsIGdhcyBsaW1pdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuXHQgICAgICAgICAgICBlcnJvcjogZXJyb3IsIG1ldGhvZDogbWV0aG9kLCB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIHRocm93IGVycm9yO1xuXHR9XG5cdGZ1bmN0aW9uIHRpbWVyKHRpbWVvdXQpIHtcblx0ICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHQgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCk7XG5cdCAgICB9KTtcblx0fVxuXHRmdW5jdGlvbiBnZXRSZXN1bHQocGF5bG9hZCkge1xuXHQgICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcblx0ICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuXHQgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuXHQgICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XG5cdCAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwYXlsb2FkLnJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBnZXRMb3dlckNhc2UodmFsdWUpIHtcblx0ICAgIGlmICh2YWx1ZSkge1xuXHQgICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHZhbHVlO1xuXHR9XG5cdHZhciBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuXHR2YXIgSnNvblJwY1NpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhKc29uUnBjU2lnbmVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSnNvblJwY1NpZ25lcihjb25zdHJ1Y3Rvckd1YXJkLCBwcm92aWRlciwgYWRkcmVzc09ySW5kZXgpIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgSnNvblJwY1NpZ25lcik7XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXHQgICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkbyBub3QgY2FsbCB0aGUgSnNvblJwY1NpZ25lciBjb25zdHJ1Y3RvciBkaXJlY3RseTsgdXNlIHByb3ZpZGVyLmdldFNpZ25lclwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuXHQgICAgICAgIGlmIChhZGRyZXNzT3JJbmRleCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGFkZHJlc3NPckluZGV4ID0gMDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09ySW5kZXgpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9hZGRyZXNzXCIsIF90aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3NPckluZGV4KSk7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcIl9pbmRleFwiLCBudWxsKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAodHlwZW9mIChhZGRyZXNzT3JJbmRleCkgPT09IFwibnVtYmVyXCIpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX2luZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX2FkZHJlc3NcIiwgbnVsbCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIGluZGV4XCIsIFwiYWRkcmVzc09ySW5kZXhcIiwgYWRkcmVzc09ySW5kZXgpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHByb3ZpZGVyKSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGFsdGVyIEpTT04tUlBDIFNpZ25lciBjb25uZWN0aW9uXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwiY29ubmVjdFwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuY29ubmVjdFVuY2hlY2tlZCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gbmV3IFVuY2hlY2tlZEpzb25ScGNTaWduZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRoaXMucHJvdmlkZXIsIHRoaXMuX2FkZHJlc3MgfHwgdGhpcy5faW5kZXgpO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLmdldEFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBpZiAodGhpcy5fYWRkcmVzcykge1xuXHQgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX2FkZHJlc3MpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50cykge1xuXHQgICAgICAgICAgICBpZiAoYWNjb3VudHMubGVuZ3RoIDw9IF90aGlzLl9pbmRleCkge1xuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bmtub3duIGFjY291bnQgI1wiICsgX3RoaXMuX2luZGV4LCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0QWRkcmVzc1wiXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWNjb3VudHNbX3RoaXMuX2luZGV4XSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB0cmFuc2FjdGlvbiA9IGxpYiQzLnNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICB2YXIgZnJvbUFkZHJlc3MgPSB0aGlzLmdldEFkZHJlc3MoKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIGlmIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBhZGRyZXNzO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcblx0ICAgICAgICAvLyB3aXNoZXMgdG8gdXNlIHRoaXMsIGl0IGlzIGVhc3kgdG8gc3BlY2lmeSBleHBsaWNpdGx5LCBvdGhlcndpc2Vcblx0ICAgICAgICAvLyB3ZSBsb29rIGl0IHVwIGZvciB0aGVtLlxuXHQgICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHZhciBlc3RpbWF0ZSA9IGxpYiQzLnNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgZXN0aW1hdGUuZnJvbSA9IGZyb21BZGRyZXNzO1xuXHQgICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRoaXMucHJvdmlkZXIuZXN0aW1hdGVHYXMoZXN0aW1hdGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gbGliJDMucmVzb2x2ZVByb3BlcnRpZXMoe1xuXHQgICAgICAgICAgICB0eDogbGliJDMucmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pLFxuXHQgICAgICAgICAgICBzZW5kZXI6IGZyb21BZGRyZXNzXG5cdCAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgdmFyIHR4ID0gX2EudHgsIHNlbmRlciA9IF9hLnNlbmRlcjtcblx0ICAgICAgICAgICAgaWYgKHR4LmZyb20gIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHR4LmZyb20udG9Mb3dlckNhc2UoKSAhPT0gc2VuZGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZyb20gYWRkcmVzcyBtaXNtYXRjaFwiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHR4LmZyb20gPSBzZW5kZXI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGhleFR4ID0gX3RoaXMucHJvdmlkZXIuY29uc3RydWN0b3IuaGV4bGlmeVRyYW5zYWN0aW9uKHR4LCB7IGZyb206IHRydWUgfSk7XG5cdCAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5zZW5kKFwiZXRoX3NlbmRUcmFuc2FjdGlvblwiLCBbaGV4VHhdKS50aGVuKGZ1bmN0aW9uIChoYXNoKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcInNlbmRUcmFuc2FjdGlvblwiLCBlcnJvciwgaGV4VHgpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zaWduVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1NpZ25lci5wcm90b3R5cGUuc2VuZFRyYW5zYWN0aW9uID0gZnVuY3Rpb24gKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZW5kVW5jaGVja2VkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKGhhc2gpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiRsLnBvbGwoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKGhhc2gpLnRoZW4oZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHR4ID09PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCB7IG9uY2VCbG9jazogX3RoaXMucHJvdmlkZXIgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNTaWduZXIucHJvdG90eXBlLnNpZ25NZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciBkYXRhID0gKCh0eXBlb2YgKG1lc3NhZ2UpID09PSBcInN0cmluZ1wiKSA/IGxpYiQ4LnRvVXRmOEJ5dGVzKG1lc3NhZ2UpIDogbWVzc2FnZSk7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWRkcmVzcygpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9KU09OLVJQQyNldGhfc2lnblxuXHQgICAgICAgICAgICByZXR1cm4gX3RoaXMucHJvdmlkZXIuc2VuZChcImV0aF9zaWduXCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIGxpYiQxLmhleGxpZnkoZGF0YSldKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjU2lnbmVyLnByb3RvdHlwZS51bmxvY2sgPSBmdW5jdGlvbiAocGFzc3dvcmQpIHtcblx0ICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuXHQgICAgICAgIHJldHVybiB0aGlzLmdldEFkZHJlc3MoKS50aGVuKGZ1bmN0aW9uIChhZGRyZXNzKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5zZW5kKFwicGVyc29uYWxfdW5sb2NrQWNjb3VudFwiLCBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBwYXNzd29yZCwgbnVsbF0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBKc29uUnBjU2lnbmVyO1xuXHR9KGxpYiRjLlNpZ25lcikpO1xuXHRleHBvcnRzLkpzb25ScGNTaWduZXIgPSBKc29uUnBjU2lnbmVyO1xuXHR2YXIgVW5jaGVja2VkSnNvblJwY1NpZ25lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhVbmNoZWNrZWRKc29uUnBjU2lnbmVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gVW5jaGVja2VkSnNvblJwY1NpZ25lcigpIHtcblx0ICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG5cdCAgICB9XG5cdCAgICBVbmNoZWNrZWRKc29uUnBjU2lnbmVyLnByb3RvdHlwZS5zZW5kVHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikudGhlbihmdW5jdGlvbiAoaGFzaCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgaGFzaDogaGFzaCxcblx0ICAgICAgICAgICAgICAgIG5vbmNlOiBudWxsLFxuXHQgICAgICAgICAgICAgICAgZ2FzTGltaXQ6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBnYXNQcmljZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGRhdGE6IG51bGwsXG5cdCAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIGNoYWluSWQ6IG51bGwsXG5cdCAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zOiAwLFxuXHQgICAgICAgICAgICAgICAgZnJvbTogbnVsbCxcblx0ICAgICAgICAgICAgICAgIHdhaXQ6IGZ1bmN0aW9uIChjb25maXJtYXRpb25zKSB7IHJldHVybiBfdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gVW5jaGVja2VkSnNvblJwY1NpZ25lcjtcblx0fShKc29uUnBjU2lnbmVyKSk7XG5cdHZhciBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuXHQgICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlXG5cdH07XG5cdHZhciBKc29uUnBjUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoSnNvblJwY1Byb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSnNvblJwY1Byb3ZpZGVyKHVybCwgbmV0d29yaykge1xuXHQgICAgICAgIHZhciBfbmV3VGFyZ2V0ID0gdGhpcy5jb25zdHJ1Y3Rvcjtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIGxvZ2dlci5jaGVja05ldyhfbmV3VGFyZ2V0LCBKc29uUnBjUHJvdmlkZXIpO1xuXHQgICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IG5ldHdvcms7XG5cdCAgICAgICAgLy8gVGhlIG5ldHdvcmsgaXMgdW5rbm93biwgcXVlcnkgdGhlIEpTT04tUlBDIGZvciBpdFxuXHQgICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4oZnVuY3Rpb24gKG5ldHdvcmspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrT3JSZWFkeSkgfHwgdGhpcztcblx0ICAgICAgICAvLyBEZWZhdWx0IFVSTFxuXHQgICAgICAgIGlmICghdXJsKSB7XG5cdCAgICAgICAgICAgIHVybCA9IGxpYiQzLmdldFN0YXRpYyhfdGhpcy5jb25zdHJ1Y3RvciwgXCJkZWZhdWx0VXJsXCIpKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKHVybCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiY29ubmVjdGlvblwiLCBPYmplY3QuZnJlZXplKHtcblx0ICAgICAgICAgICAgICAgIHVybDogdXJsXG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZShsaWIkMy5zaGFsbG93Q29weSh1cmwpKSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzLl9uZXh0SWQgPSA0Mjtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBKc29uUnBjUHJvdmlkZXIuZGVmYXVsdFVybCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gXCJodHRwOi9cXC9sb2NhbGhvc3Q6ODU0NVwiO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZGV0ZWN0TmV0d29yayA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFpbklkLCBlcnJvcl8xLCBlcnJvcl8yLCBnZXROZXR3b3JrO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aW1lcigwKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDQsICwgOV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmQoXCJldGhfY2hhaW5JZFwiLCBbXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8xID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDU7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzUsIDcsICwgOF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmQoXCJuZXRfdmVyc2lvblwiLCBbXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IHJldHVybiBbMyAvKmJyZWFrKi8sIDldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYWluSWQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TmV0d29yayA9IGxpYiQzLmdldFN0YXRpYyh0aGlzLmNvbnN0cnVjdG9yLCBcImdldE5ldHdvcmtcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXROZXR3b3JrKGxpYiQyLkJpZ051bWJlci5mcm9tKGNoYWluSWQpLnRvTnVtYmVyKCkpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbklkOiBjaGFpbklkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IFwiaW52YWxpZE5ldHdvcmtcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcnZlckVycm9yOiBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwiY291bGQgbm90IGRldGVjdCBuZXR3b3JrXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJub05ldHdvcmtcIlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLmdldFNpZ25lciA9IGZ1bmN0aW9uIChhZGRyZXNzT3JJbmRleCkge1xuXHQgICAgICAgIHJldHVybiBuZXcgSnNvblJwY1NpZ25lcihfY29uc3RydWN0b3JHdWFyZCwgdGhpcywgYWRkcmVzc09ySW5kZXgpO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZ2V0VW5jaGVja2VkU2lnbmVyID0gZnVuY3Rpb24gKGFkZHJlc3NPckluZGV4KSB7XG5cdCAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2lnbmVyKGFkZHJlc3NPckluZGV4KS5jb25uZWN0VW5jaGVja2VkKCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5saXN0QWNjb3VudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKGZ1bmN0aW9uIChhY2NvdW50cykge1xuXHQgICAgICAgICAgICByZXR1cm4gYWNjb3VudHMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBfdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhKTsgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgcmVxdWVzdCA9IHtcblx0ICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcblx0ICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuXHQgICAgICAgIH07XG5cdCAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuXHQgICAgICAgICAgICByZXF1ZXN0OiBsaWIkMy5kZWVwQ29weShyZXF1ZXN0KSxcblx0ICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gbGliJGwuZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCksIGdldFJlc3VsdCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdCAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG5cdCAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuXHQgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLnByZXBhcmVSZXF1ZXN0ID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2Jsb2NrTnVtYmVyXCIsIFtdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dhc1ByaWNlXCIsIFtdXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmFsYW5jZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQ291bnRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5ibG9ja1RhZ11dO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRDb2RlXCIsIFtnZXRMb3dlckNhc2UocGFyYW1zLmFkZHJlc3MpLCBwYXJhbXMuYmxvY2tUYWddXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRTdG9yYWdlQXRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5wb3NpdGlvbiwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfc2VuZFJhd1RyYW5zYWN0aW9uXCIsIFtwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb25dXTtcblx0ICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG5cdCAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRCbG9ja0J5TnVtYmVyXCIsIFtwYXJhbXMuYmxvY2tUYWcsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhcmFtcy5ibG9ja0hhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlIYXNoXCIsIFtwYXJhbXMuYmxvY2tIYXNoLCAhIXBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uXCI6XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG5cdCAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcblx0ICAgICAgICAgICAgICAgIHZhciBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2NhbGxcIiwgW2hleGxpZnlUcmFuc2FjdGlvbihwYXJhbXMudHJhbnNhY3Rpb24sIHsgZnJvbTogdHJ1ZSB9KSwgcGFyYW1zLmJsb2NrVGFnXV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcblx0ICAgICAgICAgICAgICAgIHZhciBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBsaWIkMy5nZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2VzdGltYXRlR2FzXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIgJiYgcGFyYW1zLmZpbHRlci5hZGRyZXNzICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJhbXMuZmlsdGVyLmFkZHJlc3MgPSBnZXRMb3dlckNhc2UocGFyYW1zLmZpbHRlci5hZGRyZXNzKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0TG9nc1wiLCBbcGFyYW1zLmZpbHRlcl1dO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUucGVyZm9ybSA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGFyZ3MsIGVycm9yXzM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLnByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5PVF9JTVBMRU1FTlRFRCwgeyBvcGVyYXRpb246IG1ldGhvZCB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnNlbmQoYXJnc1swXSwgYXJnc1sxXSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8zID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hlY2tFcnJvcihtZXRob2QsIGVycm9yXzMsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBKc29uUnBjUHJvdmlkZXIucHJvdG90eXBlLl9zdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIpIHtcblx0ICAgICAgICAgICAgdGhpcy5fc3RhcnRQZW5kaW5nKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0YXJ0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdCAgICB9O1xuXHQgICAgSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHBlbmRpbmdGaWx0ZXIgPSB0aGlzLnNlbmQoXCJldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyXCIsIFtdKTtcblx0ICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcblx0ICAgICAgICBwZW5kaW5nRmlsdGVyLnRoZW4oZnVuY3Rpb24gKGZpbHRlcklkKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG5cdCAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VxID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVzLmZvckVhY2goZnVuY3Rpb24gKGhhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbWl0dGVkW1widDpcIiArIGhhc2gudG9Mb3dlckNhc2UoKV0gPSBcInBlbmRpbmdcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VxID0gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmVtaXQoXCJwZW5kaW5nXCIsIHR4KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIoMTAwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5fcGVuZGluZ0ZpbHRlciAhPSBwZW5kaW5nRmlsdGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuc2VuZChcImV0aF91bmluc3RhbGxGaWx0ZXJcIiwgW2ZpbHRlcklkXSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHBvbGwoKTsgfSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHsgfSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcG9sbCgpO1xuXHQgICAgICAgICAgICByZXR1cm4gZmlsdGVySWQ7XG5cdCAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24gKGVycm9yKSB7IH0pO1xuXHQgICAgfTtcblx0ICAgIEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiICYmIHRoaXMubGlzdGVuZXJDb3VudChcInBlbmRpbmdcIikgPT09IDApIHtcblx0ICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF9zdXBlci5wcm90b3R5cGUuX3N0b3BFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0ICAgIH07XG5cdCAgICAvLyBDb252ZXJ0IGFuIGV0aGVycy5qcyB0cmFuc2FjdGlvbiBpbnRvIGEgSlNPTi1SUEMgdHJhbnNhY3Rpb25cblx0ICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuXHQgICAgLy8gIC0gQWxsIHZhbHVlcyBoZXhsaWZpZWRcblx0ICAgIC8vICAtIEFsbCBudW1lcmljIHZhbHVlcyB6ZXJvLXN0cmlwZWRcblx0ICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcblx0ICAgIC8vIE5PVEU6IFRoaXMgYWxsb3dzIGEgVHJhbnNhY3Rpb25SZXF1ZXN0LCBidXQgYWxsIHZhbHVlcyBzaG91bGQgYmUgcmVzb2x2ZWRcblx0ICAgIC8vICAgICAgIGJlZm9yZSB0aGlzIGlzIGNhbGxlZFxuXHQgICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG5cdCAgICAvLyAgICAgICAgd2lsbCBiZSB0aGUgcHJlZmVycmVkIG1ldGhvZCBmb3IgdGhpcy5cblx0ICAgIEpzb25ScGNQcm92aWRlci5oZXhsaWZ5VHJhbnNhY3Rpb24gPSBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIGFsbG93RXh0cmEpIHtcblx0ICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cblx0ICAgICAgICB2YXIgYWxsb3dlZCA9IGxpYiQzLnNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuXHQgICAgICAgIGlmIChhbGxvd0V4dHJhKSB7XG5cdCAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhbGxvd0V4dHJhKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYWxsb3dFeHRyYVtrZXldKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5jaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sIGFsbG93ZWQpO1xuXHQgICAgICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgICAgICAvLyBTb21lIG5vZGVzIChJTkZVUkEgcm9wc3RlbjsgSU5GVVJBIG1haW5uZXQgaXMgZmluZSkgZG8gbm90IGxpa2UgbGVhZGluZyB6ZXJvcy5cblx0ICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB2YWx1ZSA9IGxpYiQxLmhleFZhbHVlKHRyYW5zYWN0aW9uW2tleV0pO1xuXHQgICAgICAgICAgICBpZiAoa2V5ID09PSBcImdhc0xpbWl0XCIpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFwiZ2FzXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25ba2V5XSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBsaWIkMS5oZXhsaWZ5KHRyYW5zYWN0aW9uW2tleV0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEpzb25ScGNQcm92aWRlcjtcblx0fShiYXNlUHJvdmlkZXIuQmFzZVByb3ZpZGVyKSk7XG5cdGV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0gSnNvblJwY1Byb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBqc29uUnBjUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMoanNvblJwY1Byb3ZpZGVyKTtcblx0dmFyIGpzb25ScGNQcm92aWRlcl8xID0ganNvblJwY1Byb3ZpZGVyLkpzb25ScGNTaWduZXI7XG5cdHZhciBqc29uUnBjUHJvdmlkZXJfMiA9IGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXI7XG5cblx0dmFyIHdlYnNvY2tldFByb3ZpZGVyID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9fZXh0ZW5kcyA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuXHQgICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuXHQgICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG5cdCAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuXHQgICAgfTtcblx0fSkoKTtcblx0dmFyIF9fYXdhaXRlciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcblx0ICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuXHQgICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG5cdCAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuXHQgICAgfSk7XG5cdH07XG5cdHZhciBfX2dlbmVyYXRvciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcblx0ICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG5cdCAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcblx0ICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuXHQgICAgZnVuY3Rpb24gc3RlcChvcCkge1xuXHQgICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcblx0ICAgICAgICB3aGlsZSAoXykgdHJ5IHtcblx0ICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuXHQgICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG5cdCAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG5cdCAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuXHQgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuXHQgICAgfVxuXHR9O1xuXHR2YXIgX19pbXBvcnREZWZhdWx0ID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0dmFyIHdzXzEgPSBfX2ltcG9ydERlZmF1bHQoYnJvd3NlcldzKTtcblxuXG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHQvKipcblx0ICogIE5vdGVzOlxuXHQgKlxuXHQgKiAgVGhpcyBwcm92aWRlciBkaWZmZXJzIGEgYml0IGZyb20gdGhlIHBvbGxpbmcgcHJvdmlkZXJzLiBPbmUgbWFpblxuXHQgKiAgZGlmZmVyZW5jZSBpcyBob3cgaXQgaGFuZGxlcyBjb25zaXN0ZW5jeS4gVGhlIHBvbGxpbmcgcHJvdmlkZXJzXG5cdCAqICB3aWxsIHN0YWxsIHJlc3BvbnNlcyB0byBlbnN1cmUgYSBjb25zaXN0ZW50IHN0YXRlLCB3aGlsZSB0aGlzXG5cdCAqICBXZWJTb2NrZXQgcHJvdmlkZXIgYXNzdW1lcyB0aGUgY29ubmVjdGVkIGJhY2tlbmQgd2lsbCBtYW5hZ2UgdGhpcy5cblx0ICpcblx0ICogIEZvciBleGFtcGxlLCBpZiBhIHBvbGxpbmcgcHJvdmlkZXIgZW1pdHMgYW4gZXZlbnQgd2hpY2ggaW5kaWNhdHNcblx0ICogIHRoZSBldmVudCBvY2N1cnJlZCBpbiBibG9ja2hhc2ggWFhYLCBhIGNhbGwgdG8gZmV0Y2ggdGhhdCBibG9jayBieVxuXHQgKiAgaXRzIGhhc2ggWFhYLCBpZiBub3QgcHJlc2VudCB3aWxsIHJldHJ5IHVudGlsIGl0IGlzIHByZXNlbnQuIFRoaXNcblx0ICogIGNhbiBvY2N1ciB3aGVuIHF1ZXJ5aW5nIGEgcG9vbCBvZiBub2RlcyB0aGF0IGFyZSBtaWxkbHkgb3V0IG9mIHN5bmNcblx0ICogIHdpdGggZWFjaCBvdGhlci5cblx0ICovXG5cdHZhciBOZXh0SWQgPSAxO1xuXHQvLyBGb3IgbW9yZSBpbmZvIGFib3V0IHRoZSBSZWFsLXRpbWUgRXZlbnQgQVBJIHNlZTpcblx0Ly8gICBodHRwczovL2dldGguZXRoZXJldW0ub3JnL2RvY3MvcnBjL3B1YnN1YlxuXHR2YXIgV2ViU29ja2V0UHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoV2ViU29ja2V0UHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBXZWJTb2NrZXRQcm92aWRlcih1cmwsIG5ldHdvcmspIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBhZGRlZCBpbiB0aGUgZnV0dXJlOyBwbGVhc2Ugb3BlbiBhbiBpc3N1ZSB0byBleHBlZGl0ZVxuXHQgICAgICAgIGlmIChuZXR3b3JrID09PSBcImFueVwiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiV2ViU29ja2V0UHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCAnYW55JyBuZXR3b3JrIHlldFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXR3b3JrOmFueVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHVybCwgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICBfdGhpcy5fcG9sbGluZ0ludGVydmFsID0gLTE7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX3dlYnNvY2tldFwiLCBuZXcgd3NfMS5kZWZhdWx0KF90aGlzLmNvbm5lY3Rpb24udXJsKSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX3JlcXVlc3RzXCIsIHt9KTtcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJfc3Vic1wiLCB7fSk7XG5cdCAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIFwiX3N1Yklkc1wiLCB7fSk7XG5cdCAgICAgICAgLy8gU3RhbGwgc2VuZGluZyByZXF1ZXN0cyB1bnRpbCB0aGUgc29ja2V0IGlzIG9wZW4uLi5cblx0ICAgICAgICBfdGhpcy5fd3NSZWFkeSA9IGZhbHNlO1xuXHQgICAgICAgIF90aGlzLl93ZWJzb2NrZXQub25vcGVuID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBfdGhpcy5fd3NSZWFkeSA9IHRydWU7XG5cdCAgICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLl9yZXF1ZXN0cykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl93ZWJzb2NrZXQuc2VuZChfdGhpcy5fcmVxdWVzdHNbaWRdLnBheWxvYWQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF90aGlzLl93ZWJzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2VFdmVudCkge1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IG1lc3NhZ2VFdmVudC5kYXRhO1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gSlNPTi5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgaWYgKHJlc3VsdC5pZCAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaWQgPSBTdHJpbmcocmVzdWx0LmlkKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gX3RoaXMuX3JlcXVlc3RzW2lkXTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5fcmVxdWVzdHNbaWRdO1xuXHQgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSB8fCBcInVua25vd24gZXJyb3JcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KGVycm9yLCBcImNvZGVcIiwgcmVzdWx0LmVycm9yLmNvZGUgfHwgbnVsbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KGVycm9yLCBcInJlc3BvbnNlXCIsIGRhdGEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKGVycm9yLCB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhuZXcgRXJyb3IoXCJ1bmtub3duIGVycm9yXCIpLCB1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQubWV0aG9kID09PSBcImV0aF9zdWJzY3JpcHRpb25cIikge1xuXHQgICAgICAgICAgICAgICAgLy8gU3Vic2NyaXB0aW9uLi4uXG5cdCAgICAgICAgICAgICAgICB2YXIgc3ViID0gX3RoaXMuX3N1YnNbcmVzdWx0LnBhcmFtcy5zdWJzY3JpcHRpb25dO1xuXHQgICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuXHQgICAgICAgICAgICAgICAgICAgIC8vdGhpcy5lbWl0LmFwcGx5KHRoaXMsICAgICAgICAgICAgICAgICAgKTtcblx0ICAgICAgICAgICAgICAgICAgICBzdWIucHJvY2Vzc0Z1bmMocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwidGhpcyBzaG91bGQgbm90IGhhcHBlblwiKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgLy8gVGhpcyBQcm92aWRlciBkb2VzIG5vdCBhY3R1YWxseSBwb2xsLCBidXQgd2Ugd2FudCB0byB0cmlnZ2VyXG5cdCAgICAgICAgLy8gcG9sbCBldmVudHMgZm9yIHRoaW5ncyB0aGF0IGRlcGVuZCBvbiB0aGVtIChsaWtlIHN0YWxsaW5nIGZvclxuXHQgICAgICAgIC8vIGJsb2NrIGFuZCB0cmFuc2FjdGlvbiBsb29rdXBzKVxuXHQgICAgICAgIHZhciBmYXV4UG9sbCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcInBvbGxcIik7XG5cdCAgICAgICAgfSwgMTAwMCk7XG5cdCAgICAgICAgaWYgKGZhdXhQb2xsLnVucmVmKSB7XG5cdCAgICAgICAgICAgIGZhdXhQb2xsLnVucmVmKCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBfdGhpcztcblx0ICAgIH1cblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUsIFwicG9sbGluZ0ludGVydmFsXCIsIHtcblx0ICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIDA7XG5cdCAgICAgICAgfSxcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBpbnRlcnZhbCBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcblx0ICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZXRQb2xsaW5nSW50ZXJ2YWxcIlxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9LFxuXHQgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG5cdCAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG5cdCAgICB9KTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZS5yZXNldEV2ZW50c0Jsb2NrID0gZnVuY3Rpb24gKGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgcmVzZXQgZXZlbnRzIGJsb2NrIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuXHQgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzZXRFdmVudEJsb2NrXCJcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBudWxsXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldFByb3ZpZGVyLnByb3RvdHlwZSwgXCJwb2xsaW5nXCIsIHtcblx0ICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHQgICAgICAgICAgICBpZiAoIXZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgc2V0IHBvbGxpbmcgb24gV2ViU29ja2V0UHJvdmlkZXJcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0UG9sbGluZ1wiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cdCAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICBjb25maWd1cmFibGU6IHRydWVcblx0ICAgIH0pO1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgIHZhciByaWQgPSBOZXh0SWQrKztcblx0ICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBjYWxsYmFjayhlcnJvciwgcmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeSh7XG5cdCAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuXHQgICAgICAgICAgICAgICAgaWQ6IHJpZCxcblx0ICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIF90aGlzLl9yZXF1ZXN0c1tTdHJpbmcocmlkKV0gPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgcGF5bG9hZDogcGF5bG9hZCB9O1xuXHQgICAgICAgICAgICBpZiAoX3RoaXMuX3dzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLl93ZWJzb2NrZXQuc2VuZChwYXlsb2FkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIFdlYlNvY2tldFByb3ZpZGVyLmRlZmF1bHRVcmwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFwid3M6L1xcL2xvY2FsaG9zdDo4NTQ2XCI7XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdWJzY3JpYmUgPSBmdW5jdGlvbiAodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJJZFByb21pc2UsIHN1YklkO1xuXHQgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN1YklkUHJvbWlzZSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJJZFByb21pc2UgPSBQcm9taXNlLmFsbChwYXJhbSkudGhlbihmdW5jdGlvbiAocGFyYW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc2VuZChcImV0aF9zdWJzY3JpYmVcIiwgcGFyYW0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJJZHNbdGFnXSA9IHN1YklkUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzdWJJZFByb21pc2VdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3ViSWQgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWc6IHRhZywgcHJvY2Vzc0Z1bmM6IHByb2Nlc3NGdW5jIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgV2ViU29ja2V0UHJvdmlkZXIucHJvdG90eXBlLl9zdGFydEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcblx0ICAgICAgICAgICAgY2FzZSBcImJsb2NrXCI6XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJibG9ja1wiLCBbXCJuZXdIZWFkc1wiXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBibG9ja051bWJlciA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHJlc3VsdC5udW1iZXIpLnRvTnVtYmVyKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiYmxvY2tcIiwgYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInBlbmRpbmdcIjpcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInBlbmRpbmdcIiwgW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoZXZlbnQudGFnLCBbXCJsb2dzXCIsIHRoaXMuX2dldEZpbHRlcihldmVudC5maWx0ZXIpXSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVtb3ZlZCA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoZXZlbnQuZmlsdGVyLCBfdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcblx0ICAgICAgICAgICAgICAgIHZhciBlbWl0UmVjZWlwdF8xID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBldmVudC5oYXNoO1xuXHQgICAgICAgICAgICAgICAgICAgIF90aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKS50aGVuKGZ1bmN0aW9uIChyZWNlaXB0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVjZWlwdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoaGFzaCwgcmVjZWlwdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBpdCBpcyBhbHJlYWR5IG1pbmVkXG5cdCAgICAgICAgICAgICAgICBlbWl0UmVjZWlwdF8xKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIC8vIFRvIGtlZXAgdGhpbmdzIHNpbXBsZSwgd2Ugc3RhcnQgdXAgYSBzaW5nbGUgbmV3SGVhZHMgc3Vic2NyaXB0aW9uXG5cdCAgICAgICAgICAgICAgICAvLyB0byBrZWVwIGFuIGV5ZSBvdXQgZm9yIHRyYW5zYWN0aW9ucyB3ZSBhcmUgd2F0Y2hpbmcgZm9yLlxuXHQgICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBzdWJzY3JpcHRpb24gZm9yIGFuIGV2ZW50IChpLmUuIFwidHhcIikgdGhhdCBpcyBhbHJlYWR5XG5cdCAgICAgICAgICAgICAgICAvLyBydW5uaW5nIGlzIChiYXNpY2FsbHkpIGEgbm9wLlxuXHQgICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKFwidHhcIiwgW1wibmV3SGVhZHNcIl0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZXZlbnRzLmZpbHRlcihmdW5jdGlvbiAoZSkgeyByZXR1cm4gKGUudHlwZSA9PT0gXCJ0eFwiKTsgfSkuZm9yRWFjaChlbWl0UmVjZWlwdF8xKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgLy8gTm90aGluZyBpcyBuZWVkZWRcblx0ICAgICAgICAgICAgY2FzZSBcImRlYnVnXCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCJwb2xsXCI6XG5cdCAgICAgICAgICAgIGNhc2UgXCJ3aWxsUG9sbFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwiZGlkUG9sbFwiOlxuXHQgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQ6XCIsIGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuX3N0b3BFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgdmFyIHRhZyA9IGV2ZW50LnRhZztcblx0ICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJ0eFwiKSB7XG5cdCAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9ldmVudHMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiAoZS50eXBlID09PSBcInR4XCIpOyB9KS5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0YWcgPSBcInR4XCI7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcblx0ICAgICAgICAgICAgLy8gVGhlcmUgYXJlIHJlbWFpbmluZyBldmVudCBsaXN0ZW5lcnNcblx0ICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcblx0ICAgICAgICBpZiAoIXN1YklkKSB7XG5cdCAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZGVsZXRlIHRoaXMuX3N1Yklkc1t0YWddO1xuXHQgICAgICAgIHN1YklkLnRoZW4oZnVuY3Rpb24gKHN1YklkKSB7XG5cdCAgICAgICAgICAgIGlmICghX3RoaXMuX3N1YnNbc3ViSWRdKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9zdWJzW3N1YklkXTtcblx0ICAgICAgICAgICAgX3RoaXMuc2VuZChcImV0aF91bnN1YnNjcmliZVwiLCBbc3ViSWRdKTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICBXZWJTb2NrZXRQcm92aWRlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX3dlYnNvY2tldC5yZWFkeVN0YXRlID09PSB3c18xLmRlZmF1bHQuQ09OTkVDVElORykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl93ZWJzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEhhbmd1cFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl93ZWJzb2NrZXQuY2xvc2UoMTAwMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFdlYlNvY2tldFByb3ZpZGVyO1xuXHR9KGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5XZWJTb2NrZXRQcm92aWRlciA9IFdlYlNvY2tldFByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciB3ZWJzb2NrZXRQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyh3ZWJzb2NrZXRQcm92aWRlcik7XG5cdHZhciB3ZWJzb2NrZXRQcm92aWRlcl8xID0gd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXI7XG5cblx0dmFyIHVybEpzb25ScGNQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHQvLyBBIFN0YXRpY0pzb25ScGNQcm92aWRlciBpcyB1c2VmdWwgd2hlbiB5b3UgKmtub3cqIGZvciBjZXJ0YWluIHRoYXRcblx0Ly8gdGhlIGJhY2tlbmQgd2lsbCBuZXZlciBjaGFuZ2UsIGFzIGl0IG5ldmVyIGNhbGxzIGV0aF9jaGFpbklkIHRvXG5cdC8vIHZlcmlmeSBpdHMgYmFja2VuZC4gSG93ZXZlciwgaWYgdGhlIGJhY2tlbmQgZG9lcyBjaGFuZ2UsIHRoZSBlZmZlY3RzXG5cdC8vIGFyZSB1bmRlZmluZWQgYW5kIG1heSBpbmNsdWRlOlxuXHQvLyAtIGluY29uc2lzdGVudCByZXN1bHRzXG5cdC8vIC0gbG9ja2luZyB1cCB0aGUgVUlcblx0Ly8gLSBibG9jayBza2V3IHdhcm5pbmdzXG5cdC8vIC0gd3JvbmcgcmVzdWx0c1xuXHQvLyBJZiB0aGUgbmV0d29yayBpcyBub3QgZXhwbGljaXQgKGkuZS4gYXV0by1kZXRlY3Rpb24gaXMgZXhwZWN0ZWQpLCB0aGVcblx0Ly8gbm9kZSBNVVNUIGJlIHJ1bm5pbmcgYW5kIGF2YWlsYWJsZSB0byByZXNwb25kIHRvIHJlcXVlc3RzIEJFRk9SRSB0aGlzXG5cdC8vIGlzIGluc3RhbnRpYXRlZC5cblx0dmFyIFN0YXRpY0pzb25ScGNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhTdGF0aWNKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBTdGF0aWNKc29uUnBjUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgU3RhdGljSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcms7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB0aGlzLm5ldHdvcms7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG5ldHdvcmsgPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBfc3VwZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsuY2FsbCh0aGlzKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5ldHdvcmspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm8gbmV0d29yayBkZXRlY3RlZFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgc3RpbGwgbm90IHNldCwgc2V0IGl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgc3RhdGljIG5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBcImFueVwiXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIG5ldHdvcmspO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV0d29ya107XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBTdGF0aWNKc29uUnBjUHJvdmlkZXI7XG5cdH0oanNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLlN0YXRpY0pzb25ScGNQcm92aWRlciA9IFN0YXRpY0pzb25ScGNQcm92aWRlcjtcblx0dmFyIFVybEpzb25ScGNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhVcmxKc29uUnBjUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBVcmxKc29uUnBjUHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QoX25ld1RhcmdldCwgVXJsSnNvblJwY1Byb3ZpZGVyKTtcblx0ICAgICAgICAvLyBOb3JtYWxpemUgdGhlIE5ldHdvcmsgYW5kIEFQSSBLZXlcblx0ICAgICAgICBuZXR3b3JrID0gbGliJDMuZ2V0U3RhdGljKChfbmV3VGFyZ2V0KSwgXCJnZXROZXR3b3JrXCIpKG5ldHdvcmspO1xuXHQgICAgICAgIGFwaUtleSA9IGxpYiQzLmdldFN0YXRpYygoX25ld1RhcmdldCksIFwiZ2V0QXBpS2V5XCIpKGFwaUtleSk7XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBsaWIkMy5nZXRTdGF0aWMoKF9uZXdUYXJnZXQpLCBcImdldFVybFwiKShuZXR3b3JrLCBhcGlLZXkpO1xuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbiwgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICBpZiAodHlwZW9mIChhcGlLZXkpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBPYmplY3Qua2V5cyhhcGlLZXkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHQgICAgICAgICAgICAgICAgbGliJDMuZGVmaW5lUmVhZE9ubHkoX3RoaXMsIGtleSwgYXBpS2V5W2tleV0pO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5fc3RhcnRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGxvZ2dlci53YXJuKFwiV0FSTklORzogQVBJIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgcGVuZGluZyBmaWx0ZXJzXCIpO1xuXHQgICAgfTtcblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5wcm90b3R5cGUuZ2V0U2lnbmVyID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IFwiZ2V0U2lnbmVyXCIgfSk7XG5cdCAgICB9O1xuXHQgICAgVXJsSnNvblJwY1Byb3ZpZGVyLnByb3RvdHlwZS5saXN0QWNjb3VudHMgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShbXSk7XG5cdCAgICB9O1xuXHQgICAgLy8gUmV0dXJuIGEgZGVmYXVsdEFwaUtleSBpZiBudWxsLCBvdGhlcndpc2UgdmFsaWRhdGUgdGhlIEFQSSBrZXlcblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIGFwaUtleTtcblx0ICAgIH07XG5cdCAgICAvLyBSZXR1cm5zIHRoZSB1cmwgb3IgY29ubmVjdGlvbiBmb3IgdGhlIGdpdmVuIG5ldHdvcmsgYW5kIEFQSSBrZXkuIFRoZVxuXHQgICAgLy8gQVBJIGtleSB3aWxsIGhhdmUgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGdldEFwaUtleSBmaXJzdCwgc28gYW55IHZhbGlkYXRpb25cblx0ICAgIC8vIG9yIHRyYW5zZm9ybWF0aW9ucyBjYW4gYmUgZG9uZSB0aGVyZS5cblx0ICAgIFVybEpzb25ScGNQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwibm90IGltcGxlbWVudGVkOyBzdWItY2xhc3NlcyBtdXN0IG92ZXJyaWRlIGdldFVybFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHtcblx0ICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldFVybFwiXG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFVybEpzb25ScGNQcm92aWRlcjtcblx0fShTdGF0aWNKc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5VcmxKc29uUnBjUHJvdmlkZXIgPSBVcmxKc29uUnBjUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIHVybEpzb25ScGNQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyh1cmxKc29uUnBjUHJvdmlkZXIpO1xuXHR2YXIgdXJsSnNvblJwY1Byb3ZpZGVyXzEgPSB1cmxKc29uUnBjUHJvdmlkZXIuU3RhdGljSnNvblJwY1Byb3ZpZGVyO1xuXHR2YXIgdXJsSnNvblJwY1Byb3ZpZGVyXzIgPSB1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyO1xuXG5cdHZhciBhbGNoZW15UHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0Ly8gVGhpcyBrZXkgd2FzIHByb3ZpZGVkIHRvIGV0aGVycy5qcyBieSBBbGNoZW15IHRvIGJlIHVzZWQgYnkgdGhlXG5cdC8vIGRlZmF1bHQgcHJvdmlkZXIsIGJ1dCBpdCBpcyByZWNvbW1lbmRlZCB0aGF0IGZvciB5b3VyIG93blxuXHQvLyBwcm9kdWN0aW9uIGVudmlyb25tZW50cywgdGhhdCB5b3UgYWNxdWlyZSB5b3VyIG93biBBUEkga2V5IGF0OlxuXHQvLyAgIGh0dHBzOi8vZGFzaGJvYXJkLmFsY2hlbXlhcGkuaW9cblx0dmFyIGRlZmF1bHRBcGlLZXkgPSBcIl9nZzd3U1NpMEtNQnNkS25HVmZIRHVlcTZ4TUI5RWtDXCI7XG5cdHZhciBBbGNoZW15UHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG5cdCAgICBfX2V4dGVuZHMoQWxjaGVteVByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gQWxjaGVteVByb3ZpZGVyKCkge1xuXHQgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcblx0ICAgIH1cblx0ICAgIEFsY2hlbXlQcm92aWRlci5nZXRXZWJTb2NrZXRQcm92aWRlciA9IGZ1bmN0aW9uIChuZXR3b3JrLCBhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgcHJvdmlkZXIgPSBuZXcgQWxjaGVteVByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG5cdCAgICAgICAgdmFyIHVybCA9IHByb3ZpZGVyLmNvbm5lY3Rpb24udXJsLnJlcGxhY2UoL15odHRwL2ksIFwid3NcIilcblx0ICAgICAgICAgICAgLnJlcGxhY2UoXCIuYWxjaGVteWFwaS5cIiwgXCIud3MuYWxjaGVteWFwaS5cIik7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRQcm92aWRlci5XZWJTb2NrZXRQcm92aWRlcih1cmwsIHByb3ZpZGVyLm5ldHdvcmspO1xuXHQgICAgfTtcblx0ICAgIEFsY2hlbXlQcm92aWRlci5nZXRBcGlLZXkgPSBmdW5jdGlvbiAoYXBpS2V5KSB7XG5cdCAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBkZWZhdWx0QXBpS2V5O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiAoYXBpS2V5KSAhPT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGFwaUtleTtcblx0ICAgIH07XG5cdCAgICBBbGNoZW15UHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIHZhciBob3N0ID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtbWFpbm5ldC5hbGNoZW15YXBpLmlvL3YyL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtcm9wc3Rlbi5hbGNoZW15YXBpLmlvL3YyL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtcmlua2VieS5hbGNoZW15YXBpLmlvL3YyL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1nb2VybGkuYWxjaGVteWFwaS5pby92Mi9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwia292YW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1rb3Zhbi5hbGNoZW15YXBpLmlvL3YyL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBhcGlLZXkpLFxuXHQgICAgICAgICAgICB0aHJvdHRsZUNhbGxiYWNrOiBmdW5jdGlvbiAoYXR0ZW1wdCwgdXJsKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyLnNob3dUaHJvdHRsZU1lc3NhZ2UoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9O1xuXHQgICAgfTtcblx0ICAgIHJldHVybiBBbGNoZW15UHJvdmlkZXI7XG5cdH0odXJsSnNvblJwY1Byb3ZpZGVyLlVybEpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLkFsY2hlbXlQcm92aWRlciA9IEFsY2hlbXlQcm92aWRlcjtcblxuXHR9KTtcblxuXHR2YXIgYWxjaGVteVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGFsY2hlbXlQcm92aWRlcik7XG5cdHZhciBhbGNoZW15UHJvdmlkZXJfMSA9IGFsY2hlbXlQcm92aWRlci5BbGNoZW15UHJvdmlkZXI7XG5cblx0dmFyIGNsb3VkZmxhcmVQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdHZhciBfX2F3YWl0ZXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG5cdCAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cblx0ICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cblx0ICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuXHQgICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcblx0ICAgIH0pO1xuXHR9O1xuXHR2YXIgX19nZW5lcmF0b3IgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG5cdCAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuXHQgICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG5cdCAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cblx0ICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcblx0ICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG5cdCAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG5cdCAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcblx0ICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcblx0ICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcblx0ICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuXHQgICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cblx0ICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcblx0ICAgIH1cblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblx0dmFyIENsb3VkZmxhcmVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhDbG91ZGZsYXJlUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBDbG91ZGZsYXJlUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcblx0ICAgICAgICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFwaUtleSBub3Qgc3VwcG9ydGVkIGZvciBjbG91ZGZsYXJlXCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgfTtcblx0ICAgIENsb3VkZmxhcmVQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vY2xvdWRmbGFyZS1ldGguY29tL1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgcmV0dXJuIGhvc3Q7XG5cdCAgICB9O1xuXHQgICAgQ2xvdWRmbGFyZVByb3ZpZGVyLnByb3RvdHlwZS5wZXJmb3JtID0gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKG1ldGhvZCA9PT0gXCJnZXRCbG9ja051bWJlclwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF9zdXBlci5wcm90b3R5cGUucGVyZm9ybS5jYWxsKHRoaXMsIFwiZ2V0QmxvY2tcIiwgeyBibG9ja1RhZzogXCJsYXRlc3RcIiB9KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGJsb2NrLm51bWJlcl07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX3N1cGVyLnByb3RvdHlwZS5wZXJmb3JtLmNhbGwodGhpcywgbWV0aG9kLCBwYXJhbXMpXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIENsb3VkZmxhcmVQcm92aWRlcjtcblx0fSh1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyKSk7XG5cdGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gQ2xvdWRmbGFyZVByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBjbG91ZGZsYXJlUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMoY2xvdWRmbGFyZVByb3ZpZGVyKTtcblx0dmFyIGNsb3VkZmxhcmVQcm92aWRlcl8xID0gY2xvdWRmbGFyZVByb3ZpZGVyLkNsb3VkZmxhcmVQcm92aWRlcjtcblxuXHR2YXIgZXRoZXJzY2FuUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0Ly8gVGhlIHRyYW5zYWN0aW9uIGhhcyBhbHJlYWR5IGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBjYWxscyBpbiBQcm92aWRlclxuXHRmdW5jdGlvbiBnZXRUcmFuc2FjdGlvblN0cmluZyh0cmFuc2FjdGlvbikge1xuXHQgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgZm9yICh2YXIga2V5IGluIHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHZhbHVlID0gbGliJDEuaGV4bGlmeSh0cmFuc2FjdGlvbltrZXldKTtcblx0ICAgICAgICBpZiAoeyBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcblx0ICAgICAgICAgICAgdmFsdWUgPSBsaWIkMS5oZXhWYWx1ZSh2YWx1ZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJlc3VsdC5wdXNoKGtleSArIFwiPVwiICsgdmFsdWUpO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdC5qb2luKFwiJlwiKTtcblx0fVxuXHRmdW5jdGlvbiBnZXRSZXN1bHQocmVzdWx0KSB7XG5cdCAgICAvLyBnZXRMb2dzLCBnZXRIaXN0b3J5IGhhdmUgd2VpcmQgc3VjY2VzcyByZXNwb25zZXNcblx0ICAgIGlmIChyZXN1bHQuc3RhdHVzID09IDAgJiYgKHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHJlY29yZHMgZm91bmRcIiB8fCByZXN1bHQubWVzc2FnZSA9PT0gXCJObyB0cmFuc2FjdGlvbnMgZm91bmRcIikpIHtcblx0ICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcblx0ICAgIH1cblx0ICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IDEgfHwgcmVzdWx0Lm1lc3NhZ2UgIT0gXCJPS1wiKSB7XG5cdCAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcblx0ICAgICAgICBlcnJvci5yZXN1bHQgPSBKU09OLnN0cmluZ2lmeShyZXN1bHQpO1xuXHQgICAgICAgIGlmICgocmVzdWx0LnJlc3VsdCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpID49IDApIHtcblx0ICAgICAgICAgICAgZXJyb3IudGhyb3R0bGVSZXRyeSA9IHRydWU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG5cdH1cblx0ZnVuY3Rpb24gZ2V0SnNvblJlc3VsdChyZXN1bHQpIHtcblx0ICAgIC8vIFRoaXMgcmVzcG9uc2UgaW5kaWNhdGVzIHdlIGFyZSBiZWluZyB0aHJvdHRsZWRcblx0ICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0LnN0YXR1cyA9PSAwICYmIHJlc3VsdC5tZXNzYWdlID09IFwiTk9UT0tcIiAmJiAocmVzdWx0LnJlc3VsdCB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJyYXRlIGxpbWl0XCIpID49IDApIHtcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJ0aHJvdHRsZWQgcmVzcG9uc2VcIik7XG5cdCAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcblx0ICAgICAgICBlcnJvci50aHJvdHRsZVJldHJ5ID0gdHJ1ZTtcblx0ICAgICAgICB0aHJvdyBlcnJvcjtcblx0ICAgIH1cblx0ICAgIGlmIChyZXN1bHQuanNvbnJwYyAhPSBcIjIuMFwiKSB7XG5cdCAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJpbnZhbGlkIHJlc3BvbnNlXCIpO1xuXHQgICAgICAgIGVycm9yLnJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG5cdCAgICAgICAgdGhyb3cgZXJyb3I7XG5cdCAgICB9XG5cdCAgICBpZiAocmVzdWx0LmVycm9yKSB7XG5cdCAgICAgICAgLy8gQFRPRE86IG5vdCBhbnlcblx0ICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UgfHwgXCJ1bmtub3duIGVycm9yXCIpO1xuXHQgICAgICAgIGlmIChyZXN1bHQuZXJyb3IuY29kZSkge1xuXHQgICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzdWx0LmVycm9yLmNvZGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChyZXN1bHQuZXJyb3IuZGF0YSkge1xuXHQgICAgICAgICAgICBlcnJvci5kYXRhID0gcmVzdWx0LmVycm9yLmRhdGE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHRocm93IGVycm9yO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG5cdH1cblx0Ly8gVGhlIGJsb2NrVGFnIHdhcyBub3JtYWxpemVkIGFzIGEgc3RyaW5nIGJ5IHRoZSBQcm92aWRlciBwcmUtcGVyZm9ybSBvcGVyYXRpb25zXG5cdGZ1bmN0aW9uIGNoZWNrTG9nVGFnKGJsb2NrVGFnKSB7XG5cdCAgICBpZiAoYmxvY2tUYWcgPT09IFwicGVuZGluZ1wiKSB7XG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGVuZGluZyBub3Qgc3VwcG9ydGVkXCIpO1xuXHQgICAgfVxuXHQgICAgaWYgKGJsb2NrVGFnID09PSBcImxhdGVzdFwiKSB7XG5cdCAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHBhcnNlSW50KGJsb2NrVGFnLnN1YnN0cmluZygyKSwgMTYpO1xuXHR9XG5cdHZhciBkZWZhdWx0QXBpS2V5ID0gXCI5RDEzWkU3WFNCVEo5NE45Qk5KMk1BMzNWTUFZMllQSVJCXCI7XG5cdGZ1bmN0aW9uIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgdHJhbnNhY3Rpb24pIHtcblx0ICAgIC8vIEdldCB0aGUgbWVzc2FnZSBmcm9tIGFueSBuZXN0ZWQgZXJyb3Igc3RydWN0dXJlXG5cdCAgICB2YXIgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG5cdCAgICBpZiAoZXJyb3IuY29kZSA9PT0gbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SKSB7XG5cdCAgICAgICAgaWYgKGVycm9yLmVycm9yICYmIHR5cGVvZiAoZXJyb3IuZXJyb3IubWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmVycm9yLm1lc3NhZ2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IuYm9keSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmJvZHk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoZXJyb3IucmVzcG9uc2VUZXh0KSA9PT0gXCJzdHJpbmdcIikge1xuXHQgICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IucmVzcG9uc2VUZXh0O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIG1lc3NhZ2UgPSAobWVzc2FnZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuXHQgICAgLy8gXCJJbnN1ZmZpY2llbnQgZnVuZHMuIFRoZSBhY2NvdW50IHlvdSB0cmllZCB0byBzZW5kIHRyYW5zYWN0aW9uIGZyb20gZG9lcyBub3QgaGF2ZSBlbm91Z2ggZnVuZHMuIFJlcXVpcmVkIDIxNDY0MDAwMDAwMDAwIGFuZCBnb3Q6IDBcIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2luc3VmZmljaWVudCBmdW5kcy8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLklOU1VGRklDSUVOVF9GVU5EUywge1xuXHQgICAgICAgICAgICBlcnJvcjogZXJyb3IsIG1ldGhvZDogbWV0aG9kLCB0cmFuc2FjdGlvbjogdHJhbnNhY3Rpb25cblx0ICAgICAgICB9KTtcblx0ICAgIH1cblx0ICAgIC8vIFwiVHJhbnNhY3Rpb24gd2l0aCB0aGUgc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkLlwiXG5cdCAgICBpZiAobWVzc2FnZS5tYXRjaCgvc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkfHRyYW5zYWN0aW9uIG5vbmNlIGlzIHRvbyBsb3cvKSkge1xuXHQgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIGxpYi5Mb2dnZXIuZXJyb3JzLk5PTkNFX0VYUElSRUQsIHtcblx0ICAgICAgICAgICAgZXJyb3I6IGVycm9yLCBtZXRob2Q6IG1ldGhvZCwgdHJhbnNhY3Rpb246IHRyYW5zYWN0aW9uXG5cdCAgICAgICAgfSk7XG5cdCAgICB9XG5cdCAgICAvLyBcIlRyYW5zYWN0aW9uIGdhcyBwcmljZSBpcyB0b28gbG93LiBUaGVyZSBpcyBhbm90aGVyIHRyYW5zYWN0aW9uIHdpdGggc2FtZSBub25jZSBpbiB0aGUgcXVldWUuIFRyeSBpbmNyZWFzaW5nIHRoZSBnYXMgcHJpY2Ugb3IgaW5jcmVtZW50aW5nIHRoZSBub25jZS5cIlxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2Fub3RoZXIgdHJhbnNhY3Rpb24gd2l0aCBzYW1lIG5vbmNlLykpIHtcblx0ICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInJlcGxhY2VtZW50IGZlZSB0b28gbG93XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG5cdCAgICAgICAgICAgIGVycm9yOiBlcnJvciwgbWV0aG9kOiBtZXRob2QsIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgaWYgKG1lc3NhZ2UubWF0Y2goL2V4ZWN1dGlvbiBmYWlsZWQgZHVlIHRvIGFuIGV4Y2VwdGlvbi8pKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZXN0aW1hdGUgZ2FzOyB0cmFuc2FjdGlvbiBtYXkgZmFpbCBvciBtYXkgcmVxdWlyZSBtYW51YWwgZ2FzIGxpbWl0XCIsIGxpYi5Mb2dnZXIuZXJyb3JzLlVOUFJFRElDVEFCTEVfR0FTX0xJTUlULCB7XG5cdCAgICAgICAgICAgIGVycm9yOiBlcnJvciwgbWV0aG9kOiBtZXRob2QsIHRyYW5zYWN0aW9uOiB0cmFuc2FjdGlvblxuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgZXJyb3I7XG5cdH1cblx0dmFyIEV0aGVyc2NhblByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEV0aGVyc2NhblByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEV0aGVyc2NhblByb3ZpZGVyKTtcblx0ICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldHdvcmspIHx8IHRoaXM7XG5cdCAgICAgICAgdmFyIG5hbWUgPSBcImludmFsaWRcIjtcblx0ICAgICAgICBpZiAoX3RoaXMubmV0d29yaykge1xuXHQgICAgICAgICAgICBuYW1lID0gX3RoaXMubmV0d29yay5uYW1lO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgYmFzZVVybCA9IG51bGw7XG5cdCAgICAgICAgc3dpdGNoIChuYW1lKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGJhc2VVcmwgPSBcImh0dHBzOi8vYXBpLmV0aGVyc2Nhbi5pb1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG5cdCAgICAgICAgICAgICAgICBiYXNlVXJsID0gXCJodHRwczovL2FwaS1yb3BzdGVuLmV0aGVyc2Nhbi5pb1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJyaW5rZWJ5XCI6XG5cdCAgICAgICAgICAgICAgICBiYXNlVXJsID0gXCJodHRwczovL2FwaS1yaW5rZWJ5LmV0aGVyc2Nhbi5pb1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuXHQgICAgICAgICAgICAgICAgYmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkta292YW4uZXRoZXJzY2FuLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuXHQgICAgICAgICAgICAgICAgYmFzZVVybCA9IFwiaHR0cHM6Ly9hcGktZ29lcmxpLmV0aGVyc2Nhbi5pb1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJiYXNlVXJsXCIsIGJhc2VVcmwpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcImFwaUtleVwiLCBhcGlLZXkgfHwgZGVmYXVsdEFwaUtleSk7XG5cdCAgICAgICAgcmV0dXJuIF90aGlzO1xuXHQgICAgfVxuXHQgICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLmRldGVjdE5ldHdvcmsgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGhpcy5uZXR3b3JrXTtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgRXRoZXJzY2FuUHJvdmlkZXIucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB1cmwsIGFwaUtleSwgZ2V0LCBfYSwgdHJhbnNhY3Rpb24sIGVycm9yXzEsIHRyYW5zYWN0aW9uLCBlcnJvcl8yLCB0b3BpYzAsIGxvZ3MsIHR4cywgaSwgbG9nLCB0eCwgX2I7XG5cdCAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcblx0ICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMuYmFzZVVybDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgYXBpS2V5ID0gXCJcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYXBpS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlLZXkgKz0gXCImYXBpa2V5PVwiICsgdGhpcy5hcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgZ2V0ID0gZnVuY3Rpb24gKHVybCwgcHJvY0Z1bmMpIHsgcmV0dXJuIF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aW9uLCByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24gPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVTbG90SW50ZXJ2YWw6IDEwMDAsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuc2hvd1Rocm90dGxlTWVzc2FnZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGxpYiRsLmZldGNoSnNvbihjb25uZWN0aW9uLCBudWxsLCBwcm9jRnVuYyB8fCBnZXRKc29uUmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGxpYiQzLmRlZXBDb3B5KHJlc3VsdCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pOyB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYSA9IG1ldGhvZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrTnVtYmVyXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOiByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOiByZXR1cm4gWzMgLypicmVhayovLCA2XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDEwXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDExXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOiByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAyNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjhdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9ibG9ja051bWJlclwiICsgYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nYXNQcmljZVwiICsgYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJucyBiYXNlLTEwIHJlc3VsdFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1hY2NvdW50JmFjdGlvbj1iYWxhbmNlJmFkZHJlc3M9XCIgKyBwYXJhbXMuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwsIGdldFJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvbkNvdW50JmFkZHJlc3M9XCIgKyBwYXJhbXMuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0Q29kZSZhZGRyZXNzPVwiICsgcGFyYW1zLmFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZ0YWc9XCIgKyBwYXJhbXMuYmxvY2tUYWcgKyBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2dldFN0b3JhZ2VBdCZhZGRyZXNzPVwiICsgcGFyYW1zLmFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZwb3NpdGlvbj1cIiArIHBhcmFtcy5wb3NpdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZyArIGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfc2VuZFJhd1RyYW5zYWN0aW9uJmhleD1cIiArIHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRCbG9ja0J5TnVtYmVyJnRhZz1cIiArIHBhcmFtcy5ibG9ja1RhZztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZib29sZWFuPXRydWVcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZib29sZWFuPWZhbHNlXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnZXRCbG9jayBieSBibG9ja0hhc2ggbm90IGltcGxlbWVudGVkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgOTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCZ0eGhhc2g9XCIgKyBwYXJhbXMudHJhbnNhY3Rpb25IYXNoO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZ2V0KHVybCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXByb3h5JmFjdGlvbj1ldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JnR4aGFzaD1cIiArIHBhcmFtcy50cmFuc2FjdGlvbkhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBnZXRUcmFuc2FjdGlvblN0cmluZyhwYXJhbXMudHJhbnNhY3Rpb24pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gXCImXCIgKyB0cmFuc2FjdGlvbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCIvYXBpP21vZHVsZT1wcm94eSZhY3Rpb249ZXRoX2NhbGxcIiArIHRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvL3VybCArPSBcIiZ0YWc9XCIgKyBwYXJhbXMuYmxvY2tUYWcgKyBhcGlLZXk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgIT09IFwibGF0ZXN0XCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV0aGVyc2NhblByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgYmxvY2tUYWcgZm9yIGNhbGxcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAxMjtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy50cnlzLnB1c2goWzEyLCAxNCwgLCAxNV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXQodXJsKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9jLnNlbnQoKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JfMSA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNoZWNrRXJyb3IoXCJjYWxsXCIsIGVycm9yXzEsIHBhcmFtcy50cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gZ2V0VHJhbnNhY3Rpb25TdHJpbmcocGFyYW1zLnRyYW5zYWN0aW9uKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IFwiJlwiICsgdHJhbnNhY3Rpb247XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9cHJveHkmYWN0aW9uPWV0aF9lc3RpbWF0ZUdhcyZcIiArIHRyYW5zYWN0aW9uO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE2O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9jLnRyeXMucHVzaChbMTYsIDE4LCAsIDE5XSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldCh1cmwpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Muc2VudCgpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcl8yID0gX2Muc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2hlY2tFcnJvcihcImVzdGltYXRlR2FzXCIsIGVycm9yXzIsIHBhcmFtcy50cmFuc2FjdGlvbildO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPWxvZ3MmYWN0aW9uPWdldExvZ3NcIjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIuZnJvbUJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImZnJvbUJsb2NrPVwiICsgY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci5mcm9tQmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvQmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZ0b0Jsb2NrPVwiICsgY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci50b0Jsb2NrKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5hZGRyZXNzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImYWRkcmVzcz1cIiArIHBhcmFtcy5maWx0ZXIuYWRkcmVzcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBAVE9ETzogV2UgY2FuIGhhbmRsZSBzbGlnaHRseSBtb3JlIGNvbXBsaWNhdGVkIGxvZ3MgdXNpbmcgdGhlIGxvZ3MgQVBJXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLnRvcGljcyAmJiBwYXJhbXMuZmlsdGVyLnRvcGljcy5sZW5ndGggPiAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgdG9waWMgY291bnRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljczogcGFyYW1zLmZpbHRlci50b3BpY3MgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9waWMwID0gcGFyYW1zLmZpbHRlci50b3BpY3NbMF07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodG9waWMwKSAhPT0gXCJzdHJpbmdcIiB8fCB0b3BpYzAubGVuZ3RoICE9PSA2Nikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGZvcm1hdFwiLCBsaWIuTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgdG9waWMwOiB0b3BpYzAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZ0b3BpYzA9XCIgKyB0b3BpYzA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IGFwaUtleTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0KHVybCwgZ2V0UmVzdWx0KV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9ncyA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdHhzID0ge307XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDIxO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjE6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBsb2dzLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDI1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbG9nID0gbG9nc1tpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvZy5ibG9ja0hhc2ggIT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHR4c1tsb2cudHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMjNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFRyYW5zYWN0aW9uKGxvZy50cmFuc2FjdGlvbkhhc2gpXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eCA9IF9jLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eHNbbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSB0eC5ibG9ja0hhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAyMztcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDIzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBsb2cuYmxvY2tIYXNoID0gdHhzW2xvZy50cmFuc2FjdGlvbkhhc2hdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDI0O1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMjFdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjU6IHJldHVybiBbMiAvKnJldHVybiovLCBsb2dzXTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDI2OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgIT09IFwiaG9tZXN0ZWFkXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCAwLjBdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBcIi9hcGk/bW9kdWxlPXN0YXRzJmFjdGlvbj1ldGhwcmljZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB1cmwgKz0gYXBpS2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYiA9IHBhcnNlRmxvYXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGdldCh1cmwsIGdldFJlc3VsdCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjc6IHJldHVybiBbMiAvKnJldHVybiovLCBfYi5hcHBseSh2b2lkIDAsIFsoX2Muc2VudCgpKS5ldGh1c2RdKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAyODogcmV0dXJuIFszIC8qYnJlYWsqLywgMjldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjk6IHJldHVybiBbMiAvKnJldHVybiovLCBfc3VwZXIucHJvdG90eXBlLnBlcmZvcm0uY2FsbCh0aGlzLCBtZXRob2QsIHBhcmFtcyldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICAvLyBAVE9ETzogQWxsb3cgc3RhcnRCbG9jayBhbmQgZW5kQmxvY2sgdG8gYmUgUHJvbWlzZXNcblx0ICAgIEV0aGVyc2NhblByb3ZpZGVyLnByb3RvdHlwZS5nZXRIaXN0b3J5ID0gZnVuY3Rpb24gKGFkZHJlc3NPck5hbWUsIHN0YXJ0QmxvY2ssIGVuZEJsb2NrKSB7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICB2YXIgdXJsID0gdGhpcy5iYXNlVXJsO1xuXHQgICAgICAgIHZhciBhcGlLZXkgPSBcIlwiO1xuXHQgICAgICAgIGlmICh0aGlzLmFwaUtleSkge1xuXHQgICAgICAgICAgICBhcGlLZXkgKz0gXCImYXBpa2V5PVwiICsgdGhpcy5hcGlLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChzdGFydEJsb2NrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgc3RhcnRCbG9jayA9IDA7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChlbmRCbG9jayA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIGVuZEJsb2NrID0gOTk5OTk5OTk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVOYW1lKGFkZHJlc3NPck5hbWUpLnRoZW4oZnVuY3Rpb24gKGFkZHJlc3MpIHtcblx0ICAgICAgICAgICAgdXJsICs9IFwiL2FwaT9tb2R1bGU9YWNjb3VudCZhY3Rpb249dHhsaXN0JmFkZHJlc3M9XCIgKyBhZGRyZXNzO1xuXHQgICAgICAgICAgICB1cmwgKz0gXCImc3RhcnRibG9jaz1cIiArIHN0YXJ0QmxvY2s7XG5cdCAgICAgICAgICAgIHVybCArPSBcIiZlbmRibG9jaz1cIiArIGVuZEJsb2NrO1xuXHQgICAgICAgICAgICB1cmwgKz0gXCImc29ydD1hc2NcIiArIGFwaUtleTtcblx0ICAgICAgICAgICAgX3RoaXMuZW1pdChcImRlYnVnXCIsIHtcblx0ICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG5cdCAgICAgICAgICAgICAgICBwcm92aWRlcjogX3RoaXNcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0ge1xuXHQgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG5cdCAgICAgICAgICAgICAgICB0aHJvdHRsZVNsb3RJbnRlcnZhbDogMTAwMCxcblx0ICAgICAgICAgICAgICAgIHRocm90dGxlQ2FsbGJhY2s6IGZ1bmN0aW9uIChhdHRlbXB0LCB1cmwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlci5zaG93VGhyb3R0bGVNZXNzYWdlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBsaWIkbC5mZXRjaEpzb24oY29ubmVjdGlvbiwgbnVsbCwgZ2V0UmVzdWx0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBsaWIkMy5kZWVwQ29weShyZXN1bHQpLFxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBfdGhpc1xuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3V0cHV0ID0gW107XG5cdCAgICAgICAgICAgICAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAodHgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBbXCJjb250cmFjdEFkZHJlc3NcIiwgXCJ0b1wiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4W2tleV0gPT0gXCJcIikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHR4W2tleV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAodHguY3JlYXRlcyA9PSBudWxsICYmIHR4LmNvbnRyYWN0QWRkcmVzcyAhPSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNyZWF0ZXMgPSB0eC5jb250cmFjdEFkZHJlc3M7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX3RoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0eC50aW1lU3RhbXApIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50aW1lc3RhbXAgPSBwYXJzZUludCh0eC50aW1lU3RhbXApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChpdGVtKTtcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIEV0aGVyc2NhblByb3ZpZGVyO1xuXHR9KGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5FdGhlcnNjYW5Qcm92aWRlciA9IEV0aGVyc2NhblByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBldGhlcnNjYW5Qcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyhldGhlcnNjYW5Qcm92aWRlcik7XG5cdHZhciBldGhlcnNjYW5Qcm92aWRlcl8xID0gZXRoZXJzY2FuUHJvdmlkZXIuRXRoZXJzY2FuUHJvdmlkZXI7XG5cblx0dmFyIGZhbGxiYWNrUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHR2YXIgX19hd2FpdGVyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuXHQgICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG5cdCAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcblx0ICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cblx0ICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG5cdCAgICB9KTtcblx0fTtcblx0dmFyIF9fZ2VuZXJhdG9yID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuXHQgICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcblx0ICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuXHQgICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG5cdCAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG5cdCAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuXHQgICAgICAgIHdoaWxlIChfKSB0cnkge1xuXHQgICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG5cdCAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcblx0ICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuXHQgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuXHQgICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuXHQgICAgICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuXHQgICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcblx0ICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG5cdCAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG5cdCAgICB9XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXG5cblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdGZ1bmN0aW9uIG5vdygpIHsgcmV0dXJuIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7IH1cblx0Ly8gUmV0dXJucyB0byBuZXR3b3JrIGFzIGxvbmcgYXMgYWxsIGFncmVlLCBvciBudWxsIGlmIGFueSBpcyBudWxsLlxuXHQvLyBUaHJvd3MgYW4gZXJyb3IgaWYgYW55IHR3byBuZXR3b3JrcyBkbyBub3QgbWF0Y2guXG5cdGZ1bmN0aW9uIGNoZWNrTmV0d29ya3MobmV0d29ya3MpIHtcblx0ICAgIHZhciByZXN1bHQgPSBudWxsO1xuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXR3b3Jrcy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgIHZhciBuZXR3b3JrID0gbmV0d29ya3NbaV07XG5cdCAgICAgICAgLy8gTnVsbCEgV2UgZG8gbm90IGtub3cgb3VyIG5ldHdvcms7IGJhaWwuXG5cdCAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIG5ldHdvcmsgbWF0Y2hlcyB0aGUgcHJldmlvdXMgbmV0d29ya3Ncblx0ICAgICAgICAgICAgaWYgKCEocmVzdWx0Lm5hbWUgPT09IG5ldHdvcmsubmFtZSAmJiByZXN1bHQuY2hhaW5JZCA9PT0gbmV0d29yay5jaGFpbklkICYmXG5cdCAgICAgICAgICAgICAgICAoKHJlc3VsdC5lbnNBZGRyZXNzID09PSBuZXR3b3JrLmVuc0FkZHJlc3MpIHx8IChyZXN1bHQuZW5zQWRkcmVzcyA9PSBudWxsICYmIG5ldHdvcmsuZW5zQWRkcmVzcyA9PSBudWxsKSkpKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZXIgbWlzbWF0Y2hcIiwgXCJuZXR3b3Jrc1wiLCBuZXR3b3Jrcyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdCA9IG5ldHdvcms7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBtZWRpYW4odmFsdWVzLCBtYXhEZWx0YSkge1xuXHQgICAgdmFsdWVzID0gdmFsdWVzLnNsaWNlKCkuc29ydCgpO1xuXHQgICAgdmFyIG1pZGRsZSA9IE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDIpO1xuXHQgICAgLy8gT2RkIGxlbmd0aDsgdGFrZSB0aGUgbWlkZGxlXG5cdCAgICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWVzW21pZGRsZV07XG5cdCAgICB9XG5cdCAgICAvLyBFdmVuIGxlbmd0aDsgdGFrZSB0aGUgYXZlcmFnZSBvZiB0aGUgdHdvIG1pZGRsZVxuXHQgICAgdmFyIGEgPSB2YWx1ZXNbbWlkZGxlIC0gMV0sIGIgPSB2YWx1ZXNbbWlkZGxlXTtcblx0ICAgIGlmIChtYXhEZWx0YSAhPSBudWxsICYmIE1hdGguYWJzKGEgLSBiKSA+IG1heERlbHRhKSB7XG5cdCAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGEgKyBiKSAvIDI7XG5cdH1cblx0ZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG5cdCAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0ICAgICAgICByZXR1cm4gXCJudWxsXCI7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcblx0ICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChsaWIkMi5CaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpKSB7XG5cdCAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHQgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHNlcmlhbGl6ZShpKTsgfSkpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwib2JqZWN0XCIpIHtcblx0ICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcblx0ICAgICAgICBrZXlzLnNvcnQoKTtcblx0ICAgICAgICByZXR1cm4gXCJ7XCIgKyBrZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG5cdCAgICAgICAgICAgIHZhciB2ID0gdmFsdWVba2V5XTtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwiZnVuY3Rpb25cIikge1xuXHQgICAgICAgICAgICAgICAgdiA9IFwiW2Z1bmN0aW9uXVwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdiA9IHNlcmlhbGl6ZSh2KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOlwiICsgdjtcblx0ICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwifVwiO1xuXHQgICAgfVxuXHQgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZSB0eXBlOiBcIiArIHR5cGVvZiAodmFsdWUpKTtcblx0fVxuXHQvLyBOZXh0IHJlcXVlc3QgSUQgdG8gdXNlIGZvciBlbWl0dGluZyBkZWJ1ZyBpbmZvXG5cdHZhciBuZXh0UmlkID0gMTtcblx0O1xuXHRmdW5jdGlvbiBzdGFsbChkdXJhdGlvbikge1xuXHQgICAgdmFyIGNhbmNlbCA9IG51bGw7XG5cdCAgICB2YXIgdGltZXIgPSBudWxsO1xuXHQgICAgdmFyIHByb21pc2UgPSAobmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0ICAgICAgICBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIGlmICh0aW1lcikge1xuXHQgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0ICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXNvbHZlKCk7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FuY2VsLCBkdXJhdGlvbik7XG5cdCAgICB9KSk7XG5cdCAgICB2YXIgd2FpdCA9IGZ1bmN0aW9uIChmdW5jKSB7XG5cdCAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jKTtcblx0ICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgIH07XG5cdCAgICBmdW5jdGlvbiBnZXRQcm9taXNlKCkge1xuXHQgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIHsgY2FuY2VsOiBjYW5jZWwsIGdldFByb21pc2U6IGdldFByb21pc2UsIHdhaXQ6IHdhaXQgfTtcblx0fVxuXHR2YXIgRm9yd2FyZEVycm9ycyA9IFtcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLFxuXHQgICAgbGliLkxvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLFxuXHQgICAgbGliLkxvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCxcblx0ICAgIGxpYi5Mb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELFxuXHQgICAgbGliLkxvZ2dlci5lcnJvcnMuVU5QUkVESUNUQUJMRV9HQVNfTElNSVRcblx0XTtcblx0dmFyIEZvcndhcmRQcm9wZXJ0aWVzID0gW1xuXHQgICAgXCJhZGRyZXNzXCIsXG5cdCAgICBcImFyZ3NcIixcblx0ICAgIFwiZXJyb3JBcmdzXCIsXG5cdCAgICBcImVycm9yU2lnbmF0dXJlXCIsXG5cdCAgICBcIm1ldGhvZFwiLFxuXHQgICAgXCJ0cmFuc2FjdGlvblwiLFxuXHRdO1xuXHQ7XG5cdGZ1bmN0aW9uIGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KSB7XG5cdCAgICB2YXIgcmVzdWx0ID0ge1xuXHQgICAgICAgIHdlaWdodDogY29uZmlnLndlaWdodFxuXHQgICAgfTtcblx0ICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwicHJvdmlkZXJcIiwgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZy5wcm92aWRlcjsgfSB9KTtcblx0ICAgIGlmIChjb25maWcuc3RhcnQpIHtcblx0ICAgICAgICByZXN1bHQuc3RhcnQgPSBjb25maWcuc3RhcnQ7XG5cdCAgICB9XG5cdCAgICBpZiAobm93KSB7XG5cdCAgICAgICAgcmVzdWx0LmR1cmF0aW9uID0gKG5vdyAtIGNvbmZpZy5zdGFydCk7XG5cdCAgICB9XG5cdCAgICBpZiAoY29uZmlnLmRvbmUpIHtcblx0ICAgICAgICBpZiAoY29uZmlnLmVycm9yKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGNvbmZpZy5lcnJvcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHJlc3VsdC5yZXN1bHQgPSBjb25maWcucmVzdWx0IHx8IG51bGw7XG5cdCAgICAgICAgfVxuXHQgICAgfVxuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fVxuXHRmdW5jdGlvbiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLCBxdW9ydW0pIHtcblx0ICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuXHQgICAgICAgIC8vIENvdW50IHRoZSB2b3RlcyBmb3IgZWFjaCByZXN1bHRcblx0ICAgICAgICB2YXIgdGFsbHkgPSB7fTtcblx0ICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgdmFyIHZhbHVlID0gbm9ybWFsaXplKGMucmVzdWx0KTtcblx0ICAgICAgICAgICAgaWYgKCF0YWxseVt2YWx1ZV0pIHtcblx0ICAgICAgICAgICAgICAgIHRhbGx5W3ZhbHVlXSA9IHsgY291bnQ6IDAsIHJlc3VsdDogYy5yZXN1bHQgfTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0YWxseVt2YWx1ZV0uY291bnQrKztcblx0ICAgICAgICB9KTtcblx0ICAgICAgICAvLyBDaGVjayBmb3IgYSBxdW9ydW0gb24gYW55IGdpdmVuIHJlc3VsdFxuXHQgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGFsbHkpO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICB2YXIgY2hlY2sgPSB0YWxseVtrZXlzW2ldXTtcblx0ICAgICAgICAgICAgaWYgKGNoZWNrLmNvdW50ID49IHF1b3J1bSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrLnJlc3VsdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICAvLyBObyBxdXJvdW1cblx0ICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgfTtcblx0fVxuXHRmdW5jdGlvbiBnZXRQcm9jZXNzRnVuYyhwcm92aWRlciwgbWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgIHZhciBub3JtYWxpemUgPSBzZXJpYWxpemU7XG5cdCAgICBzd2l0Y2ggKG1ldGhvZCkge1xuXHQgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1lZGlhbiB2YWx1ZSwgdW5sZXNzIHRoZXJlIGlzIChtZWRpYW4gKyAxKSBpcyBhbHNvXG5cdCAgICAgICAgICAgIC8vIHByZXNlbnQsIGluIHdoaWNoIGNhc2UgdGhhdCBpcyBwcm9iYWJseSB0cnVlIGFuZCB0aGUgbWVkaWFuXG5cdCAgICAgICAgICAgIC8vIGlzIGdvaW5nIHRvIGJlIHN0YWxlIHNvb24uIEluIHRoZSBldmVudCBvZiBhIG1hbGljaW91cyBub2RlLFxuXHQgICAgICAgICAgICAvLyB0aGUgbGllIHdpbGwgYmUgdHJ1ZSBzb29uIGVub3VnaC5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucmVzdWx0OyB9KTtcblx0ICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbWVkaWFuIGJsb2NrIG51bWJlclxuXHQgICAgICAgICAgICAgICAgdmFyIGJsb2NrTnVtYmVyID0gbWVkaWFuKGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSksIDIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBNYXRoLmNlaWwoYmxvY2tOdW1iZXIpO1xuXHQgICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgYmxvY2sgaGVpZ2h0IGlzIHByZXNlbnQsIGl0cyBwcm9sbHkgc2FmZSB0byB1c2Vcblx0ICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMuaW5kZXhPZihibG9ja051bWJlciArIDEpID49IDApIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcisrO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZXZlciByb2xsIGJhY2sgdGhlIGJsb2NrTnVtYmVyXG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPj0gcHJvdmlkZXIuX2hpZ2hlc3RCbG9ja051bWJlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIG1pZGRsZSAocm91bmQgaW5kZXggdXApIHZhbHVlLCBzaW1pbGFyIHRvIG1lZGlhblxuXHQgICAgICAgICAgICAvLyBidXQgZG8gbm90IGF2ZXJhZ2UgZXZlbiBlbnRyaWVzIGFuZCBjaG9vc2UgdGhlIGhpZ2hlci5cblx0ICAgICAgICAgICAgLy8gTWFsaWNpb3VzIGFjdG9ycyBtdXN0IGNvbXByb21pc2UgNTAlIG9mIHRoZSBub2RlcyB0byBsaWUuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IGNvbmZpZ3MubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnJlc3VsdDsgfSk7XG5cdCAgICAgICAgICAgICAgICB2YWx1ZXMuc29ydCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAyKV07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgY2FzZSBcImdldEV0aGVyUHJpY2VcIjpcblx0ICAgICAgICAgICAgLy8gUmV0dXJucyB0aGUgbWVkaWFuIHByaWNlLiBNYWxpY2lvdXMgYWN0b3JzIG11c3QgY29tcHJvbWlzZSBhdFxuXHQgICAgICAgICAgICAvLyBsZWFzdCA1MCUgb2YgdGhlIG5vZGVzIHRvIGxpZSAoaW4gYSBtZWFuaW5nZnVsIHdheSkuXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhbihjb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5yZXN1bHQ7IH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAvLyBObyBhZGRpdGlvbmFsIG5vcm1hbGl6aW5nIHJlcXVpcmVkOyBzZXJpYWxpemUgaXMgZW5vdWdoXG5cdCAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcblx0ICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuXHQgICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG5cdCAgICAgICAgY2FzZSBcImdldFN0b3JhZ2VBdFwiOlxuXHQgICAgICAgIGNhc2UgXCJjYWxsXCI6XG5cdCAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6XG5cdCAgICAgICAgY2FzZSBcImdldExvZ3NcIjpcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuXHQgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblwiOlxuXHQgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcblx0ICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHggPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdHggPSBsaWIkMy5zaGFsbG93Q29weSh0eCk7XG5cdCAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKHR4KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuXHQgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOlxuXHQgICAgICAgICAgICAvLyBXZSBkcm9wIHRoZSBjb25maXJtYXRpb25zIGZyb20gdHJhbnNhY3Rpb25zIGFzIGl0IGlzIGFwcHJveGltYXRlXG5cdCAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuXHQgICAgICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKGJsb2NrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbGliJDMuc2hhbGxvd0NvcHkoYmxvY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIGJsb2NrLnRyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoZnVuY3Rpb24gKHR4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR4ID0gbGliJDMuc2hhbGxvd0NvcHkodHgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gLTE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eDtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIGRlZmF1bHQ6XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG5cdCAgICB9XG5cdCAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBpZiBhbmQgb25seSBpZiB0aGUgZXhwZWN0ZWQgcXVvcnVtIGlzXG5cdCAgICAvLyBzYXRpc2ZpZWQgYW5kIGFncmVlZCB1cG9uIGZvciB0aGUgZmluYWwgcmVzdWx0LlxuXHQgICAgcmV0dXJuIG5vcm1hbGl6ZWRUYWxseShub3JtYWxpemUsIHByb3ZpZGVyLnF1b3J1bSk7XG5cdH1cblx0Ly8gSWYgd2UgYXJlIGRvaW5nIGEgYmxvY2tUYWcgcXVlcnksIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzXG5cdC8vIGNhdWdodCB1cCB0byB0aGUgRmFsbGJhY2tQcm92aWRlciwgYmVmb3JlIHNlbmRpbmcgYSByZXF1ZXN0IHRvIGl0LlxuXHRmdW5jdGlvbiB3YWl0Rm9yU3luYyhjb25maWcsIGJsb2NrTnVtYmVyKSB7XG5cdCAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyO1xuXHQgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcblx0ICAgICAgICAgICAgcHJvdmlkZXIgPSAoY29uZmlnLnByb3ZpZGVyKTtcblx0ICAgICAgICAgICAgaWYgKChwcm92aWRlci5ibG9ja051bWJlciAhPSBudWxsICYmIHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB8fCBibG9ja051bWJlciA9PT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlcl07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxpYiRsLnBvbGwoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYXJlIHN5bmNlZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocHJvdmlkZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZTsganVzdCBxdWl0XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnLmNhbmNlbGxlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKG51bGwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGFnYWluLCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh1bmRlZmluZWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0sIHsgb25jZVBvbGw6IHByb3ZpZGVyIH0pXTtcblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdGZ1bmN0aW9uIGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICB2YXIgcHJvdmlkZXIsIF9hLCBmaWx0ZXI7XG5cdCAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBjb25maWcucHJvdmlkZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgX2EgPSBtZXRob2Q7XG5cdCAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOiByZXR1cm4gWzMgLypicmVhayovLCAxXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldEV0aGVyUHJpY2VcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOiByZXR1cm4gWzMgLypicmVhayovLCAzXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldENvZGVcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgNl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja1wiOiByZXR1cm4gWzMgLypicmVhayovLCA5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNhbGxcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6IHJldHVybiBbMyAvKmJyZWFrKi8sIDE1XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjogcmV0dXJuIFszIC8qYnJlYWsqLywgMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKCldO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5nZXRFdGhlclByaWNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRFdGhlclByaWNlKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxOV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDM6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmIGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLmFkZHJlc3MsIHBhcmFtcy5ibG9ja1RhZyB8fCBcImxhdGVzdFwiKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDY6XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCEocGFyYW1zLmJsb2NrVGFnICYmIGxpYiQxLmlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpKSByZXR1cm4gWzMgLypicmVhayovLCA4XTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA3OlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gODtcblx0ICAgICAgICAgICAgICAgIGNhc2UgODogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHByb3ZpZGVyLmdldFN0b3JhZ2VBdChwYXJhbXMuYWRkcmVzcywgcGFyYW1zLnBvc2l0aW9uLCBwYXJhbXMuYmxvY2tUYWcgfHwgXCJsYXRlc3RcIildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSA5OlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtcy5ibG9ja1RhZyAmJiBsaWIkMS5pc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTFdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEwOlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTE7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDExOiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnNcIiA6IFwiZ2V0QmxvY2tcIildKHBhcmFtcy5ibG9ja1RhZyB8fCBwYXJhbXMuYmxvY2tIYXNoKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEyOlxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKHBhcmFtcy5ibG9ja1RhZyAmJiBsaWIkMS5pc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMTRdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKV07XG5cdCAgICAgICAgICAgICAgICBjYXNlIDEzOlxuXHQgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0gX2Iuc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMTQ7XG5cdCAgICAgICAgICAgICAgICBjYXNlIDE0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb24pXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTU6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbkhhc2gpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTY6XG5cdCAgICAgICAgICAgICAgICAgICAgZmlsdGVyID0gcGFyYW1zLmZpbHRlcjtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoISgoZmlsdGVyLmZyb21CbG9jayAmJiBsaWIkMS5pc0hleFN0cmluZyhmaWx0ZXIuZnJvbUJsb2NrKSkgfHwgKGZpbHRlci50b0Jsb2NrICYmIGxpYiQxLmlzSGV4U3RyaW5nKGZpbHRlci50b0Jsb2NrKSkpKSByZXR1cm4gWzMgLypicmVhayovLCAxOF07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpXTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTc6XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSBfYi5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxODtcblx0ICAgICAgICAgICAgICAgIGNhc2UgMTg6IHJldHVybiBbMiAvKnJldHVybiovLCBwcm92aWRlci5nZXRMb2dzKGZpbHRlcildO1xuXHQgICAgICAgICAgICAgICAgY2FzZSAxOTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGxvZ2dlci50aHJvd0Vycm9yKFwidW5rbm93biBtZXRob2QgZXJyb3JcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXNcblx0ICAgICAgICAgICAgICAgICAgICB9KV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9KTtcblx0ICAgIH0pO1xuXHR9XG5cdHZhciBGYWxsYmFja1Byb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEZhbGxiYWNrUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBGYWxsYmFja1Byb3ZpZGVyKHByb3ZpZGVycywgcXVvcnVtKSB7XG5cdCAgICAgICAgdmFyIF9uZXdUYXJnZXQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuXHQgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cdCAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KF9uZXdUYXJnZXQsIEZhbGxiYWNrUHJvdmlkZXIpO1xuXHQgICAgICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByb3ZpZGVyc1wiLCBcInByb3ZpZGVyc1wiLCBwcm92aWRlcnMpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgcHJvdmlkZXJDb25maWdzID0gcHJvdmlkZXJzLm1hcChmdW5jdGlvbiAoY29uZmlnT3JQcm92aWRlciwgaW5kZXgpIHtcblx0ICAgICAgICAgICAgaWYgKGxpYiRiLlByb3ZpZGVyLmlzUHJvdmlkZXIoY29uZmlnT3JQcm92aWRlcikpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgcHJvdmlkZXI6IGNvbmZpZ09yUHJvdmlkZXIsIHdlaWdodDogMSwgc3RhbGxUaW1lb3V0OiA3NTAsIHByaW9yaXR5OiAxIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBjb25maWcgPSBsaWIkMy5zaGFsbG93Q29weShjb25maWdPclByb3ZpZGVyKTtcblx0ICAgICAgICAgICAgaWYgKGNvbmZpZy5wcmlvcml0eSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgICAgICBjb25maWcucHJpb3JpdHkgPSAxO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIGlmIChjb25maWcuc3RhbGxUaW1lb3V0ID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbFRpbWVvdXQgPSA3NTA7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKGNvbmZpZy53ZWlnaHQgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgY29uZmlnLndlaWdodCA9IDE7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHdlaWdodCA9IGNvbmZpZy53ZWlnaHQ7XG5cdCAgICAgICAgICAgIGlmICh3ZWlnaHQgJSAxIHx8IHdlaWdodCA+IDUxMiB8fCB3ZWlnaHQgPCAxKSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB3ZWlnaHQ7IG11c3QgYmUgaW50ZWdlciBpbiBbMSwgNTEyXVwiLCBcInByb3ZpZGVyc1tcIiArIGluZGV4ICsgXCJdLndlaWdodFwiLCB3ZWlnaHQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKGNvbmZpZyk7XG5cdCAgICAgICAgfSk7XG5cdCAgICAgICAgdmFyIHRvdGFsID0gcHJvdmlkZXJDb25maWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHsgcmV0dXJuIChhY2N1bSArIGMud2VpZ2h0KTsgfSwgMCk7XG5cdCAgICAgICAgaWYgKHF1b3J1bSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHF1b3J1bSA9IHRvdGFsIC8gMjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAocXVvcnVtID4gdG90YWwpIHtcblx0ICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInF1b3J1bSB3aWxsIGFsd2F5cyBmYWlsOyBsYXJnZXIgdGhhbiB0b3RhbCB3ZWlnaHRcIiwgXCJxdW9ydW1cIiwgcXVvcnVtKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gQXJlIGFsbCBwcm92aWRlcnMnIG5ldHdvcmtzIGFyZSBrbm93blxuXHQgICAgICAgIHZhciBuZXR3b3JrT3JSZWFkeSA9IGNoZWNrTmV0d29ya3MocHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMucHJvdmlkZXIpLm5ldHdvcms7IH0pKTtcblx0ICAgICAgICAvLyBOb3QgYWxsIG5ldHdvcmtzIGFyZSBrbm93bjsgd2UgbXVzdCBzdGFsbFxuXHQgICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIG5ldHdvcmtPclJlYWR5ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0sIDApO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuZXR3b3JrT3JSZWFkeSkgfHwgdGhpcztcblx0ICAgICAgICAvLyBQcmVzZXJ2ZSBhIGNvcHksIHNvIHdlIGRvIG5vdCBnZXQgbXV0YXRlZFxuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInByb3ZpZGVyQ29uZmlnc1wiLCBPYmplY3QuZnJlZXplKHByb3ZpZGVyQ29uZmlncykpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInF1b3J1bVwiLCBxdW9ydW0pO1xuXHQgICAgICAgIF90aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSAtMTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBGYWxsYmFja1Byb3ZpZGVyLnByb3RvdHlwZS5kZXRlY3ROZXR3b3JrID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG5ldHdvcmtzO1xuXHQgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMucHJvdmlkZXIuZ2V0TmV0d29yaygpOyB9KSldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmV0d29ya3MgPSBfYS5zZW50KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjaGVja05ldHdvcmtzKG5ldHdvcmtzKV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0pO1xuXHQgICAgfTtcblx0ICAgIEZhbGxiYWNrUHJvdmlkZXIucHJvdG90eXBlLnBlcmZvcm0gPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciByZXN1bHRzLCBpXzEsIHJlc3VsdCwgcHJvY2Vzc0Z1bmMsIGNvbmZpZ3MsIGN1cnJlbnRCbG9ja051bWJlciwgaSwgZmlyc3QsIF9sb29wXzEsIHRoaXNfMSwgc3RhdGVfMTtcblx0ICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuXHQgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobWV0aG9kID09PSBcInNlbmRUcmFuc2FjdGlvblwiKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UuYWxsKHRoaXMucHJvdmlkZXJDb25maWdzLm1hcChmdW5jdGlvbiAoYykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmhhc2g7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbnkgc3VjY2VzcyBpcyBnb29kIGVub3VnaCAob3RoZXIgZXJyb3JzIGFyZSBsaWtlbHkgXCJhbHJlYWR5IHNlZW5cIiBlcnJvcnNcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpXzEgPSAwOyBpXzEgPCByZXN1bHRzLmxlbmd0aDsgaV8xKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHNbaV8xXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHJlc3VsdCkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzdWx0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGV5IHdlcmUgYWxsIGFuIGVycm9yOyBwaWNrIHRoZSBmaXJzdCBlcnJvclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyByZXN1bHRzWzBdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyID09PSAtMSAmJiBtZXRob2QgIT09IFwiZ2V0QmxvY2tOdW1iZXJcIikpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldEJsb2NrTnVtYmVyKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDQ7XG5cdCAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRnVuYyA9IGdldFByb2Nlc3NGdW5jKHRoaXMsIG1ldGhvZCwgcGFyYW1zKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncyA9IGJyb3dzZXIkNi5zaHVmZmxlZCh0aGlzLnByb3ZpZGVyQ29uZmlncy5tYXAobGliJDMuc2hhbGxvd0NvcHkpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiAoYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpOyB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrTnVtYmVyID0gdGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpID0gMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQwLCBpbmZsaWdodFdlaWdodCwgX2xvb3BfMiwgd2FpdGluZywgcmVzdWx0cywgcmVzdWx0LCBlcnJvcnM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0MCA9IG5vdygpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRXZWlnaHQgPSBjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gKGMucnVubmVyICYmICgodDAgLSBjLnN0YXJ0KSA8IGMuc3RhbGxUaW1lb3V0KSk7IH0pXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHsgcmV0dXJuIChhY2N1bSArIGMud2VpZ2h0KTsgfSwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb25maWcgPSBjb25maWdzW2krK107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJpZCA9IG5leHRSaWQrKztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhcnQgPSBub3coKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhbGxlciA9IHN0YWxsKGNvbmZpZy5zdGFsbFRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbGVyLndhaXQoZnVuY3Rpb24gKCkgeyBjb25maWcuc3RhbGxlciA9IG51bGw7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ydW5uZXIgPSBnZXRSdW5uZXIoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIsIG1ldGhvZCwgcGFyYW1zKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcucmVzdWx0ID0gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBub3coKSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBsaWIkMy5kZWVwQ29weShwYXJhbXMpIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWcuZG9uZSA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5lcnJvciA9IGVycm9yO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmlkOiByaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBub3coKSksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBsaWIkMy5kZWVwQ29weShwYXJhbXMpIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IF90aGlzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzXzEubGlzdGVuZXJDb3VudChcImRlYnVnXCIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMS5lbWl0KFwiZGVidWdcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2VuZDogZXhwb3NlRGVidWdDb25maWcoY29uZmlnLCBudWxsKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHsgbWV0aG9kOiBtZXRob2QsIHBhcmFtczogbGliJDMuZGVlcENvcHkocGFyYW1zKSB9LFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNfMVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRXZWlnaHQgKz0gY29uZmlnLndlaWdodDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdGFydCBydW5uaW5nIGVub3VnaCB0byBtZWV0IHF1b3J1bVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGluZmxpZ2h0V2VpZ2h0IDwgdGhpc18xLnF1b3J1bSAmJiBpIDwgY29uZmlncy5sZW5ndGgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9vcF8yKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nID0gW107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYy5kb25lIHx8ICFjLnJ1bm5lcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRpbmcucHVzaChjLnJ1bm5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goYy5zdGFsbGVyLmdldFByb21pc2UoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhaXRpbmcubGVuZ3RoKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFByb21pc2UucmFjZSh3YWl0aW5nKV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IGNvbmZpZ3MuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAoYy5kb25lICYmIGMuZXJyb3IgPT0gbnVsbCk7IH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEocmVzdWx0cy5sZW5ndGggPj0gdGhpc18xLnF1b3J1bSkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHsgdmFsdWU6IHJlc3VsdCB9XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIWZpcnN0KSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHN0YWxsKDEwMCkuZ2V0UHJvbWlzZSgpXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBjb25maWdzLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWMuZG9uZSB8fCBjLmVycm9yID09IG51bGwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29kZSA9IChjLmVycm9yKS5jb2RlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChGb3J3YXJkRXJyb3JzLmluZGV4T2YoY29kZSkgPj0gMCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW2NvZGVdKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVtjb2RlXSA9IHsgZXJyb3I6IGMuZXJyb3IsIHdlaWdodDogMCB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtW2NvZGVdLndlaWdodCArPSBjLndlaWdodDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgKHt9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhlcnJvcnMpLmZvckVhY2goZnVuY3Rpb24gKGVycm9yQ29kZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0YWxseSA9IGVycm9yc1tlcnJvckNvZGVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YWxseS53ZWlnaHQgPCBfdGhpcy5xdW9ydW0pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGUgPSAodGFsbHkuZXJyb3IpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEZvcndhcmRQcm9wZXJ0aWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVbbmFtZV0gPT0gbnVsbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzW25hbWVdID0gZVtuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihlLnJlYXNvbiB8fCBlLm1lc3NhZ2UsIGVycm9yQ29kZSwgcHJvcHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGwgY29uZmlncyBoYXZlIHJ1biB0byBjb21wbGV0aW9uOyB3ZSB3aWxsIG5ldmVyIGdldCBtb3JlIGRhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maWdzLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gIWMuZG9uZTsgfSkubGVuZ3RoID09PSAwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIFwiYnJlYWtcIl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qL107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNfMSA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNTtcblx0ICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJ1ZSkgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfbG9vcF8xKCldO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVfMSA9IF9hLnNlbnQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZV8xID09PSBcIm9iamVjdFwiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHN0YXRlXzEudmFsdWVdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuXHQgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2h1dCBkb3duIGFueSBzdGFsbGVyczsgc2hvdWxkbid0IGJlIGFueVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLnN0YWxsZXIuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbG9nZ2VyLnRocm93RXJyb3IoXCJmYWlsZWQgdG8gbWVldCBxdW9ydW1cIiwgbGliLkxvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9yZXN1bHRzOiBjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZXJyb3JzOiBjb25maWdzLm1hcCgoYykgPT4gYy5lcnJvciksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0czogY29uZmlncy5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGV4cG9zZURlYnVnQ29uZmlnKGMpOyB9KSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gRmFsbGJhY2tQcm92aWRlcjtcblx0fShiYXNlUHJvdmlkZXIuQmFzZVByb3ZpZGVyKSk7XG5cdGV4cG9ydHMuRmFsbGJhY2tQcm92aWRlciA9IEZhbGxiYWNrUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGZhbGxiYWNrUHJvdmlkZXIkMSA9IHVud3JhcEV4cG9ydHMoZmFsbGJhY2tQcm92aWRlcik7XG5cdHZhciBmYWxsYmFja1Byb3ZpZGVyXzEgPSBmYWxsYmFja1Byb3ZpZGVyLkZhbGxiYWNrUHJvdmlkZXI7XG5cblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBJcGNQcm92aWRlciA9IG51bGw7XG5cblxuXHR2YXIgYnJvd3NlcklwY1Byb3ZpZGVyID0ge1xuXHRcdElwY1Byb3ZpZGVyOiBJcGNQcm92aWRlclxuXHR9O1xuXG5cdHZhciBpbmZ1cmFQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblxuXHR2YXIgbG9nZ2VyID0gbmV3IGxpYi5Mb2dnZXIoX3ZlcnNpb24kSS52ZXJzaW9uKTtcblxuXHR2YXIgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcblx0dmFyIEluZnVyYVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKEluZnVyYVByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gSW5mdXJhUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIHByb3ZpZGVyID0gbmV3IEluZnVyYVByb3ZpZGVyKG5ldHdvcmssIGFwaUtleSk7XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSBwcm92aWRlci5jb25uZWN0aW9uO1xuXHQgICAgICAgIGlmIChjb25uZWN0aW9uLnBhc3N3b3JkKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiSU5GVVJBIFdlYlNvY2tldCBwcm9qZWN0IHNlY3JldHMgdW5zdXBwb3J0ZWRcIiwgbGliLkxvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG5cdCAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiSW5mdXJhUHJvdmlkZXIuZ2V0V2ViU29ja2V0UHJvdmlkZXIoKVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG5cdCAgICAgICAgcmV0dXJuIG5ldyB3ZWJzb2NrZXRQcm92aWRlci5XZWJTb2NrZXRQcm92aWRlcih1cmwsIG5ldHdvcmspO1xuXHQgICAgfTtcblx0ICAgIEluZnVyYVByb3ZpZGVyLmdldEFwaUtleSA9IGZ1bmN0aW9uIChhcGlLZXkpIHtcblx0ICAgICAgICB2YXIgYXBpS2V5T2JqID0ge1xuXHQgICAgICAgICAgICBhcGlLZXk6IGRlZmF1bHRQcm9qZWN0SWQsXG5cdCAgICAgICAgICAgIHByb2plY3RJZDogZGVmYXVsdFByb2plY3RJZCxcblx0ICAgICAgICAgICAgcHJvamVjdFNlY3JldDogbnVsbFxuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgPT09IFwic3RyaW5nXCIpLCBcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIiwgXCJwcm9qZWN0SWRcIiwgYXBpS2V5LnByb2plY3RJZCk7XG5cdCAgICAgICAgICAgIGxvZ2dlci5hc3NlcnRBcmd1bWVudCgodHlwZW9mIChhcGlLZXkucHJvamVjdFNlY3JldCkgPT09IFwic3RyaW5nXCIpLCBcImludmFsaWQgcHJvamVjdFNlY3JldFwiLCBcInByb2plY3RTZWNyZXRcIiwgXCJbUkVEQUNURURdXCIpO1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcblx0ICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RTZWNyZXQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSBpZiAoYXBpS2V5LnByb2plY3RJZCkge1xuXHQgICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgYXBpS2V5T2JqLmFwaUtleSA9IGFwaUtleU9iai5wcm9qZWN0SWQ7XG5cdCAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcblx0ICAgIH07XG5cdCAgICBJbmZ1cmFQcm92aWRlci5nZXRVcmwgPSBmdW5jdGlvbiAobmV0d29yaywgYXBpS2V5KSB7XG5cdCAgICAgICAgdmFyIGhvc3QgPSBudWxsO1xuXHQgICAgICAgIHN3aXRjaCAobmV0d29yayA/IG5ldHdvcmsubmFtZSA6IFwidW5rbm93blwiKSB7XG5cdCAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcIm1haW5uZXQuaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcInJvcHN0ZW4uaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcInJpbmtlYnkuaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJrb3Zhbi5pbmZ1cmEuaW9cIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgZGVmYXVsdDpcblx0ICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5ULCB7XG5cdCAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIGNvbm5lY3Rpb24gPSB7XG5cdCAgICAgICAgICAgIHVybDogKFwiaHR0cHM6L1wiICsgXCIvXCIgKyBob3N0ICsgXCIvdjMvXCIgKyBhcGlLZXkucHJvamVjdElkKSxcblx0ICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogZnVuY3Rpb24gKGF0dGVtcHQsIHVybCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZXIuc2hvd1Rocm90dGxlTWVzc2FnZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0U2VjcmV0ICE9IG51bGwpIHtcblx0ICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcblx0ICAgICAgICAgICAgY29ubmVjdGlvbi5wYXNzd29yZCA9IGFwaUtleS5wcm9qZWN0U2VjcmV0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gSW5mdXJhUHJvdmlkZXI7XG5cdH0odXJsSnNvblJwY1Byb3ZpZGVyLlVybEpzb25ScGNQcm92aWRlcikpO1xuXHRleHBvcnRzLkluZnVyYVByb3ZpZGVyID0gSW5mdXJhUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZnVyYVByb3ZpZGVyJDEgPSB1bndyYXBFeHBvcnRzKGluZnVyYVByb3ZpZGVyKTtcblx0dmFyIGluZnVyYVByb3ZpZGVyXzEgPSBpbmZ1cmFQcm92aWRlci5JbmZ1cmFQcm92aWRlcjtcblxuXHR2YXIgbm9kZXNtaXRoUHJvdmlkZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19leHRlbmRzID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG5cdCAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcblx0ICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG5cdCAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG5cdCAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cblx0ICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG5cdCAgICB9O1xuXHR9KSgpO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRJLnZlcnNpb24pO1xuXHQvLyBTcGVjaWFsIEFQSSBrZXkgcHJvdmlkZWQgYnkgTm9kZXNtaXRoIGZvciBldGhlcnMuanNcblx0dmFyIGRlZmF1bHRBcGlLZXkgPSBcIkVUSEVSU19KU19TSEFSRURcIjtcblx0dmFyIE5vZGVzbWl0aFByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuXHQgICAgX19leHRlbmRzKE5vZGVzbWl0aFByb3ZpZGVyLCBfc3VwZXIpO1xuXHQgICAgZnVuY3Rpb24gTm9kZXNtaXRoUHJvdmlkZXIoKSB7XG5cdCAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuXHQgICAgfVxuXHQgICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0QXBpS2V5ID0gZnVuY3Rpb24gKGFwaUtleSkge1xuXHQgICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gYXBpS2V5IHx8IGRlZmF1bHRBcGlLZXk7XG5cdCAgICB9O1xuXHQgICAgTm9kZXNtaXRoUHJvdmlkZXIuZ2V0VXJsID0gZnVuY3Rpb24gKG5ldHdvcmssIGFwaUtleSkge1xuXHQgICAgICAgIGxvZ2dlci53YXJuKFwiTm9kZVNtaXRoIHdpbGwgYmUgZGlzY29udGludWVkIG9uIDIwMTktMTItMjA7IHBsZWFzZSBtaWdyYXRlIHRvIGFub3RoZXIgcGxhdGZvcm0uXCIpO1xuXHQgICAgICAgIHZhciBob3N0ID0gbnVsbDtcblx0ICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuXHQgICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG5cdCAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvbWFpbm5ldC9qc29ucnBjXCI7XG5cdCAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9yb3BzdGVuL2pzb25ycGNcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL3JpbmtlYnkvanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcblx0ICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9nb2VybGkvanNvbnJwY1wiO1xuXHQgICAgICAgICAgICAgICAgYnJlYWs7XG5cdCAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuXHQgICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL2tvdmFuL2pzb25ycGNcIjtcblx0ICAgICAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIGFyZ3VtZW50c1swXSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHJldHVybiAoaG9zdCArIFwiP2FwaUtleT1cIiArIGFwaUtleSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIE5vZGVzbWl0aFByb3ZpZGVyO1xuXHR9KHVybEpzb25ScGNQcm92aWRlci5VcmxKc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IE5vZGVzbWl0aFByb3ZpZGVyO1xuXG5cdH0pO1xuXG5cdHZhciBub2Rlc21pdGhQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyhub2Rlc21pdGhQcm92aWRlcik7XG5cdHZhciBub2Rlc21pdGhQcm92aWRlcl8xID0gbm9kZXNtaXRoUHJvdmlkZXIuTm9kZXNtaXRoUHJvdmlkZXI7XG5cblx0dmFyIHdlYjNQcm92aWRlciA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2V4dGVuZHMgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuXHQgICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuXHQgICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcblx0ICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuXHQgICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcblx0ICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcblx0ICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuXHQgICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuXHQgICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcblx0ICAgIH07XG5cdH0pKCk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cblx0dmFyIF9uZXh0SWQgPSAxO1xuXHRmdW5jdGlvbiBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBzZW5kRnVuYykge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIC8vIE1ldGFtYXNrIGNvbXBsYWlucyBhYm91dCBldGhfc2lnbiAoYW5kIG9uIHNvbWUgdmVyc2lvbnMgaGFuZ3MpXG5cdCAgICAgICAgaWYgKG1ldGhvZCA9PSBcImV0aF9zaWduXCIgJiYgcHJvdmlkZXIuaXNNZXRhTWFzaykge1xuXHQgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vd2lraS9NYW5hZ2VtZW50LUFQSXMjcGVyc29uYWxfc2lnblxuXHQgICAgICAgICAgICBtZXRob2QgPSBcInBlcnNvbmFsX3NpZ25cIjtcblx0ICAgICAgICAgICAgcGFyYW1zID0gW3BhcmFtc1sxXSwgcGFyYW1zWzBdXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHJlcXVlc3QgPSB7XG5cdCAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcblx0ICAgICAgICAgICAgaWQ6IChfbmV4dElkKyspLFxuXHQgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG5cdCAgICAgICAgfTtcblx0ICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICBzZW5kRnVuYyhyZXF1ZXN0LCBmdW5jdGlvbiAoZXJyb3IsIHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9yXzEgPSBuZXcgRXJyb3IocmVzdWx0LmVycm9yLm1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yXzEuY29kZSA9IHJlc3VsdC5lcnJvci5jb2RlO1xuXHQgICAgICAgICAgICAgICAgICAgIGVycm9yXzEuZGF0YSA9IHJlc3VsdC5lcnJvci5kYXRhO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3JfMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdC5yZXN1bHQpO1xuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9KTtcblx0ICAgIH07XG5cdH1cblx0ZnVuY3Rpb24gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcikge1xuXHQgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuXHQgICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBwYXJhbXMgPSBbXTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgLy8gTWV0YW1hc2sgY29tcGxhaW5zIGFib3V0IGV0aF9zaWduIChhbmQgb24gc29tZSB2ZXJzaW9ucyBoYW5ncylcblx0ICAgICAgICBpZiAobWV0aG9kID09IFwiZXRoX3NpZ25cIiAmJiBwcm92aWRlci5pc01ldGFNYXNrKSB7XG5cdCAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS93aWtpL01hbmFnZW1lbnQtQVBJcyNwZXJzb25hbF9zaWduXG5cdCAgICAgICAgICAgIG1ldGhvZCA9IFwicGVyc29uYWxfc2lnblwiO1xuXHQgICAgICAgICAgICBwYXJhbXMgPSBbcGFyYW1zWzFdLCBwYXJhbXNbMF1dO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gcHJvdmlkZXIucmVxdWVzdCh7IG1ldGhvZDogbWV0aG9kLCBwYXJhbXM6IHBhcmFtcyB9KTtcblx0ICAgIH07XG5cdH1cblx0dmFyIFdlYjNQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcblx0ICAgIF9fZXh0ZW5kcyhXZWIzUHJvdmlkZXIsIF9zdXBlcik7XG5cdCAgICBmdW5jdGlvbiBXZWIzUHJvdmlkZXIocHJvdmlkZXIsIG5ldHdvcmspIHtcblx0ICAgICAgICB2YXIgX25ld1RhcmdldCA9IHRoaXMuY29uc3RydWN0b3I7XG5cdCAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblx0ICAgICAgICBsb2dnZXIuY2hlY2tOZXcoX25ld1RhcmdldCwgV2ViM1Byb3ZpZGVyKTtcblx0ICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuXHQgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHBhdGggPSBudWxsO1xuXHQgICAgICAgIHZhciBqc29uUnBjRmV0Y2hGdW5jID0gbnVsbDtcblx0ICAgICAgICB2YXIgc3VicHJvdmlkZXIgPSBudWxsO1xuXHQgICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdCAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG5cdCAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBwcm92aWRlcjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgIHBhdGggPSBwcm92aWRlci5ob3N0IHx8IHByb3ZpZGVyLnBhdGggfHwgXCJcIjtcblx0ICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcblx0ICAgICAgICAgICAgICAgIHBhdGggPSBcIm1ldGFtYXNrXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcblx0ICAgICAgICAgICAgaWYgKHByb3ZpZGVyLnJlcXVlc3QpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChwYXRoID09PSBcIlwiKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRFaXAxMTkzRmV0Y2hlcihwcm92aWRlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZEFzeW5jKSB7XG5cdCAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZEFzeW5jLmJpbmQocHJvdmlkZXIpKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBlbHNlIGlmIChwcm92aWRlci5zZW5kKSB7XG5cdCAgICAgICAgICAgICAgICBqc29uUnBjRmV0Y2hGdW5jID0gYnVpbGRXZWIzTGVnYWN5RmV0Y2hlcihwcm92aWRlciwgcHJvdmlkZXIuc2VuZC5iaW5kKHByb3ZpZGVyKSk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFwYXRoKSB7XG5cdCAgICAgICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcGF0aCwgbmV0d29yaykgfHwgdGhpcztcblx0ICAgICAgICBsaWIkMy5kZWZpbmVSZWFkT25seShfdGhpcywgXCJqc29uUnBjRmV0Y2hGdW5jXCIsIGpzb25ScGNGZXRjaEZ1bmMpO1xuXHQgICAgICAgIGxpYiQzLmRlZmluZVJlYWRPbmx5KF90aGlzLCBcInByb3ZpZGVyXCIsIHN1YnByb3ZpZGVyKTtcblx0ICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICB9XG5cdCAgICBXZWIzUHJvdmlkZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXJhbXMpIHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5qc29uUnBjRmV0Y2hGdW5jKG1ldGhvZCwgcGFyYW1zKTtcblx0ICAgIH07XG5cdCAgICByZXR1cm4gV2ViM1Byb3ZpZGVyO1xuXHR9KGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIpKTtcblx0ZXhwb3J0cy5XZWIzUHJvdmlkZXIgPSBXZWIzUHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIHdlYjNQcm92aWRlciQxID0gdW53cmFwRXhwb3J0cyh3ZWIzUHJvdmlkZXIpO1xuXHR2YXIgd2ViM1Byb3ZpZGVyXzEgPSB3ZWIzUHJvdmlkZXIuV2ViM1Byb3ZpZGVyO1xuXG5cdHZhciBsaWIkbSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLlByb3ZpZGVyID0gbGliJGIuUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5nZXROZXR3b3JrID0gbGliJGsuZ2V0TmV0d29yaztcblxuXHRleHBvcnRzLkJhc2VQcm92aWRlciA9IGJhc2VQcm92aWRlci5CYXNlUHJvdmlkZXI7XG5cdGV4cG9ydHMuUmVzb2x2ZXIgPSBiYXNlUHJvdmlkZXIuUmVzb2x2ZXI7XG5cblx0ZXhwb3J0cy5BbGNoZW15UHJvdmlkZXIgPSBhbGNoZW15UHJvdmlkZXIuQWxjaGVteVByb3ZpZGVyO1xuXG5cdGV4cG9ydHMuQ2xvdWRmbGFyZVByb3ZpZGVyID0gY2xvdWRmbGFyZVByb3ZpZGVyLkNsb3VkZmxhcmVQcm92aWRlcjtcblxuXHRleHBvcnRzLkV0aGVyc2NhblByb3ZpZGVyID0gZXRoZXJzY2FuUHJvdmlkZXIuRXRoZXJzY2FuUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5GYWxsYmFja1Byb3ZpZGVyID0gZmFsbGJhY2tQcm92aWRlci5GYWxsYmFja1Byb3ZpZGVyO1xuXG5cdGV4cG9ydHMuSXBjUHJvdmlkZXIgPSBicm93c2VySXBjUHJvdmlkZXIuSXBjUHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5JbmZ1cmFQcm92aWRlciA9IGluZnVyYVByb3ZpZGVyLkluZnVyYVByb3ZpZGVyO1xuXG5cdGV4cG9ydHMuSnNvblJwY1Byb3ZpZGVyID0ganNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcjtcblx0ZXhwb3J0cy5Kc29uUnBjU2lnbmVyID0ganNvblJwY1Byb3ZpZGVyLkpzb25ScGNTaWduZXI7XG5cblx0ZXhwb3J0cy5Ob2Rlc21pdGhQcm92aWRlciA9IG5vZGVzbWl0aFByb3ZpZGVyLk5vZGVzbWl0aFByb3ZpZGVyO1xuXG5cdGV4cG9ydHMuU3RhdGljSnNvblJwY1Byb3ZpZGVyID0gdXJsSnNvblJwY1Byb3ZpZGVyLlN0YXRpY0pzb25ScGNQcm92aWRlcjtcblx0ZXhwb3J0cy5VcmxKc29uUnBjUHJvdmlkZXIgPSB1cmxKc29uUnBjUHJvdmlkZXIuVXJsSnNvblJwY1Byb3ZpZGVyO1xuXG5cdGV4cG9ydHMuV2ViM1Byb3ZpZGVyID0gd2ViM1Byb3ZpZGVyLldlYjNQcm92aWRlcjtcblxuXHRleHBvcnRzLldlYlNvY2tldFByb3ZpZGVyID0gd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5Gb3JtYXR0ZXIgPSBmb3JtYXR0ZXIuRm9ybWF0dGVyO1xuXG5cblx0dmFyIGxvZ2dlciA9IG5ldyBsaWIuTG9nZ2VyKF92ZXJzaW9uJEkudmVyc2lvbik7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBIZWxwZXIgRnVuY3Rpb25zXG5cdGZ1bmN0aW9uIGdldERlZmF1bHRQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zKSB7XG5cdCAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG5cdCAgICAgICAgbmV0d29yayA9IFwiaG9tZXN0ZWFkXCI7XG5cdCAgICB9XG5cdCAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuXHQgICAgaWYgKHR5cGVvZiAobmV0d29yaykgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICAvLyBAVE9ETzogQWRkIHN1cHBvcnQgZm9yIElwY1Byb3ZpZGVyOyBtYXliZSBpZiBpdCBlbmRzIGluIFwiLmlwY1wiP1xuXHQgICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcblx0ICAgICAgICB2YXIgbWF0Y2ggPSBuZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO1xuXHQgICAgICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG5cdCAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcganNvblJwY1Byb3ZpZGVyLkpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcblx0ICAgICAgICAgICAgICAgIGNhc2UgXCJ3c1wiOlxuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgd2Vic29ja2V0UHJvdmlkZXIuV2ViU29ja2V0UHJvdmlkZXIobmV0d29yayk7XG5cdCAgICAgICAgICAgICAgICBkZWZhdWx0OlxuXHQgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBVUkwgc2NoZW1lXCIsIFwibmV0d29ya1wiLCBuZXR3b3JrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHZhciBuID0gbGliJGsuZ2V0TmV0d29yayhuZXR3b3JrKTtcblx0ICAgIGlmICghbiB8fCAhbi5fZGVmYXVsdFByb3ZpZGVyKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLCBsaWIuTG9nZ2VyLmVycm9ycy5ORVRXT1JLX0VSUk9SLCB7XG5cdCAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZWZhdWx0UHJvdmlkZXJcIixcblx0ICAgICAgICAgICAgbmV0d29yazogbmV0d29ya1xuXHQgICAgICAgIH0pO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIG4uX2RlZmF1bHRQcm92aWRlcih7XG5cdCAgICAgICAgRmFsbGJhY2tQcm92aWRlcjogZmFsbGJhY2tQcm92aWRlci5GYWxsYmFja1Byb3ZpZGVyLFxuXHQgICAgICAgIEFsY2hlbXlQcm92aWRlcjogYWxjaGVteVByb3ZpZGVyLkFsY2hlbXlQcm92aWRlcixcblx0ICAgICAgICBDbG91ZGZsYXJlUHJvdmlkZXI6IGNsb3VkZmxhcmVQcm92aWRlci5DbG91ZGZsYXJlUHJvdmlkZXIsXG5cdCAgICAgICAgRXRoZXJzY2FuUHJvdmlkZXI6IGV0aGVyc2NhblByb3ZpZGVyLkV0aGVyc2NhblByb3ZpZGVyLFxuXHQgICAgICAgIEluZnVyYVByb3ZpZGVyOiBpbmZ1cmFQcm92aWRlci5JbmZ1cmFQcm92aWRlcixcblx0ICAgICAgICBKc29uUnBjUHJvdmlkZXI6IGpzb25ScGNQcm92aWRlci5Kc29uUnBjUHJvdmlkZXIsXG5cdCAgICAgICAgTm9kZXNtaXRoUHJvdmlkZXI6IG5vZGVzbWl0aFByb3ZpZGVyLk5vZGVzbWl0aFByb3ZpZGVyLFxuXHQgICAgICAgIFdlYjNQcm92aWRlcjogd2ViM1Byb3ZpZGVyLldlYjNQcm92aWRlcixcblx0ICAgICAgICBJcGNQcm92aWRlcjogYnJvd3NlcklwY1Byb3ZpZGVyLklwY1Byb3ZpZGVyLFxuXHQgICAgfSwgb3B0aW9ucyk7XG5cdH1cblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBnZXREZWZhdWx0UHJvdmlkZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JG0gPSB1bndyYXBFeHBvcnRzKGxpYiRtKTtcblx0dmFyIGxpYl8xJG0gPSBsaWIkbS5Qcm92aWRlcjtcblx0dmFyIGxpYl8yJGsgPSBsaWIkbS5nZXROZXR3b3JrO1xuXHR2YXIgbGliXzMkZyA9IGxpYiRtLkJhc2VQcm92aWRlcjtcblx0dmFyIGxpYl80JGMgPSBsaWIkbS5SZXNvbHZlcjtcblx0dmFyIGxpYl81JGIgPSBsaWIkbS5BbGNoZW15UHJvdmlkZXI7XG5cdHZhciBsaWJfNiQ3ID0gbGliJG0uQ2xvdWRmbGFyZVByb3ZpZGVyO1xuXHR2YXIgbGliXzckNiA9IGxpYiRtLkV0aGVyc2NhblByb3ZpZGVyO1xuXHR2YXIgbGliXzgkNSA9IGxpYiRtLkZhbGxiYWNrUHJvdmlkZXI7XG5cdHZhciBsaWJfOSQ1ID0gbGliJG0uSXBjUHJvdmlkZXI7XG5cdHZhciBsaWJfMTAkMyA9IGxpYiRtLkluZnVyYVByb3ZpZGVyO1xuXHR2YXIgbGliXzExJDIgPSBsaWIkbS5Kc29uUnBjUHJvdmlkZXI7XG5cdHZhciBsaWJfMTIkMiA9IGxpYiRtLkpzb25ScGNTaWduZXI7XG5cdHZhciBsaWJfMTMkMiA9IGxpYiRtLk5vZGVzbWl0aFByb3ZpZGVyO1xuXHR2YXIgbGliXzE0JDEgPSBsaWIkbS5TdGF0aWNKc29uUnBjUHJvdmlkZXI7XG5cdHZhciBsaWJfMTUkMSA9IGxpYiRtLlVybEpzb25ScGNQcm92aWRlcjtcblx0dmFyIGxpYl8xNiQxID0gbGliJG0uV2ViM1Byb3ZpZGVyO1xuXHR2YXIgbGliXzE3ID0gbGliJG0uV2ViU29ja2V0UHJvdmlkZXI7XG5cdHZhciBsaWJfMTggPSBsaWIkbS5Gb3JtYXR0ZXI7XG5cdHZhciBsaWJfMTkgPSBsaWIkbS5nZXREZWZhdWx0UHJvdmlkZXI7XG5cblx0dmFyIGxpYiRuID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5cblxuXG5cblx0dmFyIHJlZ2V4Qnl0ZXMgPSBuZXcgUmVnRXhwKFwiXmJ5dGVzKFswLTldKykkXCIpO1xuXHR2YXIgcmVnZXhOdW1iZXIgPSBuZXcgUmVnRXhwKFwiXih1P2ludCkoWzAtOV0qKSRcIik7XG5cdHZhciByZWdleEFycmF5ID0gbmV3IFJlZ0V4cChcIl4oLiopXFxcXFsoWzAtOV0qKVxcXFxdJFwiKTtcblx0dmFyIFplcm9zID0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5cdGZ1bmN0aW9uIF9wYWNrKHR5cGUsIHZhbHVlLCBpc0FycmF5KSB7XG5cdCAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuXHQgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxpYiQxLnplcm9QYWQodmFsdWUsIDMyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQ4LnRvVXRmOEJ5dGVzKHZhbHVlKTtcblx0ICAgICAgICBjYXNlIFwiYnl0ZXNcIjpcblx0ICAgICAgICAgICAgcmV0dXJuIGxpYiQxLmFycmF5aWZ5KHZhbHVlKTtcblx0ICAgICAgICBjYXNlIFwiYm9vbFwiOlxuXHQgICAgICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA/IFwiMHgwMVwiIDogXCIweDAwXCIpO1xuXHQgICAgICAgICAgICBpZiAoaXNBcnJheSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGxpYiQxLnplcm9QYWQodmFsdWUsIDMyKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkodmFsdWUpO1xuXHQgICAgfVxuXHQgICAgdmFyIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleE51bWJlcik7XG5cdCAgICBpZiAobWF0Y2gpIHtcblx0ICAgICAgICAvL2xldCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiaW50XCIpXG5cdCAgICAgICAgdmFyIHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcblx0ICAgICAgICBpZiAoKG1hdGNoWzJdICYmIFN0cmluZyhzaXplKSAhPT0gbWF0Y2hbMl0pIHx8IChzaXplICUgOCAhPT0gMCkgfHwgc2l6ZSA9PT0gMCB8fCBzaXplID4gMjU2KSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbnVtYmVyIHR5cGUgLSBcIiArIHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNBcnJheSkge1xuXHQgICAgICAgICAgICBzaXplID0gMjU2O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YWx1ZSA9IGxpYiQyLkJpZ051bWJlci5mcm9tKHZhbHVlKS50b1R3b3Moc2l6ZSk7XG5cdCAgICAgICAgcmV0dXJuIGxpYiQxLnplcm9QYWQodmFsdWUsIHNpemUgLyA4KTtcblx0ICAgIH1cblx0ICAgIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleEJ5dGVzKTtcblx0ICAgIGlmIChtYXRjaCkge1xuXHQgICAgICAgIHZhciBzaXplID0gcGFyc2VJbnQobWF0Y2hbMV0pO1xuXHQgICAgICAgIGlmIChTdHJpbmcoc2l6ZSkgIT09IG1hdGNoWzFdIHx8IHNpemUgPT09IDAgfHwgc2l6ZSA+IDMyKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYnl0ZXMgdHlwZSAtIFwiICsgdHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGlmIChsaWIkMS5hcnJheWlmeSh2YWx1ZSkuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBcIiArIHR5cGUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBpZiAoaXNBcnJheSkge1xuXHQgICAgICAgICAgICByZXR1cm4gbGliJDEuYXJyYXlpZnkoKHZhbHVlICsgWmVyb3MpLnN1YnN0cmluZygwLCA2NikpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICByZXR1cm4gdmFsdWU7XG5cdCAgICB9XG5cdCAgICBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhBcnJheSk7XG5cdCAgICBpZiAobWF0Y2ggJiYgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0ICAgICAgICB2YXIgYmFzZVR5cGVfMSA9IG1hdGNoWzFdO1xuXHQgICAgICAgIHZhciBjb3VudCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFN0cmluZyh2YWx1ZS5sZW5ndGgpKTtcblx0ICAgICAgICBpZiAoY291bnQgIT0gdmFsdWUubGVuZ3RoKSB7XG5cdCAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFsdWUgZm9yIFwiICsgdHlwZSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciByZXN1bHRfMSA9IFtdO1xuXHQgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG5cdCAgICAgICAgICAgIHJlc3VsdF8xLnB1c2goX3BhY2soYmFzZVR5cGVfMSwgdmFsdWUsIHRydWUpKTtcblx0ICAgICAgICB9KTtcblx0ICAgICAgICByZXR1cm4gbGliJDEuY29uY2F0KHJlc3VsdF8xKTtcblx0ICAgIH1cblx0ICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdHlwZSAtIFwiICsgdHlwZSk7XG5cdH1cblx0Ly8gQFRPRE86IEFycmF5IEVudW1cblx0ZnVuY3Rpb24gcGFjayh0eXBlcywgdmFsdWVzKSB7XG5cdCAgICBpZiAodHlwZXMubGVuZ3RoICE9IHZhbHVlcy5sZW5ndGgpIHtcblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlL3ZhbHVlIGNvdW50IG1pc21hdGNoXCIpO1xuXHQgICAgfVxuXHQgICAgdmFyIHRpZ2h0ID0gW107XG5cdCAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuXHQgICAgICAgIHRpZ2h0LnB1c2goX3BhY2sodHlwZSwgdmFsdWVzW2luZGV4XSkpO1xuXHQgICAgfSk7XG5cdCAgICByZXR1cm4gbGliJDEuaGV4bGlmeShsaWIkMS5jb25jYXQodGlnaHQpKTtcblx0fVxuXHRleHBvcnRzLnBhY2sgPSBwYWNrO1xuXHRmdW5jdGlvbiBrZWNjYWsyNTYodHlwZXMsIHZhbHVlcykge1xuXHQgICAgcmV0dXJuIGxpYiQ0LmtlY2NhazI1NihwYWNrKHR5cGVzLCB2YWx1ZXMpKTtcblx0fVxuXHRleHBvcnRzLmtlY2NhazI1NiA9IGtlY2NhazI1Njtcblx0ZnVuY3Rpb24gc2hhMjU2KHR5cGVzLCB2YWx1ZXMpIHtcblx0ICAgIHJldHVybiBicm93c2VyLnNoYTI1NihwYWNrKHR5cGVzLCB2YWx1ZXMpKTtcblx0fVxuXHRleHBvcnRzLnNoYTI1NiA9IHNoYTI1NjtcblxuXHR9KTtcblxuXHR2YXIgaW5kZXgkbiA9IHVud3JhcEV4cG9ydHMobGliJG4pO1xuXHR2YXIgbGliXzEkbiA9IGxpYiRuLnBhY2s7XG5cdHZhciBsaWJfMiRsID0gbGliJG4ua2VjY2FrMjU2O1xuXHR2YXIgbGliXzMkaCA9IGxpYiRuLnNoYTI1NjtcblxuXHR2YXIgX3ZlcnNpb24kSyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblx0ZXhwb3J0cy52ZXJzaW9uID0gXCJ1bml0cy81LjAuNFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiRMID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRLKTtcblx0dmFyIF92ZXJzaW9uXzEkbiA9IF92ZXJzaW9uJEsudmVyc2lvbjtcblxuXHR2YXIgbGliJG8gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblxuXG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRLLnZlcnNpb24pO1xuXHR2YXIgbmFtZXMgPSBbXG5cdCAgICBcIndlaVwiLFxuXHQgICAgXCJrd2VpXCIsXG5cdCAgICBcIm13ZWlcIixcblx0ICAgIFwiZ3dlaVwiLFxuXHQgICAgXCJzemFib1wiLFxuXHQgICAgXCJmaW5uZXlcIixcblx0ICAgIFwiZXRoZXJcIixcblx0XTtcblx0Ly8gU29tZSBlbnZpcm9ubWVudHMgaGF2ZSBpc3N1ZXMgd2l0aCBSZWdFeCB0aGF0IGNvbnRhaW4gYmFjay10cmFja2luZywgc28gd2UgY2Fubm90XG5cdC8vIHVzZSB0aGVtLlxuXHRmdW5jdGlvbiBjb21taWZ5KHZhbHVlKSB7XG5cdCAgICB2YXIgY29tcHMgPSBTdHJpbmcodmFsdWUpLnNwbGl0KFwiLlwiKTtcblx0ICAgIGlmIChjb21wcy5sZW5ndGggPiAyIHx8ICFjb21wc1swXS5tYXRjaCgvXi0/WzAtOV0qJC8pIHx8IChjb21wc1sxXSAmJiAhY29tcHNbMV0ubWF0Y2goL15bMC05XSokLykpIHx8IHZhbHVlID09PSBcIi5cIiB8fCB2YWx1ZSA9PT0gXCItLlwiKSB7XG5cdCAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG5cdCAgICB9XG5cdCAgICAvLyBNYWtlIHN1cmUgd2UgaGF2ZSBhdCBsZWFzdCBvbmUgd2hvbGUgZGlnaXQgKDAgaWYgbm9uZSlcblx0ICAgIHZhciB3aG9sZSA9IGNvbXBzWzBdO1xuXHQgICAgdmFyIG5lZ2F0aXZlID0gXCJcIjtcblx0ICAgIGlmICh3aG9sZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLVwiKSB7XG5cdCAgICAgICAgbmVnYXRpdmUgPSBcIi1cIjtcblx0ICAgICAgICB3aG9sZSA9IHdob2xlLnN1YnN0cmluZygxKTtcblx0ICAgIH1cblx0ICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IDEgd2hvbGUgZGlnaXQgd2l0aCBubyBsZWFkaW5nIHplcm9zXG5cdCAgICB3aGlsZSAod2hvbGUuc3Vic3RyaW5nKDAsIDEpID09PSBcIjBcIikge1xuXHQgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDEpO1xuXHQgICAgfVxuXHQgICAgaWYgKHdob2xlID09PSBcIlwiKSB7XG5cdCAgICAgICAgd2hvbGUgPSBcIjBcIjtcblx0ICAgIH1cblx0ICAgIHZhciBzdWZmaXggPSBcIlwiO1xuXHQgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMikge1xuXHQgICAgICAgIHN1ZmZpeCA9IFwiLlwiICsgKGNvbXBzWzFdIHx8IFwiMFwiKTtcblx0ICAgIH1cblx0ICAgIHdoaWxlIChzdWZmaXgubGVuZ3RoID4gMiAmJiBzdWZmaXhbc3VmZml4Lmxlbmd0aCAtIDFdID09PSBcIjBcIikge1xuXHQgICAgICAgIHN1ZmZpeCA9IHN1ZmZpeC5zdWJzdHJpbmcoMCwgc3VmZml4Lmxlbmd0aCAtIDEpO1xuXHQgICAgfVxuXHQgICAgdmFyIGZvcm1hdHRlZCA9IFtdO1xuXHQgICAgd2hpbGUgKHdob2xlLmxlbmd0aCkge1xuXHQgICAgICAgIGlmICh3aG9sZS5sZW5ndGggPD0gMykge1xuXHQgICAgICAgICAgICBmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZSk7XG5cdCAgICAgICAgICAgIGJyZWFrO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBlbHNlIHtcblx0ICAgICAgICAgICAgdmFyIGluZGV4ID0gd2hvbGUubGVuZ3RoIC0gMztcblx0ICAgICAgICAgICAgZm9ybWF0dGVkLnVuc2hpZnQod2hvbGUuc3Vic3RyaW5nKGluZGV4KSk7XG5cdCAgICAgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDAsIGluZGV4KTtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbmVnYXRpdmUgKyBmb3JtYXR0ZWQuam9pbihcIixcIikgKyBzdWZmaXg7XG5cdH1cblx0ZXhwb3J0cy5jb21taWZ5ID0gY29tbWlmeTtcblx0ZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIHVuaXROYW1lKSB7XG5cdCAgICBpZiAodHlwZW9mICh1bml0TmFtZSkgPT09IFwic3RyaW5nXCIpIHtcblx0ICAgICAgICB2YXIgaW5kZXggPSBuYW1lcy5pbmRleE9mKHVuaXROYW1lKTtcblx0ICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgIHVuaXROYW1lID0gMyAqIGluZGV4O1xuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgIHJldHVybiBsaWIkMi5mb3JtYXRGaXhlZCh2YWx1ZSwgKHVuaXROYW1lICE9IG51bGwpID8gdW5pdE5hbWUgOiAxOCk7XG5cdH1cblx0ZXhwb3J0cy5mb3JtYXRVbml0cyA9IGZvcm1hdFVuaXRzO1xuXHRmdW5jdGlvbiBwYXJzZVVuaXRzKHZhbHVlLCB1bml0TmFtZSkge1xuXHQgICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG5cdCAgICAgICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG5cdCAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuXHQgICAgICAgICAgICB1bml0TmFtZSA9IDMgKiBpbmRleDtcblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbGliJDIucGFyc2VGaXhlZCh2YWx1ZSwgKHVuaXROYW1lICE9IG51bGwpID8gdW5pdE5hbWUgOiAxOCk7XG5cdH1cblx0ZXhwb3J0cy5wYXJzZVVuaXRzID0gcGFyc2VVbml0cztcblx0ZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG5cdCAgICByZXR1cm4gZm9ybWF0VW5pdHMod2VpLCAxOCk7XG5cdH1cblx0ZXhwb3J0cy5mb3JtYXRFdGhlciA9IGZvcm1hdEV0aGVyO1xuXHRmdW5jdGlvbiBwYXJzZUV0aGVyKGV0aGVyKSB7XG5cdCAgICByZXR1cm4gcGFyc2VVbml0cyhldGhlciwgMTgpO1xuXHR9XG5cdGV4cG9ydHMucGFyc2VFdGhlciA9IHBhcnNlRXRoZXI7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JG8gPSB1bndyYXBFeHBvcnRzKGxpYiRvKTtcblx0dmFyIGxpYl8xJG8gPSBsaWIkby5jb21taWZ5O1xuXHR2YXIgbGliXzIkbSA9IGxpYiRvLmZvcm1hdFVuaXRzO1xuXHR2YXIgbGliXzMkaSA9IGxpYiRvLnBhcnNlVW5pdHM7XG5cdHZhciBsaWJfNCRkID0gbGliJG8uZm9ybWF0RXRoZXI7XG5cdHZhciBsaWJfNSRjID0gbGliJG8ucGFyc2VFdGhlcjtcblxuXHR2YXIgdXRpbHMkMyA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0XCJ1c2Ugc3RyaWN0XCI7XG5cdHZhciBfX2ltcG9ydFN0YXIgPSAoY29tbW9uanNHbG9iYWwgJiYgY29tbW9uanNHbG9iYWwuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG5cdCAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuXHQgICAgdmFyIHJlc3VsdCA9IHt9O1xuXHQgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIHJlc3VsdFtrXSA9IG1vZFtrXTtcblx0ICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG5cdCAgICByZXR1cm4gcmVzdWx0O1xuXHR9O1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cblx0ZXhwb3J0cy5BYmlDb2RlciA9IGxpYiRhLkFiaUNvZGVyO1xuXHRleHBvcnRzLmNoZWNrUmVzdWx0RXJyb3JzID0gbGliJGEuY2hlY2tSZXN1bHRFcnJvcnM7XG5cdGV4cG9ydHMuZGVmYXVsdEFiaUNvZGVyID0gbGliJGEuZGVmYXVsdEFiaUNvZGVyO1xuXHRleHBvcnRzLkV2ZW50RnJhZ21lbnQgPSBsaWIkYS5FdmVudEZyYWdtZW50O1xuXHRleHBvcnRzLkZvcm1hdFR5cGVzID0gbGliJGEuRm9ybWF0VHlwZXM7XG5cdGV4cG9ydHMuRnJhZ21lbnQgPSBsaWIkYS5GcmFnbWVudDtcblx0ZXhwb3J0cy5GdW5jdGlvbkZyYWdtZW50ID0gbGliJGEuRnVuY3Rpb25GcmFnbWVudDtcblx0ZXhwb3J0cy5JbmRleGVkID0gbGliJGEuSW5kZXhlZDtcblx0ZXhwb3J0cy5JbnRlcmZhY2UgPSBsaWIkYS5JbnRlcmZhY2U7XG5cdGV4cG9ydHMuTG9nRGVzY3JpcHRpb24gPSBsaWIkYS5Mb2dEZXNjcmlwdGlvbjtcblx0ZXhwb3J0cy5QYXJhbVR5cGUgPSBsaWIkYS5QYXJhbVR5cGU7XG5cdGV4cG9ydHMuVHJhbnNhY3Rpb25EZXNjcmlwdGlvbiA9IGxpYiRhLlRyYW5zYWN0aW9uRGVzY3JpcHRpb247XG5cblx0ZXhwb3J0cy5nZXRBZGRyZXNzID0gbGliJDYuZ2V0QWRkcmVzcztcblx0ZXhwb3J0cy5nZXRDcmVhdGUyQWRkcmVzcyA9IGxpYiQ2LmdldENyZWF0ZTJBZGRyZXNzO1xuXHRleHBvcnRzLmdldENvbnRyYWN0QWRkcmVzcyA9IGxpYiQ2LmdldENvbnRyYWN0QWRkcmVzcztcblx0ZXhwb3J0cy5nZXRJY2FwQWRkcmVzcyA9IGxpYiQ2LmdldEljYXBBZGRyZXNzO1xuXHRleHBvcnRzLmlzQWRkcmVzcyA9IGxpYiQ2LmlzQWRkcmVzcztcblx0dmFyIGJhc2U2NCA9IF9faW1wb3J0U3Rhcihicm93c2VyJDgpO1xuXHRleHBvcnRzLmJhc2U2NCA9IGJhc2U2NDtcblxuXHRleHBvcnRzLmJhc2U1OCA9IGxpYiRlLkJhc2U1ODtcblxuXHRleHBvcnRzLmFycmF5aWZ5ID0gbGliJDEuYXJyYXlpZnk7XG5cdGV4cG9ydHMuY29uY2F0ID0gbGliJDEuY29uY2F0O1xuXHRleHBvcnRzLmhleERhdGFTbGljZSA9IGxpYiQxLmhleERhdGFTbGljZTtcblx0ZXhwb3J0cy5oZXhEYXRhTGVuZ3RoID0gbGliJDEuaGV4RGF0YUxlbmd0aDtcblx0ZXhwb3J0cy5oZXhsaWZ5ID0gbGliJDEuaGV4bGlmeTtcblx0ZXhwb3J0cy5oZXhTdHJpcFplcm9zID0gbGliJDEuaGV4U3RyaXBaZXJvcztcblx0ZXhwb3J0cy5oZXhWYWx1ZSA9IGxpYiQxLmhleFZhbHVlO1xuXHRleHBvcnRzLmhleFplcm9QYWQgPSBsaWIkMS5oZXhaZXJvUGFkO1xuXHRleHBvcnRzLmlzQnl0ZXMgPSBsaWIkMS5pc0J5dGVzO1xuXHRleHBvcnRzLmlzQnl0ZXNMaWtlID0gbGliJDEuaXNCeXRlc0xpa2U7XG5cdGV4cG9ydHMuaXNIZXhTdHJpbmcgPSBsaWIkMS5pc0hleFN0cmluZztcblx0ZXhwb3J0cy5qb2luU2lnbmF0dXJlID0gbGliJDEuam9pblNpZ25hdHVyZTtcblx0ZXhwb3J0cy56ZXJvUGFkID0gbGliJDEuemVyb1BhZDtcblx0ZXhwb3J0cy5zcGxpdFNpZ25hdHVyZSA9IGxpYiQxLnNwbGl0U2lnbmF0dXJlO1xuXHRleHBvcnRzLnN0cmlwWmVyb3MgPSBsaWIkMS5zdHJpcFplcm9zO1xuXG5cdGV4cG9ydHMuaGFzaE1lc3NhZ2UgPSBsaWIkOS5oYXNoTWVzc2FnZTtcblx0ZXhwb3J0cy5pZCA9IGxpYiQ5LmlkO1xuXHRleHBvcnRzLmlzVmFsaWROYW1lID0gbGliJDkuaXNWYWxpZE5hbWU7XG5cdGV4cG9ydHMubmFtZWhhc2ggPSBsaWIkOS5uYW1laGFzaDtcblxuXHRleHBvcnRzLmRlZmF1bHRQYXRoID0gbGliJGguZGVmYXVsdFBhdGg7XG5cdGV4cG9ydHMuZW50cm9weVRvTW5lbW9uaWMgPSBsaWIkaC5lbnRyb3B5VG9NbmVtb25pYztcblx0ZXhwb3J0cy5IRE5vZGUgPSBsaWIkaC5IRE5vZGU7XG5cdGV4cG9ydHMuaXNWYWxpZE1uZW1vbmljID0gbGliJGguaXNWYWxpZE1uZW1vbmljO1xuXHRleHBvcnRzLm1uZW1vbmljVG9FbnRyb3B5ID0gbGliJGgubW5lbW9uaWNUb0VudHJvcHk7XG5cdGV4cG9ydHMubW5lbW9uaWNUb1NlZWQgPSBsaWIkaC5tbmVtb25pY1RvU2VlZDtcblxuXHRleHBvcnRzLmdldEpzb25XYWxsZXRBZGRyZXNzID0gbGliJGkuZ2V0SnNvbldhbGxldEFkZHJlc3M7XG5cblx0ZXhwb3J0cy5rZWNjYWsyNTYgPSBsaWIkNC5rZWNjYWsyNTY7XG5cblx0ZXhwb3J0cy5Mb2dnZXIgPSBsaWIuTG9nZ2VyO1xuXG5cdGV4cG9ydHMuY29tcHV0ZUhtYWMgPSBicm93c2VyLmNvbXB1dGVIbWFjO1xuXHRleHBvcnRzLnJpcGVtZDE2MCA9IGJyb3dzZXIucmlwZW1kMTYwO1xuXHRleHBvcnRzLnNoYTI1NiA9IGJyb3dzZXIuc2hhMjU2O1xuXHRleHBvcnRzLnNoYTUxMiA9IGJyb3dzZXIuc2hhNTEyO1xuXG5cdGV4cG9ydHMuc29saWRpdHlLZWNjYWsyNTYgPSBsaWIkbi5rZWNjYWsyNTY7XG5cdGV4cG9ydHMuc29saWRpdHlQYWNrID0gbGliJG4ucGFjaztcblx0ZXhwb3J0cy5zb2xpZGl0eVNoYTI1NiA9IGxpYiRuLnNoYTI1NjtcblxuXHRleHBvcnRzLnJhbmRvbUJ5dGVzID0gYnJvd3NlciQ2LnJhbmRvbUJ5dGVzO1xuXHRleHBvcnRzLnNodWZmbGVkID0gYnJvd3NlciQ2LnNodWZmbGVkO1xuXG5cdGV4cG9ydHMuY2hlY2tQcm9wZXJ0aWVzID0gbGliJDMuY2hlY2tQcm9wZXJ0aWVzO1xuXHRleHBvcnRzLmRlZXBDb3B5ID0gbGliJDMuZGVlcENvcHk7XG5cdGV4cG9ydHMuZGVmaW5lUmVhZE9ubHkgPSBsaWIkMy5kZWZpbmVSZWFkT25seTtcblx0ZXhwb3J0cy5nZXRTdGF0aWMgPSBsaWIkMy5nZXRTdGF0aWM7XG5cdGV4cG9ydHMucmVzb2x2ZVByb3BlcnRpZXMgPSBsaWIkMy5yZXNvbHZlUHJvcGVydGllcztcblx0ZXhwb3J0cy5zaGFsbG93Q29weSA9IGxpYiQzLnNoYWxsb3dDb3B5O1xuXHR2YXIgUkxQID0gX19pbXBvcnRTdGFyKGxpYiQ1KTtcblx0ZXhwb3J0cy5STFAgPSBSTFA7XG5cblx0ZXhwb3J0cy5jb21wdXRlUHVibGljS2V5ID0gbGliJGYuY29tcHV0ZVB1YmxpY0tleTtcblx0ZXhwb3J0cy5yZWNvdmVyUHVibGljS2V5ID0gbGliJGYucmVjb3ZlclB1YmxpY0tleTtcblx0ZXhwb3J0cy5TaWduaW5nS2V5ID0gbGliJGYuU2lnbmluZ0tleTtcblxuXHRleHBvcnRzLmZvcm1hdEJ5dGVzMzJTdHJpbmcgPSBsaWIkOC5mb3JtYXRCeXRlczMyU3RyaW5nO1xuXHRleHBvcnRzLm5hbWVwcmVwID0gbGliJDgubmFtZXByZXA7XG5cdGV4cG9ydHMucGFyc2VCeXRlczMyU3RyaW5nID0gbGliJDgucGFyc2VCeXRlczMyU3RyaW5nO1xuXHRleHBvcnRzLl90b0VzY2FwZWRVdGY4U3RyaW5nID0gbGliJDguX3RvRXNjYXBlZFV0ZjhTdHJpbmc7XG5cdGV4cG9ydHMudG9VdGY4Qnl0ZXMgPSBsaWIkOC50b1V0ZjhCeXRlcztcblx0ZXhwb3J0cy50b1V0ZjhDb2RlUG9pbnRzID0gbGliJDgudG9VdGY4Q29kZVBvaW50cztcblx0ZXhwb3J0cy50b1V0ZjhTdHJpbmcgPSBsaWIkOC50b1V0ZjhTdHJpbmc7XG5cdGV4cG9ydHMuVXRmOEVycm9yRnVuY3MgPSBsaWIkOC5VdGY4RXJyb3JGdW5jcztcblxuXHRleHBvcnRzLmNvbXB1dGVBZGRyZXNzID0gbGliJGcuY29tcHV0ZUFkZHJlc3M7XG5cdGV4cG9ydHMucGFyc2VUcmFuc2FjdGlvbiA9IGxpYiRnLnBhcnNlO1xuXHRleHBvcnRzLnJlY292ZXJBZGRyZXNzID0gbGliJGcucmVjb3ZlckFkZHJlc3M7XG5cdGV4cG9ydHMuc2VyaWFsaXplVHJhbnNhY3Rpb24gPSBsaWIkZy5zZXJpYWxpemU7XG5cblx0ZXhwb3J0cy5jb21taWZ5ID0gbGliJG8uY29tbWlmeTtcblx0ZXhwb3J0cy5mb3JtYXRFdGhlciA9IGxpYiRvLmZvcm1hdEV0aGVyO1xuXHRleHBvcnRzLnBhcnNlRXRoZXIgPSBsaWIkby5wYXJzZUV0aGVyO1xuXHRleHBvcnRzLmZvcm1hdFVuaXRzID0gbGliJG8uZm9ybWF0VW5pdHM7XG5cdGV4cG9ydHMucGFyc2VVbml0cyA9IGxpYiRvLnBhcnNlVW5pdHM7XG5cblx0ZXhwb3J0cy52ZXJpZnlNZXNzYWdlID0gbGliJGoudmVyaWZ5TWVzc2FnZTtcblxuXHRleHBvcnRzLl9mZXRjaERhdGEgPSBsaWIkbC5fZmV0Y2hEYXRhO1xuXHRleHBvcnRzLmZldGNoSnNvbiA9IGxpYiRsLmZldGNoSnNvbjtcblx0ZXhwb3J0cy5wb2xsID0gbGliJGwucG9sbDtcblx0Ly8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cdC8vIEVudW1zXG5cdHZhciBzaGEyXzIgPSBicm93c2VyO1xuXHRleHBvcnRzLlN1cHBvcnRlZEFsZ29yaXRobSA9IHNoYTJfMi5TdXBwb3J0ZWRBbGdvcml0aG07XG5cdHZhciBzdHJpbmdzXzIgPSBsaWIkODtcblx0ZXhwb3J0cy5Vbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gPSBzdHJpbmdzXzIuVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtO1xuXHRleHBvcnRzLlV0ZjhFcnJvclJlYXNvbiA9IHN0cmluZ3NfMi5VdGY4RXJyb3JSZWFzb247XG5cblx0fSk7XG5cblx0dmFyIHV0aWxzJDQgPSB1bndyYXBFeHBvcnRzKHV0aWxzJDMpO1xuXHR2YXIgdXRpbHNfMSQzID0gdXRpbHMkMy5BYmlDb2Rlcjtcblx0dmFyIHV0aWxzXzIkMSA9IHV0aWxzJDMuY2hlY2tSZXN1bHRFcnJvcnM7XG5cdHZhciB1dGlsc18zJDEgPSB1dGlscyQzLmRlZmF1bHRBYmlDb2Rlcjtcblx0dmFyIHV0aWxzXzQkMSA9IHV0aWxzJDMuRXZlbnRGcmFnbWVudDtcblx0dmFyIHV0aWxzXzUkMSA9IHV0aWxzJDMuRm9ybWF0VHlwZXM7XG5cdHZhciB1dGlsc182ID0gdXRpbHMkMy5GcmFnbWVudDtcblx0dmFyIHV0aWxzXzcgPSB1dGlscyQzLkZ1bmN0aW9uRnJhZ21lbnQ7XG5cdHZhciB1dGlsc184ID0gdXRpbHMkMy5JbmRleGVkO1xuXHR2YXIgdXRpbHNfOSA9IHV0aWxzJDMuSW50ZXJmYWNlO1xuXHR2YXIgdXRpbHNfMTAgPSB1dGlscyQzLkxvZ0Rlc2NyaXB0aW9uO1xuXHR2YXIgdXRpbHNfMTEgPSB1dGlscyQzLlBhcmFtVHlwZTtcblx0dmFyIHV0aWxzXzEyID0gdXRpbHMkMy5UcmFuc2FjdGlvbkRlc2NyaXB0aW9uO1xuXHR2YXIgdXRpbHNfMTMgPSB1dGlscyQzLmdldEFkZHJlc3M7XG5cdHZhciB1dGlsc18xNCA9IHV0aWxzJDMuZ2V0Q3JlYXRlMkFkZHJlc3M7XG5cdHZhciB1dGlsc18xNSA9IHV0aWxzJDMuZ2V0Q29udHJhY3RBZGRyZXNzO1xuXHR2YXIgdXRpbHNfMTYgPSB1dGlscyQzLmdldEljYXBBZGRyZXNzO1xuXHR2YXIgdXRpbHNfMTcgPSB1dGlscyQzLmlzQWRkcmVzcztcblx0dmFyIHV0aWxzXzE4ID0gdXRpbHMkMy5iYXNlNjQ7XG5cdHZhciB1dGlsc18xOSA9IHV0aWxzJDMuYmFzZTU4O1xuXHR2YXIgdXRpbHNfMjAgPSB1dGlscyQzLmFycmF5aWZ5O1xuXHR2YXIgdXRpbHNfMjEgPSB1dGlscyQzLmNvbmNhdDtcblx0dmFyIHV0aWxzXzIyID0gdXRpbHMkMy5oZXhEYXRhU2xpY2U7XG5cdHZhciB1dGlsc18yMyA9IHV0aWxzJDMuaGV4RGF0YUxlbmd0aDtcblx0dmFyIHV0aWxzXzI0ID0gdXRpbHMkMy5oZXhsaWZ5O1xuXHR2YXIgdXRpbHNfMjUgPSB1dGlscyQzLmhleFN0cmlwWmVyb3M7XG5cdHZhciB1dGlsc18yNiA9IHV0aWxzJDMuaGV4VmFsdWU7XG5cdHZhciB1dGlsc18yNyA9IHV0aWxzJDMuaGV4WmVyb1BhZDtcblx0dmFyIHV0aWxzXzI4ID0gdXRpbHMkMy5pc0J5dGVzO1xuXHR2YXIgdXRpbHNfMjkgPSB1dGlscyQzLmlzQnl0ZXNMaWtlO1xuXHR2YXIgdXRpbHNfMzAgPSB1dGlscyQzLmlzSGV4U3RyaW5nO1xuXHR2YXIgdXRpbHNfMzEgPSB1dGlscyQzLmpvaW5TaWduYXR1cmU7XG5cdHZhciB1dGlsc18zMiA9IHV0aWxzJDMuemVyb1BhZDtcblx0dmFyIHV0aWxzXzMzID0gdXRpbHMkMy5zcGxpdFNpZ25hdHVyZTtcblx0dmFyIHV0aWxzXzM0ID0gdXRpbHMkMy5zdHJpcFplcm9zO1xuXHR2YXIgdXRpbHNfMzUgPSB1dGlscyQzLmhhc2hNZXNzYWdlO1xuXHR2YXIgdXRpbHNfMzYgPSB1dGlscyQzLmlkO1xuXHR2YXIgdXRpbHNfMzcgPSB1dGlscyQzLmlzVmFsaWROYW1lO1xuXHR2YXIgdXRpbHNfMzggPSB1dGlscyQzLm5hbWVoYXNoO1xuXHR2YXIgdXRpbHNfMzkgPSB1dGlscyQzLmRlZmF1bHRQYXRoO1xuXHR2YXIgdXRpbHNfNDAgPSB1dGlscyQzLmVudHJvcHlUb01uZW1vbmljO1xuXHR2YXIgdXRpbHNfNDEgPSB1dGlscyQzLkhETm9kZTtcblx0dmFyIHV0aWxzXzQyID0gdXRpbHMkMy5pc1ZhbGlkTW5lbW9uaWM7XG5cdHZhciB1dGlsc180MyA9IHV0aWxzJDMubW5lbW9uaWNUb0VudHJvcHk7XG5cdHZhciB1dGlsc180NCA9IHV0aWxzJDMubW5lbW9uaWNUb1NlZWQ7XG5cdHZhciB1dGlsc180NSA9IHV0aWxzJDMuZ2V0SnNvbldhbGxldEFkZHJlc3M7XG5cdHZhciB1dGlsc180NiA9IHV0aWxzJDMua2VjY2FrMjU2O1xuXHR2YXIgdXRpbHNfNDcgPSB1dGlscyQzLkxvZ2dlcjtcblx0dmFyIHV0aWxzXzQ4ID0gdXRpbHMkMy5jb21wdXRlSG1hYztcblx0dmFyIHV0aWxzXzQ5ID0gdXRpbHMkMy5yaXBlbWQxNjA7XG5cdHZhciB1dGlsc181MCA9IHV0aWxzJDMuc2hhMjU2O1xuXHR2YXIgdXRpbHNfNTEgPSB1dGlscyQzLnNoYTUxMjtcblx0dmFyIHV0aWxzXzUyID0gdXRpbHMkMy5zb2xpZGl0eUtlY2NhazI1Njtcblx0dmFyIHV0aWxzXzUzID0gdXRpbHMkMy5zb2xpZGl0eVBhY2s7XG5cdHZhciB1dGlsc181NCA9IHV0aWxzJDMuc29saWRpdHlTaGEyNTY7XG5cdHZhciB1dGlsc181NSA9IHV0aWxzJDMucmFuZG9tQnl0ZXM7XG5cdHZhciB1dGlsc181NiA9IHV0aWxzJDMuc2h1ZmZsZWQ7XG5cdHZhciB1dGlsc181NyA9IHV0aWxzJDMuY2hlY2tQcm9wZXJ0aWVzO1xuXHR2YXIgdXRpbHNfNTggPSB1dGlscyQzLmRlZXBDb3B5O1xuXHR2YXIgdXRpbHNfNTkgPSB1dGlscyQzLmRlZmluZVJlYWRPbmx5O1xuXHR2YXIgdXRpbHNfNjAgPSB1dGlscyQzLmdldFN0YXRpYztcblx0dmFyIHV0aWxzXzYxID0gdXRpbHMkMy5yZXNvbHZlUHJvcGVydGllcztcblx0dmFyIHV0aWxzXzYyID0gdXRpbHMkMy5zaGFsbG93Q29weTtcblx0dmFyIHV0aWxzXzYzID0gdXRpbHMkMy5STFA7XG5cdHZhciB1dGlsc182NCA9IHV0aWxzJDMuY29tcHV0ZVB1YmxpY0tleTtcblx0dmFyIHV0aWxzXzY1ID0gdXRpbHMkMy5yZWNvdmVyUHVibGljS2V5O1xuXHR2YXIgdXRpbHNfNjYgPSB1dGlscyQzLlNpZ25pbmdLZXk7XG5cdHZhciB1dGlsc182NyA9IHV0aWxzJDMuZm9ybWF0Qnl0ZXMzMlN0cmluZztcblx0dmFyIHV0aWxzXzY4ID0gdXRpbHMkMy5uYW1lcHJlcDtcblx0dmFyIHV0aWxzXzY5ID0gdXRpbHMkMy5wYXJzZUJ5dGVzMzJTdHJpbmc7XG5cdHZhciB1dGlsc183MCA9IHV0aWxzJDMuX3RvRXNjYXBlZFV0ZjhTdHJpbmc7XG5cdHZhciB1dGlsc183MSA9IHV0aWxzJDMudG9VdGY4Qnl0ZXM7XG5cdHZhciB1dGlsc183MiA9IHV0aWxzJDMudG9VdGY4Q29kZVBvaW50cztcblx0dmFyIHV0aWxzXzczID0gdXRpbHMkMy50b1V0ZjhTdHJpbmc7XG5cdHZhciB1dGlsc183NCA9IHV0aWxzJDMuVXRmOEVycm9yRnVuY3M7XG5cdHZhciB1dGlsc183NSA9IHV0aWxzJDMuY29tcHV0ZUFkZHJlc3M7XG5cdHZhciB1dGlsc183NiA9IHV0aWxzJDMucGFyc2VUcmFuc2FjdGlvbjtcblx0dmFyIHV0aWxzXzc3ID0gdXRpbHMkMy5yZWNvdmVyQWRkcmVzcztcblx0dmFyIHV0aWxzXzc4ID0gdXRpbHMkMy5zZXJpYWxpemVUcmFuc2FjdGlvbjtcblx0dmFyIHV0aWxzXzc5ID0gdXRpbHMkMy5jb21taWZ5O1xuXHR2YXIgdXRpbHNfODAgPSB1dGlscyQzLmZvcm1hdEV0aGVyO1xuXHR2YXIgdXRpbHNfODEgPSB1dGlscyQzLnBhcnNlRXRoZXI7XG5cdHZhciB1dGlsc184MiA9IHV0aWxzJDMuZm9ybWF0VW5pdHM7XG5cdHZhciB1dGlsc184MyA9IHV0aWxzJDMucGFyc2VVbml0cztcblx0dmFyIHV0aWxzXzg0ID0gdXRpbHMkMy52ZXJpZnlNZXNzYWdlO1xuXHR2YXIgdXRpbHNfODUgPSB1dGlscyQzLl9mZXRjaERhdGE7XG5cdHZhciB1dGlsc184NiA9IHV0aWxzJDMuZmV0Y2hKc29uO1xuXHR2YXIgdXRpbHNfODcgPSB1dGlscyQzLnBvbGw7XG5cdHZhciB1dGlsc184OCA9IHV0aWxzJDMuU3VwcG9ydGVkQWxnb3JpdGhtO1xuXHR2YXIgdXRpbHNfODkgPSB1dGlscyQzLlVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcblx0dmFyIHV0aWxzXzkwID0gdXRpbHMkMy5VdGY4RXJyb3JSZWFzb247XG5cblx0dmFyIF92ZXJzaW9uJE0gPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5cdGV4cG9ydHMudmVyc2lvbiA9IFwiZXRoZXJzLzUuMC4xNFwiO1xuXG5cdH0pO1xuXG5cdHZhciBfdmVyc2lvbiROID0gdW53cmFwRXhwb3J0cyhfdmVyc2lvbiRNKTtcblx0dmFyIF92ZXJzaW9uXzEkbyA9IF92ZXJzaW9uJE0udmVyc2lvbjtcblxuXHR2YXIgZXRoZXJzID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuXHRcInVzZSBzdHJpY3RcIjtcblx0dmFyIF9faW1wb3J0U3RhciA9IChjb21tb25qc0dsb2JhbCAmJiBjb21tb25qc0dsb2JhbC5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcblx0ICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG5cdCAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuXHQgICAgcmVzdWx0W1wiZGVmYXVsdFwiXSA9IG1vZDtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH07XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuXHRleHBvcnRzLkNvbnRyYWN0ID0gbGliJGQuQ29udHJhY3Q7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gbGliJGQuQ29udHJhY3RGYWN0b3J5O1xuXG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gbGliJDIuQmlnTnVtYmVyO1xuXHRleHBvcnRzLkZpeGVkTnVtYmVyID0gbGliJDIuRml4ZWROdW1iZXI7XG5cblx0ZXhwb3J0cy5TaWduZXIgPSBsaWIkYy5TaWduZXI7XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IGxpYiRjLlZvaWRTaWduZXI7XG5cblx0ZXhwb3J0cy5XYWxsZXQgPSBsaWIkai5XYWxsZXQ7XG5cdHZhciBjb25zdGFudHMgPSBfX2ltcG9ydFN0YXIobGliJDcpO1xuXHRleHBvcnRzLmNvbnN0YW50cyA9IGNvbnN0YW50cztcblx0dmFyIHByb3ZpZGVycyA9IF9faW1wb3J0U3RhcihsaWIkbSk7XG5cdGV4cG9ydHMucHJvdmlkZXJzID0gcHJvdmlkZXJzO1xuXHR2YXIgcHJvdmlkZXJzXzEgPSBsaWIkbTtcblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBwcm92aWRlcnNfMS5nZXREZWZhdWx0UHJvdmlkZXI7XG5cblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGJyb3dzZXIkNC5Xb3JkbGlzdDtcblx0ZXhwb3J0cy53b3JkbGlzdHMgPSBicm93c2VyJDQud29yZGxpc3RzO1xuXHR2YXIgdXRpbHMgPSBfX2ltcG9ydFN0YXIodXRpbHMkMyk7XG5cdGV4cG9ydHMudXRpbHMgPSB1dGlscztcblxuXHRleHBvcnRzLmVycm9ycyA9IGxpYi5FcnJvckNvZGU7XG5cdC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXHQvLyBDb21waWxlLVRpbWUgQ29uc3RhbnRzXG5cdC8vIFRoaXMgaXMgZ2VuZXJhdGVkIGJ5IFwibnBtIHJ1biBkaXN0XCJcblxuXHRleHBvcnRzLnZlcnNpb24gPSBfdmVyc2lvbiRNLnZlcnNpb247XG5cdHZhciBsb2dnZXIgPSBuZXcgbGliLkxvZ2dlcihfdmVyc2lvbiRNLnZlcnNpb24pO1xuXHRleHBvcnRzLmxvZ2dlciA9IGxvZ2dlcjtcblxuXHR9KTtcblxuXHR2YXIgZXRoZXJzJDEgPSB1bndyYXBFeHBvcnRzKGV0aGVycyk7XG5cdHZhciBldGhlcnNfMSA9IGV0aGVycy5Db250cmFjdDtcblx0dmFyIGV0aGVyc18yID0gZXRoZXJzLkNvbnRyYWN0RmFjdG9yeTtcblx0dmFyIGV0aGVyc18zID0gZXRoZXJzLkJpZ051bWJlcjtcblx0dmFyIGV0aGVyc180ID0gZXRoZXJzLkZpeGVkTnVtYmVyO1xuXHR2YXIgZXRoZXJzXzUgPSBldGhlcnMuU2lnbmVyO1xuXHR2YXIgZXRoZXJzXzYgPSBldGhlcnMuVm9pZFNpZ25lcjtcblx0dmFyIGV0aGVyc183ID0gZXRoZXJzLldhbGxldDtcblx0dmFyIGV0aGVyc184ID0gZXRoZXJzLmNvbnN0YW50cztcblx0dmFyIGV0aGVyc185ID0gZXRoZXJzLnByb3ZpZGVycztcblx0dmFyIGV0aGVyc18xMCA9IGV0aGVycy5nZXREZWZhdWx0UHJvdmlkZXI7XG5cdHZhciBldGhlcnNfMTEgPSBldGhlcnMuV29yZGxpc3Q7XG5cdHZhciBldGhlcnNfMTIgPSBldGhlcnMud29yZGxpc3RzO1xuXHR2YXIgZXRoZXJzXzEzID0gZXRoZXJzLnV0aWxzO1xuXHR2YXIgZXRoZXJzXzE0ID0gZXRoZXJzLmVycm9ycztcblx0dmFyIGV0aGVyc18xNSA9IGV0aGVycy52ZXJzaW9uO1xuXHR2YXIgZXRoZXJzXzE2ID0gZXRoZXJzLmxvZ2dlcjtcblxuXHR2YXIgbGliJHAgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG5cdFwidXNlIHN0cmljdFwiO1xuXHR2YXIgX19pbXBvcnRTdGFyID0gKGNvbW1vbmpzR2xvYmFsICYmIGNvbW1vbmpzR2xvYmFsLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuXHQgICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcblx0ICAgIHZhciByZXN1bHQgPSB7fTtcblx0ICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSByZXN1bHRba10gPSBtb2Rba107XG5cdCAgICByZXN1bHRbXCJkZWZhdWx0XCJdID0gbW9kO1xuXHQgICAgcmV0dXJuIHJlc3VsdDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuXHQvLyBUbyBtb2RpZnkgdGhpcyBmaWxlLCB5b3UgbXVzdCB1cGRhdGUgLi9hZG1pbi9jbWRzL3VwZGF0ZS1leHBvcnRzLmpzXG5cdHZhciBldGhlcnMkMSA9IF9faW1wb3J0U3RhcihldGhlcnMpO1xuXHRleHBvcnRzLmV0aGVycyA9IGV0aGVycyQxO1xuXHR0cnkge1xuXHQgICAgdmFyIGFueUdsb2JhbCA9IHdpbmRvdztcblx0ICAgIGlmIChhbnlHbG9iYWwuX2V0aGVycyA9PSBudWxsKSB7XG5cdCAgICAgICAgYW55R2xvYmFsLl9ldGhlcnMgPSBldGhlcnMkMTtcblx0ICAgIH1cblx0fVxuXHRjYXRjaCAoZXJyb3IpIHsgfVxuXHR2YXIgZXRoZXJzXzEgPSBldGhlcnM7XG5cdGV4cG9ydHMuU2lnbmVyID0gZXRoZXJzXzEuU2lnbmVyO1xuXHRleHBvcnRzLldhbGxldCA9IGV0aGVyc18xLldhbGxldDtcblx0ZXhwb3J0cy5Wb2lkU2lnbmVyID0gZXRoZXJzXzEuVm9pZFNpZ25lcjtcblx0ZXhwb3J0cy5nZXREZWZhdWx0UHJvdmlkZXIgPSBldGhlcnNfMS5nZXREZWZhdWx0UHJvdmlkZXI7XG5cdGV4cG9ydHMucHJvdmlkZXJzID0gZXRoZXJzXzEucHJvdmlkZXJzO1xuXHRleHBvcnRzLkNvbnRyYWN0ID0gZXRoZXJzXzEuQ29udHJhY3Q7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gZXRoZXJzXzEuQ29udHJhY3RGYWN0b3J5O1xuXHRleHBvcnRzLkJpZ051bWJlciA9IGV0aGVyc18xLkJpZ051bWJlcjtcblx0ZXhwb3J0cy5GaXhlZE51bWJlciA9IGV0aGVyc18xLkZpeGVkTnVtYmVyO1xuXHRleHBvcnRzLmNvbnN0YW50cyA9IGV0aGVyc18xLmNvbnN0YW50cztcblx0ZXhwb3J0cy5lcnJvcnMgPSBldGhlcnNfMS5lcnJvcnM7XG5cdGV4cG9ydHMubG9nZ2VyID0gZXRoZXJzXzEubG9nZ2VyO1xuXHRleHBvcnRzLnV0aWxzID0gZXRoZXJzXzEudXRpbHM7XG5cdGV4cG9ydHMud29yZGxpc3RzID0gZXRoZXJzXzEud29yZGxpc3RzO1xuXHQvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblx0Ly8gQ29tcGlsZS1UaW1lIENvbnN0YW50c1xuXHRleHBvcnRzLnZlcnNpb24gPSBldGhlcnNfMS52ZXJzaW9uO1xuXHRleHBvcnRzLldvcmRsaXN0ID0gZXRoZXJzXzEuV29yZGxpc3Q7XG5cblx0fSk7XG5cblx0dmFyIGluZGV4JHAgPSB1bndyYXBFeHBvcnRzKGxpYiRwKTtcblx0dmFyIGxpYl8xJHAgPSBsaWIkcC5ldGhlcnM7XG5cdHZhciBsaWJfMiRuID0gbGliJHAuU2lnbmVyO1xuXHR2YXIgbGliXzMkaiA9IGxpYiRwLldhbGxldDtcblx0dmFyIGxpYl80JGUgPSBsaWIkcC5Wb2lkU2lnbmVyO1xuXHR2YXIgbGliXzUkZCA9IGxpYiRwLmdldERlZmF1bHRQcm92aWRlcjtcblx0dmFyIGxpYl82JDggPSBsaWIkcC5wcm92aWRlcnM7XG5cdHZhciBsaWJfNyQ3ID0gbGliJHAuQ29udHJhY3Q7XG5cdHZhciBsaWJfOCQ2ID0gbGliJHAuQ29udHJhY3RGYWN0b3J5O1xuXHR2YXIgbGliXzkkNiA9IGxpYiRwLkJpZ051bWJlcjtcblx0dmFyIGxpYl8xMCQ0ID0gbGliJHAuRml4ZWROdW1iZXI7XG5cdHZhciBsaWJfMTEkMyA9IGxpYiRwLmNvbnN0YW50cztcblx0dmFyIGxpYl8xMiQzID0gbGliJHAuZXJyb3JzO1xuXHR2YXIgbGliXzEzJDMgPSBsaWIkcC5sb2dnZXI7XG5cdHZhciBsaWJfMTQkMiA9IGxpYiRwLnV0aWxzO1xuXHR2YXIgbGliXzE1JDIgPSBsaWIkcC53b3JkbGlzdHM7XG5cdHZhciBsaWJfMTYkMiA9IGxpYiRwLnZlcnNpb247XG5cdHZhciBsaWJfMTckMSA9IGxpYiRwLldvcmRsaXN0O1xuXG5cdGV4cG9ydHMuQmlnTnVtYmVyID0gbGliXzkkNjtcblx0ZXhwb3J0cy5Db250cmFjdCA9IGxpYl83JDc7XG5cdGV4cG9ydHMuQ29udHJhY3RGYWN0b3J5ID0gbGliXzgkNjtcblx0ZXhwb3J0cy5GaXhlZE51bWJlciA9IGxpYl8xMCQ0O1xuXHRleHBvcnRzLlNpZ25lciA9IGxpYl8yJG47XG5cdGV4cG9ydHMuVm9pZFNpZ25lciA9IGxpYl80JGU7XG5cdGV4cG9ydHMuV2FsbGV0ID0gbGliXzMkajtcblx0ZXhwb3J0cy5Xb3JkbGlzdCA9IGxpYl8xNyQxO1xuXHRleHBvcnRzLmNvbnN0YW50cyA9IGxpYl8xMSQzO1xuXHRleHBvcnRzLmRlZmF1bHQgPSBpbmRleCRwO1xuXHRleHBvcnRzLmVycm9ycyA9IGxpYl8xMiQzO1xuXHRleHBvcnRzLmV0aGVycyA9IGxpYl8xJHA7XG5cdGV4cG9ydHMuZ2V0RGVmYXVsdFByb3ZpZGVyID0gbGliXzUkZDtcblx0ZXhwb3J0cy5sb2dnZXIgPSBsaWJfMTMkMztcblx0ZXhwb3J0cy5wcm92aWRlcnMgPSBsaWJfNiQ4O1xuXHRleHBvcnRzLnV0aWxzID0gbGliXzE0JDI7XG5cdGV4cG9ydHMudmVyc2lvbiA9IGxpYl8xNiQyO1xuXHRleHBvcnRzLndvcmRsaXN0cyA9IGxpYl8xNSQyO1xuXG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbn0pKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///ebc9\n')},f633:function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nclass VotingEntity {\n    constructor(connector) {\n        this._connector = connector;\n    }\n}\nexports.default = VotingEntity;\n//# sourceMappingURL=VotingEntity.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L2VudGl0aWVzL1ZvdGluZ0VudGl0eS5qcz9mNjMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZjYzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgVm90aW5nRW50aXR5IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fY29ubmVjdG9yID0gY29ubmVjdG9yO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZvdGluZ0VudGl0eTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZvdGluZ0VudGl0eS5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///f633\n')},fe98:function(module,exports,__webpack_require__){"use strict";eval('\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { "default": mod };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nconst VotingEntity_1 = __importDefault(__webpack_require__("f633"));\nclass Vote extends VotingEntity_1.default {\n    constructor(data, connector) {\n        super(connector);\n        Object.assign(this, data);\n    }\n    async casts({ first = 1000, skip = 0 } = {}) {\n        return this._connector.castsForVote(this.id, first, skip);\n    }\n    onCasts(callback) {\n        return this._connector.onCastsForVote(this.id, callback);\n    }\n}\nexports.default = Vote;\n//# sourceMappingURL=Vote.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGFyYWdvbi9jb25uZWN0LXRoZWdyYXBoLXZvdGluZy9kaXN0L2VudGl0aWVzL1ZvdGUuanM/ZmU5OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQsdUNBQXVDLG1CQUFPLENBQUMsTUFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUIsS0FBSztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImZlOTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IFZvdGluZ0VudGl0eV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1ZvdGluZ0VudGl0eVwiKSk7XG5jbGFzcyBWb3RlIGV4dGVuZHMgVm90aW5nRW50aXR5XzEuZGVmYXVsdCB7XG4gICAgY29uc3RydWN0b3IoZGF0YSwgY29ubmVjdG9yKSB7XG4gICAgICAgIHN1cGVyKGNvbm5lY3Rvcik7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGF0YSk7XG4gICAgfVxuICAgIGFzeW5jIGNhc3RzKHsgZmlyc3QgPSAxMDAwLCBza2lwID0gMCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rvci5jYXN0c0ZvclZvdGUodGhpcy5pZCwgZmlyc3QsIHNraXApO1xuICAgIH1cbiAgICBvbkNhc3RzKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0b3Iub25DYXN0c0ZvclZvdGUodGhpcy5pZCwgY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFZvdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Wb3RlLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///fe98\n')}}]);