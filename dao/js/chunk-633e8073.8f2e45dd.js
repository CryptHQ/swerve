(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-633e8073"],{"1d17":function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Eth; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a67d");\n/* harmony import */ var _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("a8fc");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("901e");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var rlp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("a3ca");\n/* harmony import */ var rlp__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(rlp__WEBPACK_IMPORTED_MODULE_3__);\n/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n// FIXME drop:\n\n\n\n\n\nfunction hexBuffer(str) {\n  return Buffer.from(str.startsWith("0x") ? str.slice(2) : str, "hex");\n}\n\nfunction maybeHexBuffer(str) {\n  if (!str) return null;\n  return hexBuffer(str);\n}\n\nconst remapTransactionRelatedErrors = e => {\n  if (e && e.statusCode === 0x6a80) {\n    return new _ledgerhq_errors__WEBPACK_IMPORTED_MODULE_1__[/* EthAppPleaseEnableContractData */ "a"]("Please enable Contract data on the Ethereum app Settings");\n  }\n\n  return e;\n};\n/**\n * Ethereum API\n *\n * @example\n * import Eth from "@ledgerhq/hw-app-eth";\n * const eth = new Eth(transport)\n */\n\n\nclass Eth {\n  constructor(transport, scrambleKey = "w0w") {\n    this.transport = void 0;\n    this.transport = transport;\n    transport.decorateAppAPIMethods(this, ["getAddress", "provideERC20TokenInformation", "signTransaction", "signPersonalMessage", "getAppConfiguration", "starkGetPublicKey", "starkSignOrder", "starkSignTransfer", "starkProvideQuantum"], scrambleKey);\n  }\n  /**\n   * get Ethereum address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publicKey, address and (optionally) chainCode\n   * @example\n   * eth.getAddress("44\'/60\'/0\'/0/0").then(o => o.address)\n   */\n\n\n  getAddress(path, boolDisplay, boolChaincode) {\n    let paths = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* splitPath */ "b"])(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xe0, 0x02, boolDisplay ? 0x01 : 0x00, boolChaincode ? 0x01 : 0x00, buffer).then(response => {\n      let result = {};\n      let publicKeyLength = response[0];\n      let addressLength = response[1 + publicKeyLength];\n      result.publicKey = response.slice(1, 1 + publicKeyLength).toString("hex");\n      result.address = "0x" + response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength).toString("ascii");\n\n      if (boolChaincode) {\n        result.chainCode = response.slice(1 + publicKeyLength + 1 + addressLength, 1 + publicKeyLength + 1 + addressLength + 32).toString("hex");\n      }\n\n      return result;\n    });\n  }\n  /**\n   * This commands provides a trusted description of an ERC 20 token\n   * to associate a contract address with a ticker and number of decimals.\n   *\n   * It shall be run immediately before performing a transaction involving a contract\n   * calling this contract address to display the proper token information to the user if necessary.\n   *\n   * @param {*} info: a blob from "erc20.js" utilities that contains all token information.\n   *\n   * @example\n   * import { byContractAddress } from "@ledgerhq/hw-app-eth/erc20"\n   * const zrxInfo = byContractAddress("0xe41d2489571d322189246dafa5ebde1f4699f498")\n   * if (zrxInfo) await appEth.provideERC20TokenInformation(zrxInfo)\n   * const signed = await appEth.signTransaction(path, rawTxHex)\n   */\n\n\n  provideERC20TokenInformation({\n    data\n  }) {\n    return this.transport.send(0xe0, 0x0a, 0x00, 0x00, data).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for older version of ETH app, since older app version had the ERC20 data hardcoded, it\'s fine to assume it worked.\n        // we return a flag to know if the call was effective or not\n        return false;\n      }\n\n      throw e;\n    });\n  }\n  /**\n   * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign\n   * @example\n   eth.signTransaction("44\'/60\'/0\'/0/0", "e8018504e3b292008252089428ee52a8f3d6e5d15f8b131996950d7f296c7952872bd72a2487400080").then(result => ...)\n   */\n\n\n  signTransaction(path, rawTxHex) {\n    let paths = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* splitPath */ "b"])(path);\n    let offset = 0;\n    let rawTx = Buffer.from(rawTxHex, "hex");\n    let toSend = [];\n    let response; // Check if the TX is encoded following EIP 155\n\n    let rlpTx = Object(rlp__WEBPACK_IMPORTED_MODULE_3__["decode"])(rawTx);\n    let rlpOffset = 0;\n\n    if (rlpTx.length > 6) {\n      let rlpVrs = Object(rlp__WEBPACK_IMPORTED_MODULE_3__["encode"])(rlpTx.slice(-3));\n      rlpOffset = rawTx.length - (rlpVrs.length - 1);\n    }\n\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 : 150;\n      let chunkSize = offset + maxChunkSize > rawTx.length ? rawTx.length - offset : maxChunkSize;\n\n      if (rlpOffset != 0 && offset + chunkSize == rlpOffset) {\n        // Make sure that the chunk doesn\'t end right on the EIP 155 marker if set\n        chunkSize--;\n      }\n\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        rawTx.copy(buffer, 1 + 4 * paths.length, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* foreach */ "a"])(toSend, (data, i) => this.transport.send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response.slice(0, 1).toString("hex");\n      const r = response.slice(1, 1 + 32).toString("hex");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");\n      return {\n        v,\n        r,\n        s\n      };\n    }, e => {\n      throw remapTransactionRelatedErrors(e);\n    });\n  }\n  /**\n   */\n\n\n  getAppConfiguration() {\n    return this.transport.send(0xe0, 0x06, 0x00, 0x00).then(response => {\n      let result = {};\n      result.arbitraryDataEnabled = response[0] & 0x01;\n      result.erc20ProvisioningNecessary = response[0] & 0x02;\n      result.starkEnabled = response[0] & 0x04;\n      result.version = "" + response[1] + "." + response[2] + "." + response[3];\n      return result;\n    });\n  }\n  /**\n  * You can sign a message according to eth_sign RPC call and retrieve v, r, s given the message and the BIP 32 path of the account to sign.\n  * @example\n  eth.signPersonalMessage("44\'/60\'/0\'/0/0", Buffer.from("test").toString("hex")).then(result => {\n  var v = result[\'v\'] - 27;\n  v = v.toString(16);\n  if (v.length < 2) {\n    v = "0" + v;\n  }\n  console.log("Signature 0x" + result[\'r\'] + result[\'s\'] + v);\n  })\n   */\n\n\n  signPersonalMessage(path, messageHex) {\n    let paths = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* splitPath */ "b"])(path);\n    let offset = 0;\n    let message = Buffer.from(messageHex, "hex");\n    let toSend = [];\n    let response;\n\n    while (offset !== message.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4 : 150;\n      let chunkSize = offset + maxChunkSize > message.length ? message.length - offset : maxChunkSize;\n      let buffer = Buffer.alloc(offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize);\n\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(message.length, 1 + 4 * paths.length);\n        message.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        message.copy(buffer, 0, offset, offset + chunkSize);\n      }\n\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n\n    return Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* foreach */ "a"])(toSend, (data, i) => this.transport.send(0xe0, 0x08, i === 0 ? 0x00 : 0x80, 0x00, data).then(apduResponse => {\n      response = apduResponse;\n    })).then(() => {\n      const v = response[0];\n      const r = response.slice(1, 1 + 32).toString("hex");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");\n      return {\n        v,\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * get Stark public key for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @return the Stark public key\n   */\n\n\n  starkGetPublicKey(path, boolDisplay) {\n    let paths = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* splitPath */ "b"])(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport.send(0xf0, 0x02, boolDisplay ? 0x01 : 0x00, 0x00, buffer).then(response => {\n      return response.slice(0, response.length - 2);\n    });\n  }\n  /**\n   * sign a Stark order\n   * @param path a path in BIP 32 format\n   * @option sourceTokenAddress contract address of the source token (not present for ETH)\n   * @param sourceQuantization quantization used for the source token\n   * @option destinationTokenAddress contract address of the destination token (not present for ETH)\n   * @param destinationQuantization quantization used for the destination token\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountSell amount to sell\n   * @param amountBuy amount to buy\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignOrder(path, sourceTokenAddress, sourceQuantization, destinationTokenAddress, destinationQuantization, sourceVault, destinationVault, amountSell, amountBuy, nonce, timestamp) {\n    const sourceTokenAddressHex = maybeHexBuffer(sourceTokenAddress);\n    const destinationTokenAddressHex = maybeHexBuffer(destinationTokenAddress);\n    let paths = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* splitPath */ "b"])(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 20 + 32 + 4 + 4 + 8 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (sourceTokenAddressHex) {\n      sourceTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(sourceQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);\n    offset += 32;\n\n    if (destinationTokenAddressHex) {\n      destinationTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(destinationQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountSell.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);\n    offset += 8;\n    Buffer.from(amountBuy.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x01, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString("hex");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * sign a Stark transfer\n   * @param path a path in BIP 32 format\n   * @option transferTokenAddress contract address of the token to be transferred (not present for ETH)\n   * @param transferQuantization quantization used for the token to be transferred\n   * @param targetPublicKey target Stark public key\n   * @param sourceVault ID of the source vault\n   * @param destinationVault ID of the destination vault\n   * @param amountTransfer amount to transfer\n   * @param nonce transaction nonce\n   * @param timestamp transaction validity timestamp\n   * @return the signature\n   */\n\n\n  starkSignTransfer(path, transferTokenAddress, transferQuantization, targetPublicKey, sourceVault, destinationVault, amountTransfer, nonce, timestamp) {\n    const transferTokenAddressHex = maybeHexBuffer(transferTokenAddress);\n    const targetPublicKeyHex = hexBuffer(targetPublicKey);\n    let paths = Object(_utils__WEBPACK_IMPORTED_MODULE_0__[/* splitPath */ "b"])(path);\n    let buffer = Buffer.alloc(1 + paths.length * 4 + 20 + 32 + 32 + 4 + 4 + 8 + 4 + 4, 0);\n    let offset = 0;\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    offset = 1 + 4 * paths.length;\n\n    if (transferTokenAddressHex) {\n      transferTokenAddressHex.copy(buffer, offset);\n    }\n\n    offset += 20;\n    Buffer.from(transferQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, offset);\n    offset += 32;\n    targetPublicKeyHex.copy(buffer, offset);\n    offset += 32;\n    buffer.writeUInt32BE(sourceVault, offset);\n    offset += 4;\n    buffer.writeUInt32BE(destinationVault, offset);\n    offset += 4;\n    Buffer.from(amountTransfer.toString(16).padStart(16, "0"), "hex").copy(buffer, offset);\n    offset += 8;\n    buffer.writeUInt32BE(nonce, offset);\n    offset += 4;\n    buffer.writeUInt32BE(timestamp, offset);\n    return this.transport.send(0xf0, 0x04, 0x02, 0x00, buffer).then(response => {\n      const r = response.slice(1, 1 + 32).toString("hex");\n      const s = response.slice(1 + 32, 1 + 32 + 32).toString("hex");\n      return {\n        r,\n        s\n      };\n    });\n  }\n  /**\n   * provide quantization information before singing a deposit or withdrawal Stark powered contract call\n   *\n   * It shall be run following a provideERC20TokenInformation call for the given contract\n   *\n   * @param operationContract contract address of the token to be transferred (not present for ETH)\n   * @param operationQuantization quantization used for the token to be transferred\n   */\n\n\n  starkProvideQuantum(operationContract, operationQuantization) {\n    const operationContractHex = maybeHexBuffer(operationContract);\n    let buffer = Buffer.alloc(20 + 32, 0);\n\n    if (operationContractHex) {\n      operationContractHex.copy(buffer, 0);\n    }\n\n    Buffer.from(operationQuantization.toString(16).padStart(64, "0"), "hex").copy(buffer, 20);\n    return this.transport.send(0xf0, 0x08, 0x00, 0x00, buffer).then(() => true, e => {\n      if (e && e.statusCode === 0x6d00) {\n        // this case happen for ETH application versions not supporting Stark extensions\n        return false;\n      }\n\n      throw e;\n    });\n  }\n\n}\n//# sourceMappingURL=Eth.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("1c35").Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxlZGdlcmhxL2h3LWFwcC1ldGgvbGliLWVzL0V0aC5qcz8xZDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzZDO0FBQ3FCO0FBQ3pCO0FBQ0o7O0FBRXJDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSx1RkFBOEI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsZ0JBQWdCLGdFQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQixnRUFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCLGdCQUFnQixrREFBTTtBQUN0Qjs7QUFFQTtBQUNBLG1CQUFtQixrREFBTTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLDhEQUFPO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0EsZ0JBQWdCLGdFQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyw4REFBTztBQUNsQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGdCQUFnQixnRUFBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0VBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsK0IiLCJmaWxlIjoiMWQxNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBMZWRnZXIgTm9kZSBKUyBBUElcbiAqICAgKGMpIDIwMTYtMjAxNyBMZWRnZXJcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyBGSVhNRSBkcm9wOlxuaW1wb3J0IHsgc3BsaXRQYXRoLCBmb3JlYWNoIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IEV0aEFwcFBsZWFzZUVuYWJsZUNvbnRyYWN0RGF0YSB9IGZyb20gXCJAbGVkZ2VyaHEvZXJyb3JzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiYmlnbnVtYmVyLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gXCJybHBcIjtcblxuZnVuY3Rpb24gaGV4QnVmZmVyKHN0cikge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLnN0YXJ0c1dpdGgoXCIweFwiKSA/IHN0ci5zbGljZSgyKSA6IHN0ciwgXCJoZXhcIik7XG59XG5cbmZ1bmN0aW9uIG1heWJlSGV4QnVmZmVyKHN0cikge1xuICBpZiAoIXN0cikgcmV0dXJuIG51bGw7XG4gIHJldHVybiBoZXhCdWZmZXIoc3RyKTtcbn1cblxuY29uc3QgcmVtYXBUcmFuc2FjdGlvblJlbGF0ZWRFcnJvcnMgPSBlID0+IHtcbiAgaWYgKGUgJiYgZS5zdGF0dXNDb2RlID09PSAweDZhODApIHtcbiAgICByZXR1cm4gbmV3IEV0aEFwcFBsZWFzZUVuYWJsZUNvbnRyYWN0RGF0YShcIlBsZWFzZSBlbmFibGUgQ29udHJhY3QgZGF0YSBvbiB0aGUgRXRoZXJldW0gYXBwIFNldHRpbmdzXCIpO1xuICB9XG5cbiAgcmV0dXJuIGU7XG59O1xuLyoqXG4gKiBFdGhlcmV1bSBBUElcbiAqXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IEV0aCBmcm9tIFwiQGxlZGdlcmhxL2h3LWFwcC1ldGhcIjtcbiAqIGNvbnN0IGV0aCA9IG5ldyBFdGgodHJhbnNwb3J0KVxuICovXG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRXRoIHtcbiAgY29uc3RydWN0b3IodHJhbnNwb3J0LCBzY3JhbWJsZUtleSA9IFwidzB3XCIpIHtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHZvaWQgMDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0cmFuc3BvcnQuZGVjb3JhdGVBcHBBUElNZXRob2RzKHRoaXMsIFtcImdldEFkZHJlc3NcIiwgXCJwcm92aWRlRVJDMjBUb2tlbkluZm9ybWF0aW9uXCIsIFwic2lnblRyYW5zYWN0aW9uXCIsIFwic2lnblBlcnNvbmFsTWVzc2FnZVwiLCBcImdldEFwcENvbmZpZ3VyYXRpb25cIiwgXCJzdGFya0dldFB1YmxpY0tleVwiLCBcInN0YXJrU2lnbk9yZGVyXCIsIFwic3RhcmtTaWduVHJhbnNmZXJcIiwgXCJzdGFya1Byb3ZpZGVRdWFudHVtXCJdLCBzY3JhbWJsZUtleSk7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBFdGhlcmV1bSBhZGRyZXNzIGZvciBhIGdpdmVuIEJJUCAzMiBwYXRoLlxuICAgKiBAcGFyYW0gcGF0aCBhIHBhdGggaW4gQklQIDMyIGZvcm1hdFxuICAgKiBAb3B0aW9uIGJvb2xEaXNwbGF5IG9wdGlvbmFsbHkgZW5hYmxlIG9yIG5vdCB0aGUgZGlzcGxheVxuICAgKiBAb3B0aW9uIGJvb2xDaGFpbmNvZGUgb3B0aW9uYWxseSBlbmFibGUgb3Igbm90IHRoZSBjaGFpbmNvZGUgcmVxdWVzdFxuICAgKiBAcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgcHVibGljS2V5LCBhZGRyZXNzIGFuZCAob3B0aW9uYWxseSkgY2hhaW5Db2RlXG4gICAqIEBleGFtcGxlXG4gICAqIGV0aC5nZXRBZGRyZXNzKFwiNDQnLzYwJy8wJy8wLzBcIikudGhlbihvID0+IG8uYWRkcmVzcylcbiAgICovXG5cblxuICBnZXRBZGRyZXNzKHBhdGgsIGJvb2xEaXNwbGF5LCBib29sQ2hhaW5jb2RlKSB7XG4gICAgbGV0IHBhdGhzID0gc3BsaXRQYXRoKHBhdGgpO1xuICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMSArIHBhdGhzLmxlbmd0aCAqIDQpO1xuICAgIGJ1ZmZlclswXSA9IHBhdGhzLmxlbmd0aDtcbiAgICBwYXRocy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoZWxlbWVudCwgMSArIDQgKiBpbmRleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LnNlbmQoMHhlMCwgMHgwMiwgYm9vbERpc3BsYXkgPyAweDAxIDogMHgwMCwgYm9vbENoYWluY29kZSA/IDB4MDEgOiAweDAwLCBidWZmZXIpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgbGV0IHB1YmxpY0tleUxlbmd0aCA9IHJlc3BvbnNlWzBdO1xuICAgICAgbGV0IGFkZHJlc3NMZW5ndGggPSByZXNwb25zZVsxICsgcHVibGljS2V5TGVuZ3RoXTtcbiAgICAgIHJlc3VsdC5wdWJsaWNLZXkgPSByZXNwb25zZS5zbGljZSgxLCAxICsgcHVibGljS2V5TGVuZ3RoKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIHJlc3VsdC5hZGRyZXNzID0gXCIweFwiICsgcmVzcG9uc2Uuc2xpY2UoMSArIHB1YmxpY0tleUxlbmd0aCArIDEsIDEgKyBwdWJsaWNLZXlMZW5ndGggKyAxICsgYWRkcmVzc0xlbmd0aCkudG9TdHJpbmcoXCJhc2NpaVwiKTtcblxuICAgICAgaWYgKGJvb2xDaGFpbmNvZGUpIHtcbiAgICAgICAgcmVzdWx0LmNoYWluQ29kZSA9IHJlc3BvbnNlLnNsaWNlKDEgKyBwdWJsaWNLZXlMZW5ndGggKyAxICsgYWRkcmVzc0xlbmd0aCwgMSArIHB1YmxpY0tleUxlbmd0aCArIDEgKyBhZGRyZXNzTGVuZ3RoICsgMzIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaGlzIGNvbW1hbmRzIHByb3ZpZGVzIGEgdHJ1c3RlZCBkZXNjcmlwdGlvbiBvZiBhbiBFUkMgMjAgdG9rZW5cbiAgICogdG8gYXNzb2NpYXRlIGEgY29udHJhY3QgYWRkcmVzcyB3aXRoIGEgdGlja2VyIGFuZCBudW1iZXIgb2YgZGVjaW1hbHMuXG4gICAqXG4gICAqIEl0IHNoYWxsIGJlIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgcGVyZm9ybWluZyBhIHRyYW5zYWN0aW9uIGludm9sdmluZyBhIGNvbnRyYWN0XG4gICAqIGNhbGxpbmcgdGhpcyBjb250cmFjdCBhZGRyZXNzIHRvIGRpc3BsYXkgdGhlIHByb3BlciB0b2tlbiBpbmZvcm1hdGlvbiB0byB0aGUgdXNlciBpZiBuZWNlc3NhcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gaW5mbzogYSBibG9iIGZyb20gXCJlcmMyMC5qc1wiIHV0aWxpdGllcyB0aGF0IGNvbnRhaW5zIGFsbCB0b2tlbiBpbmZvcm1hdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogaW1wb3J0IHsgYnlDb250cmFjdEFkZHJlc3MgfSBmcm9tIFwiQGxlZGdlcmhxL2h3LWFwcC1ldGgvZXJjMjBcIlxuICAgKiBjb25zdCB6cnhJbmZvID0gYnlDb250cmFjdEFkZHJlc3MoXCIweGU0MWQyNDg5NTcxZDMyMjE4OTI0NmRhZmE1ZWJkZTFmNDY5OWY0OThcIilcbiAgICogaWYgKHpyeEluZm8pIGF3YWl0IGFwcEV0aC5wcm92aWRlRVJDMjBUb2tlbkluZm9ybWF0aW9uKHpyeEluZm8pXG4gICAqIGNvbnN0IHNpZ25lZCA9IGF3YWl0IGFwcEV0aC5zaWduVHJhbnNhY3Rpb24ocGF0aCwgcmF3VHhIZXgpXG4gICAqL1xuXG5cbiAgcHJvdmlkZUVSQzIwVG9rZW5JbmZvcm1hdGlvbih7XG4gICAgZGF0YVxuICB9KSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LnNlbmQoMHhlMCwgMHgwYSwgMHgwMCwgMHgwMCwgZGF0YSkudGhlbigoKSA9PiB0cnVlLCBlID0+IHtcbiAgICAgIGlmIChlICYmIGUuc3RhdHVzQ29kZSA9PT0gMHg2ZDAwKSB7XG4gICAgICAgIC8vIHRoaXMgY2FzZSBoYXBwZW4gZm9yIG9sZGVyIHZlcnNpb24gb2YgRVRIIGFwcCwgc2luY2Ugb2xkZXIgYXBwIHZlcnNpb24gaGFkIHRoZSBFUkMyMCBkYXRhIGhhcmRjb2RlZCwgaXQncyBmaW5lIHRvIGFzc3VtZSBpdCB3b3JrZWQuXG4gICAgICAgIC8vIHdlIHJldHVybiBhIGZsYWcgdG8ga25vdyBpZiB0aGUgY2FsbCB3YXMgZWZmZWN0aXZlIG9yIG5vdFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFlvdSBjYW4gc2lnbiBhIHRyYW5zYWN0aW9uIGFuZCByZXRyaWV2ZSB2LCByLCBzIGdpdmVuIHRoZSByYXcgdHJhbnNhY3Rpb24gYW5kIHRoZSBCSVAgMzIgcGF0aCBvZiB0aGUgYWNjb3VudCB0byBzaWduXG4gICAqIEBleGFtcGxlXG4gICBldGguc2lnblRyYW5zYWN0aW9uKFwiNDQnLzYwJy8wJy8wLzBcIiwgXCJlODAxODUwNGUzYjI5MjAwODI1MjA4OTQyOGVlNTJhOGYzZDZlNWQxNWY4YjEzMTk5Njk1MGQ3ZjI5NmM3OTUyODcyYmQ3MmEyNDg3NDAwMDgwXCIpLnRoZW4ocmVzdWx0ID0+IC4uLilcbiAgICovXG5cblxuICBzaWduVHJhbnNhY3Rpb24ocGF0aCwgcmF3VHhIZXgpIHtcbiAgICBsZXQgcGF0aHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgbGV0IHJhd1R4ID0gQnVmZmVyLmZyb20ocmF3VHhIZXgsIFwiaGV4XCIpO1xuICAgIGxldCB0b1NlbmQgPSBbXTtcbiAgICBsZXQgcmVzcG9uc2U7IC8vIENoZWNrIGlmIHRoZSBUWCBpcyBlbmNvZGVkIGZvbGxvd2luZyBFSVAgMTU1XG5cbiAgICBsZXQgcmxwVHggPSBkZWNvZGUocmF3VHgpO1xuICAgIGxldCBybHBPZmZzZXQgPSAwO1xuXG4gICAgaWYgKHJscFR4Lmxlbmd0aCA+IDYpIHtcbiAgICAgIGxldCBybHBWcnMgPSBlbmNvZGUocmxwVHguc2xpY2UoLTMpKTtcbiAgICAgIHJscE9mZnNldCA9IHJhd1R4Lmxlbmd0aCAtIChybHBWcnMubGVuZ3RoIC0gMSk7XG4gICAgfVxuXG4gICAgd2hpbGUgKG9mZnNldCAhPT0gcmF3VHgubGVuZ3RoKSB7XG4gICAgICBsZXQgbWF4Q2h1bmtTaXplID0gb2Zmc2V0ID09PSAwID8gMTUwIC0gMSAtIHBhdGhzLmxlbmd0aCAqIDQgOiAxNTA7XG4gICAgICBsZXQgY2h1bmtTaXplID0gb2Zmc2V0ICsgbWF4Q2h1bmtTaXplID4gcmF3VHgubGVuZ3RoID8gcmF3VHgubGVuZ3RoIC0gb2Zmc2V0IDogbWF4Q2h1bmtTaXplO1xuXG4gICAgICBpZiAocmxwT2Zmc2V0ICE9IDAgJiYgb2Zmc2V0ICsgY2h1bmtTaXplID09IHJscE9mZnNldCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgY2h1bmsgZG9lc24ndCBlbmQgcmlnaHQgb24gdGhlIEVJUCAxNTUgbWFya2VyIGlmIHNldFxuICAgICAgICBjaHVua1NpemUtLTtcbiAgICAgIH1cblxuICAgICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhvZmZzZXQgPT09IDAgPyAxICsgcGF0aHMubGVuZ3RoICogNCArIGNodW5rU2l6ZSA6IGNodW5rU2l6ZSk7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgYnVmZmVyWzBdID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICBwYXRocy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGVsZW1lbnQsIDEgKyA0ICogaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmF3VHguY29weShidWZmZXIsIDEgKyA0ICogcGF0aHMubGVuZ3RoLCBvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYXdUeC5jb3B5KGJ1ZmZlciwgMCwgb2Zmc2V0LCBvZmZzZXQgKyBjaHVua1NpemUpO1xuICAgICAgfVxuXG4gICAgICB0b1NlbmQucHVzaChidWZmZXIpO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZm9yZWFjaCh0b1NlbmQsIChkYXRhLCBpKSA9PiB0aGlzLnRyYW5zcG9ydC5zZW5kKDB4ZTAsIDB4MDQsIGkgPT09IDAgPyAweDAwIDogMHg4MCwgMHgwMCwgZGF0YSkudGhlbihhcGR1UmVzcG9uc2UgPT4ge1xuICAgICAgcmVzcG9uc2UgPSBhcGR1UmVzcG9uc2U7XG4gICAgfSkpLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgdiA9IHJlc3BvbnNlLnNsaWNlKDAsIDEpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgY29uc3QgciA9IHJlc3BvbnNlLnNsaWNlKDEsIDEgKyAzMikudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICBjb25zdCBzID0gcmVzcG9uc2Uuc2xpY2UoMSArIDMyLCAxICsgMzIgKyAzMikudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2LFxuICAgICAgICByLFxuICAgICAgICBzXG4gICAgICB9O1xuICAgIH0sIGUgPT4ge1xuICAgICAgdGhyb3cgcmVtYXBUcmFuc2FjdGlvblJlbGF0ZWRFcnJvcnMoZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqL1xuXG5cbiAgZ2V0QXBwQ29uZmlndXJhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuc2VuZCgweGUwLCAweDA2LCAweDAwLCAweDAwKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdC5hcmJpdHJhcnlEYXRhRW5hYmxlZCA9IHJlc3BvbnNlWzBdICYgMHgwMTtcbiAgICAgIHJlc3VsdC5lcmMyMFByb3Zpc2lvbmluZ05lY2Vzc2FyeSA9IHJlc3BvbnNlWzBdICYgMHgwMjtcbiAgICAgIHJlc3VsdC5zdGFya0VuYWJsZWQgPSByZXNwb25zZVswXSAmIDB4MDQ7XG4gICAgICByZXN1bHQudmVyc2lvbiA9IFwiXCIgKyByZXNwb25zZVsxXSArIFwiLlwiICsgcmVzcG9uc2VbMl0gKyBcIi5cIiArIHJlc3BvbnNlWzNdO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgKiBZb3UgY2FuIHNpZ24gYSBtZXNzYWdlIGFjY29yZGluZyB0byBldGhfc2lnbiBSUEMgY2FsbCBhbmQgcmV0cmlldmUgdiwgciwgcyBnaXZlbiB0aGUgbWVzc2FnZSBhbmQgdGhlIEJJUCAzMiBwYXRoIG9mIHRoZSBhY2NvdW50IHRvIHNpZ24uXG4gICogQGV4YW1wbGVcbiAgZXRoLnNpZ25QZXJzb25hbE1lc3NhZ2UoXCI0NCcvNjAnLzAnLzAvMFwiLCBCdWZmZXIuZnJvbShcInRlc3RcIikudG9TdHJpbmcoXCJoZXhcIikpLnRoZW4ocmVzdWx0ID0+IHtcbiAgdmFyIHYgPSByZXN1bHRbJ3YnXSAtIDI3O1xuICB2ID0gdi50b1N0cmluZygxNik7XG4gIGlmICh2Lmxlbmd0aCA8IDIpIHtcbiAgICB2ID0gXCIwXCIgKyB2O1xuICB9XG4gIGNvbnNvbGUubG9nKFwiU2lnbmF0dXJlIDB4XCIgKyByZXN1bHRbJ3InXSArIHJlc3VsdFsncyddICsgdik7XG4gIH0pXG4gICAqL1xuXG5cbiAgc2lnblBlcnNvbmFsTWVzc2FnZShwYXRoLCBtZXNzYWdlSGV4KSB7XG4gICAgbGV0IHBhdGhzID0gc3BsaXRQYXRoKHBhdGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZUhleCwgXCJoZXhcIik7XG4gICAgbGV0IHRvU2VuZCA9IFtdO1xuICAgIGxldCByZXNwb25zZTtcblxuICAgIHdoaWxlIChvZmZzZXQgIT09IG1lc3NhZ2UubGVuZ3RoKSB7XG4gICAgICBsZXQgbWF4Q2h1bmtTaXplID0gb2Zmc2V0ID09PSAwID8gMTUwIC0gMSAtIHBhdGhzLmxlbmd0aCAqIDQgLSA0IDogMTUwO1xuICAgICAgbGV0IGNodW5rU2l6ZSA9IG9mZnNldCArIG1heENodW5rU2l6ZSA+IG1lc3NhZ2UubGVuZ3RoID8gbWVzc2FnZS5sZW5ndGggLSBvZmZzZXQgOiBtYXhDaHVua1NpemU7XG4gICAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKG9mZnNldCA9PT0gMCA/IDEgKyBwYXRocy5sZW5ndGggKiA0ICsgNCArIGNodW5rU2l6ZSA6IGNodW5rU2l6ZSk7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgYnVmZmVyWzBdID0gcGF0aHMubGVuZ3RoO1xuICAgICAgICBwYXRocy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGVsZW1lbnQsIDEgKyA0ICogaW5kZXgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUobWVzc2FnZS5sZW5ndGgsIDEgKyA0ICogcGF0aHMubGVuZ3RoKTtcbiAgICAgICAgbWVzc2FnZS5jb3B5KGJ1ZmZlciwgMSArIDQgKiBwYXRocy5sZW5ndGggKyA0LCBvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlLmNvcHkoYnVmZmVyLCAwLCBvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIHRvU2VuZC5wdXNoKGJ1ZmZlcik7XG4gICAgICBvZmZzZXQgKz0gY2h1bmtTaXplO1xuICAgIH1cblxuICAgIHJldHVybiBmb3JlYWNoKHRvU2VuZCwgKGRhdGEsIGkpID0+IHRoaXMudHJhbnNwb3J0LnNlbmQoMHhlMCwgMHgwOCwgaSA9PT0gMCA/IDB4MDAgOiAweDgwLCAweDAwLCBkYXRhKS50aGVuKGFwZHVSZXNwb25zZSA9PiB7XG4gICAgICByZXNwb25zZSA9IGFwZHVSZXNwb25zZTtcbiAgICB9KSkudGhlbigoKSA9PiB7XG4gICAgICBjb25zdCB2ID0gcmVzcG9uc2VbMF07XG4gICAgICBjb25zdCByID0gcmVzcG9uc2Uuc2xpY2UoMSwgMSArIDMyKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIGNvbnN0IHMgPSByZXNwb25zZS5zbGljZSgxICsgMzIsIDEgKyAzMiArIDMyKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHYsXG4gICAgICAgIHIsXG4gICAgICAgIHNcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGdldCBTdGFyayBwdWJsaWMga2V5IGZvciBhIGdpdmVuIEJJUCAzMiBwYXRoLlxuICAgKiBAcGFyYW0gcGF0aCBhIHBhdGggaW4gQklQIDMyIGZvcm1hdFxuICAgKiBAb3B0aW9uIGJvb2xEaXNwbGF5IG9wdGlvbmFsbHkgZW5hYmxlIG9yIG5vdCB0aGUgZGlzcGxheVxuICAgKiBAcmV0dXJuIHRoZSBTdGFyayBwdWJsaWMga2V5XG4gICAqL1xuXG5cbiAgc3RhcmtHZXRQdWJsaWNLZXkocGF0aCwgYm9vbERpc3BsYXkpIHtcbiAgICBsZXQgcGF0aHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gICAgbGV0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxICsgcGF0aHMubGVuZ3RoICogNCk7XG4gICAgYnVmZmVyWzBdID0gcGF0aHMubGVuZ3RoO1xuICAgIHBhdGhzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBidWZmZXIud3JpdGVVSW50MzJCRShlbGVtZW50LCAxICsgNCAqIGluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQuc2VuZCgweGYwLCAweDAyLCBib29sRGlzcGxheSA/IDB4MDEgOiAweDAwLCAweDAwLCBidWZmZXIpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLnNsaWNlKDAsIHJlc3BvbnNlLmxlbmd0aCAtIDIpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBzaWduIGEgU3Rhcmsgb3JkZXJcbiAgICogQHBhcmFtIHBhdGggYSBwYXRoIGluIEJJUCAzMiBmb3JtYXRcbiAgICogQG9wdGlvbiBzb3VyY2VUb2tlbkFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgc291cmNlIHRva2VuIChub3QgcHJlc2VudCBmb3IgRVRIKVxuICAgKiBAcGFyYW0gc291cmNlUXVhbnRpemF0aW9uIHF1YW50aXphdGlvbiB1c2VkIGZvciB0aGUgc291cmNlIHRva2VuXG4gICAqIEBvcHRpb24gZGVzdGluYXRpb25Ub2tlbkFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgZGVzdGluYXRpb24gdG9rZW4gKG5vdCBwcmVzZW50IGZvciBFVEgpXG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvblF1YW50aXphdGlvbiBxdWFudGl6YXRpb24gdXNlZCBmb3IgdGhlIGRlc3RpbmF0aW9uIHRva2VuXG4gICAqIEBwYXJhbSBzb3VyY2VWYXVsdCBJRCBvZiB0aGUgc291cmNlIHZhdWx0XG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvblZhdWx0IElEIG9mIHRoZSBkZXN0aW5hdGlvbiB2YXVsdFxuICAgKiBAcGFyYW0gYW1vdW50U2VsbCBhbW91bnQgdG8gc2VsbFxuICAgKiBAcGFyYW0gYW1vdW50QnV5IGFtb3VudCB0byBidXlcbiAgICogQHBhcmFtIG5vbmNlIHRyYW5zYWN0aW9uIG5vbmNlXG4gICAqIEBwYXJhbSB0aW1lc3RhbXAgdHJhbnNhY3Rpb24gdmFsaWRpdHkgdGltZXN0YW1wXG4gICAqIEByZXR1cm4gdGhlIHNpZ25hdHVyZVxuICAgKi9cblxuXG4gIHN0YXJrU2lnbk9yZGVyKHBhdGgsIHNvdXJjZVRva2VuQWRkcmVzcywgc291cmNlUXVhbnRpemF0aW9uLCBkZXN0aW5hdGlvblRva2VuQWRkcmVzcywgZGVzdGluYXRpb25RdWFudGl6YXRpb24sIHNvdXJjZVZhdWx0LCBkZXN0aW5hdGlvblZhdWx0LCBhbW91bnRTZWxsLCBhbW91bnRCdXksIG5vbmNlLCB0aW1lc3RhbXApIHtcbiAgICBjb25zdCBzb3VyY2VUb2tlbkFkZHJlc3NIZXggPSBtYXliZUhleEJ1ZmZlcihzb3VyY2VUb2tlbkFkZHJlc3MpO1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uVG9rZW5BZGRyZXNzSGV4ID0gbWF5YmVIZXhCdWZmZXIoZGVzdGluYXRpb25Ub2tlbkFkZHJlc3MpO1xuICAgIGxldCBwYXRocyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEgKyBwYXRocy5sZW5ndGggKiA0ICsgMjAgKyAzMiArIDIwICsgMzIgKyA0ICsgNCArIDggKyA4ICsgNCArIDQsIDApO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGJ1ZmZlclswXSA9IHBhdGhzLmxlbmd0aDtcbiAgICBwYXRocy5mb3JFYWNoKChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoZWxlbWVudCwgMSArIDQgKiBpbmRleCk7XG4gICAgfSk7XG4gICAgb2Zmc2V0ID0gMSArIDQgKiBwYXRocy5sZW5ndGg7XG5cbiAgICBpZiAoc291cmNlVG9rZW5BZGRyZXNzSGV4KSB7XG4gICAgICBzb3VyY2VUb2tlbkFkZHJlc3NIZXguY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IDIwO1xuICAgIEJ1ZmZlci5mcm9tKHNvdXJjZVF1YW50aXphdGlvbi50b1N0cmluZygxNikucGFkU3RhcnQoNjQsIFwiMFwiKSwgXCJoZXhcIikuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDMyO1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uVG9rZW5BZGRyZXNzSGV4KSB7XG4gICAgICBkZXN0aW5hdGlvblRva2VuQWRkcmVzc0hleC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICB9XG5cbiAgICBvZmZzZXQgKz0gMjA7XG4gICAgQnVmZmVyLmZyb20oZGVzdGluYXRpb25RdWFudGl6YXRpb24udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCBcIjBcIiksIFwiaGV4XCIpLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSAzMjtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShzb3VyY2VWYXVsdCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShkZXN0aW5hdGlvblZhdWx0LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIEJ1ZmZlci5mcm9tKGFtb3VudFNlbGwudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCBcIjBcIiksIFwiaGV4XCIpLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA4O1xuICAgIEJ1ZmZlci5mcm9tKGFtb3VudEJ1eS50b1N0cmluZygxNikucGFkU3RhcnQoMTYsIFwiMFwiKSwgXCJoZXhcIikuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDg7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUobm9uY2UsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgYnVmZmVyLndyaXRlVUludDMyQkUodGltZXN0YW1wLCBvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzLnRyYW5zcG9ydC5zZW5kKDB4ZjAsIDB4MDQsIDB4MDEsIDB4MDAsIGJ1ZmZlcikudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCByID0gcmVzcG9uc2Uuc2xpY2UoMSwgMSArIDMyKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIGNvbnN0IHMgPSByZXNwb25zZS5zbGljZSgxICsgMzIsIDEgKyAzMiArIDMyKS50b1N0cmluZyhcImhleFwiKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHIsXG4gICAgICAgIHNcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHNpZ24gYSBTdGFyayB0cmFuc2ZlclxuICAgKiBAcGFyYW0gcGF0aCBhIHBhdGggaW4gQklQIDMyIGZvcm1hdFxuICAgKiBAb3B0aW9uIHRyYW5zZmVyVG9rZW5BZGRyZXNzIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIHRva2VuIHRvIGJlIHRyYW5zZmVycmVkIChub3QgcHJlc2VudCBmb3IgRVRIKVxuICAgKiBAcGFyYW0gdHJhbnNmZXJRdWFudGl6YXRpb24gcXVhbnRpemF0aW9uIHVzZWQgZm9yIHRoZSB0b2tlbiB0byBiZSB0cmFuc2ZlcnJlZFxuICAgKiBAcGFyYW0gdGFyZ2V0UHVibGljS2V5IHRhcmdldCBTdGFyayBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBzb3VyY2VWYXVsdCBJRCBvZiB0aGUgc291cmNlIHZhdWx0XG4gICAqIEBwYXJhbSBkZXN0aW5hdGlvblZhdWx0IElEIG9mIHRoZSBkZXN0aW5hdGlvbiB2YXVsdFxuICAgKiBAcGFyYW0gYW1vdW50VHJhbnNmZXIgYW1vdW50IHRvIHRyYW5zZmVyXG4gICAqIEBwYXJhbSBub25jZSB0cmFuc2FjdGlvbiBub25jZVxuICAgKiBAcGFyYW0gdGltZXN0YW1wIHRyYW5zYWN0aW9uIHZhbGlkaXR5IHRpbWVzdGFtcFxuICAgKiBAcmV0dXJuIHRoZSBzaWduYXR1cmVcbiAgICovXG5cblxuICBzdGFya1NpZ25UcmFuc2ZlcihwYXRoLCB0cmFuc2ZlclRva2VuQWRkcmVzcywgdHJhbnNmZXJRdWFudGl6YXRpb24sIHRhcmdldFB1YmxpY0tleSwgc291cmNlVmF1bHQsIGRlc3RpbmF0aW9uVmF1bHQsIGFtb3VudFRyYW5zZmVyLCBub25jZSwgdGltZXN0YW1wKSB7XG4gICAgY29uc3QgdHJhbnNmZXJUb2tlbkFkZHJlc3NIZXggPSBtYXliZUhleEJ1ZmZlcih0cmFuc2ZlclRva2VuQWRkcmVzcyk7XG4gICAgY29uc3QgdGFyZ2V0UHVibGljS2V5SGV4ID0gaGV4QnVmZmVyKHRhcmdldFB1YmxpY0tleSk7XG4gICAgbGV0IHBhdGhzID0gc3BsaXRQYXRoKHBhdGgpO1xuICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMSArIHBhdGhzLmxlbmd0aCAqIDQgKyAyMCArIDMyICsgMzIgKyA0ICsgNCArIDggKyA0ICsgNCwgMCk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgYnVmZmVyWzBdID0gcGF0aHMubGVuZ3RoO1xuICAgIHBhdGhzLmZvckVhY2goKGVsZW1lbnQsIGluZGV4KSA9PiB7XG4gICAgICBidWZmZXIud3JpdGVVSW50MzJCRShlbGVtZW50LCAxICsgNCAqIGluZGV4KTtcbiAgICB9KTtcbiAgICBvZmZzZXQgPSAxICsgNCAqIHBhdGhzLmxlbmd0aDtcblxuICAgIGlmICh0cmFuc2ZlclRva2VuQWRkcmVzc0hleCkge1xuICAgICAgdHJhbnNmZXJUb2tlbkFkZHJlc3NIZXguY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IDIwO1xuICAgIEJ1ZmZlci5mcm9tKHRyYW5zZmVyUXVhbnRpemF0aW9uLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg2NCwgXCIwXCIpLCBcImhleFwiKS5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gMzI7XG4gICAgdGFyZ2V0UHVibGljS2V5SGV4LmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSAzMjtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShzb3VyY2VWYXVsdCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShkZXN0aW5hdGlvblZhdWx0LCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIEJ1ZmZlci5mcm9tKGFtb3VudFRyYW5zZmVyLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgxNiwgXCIwXCIpLCBcImhleFwiKS5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gODtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRShub25jZSwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gNDtcbiAgICBidWZmZXIud3JpdGVVSW50MzJCRSh0aW1lc3RhbXAsIG9mZnNldCk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LnNlbmQoMHhmMCwgMHgwNCwgMHgwMiwgMHgwMCwgYnVmZmVyKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgIGNvbnN0IHIgPSByZXNwb25zZS5zbGljZSgxLCAxICsgMzIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgY29uc3QgcyA9IHJlc3BvbnNlLnNsaWNlKDEgKyAzMiwgMSArIDMyICsgMzIpLnRvU3RyaW5nKFwiaGV4XCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgc1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcHJvdmlkZSBxdWFudGl6YXRpb24gaW5mb3JtYXRpb24gYmVmb3JlIHNpbmdpbmcgYSBkZXBvc2l0IG9yIHdpdGhkcmF3YWwgU3RhcmsgcG93ZXJlZCBjb250cmFjdCBjYWxsXG4gICAqXG4gICAqIEl0IHNoYWxsIGJlIHJ1biBmb2xsb3dpbmcgYSBwcm92aWRlRVJDMjBUb2tlbkluZm9ybWF0aW9uIGNhbGwgZm9yIHRoZSBnaXZlbiBjb250cmFjdFxuICAgKlxuICAgKiBAcGFyYW0gb3BlcmF0aW9uQ29udHJhY3QgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgdG9rZW4gdG8gYmUgdHJhbnNmZXJyZWQgKG5vdCBwcmVzZW50IGZvciBFVEgpXG4gICAqIEBwYXJhbSBvcGVyYXRpb25RdWFudGl6YXRpb24gcXVhbnRpemF0aW9uIHVzZWQgZm9yIHRoZSB0b2tlbiB0byBiZSB0cmFuc2ZlcnJlZFxuICAgKi9cblxuXG4gIHN0YXJrUHJvdmlkZVF1YW50dW0ob3BlcmF0aW9uQ29udHJhY3QsIG9wZXJhdGlvblF1YW50aXphdGlvbikge1xuICAgIGNvbnN0IG9wZXJhdGlvbkNvbnRyYWN0SGV4ID0gbWF5YmVIZXhCdWZmZXIob3BlcmF0aW9uQ29udHJhY3QpO1xuICAgIGxldCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjAgKyAzMiwgMCk7XG5cbiAgICBpZiAob3BlcmF0aW9uQ29udHJhY3RIZXgpIHtcbiAgICAgIG9wZXJhdGlvbkNvbnRyYWN0SGV4LmNvcHkoYnVmZmVyLCAwKTtcbiAgICB9XG5cbiAgICBCdWZmZXIuZnJvbShvcGVyYXRpb25RdWFudGl6YXRpb24udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDY0LCBcIjBcIiksIFwiaGV4XCIpLmNvcHkoYnVmZmVyLCAyMCk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LnNlbmQoMHhmMCwgMHgwOCwgMHgwMCwgMHgwMCwgYnVmZmVyKS50aGVuKCgpID0+IHRydWUsIGUgPT4ge1xuICAgICAgaWYgKGUgJiYgZS5zdGF0dXNDb2RlID09PSAweDZkMDApIHtcbiAgICAgICAgLy8gdGhpcyBjYXNlIGhhcHBlbiBmb3IgRVRIIGFwcGxpY2F0aW9uIHZlcnNpb25zIG5vdCBzdXBwb3J0aW5nIFN0YXJrIGV4dGVuc2lvbnNcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG5cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV0aC5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///1d17\n')},a67d:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export defer */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return splitPath; });\n/* unused harmony export eachSeries */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return foreach; });\n/* unused harmony export doIf */\n/* unused harmony export asyncWhile */\n/********************************************************************************\n *   Ledger Node JS API\n *   (c) 2016-2017 Ledger\n *\n *  Licensed under the Apache License, Version 2.0 (the "License");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an "AS IS" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\nfunction defer() {\n  let resolve, reject;\n  let promise = new Promise(function (success, failure) {\n    resolve = success;\n    reject = failure;\n  });\n  if (!resolve || !reject) throw "defer() error"; // this never happens and is just to make flow happy\n\n  return {\n    promise,\n    resolve,\n    reject\n  };\n} // TODO use bip32-path library\n\nfunction splitPath(path) {\n  let result = [];\n  let components = path.split("/");\n  components.forEach(element => {\n    let number = parseInt(element, 10);\n\n    if (isNaN(number)) {\n      return; // FIXME shouldn\'t it throws instead?\n    }\n\n    if (element.length > 1 && element[element.length - 1] === "\'") {\n      number += 0x80000000;\n    }\n\n    result.push(number);\n  });\n  return result;\n} // TODO use async await\n\nfunction eachSeries(arr, fun) {\n  return arr.reduce((p, e) => p.then(() => fun(e)), Promise.resolve());\n}\nfunction foreach(arr, callback) {\n  function iterate(index, array, result) {\n    if (index >= array.length) {\n      return result;\n    } else return callback(array[index], index).then(function (res) {\n      result.push(res);\n      return iterate(index + 1, array, result);\n    });\n  }\n\n  return Promise.resolve().then(() => iterate(0, arr, []));\n}\nfunction doIf(condition, callback) {\n  return Promise.resolve().then(() => {\n    if (condition) {\n      return callback();\n    }\n  });\n}\nfunction asyncWhile(predicate, callback) {\n  function iterate(result) {\n    if (!predicate()) {\n      return result;\n    } else {\n      return callback().then(res => {\n        result.push(res);\n        return iterate(result);\n      });\n    }\n  }\n\n  return Promise.resolve([]).then(iterate);\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxlZGdlcmhxL2h3LWFwcC1ldGgvbGliLWVzL3V0aWxzLmpzP2E2N2QiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGlEQUFpRDs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU07QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVNO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiYTY3ZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogICBMZWRnZXIgTm9kZSBKUyBBUElcbiAqICAgKGMpIDIwMTYtMjAxNyBMZWRnZXJcbiAqXG4gKiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZnVuY3Rpb24gZGVmZXIoKSB7XG4gIGxldCByZXNvbHZlLCByZWplY3Q7XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICByZXNvbHZlID0gc3VjY2VzcztcbiAgICByZWplY3QgPSBmYWlsdXJlO1xuICB9KTtcbiAgaWYgKCFyZXNvbHZlIHx8ICFyZWplY3QpIHRocm93IFwiZGVmZXIoKSBlcnJvclwiOyAvLyB0aGlzIG5ldmVyIGhhcHBlbnMgYW5kIGlzIGp1c3QgdG8gbWFrZSBmbG93IGhhcHB5XG5cbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59IC8vIFRPRE8gdXNlIGJpcDMyLXBhdGggbGlicmFyeVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRQYXRoKHBhdGgpIHtcbiAgbGV0IHJlc3VsdCA9IFtdO1xuICBsZXQgY29tcG9uZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBjb21wb25lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgbGV0IG51bWJlciA9IHBhcnNlSW50KGVsZW1lbnQsIDEwKTtcblxuICAgIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgICByZXR1cm47IC8vIEZJWE1FIHNob3VsZG4ndCBpdCB0aHJvd3MgaW5zdGVhZD9cbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC5sZW5ndGggPiAxICYmIGVsZW1lbnRbZWxlbWVudC5sZW5ndGggLSAxXSA9PT0gXCInXCIpIHtcbiAgICAgIG51bWJlciArPSAweDgwMDAwMDAwO1xuICAgIH1cblxuICAgIHJlc3VsdC5wdXNoKG51bWJlcik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSAvLyBUT0RPIHVzZSBhc3luYyBhd2FpdFxuXG5leHBvcnQgZnVuY3Rpb24gZWFjaFNlcmllcyhhcnIsIGZ1bikge1xuICByZXR1cm4gYXJyLnJlZHVjZSgocCwgZSkgPT4gcC50aGVuKCgpID0+IGZ1bihlKSksIFByb21pc2UucmVzb2x2ZSgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JlYWNoKGFyciwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gaXRlcmF0ZShpbmRleCwgYXJyYXksIHJlc3VsdCkge1xuICAgIGlmIChpbmRleCA+PSBhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHJldHVybiBjYWxsYmFjayhhcnJheVtpbmRleF0sIGluZGV4KS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHJlcyk7XG4gICAgICByZXR1cm4gaXRlcmF0ZShpbmRleCArIDEsIGFycmF5LCByZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gaXRlcmF0ZSgwLCBhcnIsIFtdKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZG9JZihjb25kaXRpb24sIGNhbGxiYWNrKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICBpZiAoY29uZGl0aW9uKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG4gIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzeW5jV2hpbGUocHJlZGljYXRlLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBpdGVyYXRlKHJlc3VsdCkge1xuICAgIGlmICghcHJlZGljYXRlKCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjYWxsYmFjaygpLnRoZW4ocmVzID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmVzKTtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdGUocmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pLnRoZW4oaXRlcmF0ZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///a67d\n')},a8fc:function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* unused harmony export AccountNameRequiredError */\n/* unused harmony export AccountNotSupported */\n/* unused harmony export AmountRequired */\n/* unused harmony export BluetoothRequired */\n/* unused harmony export BtcUnmatchedApp */\n/* unused harmony export CantOpenDevice */\n/* unused harmony export CantScanQRCode */\n/* unused harmony export CashAddrNotSupported */\n/* unused harmony export CurrencyNotSupported */\n/* unused harmony export DBNotReset */\n/* unused harmony export DBWrongPassword */\n/* unused harmony export DeviceAppVerifyNotSupported */\n/* unused harmony export DeviceGenuineSocketEarlyClose */\n/* unused harmony export DeviceHalted */\n/* unused harmony export DeviceInOSUExpected */\n/* unused harmony export DeviceNameInvalid */\n/* unused harmony export DeviceNotGenuineError */\n/* unused harmony export DeviceOnDashboardExpected */\n/* unused harmony export DeviceOnDashboardUnexpected */\n/* unused harmony export DeviceShouldStayInApp */\n/* unused harmony export DeviceSocketFail */\n/* unused harmony export DeviceSocketNoBulkStatus */\n/* unused harmony export DisconnectedDevice */\n/* unused harmony export DisconnectedDeviceDuringOperation */\n/* unused harmony export ETHAddressNonEIP */\n/* unused harmony export EnpointConfigError */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return EthAppPleaseEnableContractData; });\n/* unused harmony export FeeEstimationFailed */\n/* unused harmony export FeeNotLoaded */\n/* unused harmony export FeeRequired */\n/* unused harmony export FeeTooHigh */\n/* unused harmony export FirmwareNotRecognized */\n/* unused harmony export FirmwareOrAppUpdateRequired */\n/* unused harmony export GasLessThanEstimate */\n/* unused harmony export GenuineCheckFailed */\n/* unused harmony export HardResetFail */\n/* unused harmony export InvalidAddress */\n/* unused harmony export InvalidAddressBecauseDestinationIsAlsoSource */\n/* unused harmony export InvalidXRPTag */\n/* unused harmony export LatestMCUInstalledError */\n/* unused harmony export LedgerAPI4xx */\n/* unused harmony export LedgerAPI5xx */\n/* unused harmony export LedgerAPIError */\n/* unused harmony export LedgerAPIErrorWithMessage */\n/* unused harmony export LedgerAPINotAvailable */\n/* unused harmony export MCUNotGenuineToDashboard */\n/* unused harmony export ManagerAppAlreadyInstalledError */\n/* unused harmony export ManagerAppDepInstallRequired */\n/* unused harmony export ManagerAppDepUninstallRequired */\n/* unused harmony export ManagerAppRelyOnBTCError */\n/* unused harmony export ManagerDeviceLockedError */\n/* unused harmony export ManagerFirmwareNotEnoughSpaceError */\n/* unused harmony export ManagerNotEnoughSpaceError */\n/* unused harmony export ManagerUninstallBTCDep */\n/* unused harmony export NetworkDown */\n/* unused harmony export NoAccessToCamera */\n/* unused harmony export NoAddressesFound */\n/* unused harmony export NoDBPathGiven */\n/* unused harmony export NotEnoughBalance */\n/* unused harmony export NotEnoughBalanceBecauseDestinationNotCreated */\n/* unused harmony export NotEnoughBalanceInParentAccount */\n/* unused harmony export NotEnoughBalanceToDelegate */\n/* unused harmony export NotEnoughGas */\n/* unused harmony export NotEnoughSpendableBalance */\n/* unused harmony export NotSupportedLegacyAddress */\n/* unused harmony export PairingFailed */\n/* unused harmony export PasswordIncorrectError */\n/* unused harmony export PasswordsDontMatchError */\n/* unused harmony export RecipientRequired */\n/* unused harmony export RecommendSubAccountsToEmpty */\n/* unused harmony export RecommendUndelegation */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return StatusCodes; });\n/* unused harmony export SyncError */\n/* unused harmony export TimeoutTagged */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return TransportError; });\n/* unused harmony export TransportInterfaceNotAvailable */\n/* unused harmony export TransportOpenUserCancelled */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return TransportRaceCondition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return TransportStatusError; });\n/* unused harmony export TransportWebUSBGestureRequired */\n/* unused harmony export UnavailableTezosOriginatedAccountReceive */\n/* unused harmony export UnavailableTezosOriginatedAccountSend */\n/* unused harmony export UnexpectedBootloader */\n/* unused harmony export UnknownMCU */\n/* unused harmony export UpdateFetchFileFail */\n/* unused harmony export UpdateIncorrectHash */\n/* unused harmony export UpdateIncorrectSig */\n/* unused harmony export UpdateYourApp */\n/* unused harmony export UserRefusedAddress */\n/* unused harmony export UserRefusedAllowManager */\n/* unused harmony export UserRefusedDeviceNameChange */\n/* unused harmony export UserRefusedFirmwareUpdate */\n/* unused harmony export UserRefusedOnDevice */\n/* unused harmony export WebsocketConnectionError */\n/* unused harmony export WebsocketConnectionFailed */\n/* unused harmony export WrongAppForCurrency */\n/* unused harmony export WrongDeviceForAccount */\n/* unused harmony export addCustomErrorDeserializer */\n/* unused harmony export createCustomErrorClass */\n/* unused harmony export deserializeError */\n/* unused harmony export getAltStatusMessage */\n/* unused harmony export serializeError */\n/* eslint-disable no-continue */\r\n/* eslint-disable no-param-reassign */\r\n/* eslint-disable no-prototype-builtins */\r\nvar errorClasses = {};\r\nvar deserializers = {};\r\nvar addCustomErrorDeserializer = function (name, deserializer) {\r\n    deserializers[name] = deserializer;\r\n};\r\nvar createCustomErrorClass = function (name) {\r\n    var C = function CustomError(message, fields) {\r\n        Object.assign(this, fields);\r\n        this.name = name;\r\n        this.message = message || name;\r\n        this.stack = new Error().stack;\r\n    };\r\n    C.prototype = new Error();\r\n    errorClasses[name] = C;\r\n    return C;\r\n};\r\n// inspired from https://github.com/programble/errio/blob/master/index.js\r\nvar deserializeError = function (object) {\r\n    if (typeof object === "object" && object) {\r\n        try {\r\n            // $FlowFixMe FIXME HACK\r\n            var msg = JSON.parse(object.message);\r\n            if (msg.message && msg.name) {\r\n                object = msg;\r\n            }\r\n        }\r\n        catch (e) {\r\n            // nothing\r\n        }\r\n        var error = void 0;\r\n        if (typeof object.name === "string") {\r\n            var name_1 = object.name;\r\n            var des = deserializers[name_1];\r\n            if (des) {\r\n                error = des(object);\r\n            }\r\n            else {\r\n                var constructor = name_1 === "Error" ? Error : errorClasses[name_1];\r\n                if (!constructor) {\r\n                    console.warn("deserializing an unknown class \'" + name_1 + "\'");\r\n                    constructor = createCustomErrorClass(name_1);\r\n                }\r\n                error = Object.create(constructor.prototype);\r\n                try {\r\n                    for (var prop in object) {\r\n                        if (object.hasOwnProperty(prop)) {\r\n                            error[prop] = object[prop];\r\n                        }\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // sometimes setting a property can fail (e.g. .name)\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            error = new Error(object.message);\r\n        }\r\n        if (!error.stack && Error.captureStackTrace) {\r\n            Error.captureStackTrace(error, deserializeError);\r\n        }\r\n        return error;\r\n    }\r\n    return new Error(String(object));\r\n};\r\n// inspired from https://github.com/sindresorhus/serialize-error/blob/master/index.js\r\nvar serializeError = function (value) {\r\n    if (!value)\r\n        return value;\r\n    if (typeof value === "object") {\r\n        return destroyCircular(value, []);\r\n    }\r\n    if (typeof value === "function") {\r\n        return "[Function: " + (value.name || "anonymous") + "]";\r\n    }\r\n    return value;\r\n};\r\n// https://www.npmjs.com/package/destroy-circular\r\nfunction destroyCircular(from, seen) {\r\n    var to = {};\r\n    seen.push(from);\r\n    for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\r\n        var key = _a[_i];\r\n        var value = from[key];\r\n        if (typeof value === "function") {\r\n            continue;\r\n        }\r\n        if (!value || typeof value !== "object") {\r\n            to[key] = value;\r\n            continue;\r\n        }\r\n        if (seen.indexOf(from[key]) === -1) {\r\n            to[key] = destroyCircular(from[key], seen.slice(0));\r\n            continue;\r\n        }\r\n        to[key] = "[Circular]";\r\n    }\r\n    if (typeof from.name === "string") {\r\n        to.name = from.name;\r\n    }\r\n    if (typeof from.message === "string") {\r\n        to.message = from.message;\r\n    }\r\n    if (typeof from.stack === "string") {\r\n        to.stack = from.stack;\r\n    }\r\n    return to;\r\n}\n\nvar AccountNameRequiredError = createCustomErrorClass("AccountNameRequired");\r\nvar AccountNotSupported = createCustomErrorClass("AccountNotSupported");\r\nvar AmountRequired = createCustomErrorClass("AmountRequired");\r\nvar BluetoothRequired = createCustomErrorClass("BluetoothRequired");\r\nvar BtcUnmatchedApp = createCustomErrorClass("BtcUnmatchedApp");\r\nvar CantOpenDevice = createCustomErrorClass("CantOpenDevice");\r\nvar CashAddrNotSupported = createCustomErrorClass("CashAddrNotSupported");\r\nvar CurrencyNotSupported = createCustomErrorClass("CurrencyNotSupported");\r\nvar DeviceAppVerifyNotSupported = createCustomErrorClass("DeviceAppVerifyNotSupported");\r\nvar DeviceGenuineSocketEarlyClose = createCustomErrorClass("DeviceGenuineSocketEarlyClose");\r\nvar DeviceNotGenuineError = createCustomErrorClass("DeviceNotGenuine");\r\nvar DeviceOnDashboardExpected = createCustomErrorClass("DeviceOnDashboardExpected");\r\nvar DeviceOnDashboardUnexpected = createCustomErrorClass("DeviceOnDashboardUnexpected");\r\nvar DeviceInOSUExpected = createCustomErrorClass("DeviceInOSUExpected");\r\nvar DeviceHalted = createCustomErrorClass("DeviceHalted");\r\nvar DeviceNameInvalid = createCustomErrorClass("DeviceNameInvalid");\r\nvar DeviceSocketFail = createCustomErrorClass("DeviceSocketFail");\r\nvar DeviceSocketNoBulkStatus = createCustomErrorClass("DeviceSocketNoBulkStatus");\r\nvar DisconnectedDevice = createCustomErrorClass("DisconnectedDevice");\r\nvar DisconnectedDeviceDuringOperation = createCustomErrorClass("DisconnectedDeviceDuringOperation");\r\nvar EnpointConfigError = createCustomErrorClass("EnpointConfig");\r\nvar EthAppPleaseEnableContractData = createCustomErrorClass("EthAppPleaseEnableContractData");\r\nvar FeeEstimationFailed = createCustomErrorClass("FeeEstimationFailed");\r\nvar FirmwareNotRecognized = createCustomErrorClass("FirmwareNotRecognized");\r\nvar HardResetFail = createCustomErrorClass("HardResetFail");\r\nvar InvalidXRPTag = createCustomErrorClass("InvalidXRPTag");\r\nvar InvalidAddress = createCustomErrorClass("InvalidAddress");\r\nvar InvalidAddressBecauseDestinationIsAlsoSource = createCustomErrorClass("InvalidAddressBecauseDestinationIsAlsoSource");\r\nvar LatestMCUInstalledError = createCustomErrorClass("LatestMCUInstalledError");\r\nvar UnknownMCU = createCustomErrorClass("UnknownMCU");\r\nvar LedgerAPIError = createCustomErrorClass("LedgerAPIError");\r\nvar LedgerAPIErrorWithMessage = createCustomErrorClass("LedgerAPIErrorWithMessage");\r\nvar LedgerAPINotAvailable = createCustomErrorClass("LedgerAPINotAvailable");\r\nvar ManagerAppAlreadyInstalledError = createCustomErrorClass("ManagerAppAlreadyInstalled");\r\nvar ManagerAppRelyOnBTCError = createCustomErrorClass("ManagerAppRelyOnBTC");\r\nvar ManagerAppDepInstallRequired = createCustomErrorClass("ManagerAppDepInstallRequired");\r\nvar ManagerAppDepUninstallRequired = createCustomErrorClass("ManagerAppDepUninstallRequired");\r\nvar ManagerDeviceLockedError = createCustomErrorClass("ManagerDeviceLocked");\r\nvar ManagerFirmwareNotEnoughSpaceError = createCustomErrorClass("ManagerFirmwareNotEnoughSpace");\r\nvar ManagerNotEnoughSpaceError = createCustomErrorClass("ManagerNotEnoughSpace");\r\nvar ManagerUninstallBTCDep = createCustomErrorClass("ManagerUninstallBTCDep");\r\nvar NetworkDown = createCustomErrorClass("NetworkDown");\r\nvar NoAddressesFound = createCustomErrorClass("NoAddressesFound");\r\nvar NotEnoughBalance = createCustomErrorClass("NotEnoughBalance");\r\nvar NotEnoughBalanceToDelegate = createCustomErrorClass("NotEnoughBalanceToDelegate");\r\nvar NotEnoughBalanceInParentAccount = createCustomErrorClass("NotEnoughBalanceInParentAccount");\r\nvar NotEnoughSpendableBalance = createCustomErrorClass("NotEnoughSpendableBalance");\r\nvar NotEnoughBalanceBecauseDestinationNotCreated = createCustomErrorClass("NotEnoughBalanceBecauseDestinationNotCreated");\r\nvar NoAccessToCamera = createCustomErrorClass("NoAccessToCamera");\r\nvar NotEnoughGas = createCustomErrorClass("NotEnoughGas");\r\nvar NotSupportedLegacyAddress = createCustomErrorClass("NotSupportedLegacyAddress");\r\nvar GasLessThanEstimate = createCustomErrorClass("GasLessThanEstimate");\r\nvar PasswordsDontMatchError = createCustomErrorClass("PasswordsDontMatch");\r\nvar PasswordIncorrectError = createCustomErrorClass("PasswordIncorrect");\r\nvar RecommendSubAccountsToEmpty = createCustomErrorClass("RecommendSubAccountsToEmpty");\r\nvar RecommendUndelegation = createCustomErrorClass("RecommendUndelegation");\r\nvar TimeoutTagged = createCustomErrorClass("TimeoutTagged");\r\nvar UnexpectedBootloader = createCustomErrorClass("UnexpectedBootloader");\r\nvar MCUNotGenuineToDashboard = createCustomErrorClass("MCUNotGenuineToDashboard");\r\nvar RecipientRequired = createCustomErrorClass("RecipientRequired");\r\nvar UnavailableTezosOriginatedAccountReceive = createCustomErrorClass("UnavailableTezosOriginatedAccountReceive");\r\nvar UnavailableTezosOriginatedAccountSend = createCustomErrorClass("UnavailableTezosOriginatedAccountSend");\r\nvar UpdateFetchFileFail = createCustomErrorClass("UpdateFetchFileFail");\r\nvar UpdateIncorrectHash = createCustomErrorClass("UpdateIncorrectHash");\r\nvar UpdateIncorrectSig = createCustomErrorClass("UpdateIncorrectSig");\r\nvar UpdateYourApp = createCustomErrorClass("UpdateYourApp");\r\nvar UserRefusedDeviceNameChange = createCustomErrorClass("UserRefusedDeviceNameChange");\r\nvar UserRefusedAddress = createCustomErrorClass("UserRefusedAddress");\r\nvar UserRefusedFirmwareUpdate = createCustomErrorClass("UserRefusedFirmwareUpdate");\r\nvar UserRefusedAllowManager = createCustomErrorClass("UserRefusedAllowManager");\r\nvar UserRefusedOnDevice = createCustomErrorClass("UserRefusedOnDevice"); // TODO rename because it\'s just for transaction refusal\r\nvar TransportOpenUserCancelled = createCustomErrorClass("TransportOpenUserCancelled");\r\nvar TransportInterfaceNotAvailable = createCustomErrorClass("TransportInterfaceNotAvailable");\r\nvar TransportRaceCondition = createCustomErrorClass("TransportRaceCondition");\r\nvar TransportWebUSBGestureRequired = createCustomErrorClass("TransportWebUSBGestureRequired");\r\nvar DeviceShouldStayInApp = createCustomErrorClass("DeviceShouldStayInApp");\r\nvar WebsocketConnectionError = createCustomErrorClass("WebsocketConnectionError");\r\nvar WebsocketConnectionFailed = createCustomErrorClass("WebsocketConnectionFailed");\r\nvar WrongDeviceForAccount = createCustomErrorClass("WrongDeviceForAccount");\r\nvar WrongAppForCurrency = createCustomErrorClass("WrongAppForCurrency");\r\nvar ETHAddressNonEIP = createCustomErrorClass("ETHAddressNonEIP");\r\nvar CantScanQRCode = createCustomErrorClass("CantScanQRCode");\r\nvar FeeNotLoaded = createCustomErrorClass("FeeNotLoaded");\r\nvar FeeRequired = createCustomErrorClass("FeeRequired");\r\nvar FeeTooHigh = createCustomErrorClass("FeeTooHigh");\r\nvar SyncError = createCustomErrorClass("SyncError");\r\nvar PairingFailed = createCustomErrorClass("PairingFailed");\r\nvar GenuineCheckFailed = createCustomErrorClass("GenuineCheckFailed");\r\nvar LedgerAPI4xx = createCustomErrorClass("LedgerAPI4xx");\r\nvar LedgerAPI5xx = createCustomErrorClass("LedgerAPI5xx");\r\nvar FirmwareOrAppUpdateRequired = createCustomErrorClass("FirmwareOrAppUpdateRequired");\r\n// db stuff, no need to translate\r\nvar NoDBPathGiven = createCustomErrorClass("NoDBPathGiven");\r\nvar DBWrongPassword = createCustomErrorClass("DBWrongPassword");\r\nvar DBNotReset = createCustomErrorClass("DBNotReset");\r\n/**\r\n * TransportError is used for any generic transport errors.\r\n * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.\r\n */\r\nfunction TransportError(message, id) {\r\n    this.name = "TransportError";\r\n    this.message = message;\r\n    this.stack = new Error().stack;\r\n    this.id = id;\r\n}\r\nTransportError.prototype = new Error();\r\naddCustomErrorDeserializer("TransportError", function (e) { return new TransportError(e.message, e.id); });\r\nvar StatusCodes = {\r\n    PIN_REMAINING_ATTEMPTS: 0x63c0,\r\n    INCORRECT_LENGTH: 0x6700,\r\n    MISSING_CRITICAL_PARAMETER: 0x6800,\r\n    COMMAND_INCOMPATIBLE_FILE_STRUCTURE: 0x6981,\r\n    SECURITY_STATUS_NOT_SATISFIED: 0x6982,\r\n    CONDITIONS_OF_USE_NOT_SATISFIED: 0x6985,\r\n    INCORRECT_DATA: 0x6a80,\r\n    NOT_ENOUGH_MEMORY_SPACE: 0x6a84,\r\n    REFERENCED_DATA_NOT_FOUND: 0x6a88,\r\n    FILE_ALREADY_EXISTS: 0x6a89,\r\n    INCORRECT_P1_P2: 0x6b00,\r\n    INS_NOT_SUPPORTED: 0x6d00,\r\n    CLA_NOT_SUPPORTED: 0x6e00,\r\n    TECHNICAL_PROBLEM: 0x6f00,\r\n    OK: 0x9000,\r\n    MEMORY_PROBLEM: 0x9240,\r\n    NO_EF_SELECTED: 0x9400,\r\n    INVALID_OFFSET: 0x9402,\r\n    FILE_NOT_FOUND: 0x9404,\r\n    INCONSISTENT_FILE: 0x9408,\r\n    ALGORITHM_NOT_SUPPORTED: 0x9484,\r\n    INVALID_KCV: 0x9485,\r\n    CODE_NOT_INITIALIZED: 0x9802,\r\n    ACCESS_CONDITION_NOT_FULFILLED: 0x9804,\r\n    CONTRADICTION_SECRET_CODE_STATUS: 0x9808,\r\n    CONTRADICTION_INVALIDATION: 0x9810,\r\n    CODE_BLOCKED: 0x9840,\r\n    MAX_VALUE_REACHED: 0x9850,\r\n    GP_AUTH_FAILED: 0x6300,\r\n    LICENSING: 0x6f42,\r\n    HALTED: 0x6faa,\r\n};\r\nfunction getAltStatusMessage(code) {\r\n    switch (code) {\r\n        // improve text of most common errors\r\n        case 0x6700:\r\n            return "Incorrect length";\r\n        case 0x6800:\r\n            return "Missing critical parameter";\r\n        case 0x6982:\r\n            return "Security not satisfied (dongle locked or have invalid access rights)";\r\n        case 0x6985:\r\n            return "Condition of use not satisfied (denied by the user?)";\r\n        case 0x6a80:\r\n            return "Invalid data received";\r\n        case 0x6b00:\r\n            return "Invalid parameter received";\r\n    }\r\n    if (0x6f00 <= code && code <= 0x6fff) {\r\n        return "Internal error, please report";\r\n    }\r\n}\r\n/**\r\n * Error thrown when a device returned a non success status.\r\n * the error.statusCode is one of the `StatusCodes` exported by this library.\r\n */\r\nfunction TransportStatusError(statusCode) {\r\n    this.name = "TransportStatusError";\r\n    var statusText = Object.keys(StatusCodes).find(function (k) { return StatusCodes[k] === statusCode; }) ||\r\n        "UNKNOWN_ERROR";\r\n    var smsg = getAltStatusMessage(statusCode) || statusText;\r\n    var statusCodeStr = statusCode.toString(16);\r\n    this.message = "Ledger device: " + smsg + " (0x" + statusCodeStr + ")";\r\n    this.stack = new Error().stack;\r\n    this.statusCode = statusCode;\r\n    this.statusText = statusText;\r\n}\r\nTransportStatusError.prototype = new Error();\r\naddCustomErrorDeserializer("TransportStatusError", function (e) { return new TransportStatusError(e.statusCode); });\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGxlZGdlcmhxL2Vycm9ycy9kaXN0L2luZGV4LmpzP2E4ZmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsNENBQTRDLEVBQUU7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxzQ0FBc0MsRUFBRTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsK0NBQStDLEVBQUU7O0FBRXFxRSIsImZpbGUiOiJhOGZjLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tY29udGludWUgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zICovXHJcbnZhciBlcnJvckNsYXNzZXMgPSB7fTtcclxudmFyIGRlc2VyaWFsaXplcnMgPSB7fTtcclxudmFyIGFkZEN1c3RvbUVycm9yRGVzZXJpYWxpemVyID0gZnVuY3Rpb24gKG5hbWUsIGRlc2VyaWFsaXplcikge1xyXG4gICAgZGVzZXJpYWxpemVyc1tuYW1lXSA9IGRlc2VyaWFsaXplcjtcclxufTtcclxudmFyIGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdmFyIEMgPSBmdW5jdGlvbiBDdXN0b21FcnJvcihtZXNzYWdlLCBmaWVsZHMpIHtcclxuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGZpZWxkcyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8IG5hbWU7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xyXG4gICAgfTtcclxuICAgIEMucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbiAgICBlcnJvckNsYXNzZXNbbmFtZV0gPSBDO1xyXG4gICAgcmV0dXJuIEM7XHJcbn07XHJcbi8vIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3Byb2dyYW1ibGUvZXJyaW8vYmxvYi9tYXN0ZXIvaW5kZXguanNcclxudmFyIGRlc2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAob2JqZWN0KSB7XHJcbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gXCJvYmplY3RcIiAmJiBvYmplY3QpIHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIEZJWE1FIEhBQ0tcclxuICAgICAgICAgICAgdmFyIG1zZyA9IEpTT04ucGFyc2Uob2JqZWN0Lm1lc3NhZ2UpO1xyXG4gICAgICAgICAgICBpZiAobXNnLm1lc3NhZ2UgJiYgbXNnLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgIG9iamVjdCA9IG1zZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAvLyBub3RoaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcclxuICAgICAgICBpZiAodHlwZW9mIG9iamVjdC5uYW1lID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lXzEgPSBvYmplY3QubmFtZTtcclxuICAgICAgICAgICAgdmFyIGRlcyA9IGRlc2VyaWFsaXplcnNbbmFtZV8xXTtcclxuICAgICAgICAgICAgaWYgKGRlcykge1xyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBkZXMob2JqZWN0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IG5hbWVfMSA9PT0gXCJFcnJvclwiID8gRXJyb3IgOiBlcnJvckNsYXNzZXNbbmFtZV8xXTtcclxuICAgICAgICAgICAgICAgIGlmICghY29uc3RydWN0b3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJkZXNlcmlhbGl6aW5nIGFuIHVua25vd24gY2xhc3MgJ1wiICsgbmFtZV8xICsgXCInXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhuYW1lXzEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZXJyb3IgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW3Byb3BdID0gb2JqZWN0W3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzb21ldGltZXMgc2V0dGluZyBhIHByb3BlcnR5IGNhbiBmYWlsIChlLmcuIC5uYW1lKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihvYmplY3QubWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZXJyb3Iuc3RhY2sgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIGRlc2VyaWFsaXplRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IEVycm9yKFN0cmluZyhvYmplY3QpKTtcclxufTtcclxuLy8gaW5zcGlyZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3NlcmlhbGl6ZS1lcnJvci9ibG9iL21hc3Rlci9pbmRleC5qc1xyXG52YXIgc2VyaWFsaXplRXJyb3IgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgIGlmICghdmFsdWUpXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIHJldHVybiBkZXN0cm95Q2lyY3VsYXIodmFsdWUsIFtdKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBcIltGdW5jdGlvbjogXCIgKyAodmFsdWUubmFtZSB8fCBcImFub255bW91c1wiKSArIFwiXVwiO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59O1xyXG4vLyBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9kZXN0cm95LWNpcmN1bGFyXHJcbmZ1bmN0aW9uIGRlc3Ryb3lDaXJjdWxhcihmcm9tLCBzZWVuKSB7XHJcbiAgICB2YXIgdG8gPSB7fTtcclxuICAgIHNlZW4ucHVzaChmcm9tKTtcclxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3Qua2V5cyhmcm9tKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IGZyb21ba2V5XTtcclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHRvW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWVuLmluZGV4T2YoZnJvbVtrZXldKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgdG9ba2V5XSA9IGRlc3Ryb3lDaXJjdWxhcihmcm9tW2tleV0sIHNlZW4uc2xpY2UoMCkpO1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdG9ba2V5XSA9IFwiW0NpcmN1bGFyXVwiO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBmcm9tLm5hbWUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB0by5uYW1lID0gZnJvbS5uYW1lO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBmcm9tLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICB0by5tZXNzYWdlID0gZnJvbS5tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBmcm9tLnN0YWNrID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgdG8uc3RhY2sgPSBmcm9tLnN0YWNrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvO1xyXG59XG5cbnZhciBBY2NvdW50TmFtZVJlcXVpcmVkRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQWNjb3VudE5hbWVSZXF1aXJlZFwiKTtcclxudmFyIEFjY291bnROb3RTdXBwb3J0ZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQWNjb3VudE5vdFN1cHBvcnRlZFwiKTtcclxudmFyIEFtb3VudFJlcXVpcmVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkFtb3VudFJlcXVpcmVkXCIpO1xyXG52YXIgQmx1ZXRvb3RoUmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQmx1ZXRvb3RoUmVxdWlyZWRcIik7XHJcbnZhciBCdGNVbm1hdGNoZWRBcHAgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQnRjVW5tYXRjaGVkQXBwXCIpO1xyXG52YXIgQ2FudE9wZW5EZXZpY2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiQ2FudE9wZW5EZXZpY2VcIik7XHJcbnZhciBDYXNoQWRkck5vdFN1cHBvcnRlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJDYXNoQWRkck5vdFN1cHBvcnRlZFwiKTtcclxudmFyIEN1cnJlbmN5Tm90U3VwcG9ydGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkN1cnJlbmN5Tm90U3VwcG9ydGVkXCIpO1xyXG52YXIgRGV2aWNlQXBwVmVyaWZ5Tm90U3VwcG9ydGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZUFwcFZlcmlmeU5vdFN1cHBvcnRlZFwiKTtcclxudmFyIERldmljZUdlbnVpbmVTb2NrZXRFYXJseUNsb3NlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZUdlbnVpbmVTb2NrZXRFYXJseUNsb3NlXCIpO1xyXG52YXIgRGV2aWNlTm90R2VudWluZUVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZU5vdEdlbnVpbmVcIik7XHJcbnZhciBEZXZpY2VPbkRhc2hib2FyZEV4cGVjdGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZU9uRGFzaGJvYXJkRXhwZWN0ZWRcIik7XHJcbnZhciBEZXZpY2VPbkRhc2hib2FyZFVuZXhwZWN0ZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRGV2aWNlT25EYXNoYm9hcmRVbmV4cGVjdGVkXCIpO1xyXG52YXIgRGV2aWNlSW5PU1VFeHBlY3RlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEZXZpY2VJbk9TVUV4cGVjdGVkXCIpO1xyXG52YXIgRGV2aWNlSGFsdGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZUhhbHRlZFwiKTtcclxudmFyIERldmljZU5hbWVJbnZhbGlkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZU5hbWVJbnZhbGlkXCIpO1xyXG52YXIgRGV2aWNlU29ja2V0RmFpbCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEZXZpY2VTb2NrZXRGYWlsXCIpO1xyXG52YXIgRGV2aWNlU29ja2V0Tm9CdWxrU3RhdHVzID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRldmljZVNvY2tldE5vQnVsa1N0YXR1c1wiKTtcclxudmFyIERpc2Nvbm5lY3RlZERldmljZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEaXNjb25uZWN0ZWREZXZpY2VcIik7XHJcbnZhciBEaXNjb25uZWN0ZWREZXZpY2VEdXJpbmdPcGVyYXRpb24gPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRGlzY29ubmVjdGVkRGV2aWNlRHVyaW5nT3BlcmF0aW9uXCIpO1xyXG52YXIgRW5wb2ludENvbmZpZ0Vycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkVucG9pbnRDb25maWdcIik7XHJcbnZhciBFdGhBcHBQbGVhc2VFbmFibGVDb250cmFjdERhdGEgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRXRoQXBwUGxlYXNlRW5hYmxlQ29udHJhY3REYXRhXCIpO1xyXG52YXIgRmVlRXN0aW1hdGlvbkZhaWxlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJGZWVFc3RpbWF0aW9uRmFpbGVkXCIpO1xyXG52YXIgRmlybXdhcmVOb3RSZWNvZ25pemVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkZpcm13YXJlTm90UmVjb2duaXplZFwiKTtcclxudmFyIEhhcmRSZXNldEZhaWwgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiSGFyZFJlc2V0RmFpbFwiKTtcclxudmFyIEludmFsaWRYUlBUYWcgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiSW52YWxpZFhSUFRhZ1wiKTtcclxudmFyIEludmFsaWRBZGRyZXNzID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkludmFsaWRBZGRyZXNzXCIpO1xyXG52YXIgSW52YWxpZEFkZHJlc3NCZWNhdXNlRGVzdGluYXRpb25Jc0Fsc29Tb3VyY2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiSW52YWxpZEFkZHJlc3NCZWNhdXNlRGVzdGluYXRpb25Jc0Fsc29Tb3VyY2VcIik7XHJcbnZhciBMYXRlc3RNQ1VJbnN0YWxsZWRFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJMYXRlc3RNQ1VJbnN0YWxsZWRFcnJvclwiKTtcclxudmFyIFVua25vd25NQ1UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVW5rbm93bk1DVVwiKTtcclxudmFyIExlZGdlckFQSUVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkxlZGdlckFQSUVycm9yXCIpO1xyXG52YXIgTGVkZ2VyQVBJRXJyb3JXaXRoTWVzc2FnZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJMZWRnZXJBUElFcnJvcldpdGhNZXNzYWdlXCIpO1xyXG52YXIgTGVkZ2VyQVBJTm90QXZhaWxhYmxlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkxlZGdlckFQSU5vdEF2YWlsYWJsZVwiKTtcclxudmFyIE1hbmFnZXJBcHBBbHJlYWR5SW5zdGFsbGVkRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTWFuYWdlckFwcEFscmVhZHlJbnN0YWxsZWRcIik7XHJcbnZhciBNYW5hZ2VyQXBwUmVseU9uQlRDRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTWFuYWdlckFwcFJlbHlPbkJUQ1wiKTtcclxudmFyIE1hbmFnZXJBcHBEZXBJbnN0YWxsUmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTWFuYWdlckFwcERlcEluc3RhbGxSZXF1aXJlZFwiKTtcclxudmFyIE1hbmFnZXJBcHBEZXBVbmluc3RhbGxSZXF1aXJlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNYW5hZ2VyQXBwRGVwVW5pbnN0YWxsUmVxdWlyZWRcIik7XHJcbnZhciBNYW5hZ2VyRGV2aWNlTG9ja2VkRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTWFuYWdlckRldmljZUxvY2tlZFwiKTtcclxudmFyIE1hbmFnZXJGaXJtd2FyZU5vdEVub3VnaFNwYWNlRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTWFuYWdlckZpcm13YXJlTm90RW5vdWdoU3BhY2VcIik7XHJcbnZhciBNYW5hZ2VyTm90RW5vdWdoU3BhY2VFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJNYW5hZ2VyTm90RW5vdWdoU3BhY2VcIik7XHJcbnZhciBNYW5hZ2VyVW5pbnN0YWxsQlRDRGVwID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk1hbmFnZXJVbmluc3RhbGxCVENEZXBcIik7XHJcbnZhciBOZXR3b3JrRG93biA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOZXR3b3JrRG93blwiKTtcclxudmFyIE5vQWRkcmVzc2VzRm91bmQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm9BZGRyZXNzZXNGb3VuZFwiKTtcclxudmFyIE5vdEVub3VnaEJhbGFuY2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoQmFsYW5jZVwiKTtcclxudmFyIE5vdEVub3VnaEJhbGFuY2VUb0RlbGVnYXRlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk5vdEVub3VnaEJhbGFuY2VUb0RlbGVnYXRlXCIpO1xyXG52YXIgTm90RW5vdWdoQmFsYW5jZUluUGFyZW50QWNjb3VudCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RFbm91Z2hCYWxhbmNlSW5QYXJlbnRBY2NvdW50XCIpO1xyXG52YXIgTm90RW5vdWdoU3BlbmRhYmxlQmFsYW5jZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RFbm91Z2hTcGVuZGFibGVCYWxhbmNlXCIpO1xyXG52YXIgTm90RW5vdWdoQmFsYW5jZUJlY2F1c2VEZXN0aW5hdGlvbk5vdENyZWF0ZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoQmFsYW5jZUJlY2F1c2VEZXN0aW5hdGlvbk5vdENyZWF0ZWRcIik7XHJcbnZhciBOb0FjY2Vzc1RvQ2FtZXJhID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIk5vQWNjZXNzVG9DYW1lcmFcIik7XHJcbnZhciBOb3RFbm91Z2hHYXMgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm90RW5vdWdoR2FzXCIpO1xyXG52YXIgTm90U3VwcG9ydGVkTGVnYWN5QWRkcmVzcyA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJOb3RTdXBwb3J0ZWRMZWdhY3lBZGRyZXNzXCIpO1xyXG52YXIgR2FzTGVzc1RoYW5Fc3RpbWF0ZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJHYXNMZXNzVGhhbkVzdGltYXRlXCIpO1xyXG52YXIgUGFzc3dvcmRzRG9udE1hdGNoRXJyb3IgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUGFzc3dvcmRzRG9udE1hdGNoXCIpO1xyXG52YXIgUGFzc3dvcmRJbmNvcnJlY3RFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJQYXNzd29yZEluY29ycmVjdFwiKTtcclxudmFyIFJlY29tbWVuZFN1YkFjY291bnRzVG9FbXB0eSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJSZWNvbW1lbmRTdWJBY2NvdW50c1RvRW1wdHlcIik7XHJcbnZhciBSZWNvbW1lbmRVbmRlbGVnYXRpb24gPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUmVjb21tZW5kVW5kZWxlZ2F0aW9uXCIpO1xyXG52YXIgVGltZW91dFRhZ2dlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJUaW1lb3V0VGFnZ2VkXCIpO1xyXG52YXIgVW5leHBlY3RlZEJvb3Rsb2FkZXIgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVW5leHBlY3RlZEJvb3Rsb2FkZXJcIik7XHJcbnZhciBNQ1VOb3RHZW51aW5lVG9EYXNoYm9hcmQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTUNVTm90R2VudWluZVRvRGFzaGJvYXJkXCIpO1xyXG52YXIgUmVjaXBpZW50UmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiUmVjaXBpZW50UmVxdWlyZWRcIik7XHJcbnZhciBVbmF2YWlsYWJsZVRlem9zT3JpZ2luYXRlZEFjY291bnRSZWNlaXZlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVuYXZhaWxhYmxlVGV6b3NPcmlnaW5hdGVkQWNjb3VudFJlY2VpdmVcIik7XHJcbnZhciBVbmF2YWlsYWJsZVRlem9zT3JpZ2luYXRlZEFjY291bnRTZW5kID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVuYXZhaWxhYmxlVGV6b3NPcmlnaW5hdGVkQWNjb3VudFNlbmRcIik7XHJcbnZhciBVcGRhdGVGZXRjaEZpbGVGYWlsID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVwZGF0ZUZldGNoRmlsZUZhaWxcIik7XHJcbnZhciBVcGRhdGVJbmNvcnJlY3RIYXNoID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVwZGF0ZUluY29ycmVjdEhhc2hcIik7XHJcbnZhciBVcGRhdGVJbmNvcnJlY3RTaWcgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVXBkYXRlSW5jb3JyZWN0U2lnXCIpO1xyXG52YXIgVXBkYXRlWW91ckFwcCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVcGRhdGVZb3VyQXBwXCIpO1xyXG52YXIgVXNlclJlZnVzZWREZXZpY2VOYW1lQ2hhbmdlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVzZXJSZWZ1c2VkRGV2aWNlTmFtZUNoYW5nZVwiKTtcclxudmFyIFVzZXJSZWZ1c2VkQWRkcmVzcyA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVc2VyUmVmdXNlZEFkZHJlc3NcIik7XHJcbnZhciBVc2VyUmVmdXNlZEZpcm13YXJlVXBkYXRlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlVzZXJSZWZ1c2VkRmlybXdhcmVVcGRhdGVcIik7XHJcbnZhciBVc2VyUmVmdXNlZEFsbG93TWFuYWdlciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJVc2VyUmVmdXNlZEFsbG93TWFuYWdlclwiKTtcclxudmFyIFVzZXJSZWZ1c2VkT25EZXZpY2UgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVXNlclJlZnVzZWRPbkRldmljZVwiKTsgLy8gVE9ETyByZW5hbWUgYmVjYXVzZSBpdCdzIGp1c3QgZm9yIHRyYW5zYWN0aW9uIHJlZnVzYWxcclxudmFyIFRyYW5zcG9ydE9wZW5Vc2VyQ2FuY2VsbGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlRyYW5zcG9ydE9wZW5Vc2VyQ2FuY2VsbGVkXCIpO1xyXG52YXIgVHJhbnNwb3J0SW50ZXJmYWNlTm90QXZhaWxhYmxlID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlRyYW5zcG9ydEludGVyZmFjZU5vdEF2YWlsYWJsZVwiKTtcclxudmFyIFRyYW5zcG9ydFJhY2VDb25kaXRpb24gPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiVHJhbnNwb3J0UmFjZUNvbmRpdGlvblwiKTtcclxudmFyIFRyYW5zcG9ydFdlYlVTQkdlc3R1cmVSZXF1aXJlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJUcmFuc3BvcnRXZWJVU0JHZXN0dXJlUmVxdWlyZWRcIik7XHJcbnZhciBEZXZpY2VTaG91bGRTdGF5SW5BcHAgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRGV2aWNlU2hvdWxkU3RheUluQXBwXCIpO1xyXG52YXIgV2Vic29ja2V0Q29ubmVjdGlvbkVycm9yID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIldlYnNvY2tldENvbm5lY3Rpb25FcnJvclwiKTtcclxudmFyIFdlYnNvY2tldENvbm5lY3Rpb25GYWlsZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiV2Vic29ja2V0Q29ubmVjdGlvbkZhaWxlZFwiKTtcclxudmFyIFdyb25nRGV2aWNlRm9yQWNjb3VudCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJXcm9uZ0RldmljZUZvckFjY291bnRcIik7XHJcbnZhciBXcm9uZ0FwcEZvckN1cnJlbmN5ID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIldyb25nQXBwRm9yQ3VycmVuY3lcIik7XHJcbnZhciBFVEhBZGRyZXNzTm9uRUlQID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkVUSEFkZHJlc3NOb25FSVBcIik7XHJcbnZhciBDYW50U2NhblFSQ29kZSA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJDYW50U2NhblFSQ29kZVwiKTtcclxudmFyIEZlZU5vdExvYWRlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJGZWVOb3RMb2FkZWRcIik7XHJcbnZhciBGZWVSZXF1aXJlZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJGZWVSZXF1aXJlZFwiKTtcclxudmFyIEZlZVRvb0hpZ2ggPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRmVlVG9vSGlnaFwiKTtcclxudmFyIFN5bmNFcnJvciA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJTeW5jRXJyb3JcIik7XHJcbnZhciBQYWlyaW5nRmFpbGVkID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIlBhaXJpbmdGYWlsZWRcIik7XHJcbnZhciBHZW51aW5lQ2hlY2tGYWlsZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiR2VudWluZUNoZWNrRmFpbGVkXCIpO1xyXG52YXIgTGVkZ2VyQVBJNHh4ID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkxlZGdlckFQSTR4eFwiKTtcclxudmFyIExlZGdlckFQSTV4eCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJMZWRnZXJBUEk1eHhcIik7XHJcbnZhciBGaXJtd2FyZU9yQXBwVXBkYXRlUmVxdWlyZWQgPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiRmlybXdhcmVPckFwcFVwZGF0ZVJlcXVpcmVkXCIpO1xyXG4vLyBkYiBzdHVmZiwgbm8gbmVlZCB0byB0cmFuc2xhdGVcclxudmFyIE5vREJQYXRoR2l2ZW4gPSBjcmVhdGVDdXN0b21FcnJvckNsYXNzKFwiTm9EQlBhdGhHaXZlblwiKTtcclxudmFyIERCV3JvbmdQYXNzd29yZCA9IGNyZWF0ZUN1c3RvbUVycm9yQ2xhc3MoXCJEQldyb25nUGFzc3dvcmRcIik7XHJcbnZhciBEQk5vdFJlc2V0ID0gY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcyhcIkRCTm90UmVzZXRcIik7XHJcbi8qKlxyXG4gKiBUcmFuc3BvcnRFcnJvciBpcyB1c2VkIGZvciBhbnkgZ2VuZXJpYyB0cmFuc3BvcnQgZXJyb3JzLlxyXG4gKiBlLmcuIEVycm9yIHRocm93biB3aGVuIGRhdGEgcmVjZWl2ZWQgYnkgZXhjaGFuZ2VzIGFyZSBpbmNvcnJlY3Qgb3IgaWYgZXhjaGFuZ2VkIGZhaWxlZCB0byBjb21tdW5pY2F0ZSB3aXRoIHRoZSBkZXZpY2UgZm9yIHZhcmlvdXMgcmVhc29uLlxyXG4gKi9cclxuZnVuY3Rpb24gVHJhbnNwb3J0RXJyb3IobWVzc2FnZSwgaWQpIHtcclxuICAgIHRoaXMubmFtZSA9IFwiVHJhbnNwb3J0RXJyb3JcIjtcclxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcbiAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XHJcbiAgICB0aGlzLmlkID0gaWQ7XHJcbn1cclxuVHJhbnNwb3J0RXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbmFkZEN1c3RvbUVycm9yRGVzZXJpYWxpemVyKFwiVHJhbnNwb3J0RXJyb3JcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG5ldyBUcmFuc3BvcnRFcnJvcihlLm1lc3NhZ2UsIGUuaWQpOyB9KTtcclxudmFyIFN0YXR1c0NvZGVzID0ge1xyXG4gICAgUElOX1JFTUFJTklOR19BVFRFTVBUUzogMHg2M2MwLFxyXG4gICAgSU5DT1JSRUNUX0xFTkdUSDogMHg2NzAwLFxyXG4gICAgTUlTU0lOR19DUklUSUNBTF9QQVJBTUVURVI6IDB4NjgwMCxcclxuICAgIENPTU1BTkRfSU5DT01QQVRJQkxFX0ZJTEVfU1RSVUNUVVJFOiAweDY5ODEsXHJcbiAgICBTRUNVUklUWV9TVEFUVVNfTk9UX1NBVElTRklFRDogMHg2OTgyLFxyXG4gICAgQ09ORElUSU9OU19PRl9VU0VfTk9UX1NBVElTRklFRDogMHg2OTg1LFxyXG4gICAgSU5DT1JSRUNUX0RBVEE6IDB4NmE4MCxcclxuICAgIE5PVF9FTk9VR0hfTUVNT1JZX1NQQUNFOiAweDZhODQsXHJcbiAgICBSRUZFUkVOQ0VEX0RBVEFfTk9UX0ZPVU5EOiAweDZhODgsXHJcbiAgICBGSUxFX0FMUkVBRFlfRVhJU1RTOiAweDZhODksXHJcbiAgICBJTkNPUlJFQ1RfUDFfUDI6IDB4NmIwMCxcclxuICAgIElOU19OT1RfU1VQUE9SVEVEOiAweDZkMDAsXHJcbiAgICBDTEFfTk9UX1NVUFBPUlRFRDogMHg2ZTAwLFxyXG4gICAgVEVDSE5JQ0FMX1BST0JMRU06IDB4NmYwMCxcclxuICAgIE9LOiAweDkwMDAsXHJcbiAgICBNRU1PUllfUFJPQkxFTTogMHg5MjQwLFxyXG4gICAgTk9fRUZfU0VMRUNURUQ6IDB4OTQwMCxcclxuICAgIElOVkFMSURfT0ZGU0VUOiAweDk0MDIsXHJcbiAgICBGSUxFX05PVF9GT1VORDogMHg5NDA0LFxyXG4gICAgSU5DT05TSVNURU5UX0ZJTEU6IDB4OTQwOCxcclxuICAgIEFMR09SSVRITV9OT1RfU1VQUE9SVEVEOiAweDk0ODQsXHJcbiAgICBJTlZBTElEX0tDVjogMHg5NDg1LFxyXG4gICAgQ09ERV9OT1RfSU5JVElBTElaRUQ6IDB4OTgwMixcclxuICAgIEFDQ0VTU19DT05ESVRJT05fTk9UX0ZVTEZJTExFRDogMHg5ODA0LFxyXG4gICAgQ09OVFJBRElDVElPTl9TRUNSRVRfQ09ERV9TVEFUVVM6IDB4OTgwOCxcclxuICAgIENPTlRSQURJQ1RJT05fSU5WQUxJREFUSU9OOiAweDk4MTAsXHJcbiAgICBDT0RFX0JMT0NLRUQ6IDB4OTg0MCxcclxuICAgIE1BWF9WQUxVRV9SRUFDSEVEOiAweDk4NTAsXHJcbiAgICBHUF9BVVRIX0ZBSUxFRDogMHg2MzAwLFxyXG4gICAgTElDRU5TSU5HOiAweDZmNDIsXHJcbiAgICBIQUxURUQ6IDB4NmZhYSxcclxufTtcclxuZnVuY3Rpb24gZ2V0QWx0U3RhdHVzTWVzc2FnZShjb2RlKSB7XHJcbiAgICBzd2l0Y2ggKGNvZGUpIHtcclxuICAgICAgICAvLyBpbXByb3ZlIHRleHQgb2YgbW9zdCBjb21tb24gZXJyb3JzXHJcbiAgICAgICAgY2FzZSAweDY3MDA6XHJcbiAgICAgICAgICAgIHJldHVybiBcIkluY29ycmVjdCBsZW5ndGhcIjtcclxuICAgICAgICBjYXNlIDB4NjgwMDpcclxuICAgICAgICAgICAgcmV0dXJuIFwiTWlzc2luZyBjcml0aWNhbCBwYXJhbWV0ZXJcIjtcclxuICAgICAgICBjYXNlIDB4Njk4MjpcclxuICAgICAgICAgICAgcmV0dXJuIFwiU2VjdXJpdHkgbm90IHNhdGlzZmllZCAoZG9uZ2xlIGxvY2tlZCBvciBoYXZlIGludmFsaWQgYWNjZXNzIHJpZ2h0cylcIjtcclxuICAgICAgICBjYXNlIDB4Njk4NTpcclxuICAgICAgICAgICAgcmV0dXJuIFwiQ29uZGl0aW9uIG9mIHVzZSBub3Qgc2F0aXNmaWVkIChkZW5pZWQgYnkgdGhlIHVzZXI/KVwiO1xyXG4gICAgICAgIGNhc2UgMHg2YTgwOlxyXG4gICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkIGRhdGEgcmVjZWl2ZWRcIjtcclxuICAgICAgICBjYXNlIDB4NmIwMDpcclxuICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCBwYXJhbWV0ZXIgcmVjZWl2ZWRcIjtcclxuICAgIH1cclxuICAgIGlmICgweDZmMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4NmZmZikge1xyXG4gICAgICAgIHJldHVybiBcIkludGVybmFsIGVycm9yLCBwbGVhc2UgcmVwb3J0XCI7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEVycm9yIHRocm93biB3aGVuIGEgZGV2aWNlIHJldHVybmVkIGEgbm9uIHN1Y2Nlc3Mgc3RhdHVzLlxyXG4gKiB0aGUgZXJyb3Iuc3RhdHVzQ29kZSBpcyBvbmUgb2YgdGhlIGBTdGF0dXNDb2Rlc2AgZXhwb3J0ZWQgYnkgdGhpcyBsaWJyYXJ5LlxyXG4gKi9cclxuZnVuY3Rpb24gVHJhbnNwb3J0U3RhdHVzRXJyb3Ioc3RhdHVzQ29kZSkge1xyXG4gICAgdGhpcy5uYW1lID0gXCJUcmFuc3BvcnRTdGF0dXNFcnJvclwiO1xyXG4gICAgdmFyIHN0YXR1c1RleHQgPSBPYmplY3Qua2V5cyhTdGF0dXNDb2RlcykuZmluZChmdW5jdGlvbiAoaykgeyByZXR1cm4gU3RhdHVzQ29kZXNba10gPT09IHN0YXR1c0NvZGU7IH0pIHx8XHJcbiAgICAgICAgXCJVTktOT1dOX0VSUk9SXCI7XHJcbiAgICB2YXIgc21zZyA9IGdldEFsdFN0YXR1c01lc3NhZ2Uoc3RhdHVzQ29kZSkgfHwgc3RhdHVzVGV4dDtcclxuICAgIHZhciBzdGF0dXNDb2RlU3RyID0gc3RhdHVzQ29kZS50b1N0cmluZygxNik7XHJcbiAgICB0aGlzLm1lc3NhZ2UgPSBcIkxlZGdlciBkZXZpY2U6IFwiICsgc21zZyArIFwiICgweFwiICsgc3RhdHVzQ29kZVN0ciArIFwiKVwiO1xyXG4gICAgdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrO1xyXG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcclxuICAgIHRoaXMuc3RhdHVzVGV4dCA9IHN0YXR1c1RleHQ7XHJcbn1cclxuVHJhbnNwb3J0U3RhdHVzRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XHJcbmFkZEN1c3RvbUVycm9yRGVzZXJpYWxpemVyKFwiVHJhbnNwb3J0U3RhdHVzRXJyb3JcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG5ldyBUcmFuc3BvcnRTdGF0dXNFcnJvcihlLnN0YXR1c0NvZGUpOyB9KTtcblxuZXhwb3J0IHsgQWNjb3VudE5hbWVSZXF1aXJlZEVycm9yLCBBY2NvdW50Tm90U3VwcG9ydGVkLCBBbW91bnRSZXF1aXJlZCwgQmx1ZXRvb3RoUmVxdWlyZWQsIEJ0Y1VubWF0Y2hlZEFwcCwgQ2FudE9wZW5EZXZpY2UsIENhbnRTY2FuUVJDb2RlLCBDYXNoQWRkck5vdFN1cHBvcnRlZCwgQ3VycmVuY3lOb3RTdXBwb3J0ZWQsIERCTm90UmVzZXQsIERCV3JvbmdQYXNzd29yZCwgRGV2aWNlQXBwVmVyaWZ5Tm90U3VwcG9ydGVkLCBEZXZpY2VHZW51aW5lU29ja2V0RWFybHlDbG9zZSwgRGV2aWNlSGFsdGVkLCBEZXZpY2VJbk9TVUV4cGVjdGVkLCBEZXZpY2VOYW1lSW52YWxpZCwgRGV2aWNlTm90R2VudWluZUVycm9yLCBEZXZpY2VPbkRhc2hib2FyZEV4cGVjdGVkLCBEZXZpY2VPbkRhc2hib2FyZFVuZXhwZWN0ZWQsIERldmljZVNob3VsZFN0YXlJbkFwcCwgRGV2aWNlU29ja2V0RmFpbCwgRGV2aWNlU29ja2V0Tm9CdWxrU3RhdHVzLCBEaXNjb25uZWN0ZWREZXZpY2UsIERpc2Nvbm5lY3RlZERldmljZUR1cmluZ09wZXJhdGlvbiwgRVRIQWRkcmVzc05vbkVJUCwgRW5wb2ludENvbmZpZ0Vycm9yLCBFdGhBcHBQbGVhc2VFbmFibGVDb250cmFjdERhdGEsIEZlZUVzdGltYXRpb25GYWlsZWQsIEZlZU5vdExvYWRlZCwgRmVlUmVxdWlyZWQsIEZlZVRvb0hpZ2gsIEZpcm13YXJlTm90UmVjb2duaXplZCwgRmlybXdhcmVPckFwcFVwZGF0ZVJlcXVpcmVkLCBHYXNMZXNzVGhhbkVzdGltYXRlLCBHZW51aW5lQ2hlY2tGYWlsZWQsIEhhcmRSZXNldEZhaWwsIEludmFsaWRBZGRyZXNzLCBJbnZhbGlkQWRkcmVzc0JlY2F1c2VEZXN0aW5hdGlvbklzQWxzb1NvdXJjZSwgSW52YWxpZFhSUFRhZywgTGF0ZXN0TUNVSW5zdGFsbGVkRXJyb3IsIExlZGdlckFQSTR4eCwgTGVkZ2VyQVBJNXh4LCBMZWRnZXJBUElFcnJvciwgTGVkZ2VyQVBJRXJyb3JXaXRoTWVzc2FnZSwgTGVkZ2VyQVBJTm90QXZhaWxhYmxlLCBNQ1VOb3RHZW51aW5lVG9EYXNoYm9hcmQsIE1hbmFnZXJBcHBBbHJlYWR5SW5zdGFsbGVkRXJyb3IsIE1hbmFnZXJBcHBEZXBJbnN0YWxsUmVxdWlyZWQsIE1hbmFnZXJBcHBEZXBVbmluc3RhbGxSZXF1aXJlZCwgTWFuYWdlckFwcFJlbHlPbkJUQ0Vycm9yLCBNYW5hZ2VyRGV2aWNlTG9ja2VkRXJyb3IsIE1hbmFnZXJGaXJtd2FyZU5vdEVub3VnaFNwYWNlRXJyb3IsIE1hbmFnZXJOb3RFbm91Z2hTcGFjZUVycm9yLCBNYW5hZ2VyVW5pbnN0YWxsQlRDRGVwLCBOZXR3b3JrRG93biwgTm9BY2Nlc3NUb0NhbWVyYSwgTm9BZGRyZXNzZXNGb3VuZCwgTm9EQlBhdGhHaXZlbiwgTm90RW5vdWdoQmFsYW5jZSwgTm90RW5vdWdoQmFsYW5jZUJlY2F1c2VEZXN0aW5hdGlvbk5vdENyZWF0ZWQsIE5vdEVub3VnaEJhbGFuY2VJblBhcmVudEFjY291bnQsIE5vdEVub3VnaEJhbGFuY2VUb0RlbGVnYXRlLCBOb3RFbm91Z2hHYXMsIE5vdEVub3VnaFNwZW5kYWJsZUJhbGFuY2UsIE5vdFN1cHBvcnRlZExlZ2FjeUFkZHJlc3MsIFBhaXJpbmdGYWlsZWQsIFBhc3N3b3JkSW5jb3JyZWN0RXJyb3IsIFBhc3N3b3Jkc0RvbnRNYXRjaEVycm9yLCBSZWNpcGllbnRSZXF1aXJlZCwgUmVjb21tZW5kU3ViQWNjb3VudHNUb0VtcHR5LCBSZWNvbW1lbmRVbmRlbGVnYXRpb24sIFN0YXR1c0NvZGVzLCBTeW5jRXJyb3IsIFRpbWVvdXRUYWdnZWQsIFRyYW5zcG9ydEVycm9yLCBUcmFuc3BvcnRJbnRlcmZhY2VOb3RBdmFpbGFibGUsIFRyYW5zcG9ydE9wZW5Vc2VyQ2FuY2VsbGVkLCBUcmFuc3BvcnRSYWNlQ29uZGl0aW9uLCBUcmFuc3BvcnRTdGF0dXNFcnJvciwgVHJhbnNwb3J0V2ViVVNCR2VzdHVyZVJlcXVpcmVkLCBVbmF2YWlsYWJsZVRlem9zT3JpZ2luYXRlZEFjY291bnRSZWNlaXZlLCBVbmF2YWlsYWJsZVRlem9zT3JpZ2luYXRlZEFjY291bnRTZW5kLCBVbmV4cGVjdGVkQm9vdGxvYWRlciwgVW5rbm93bk1DVSwgVXBkYXRlRmV0Y2hGaWxlRmFpbCwgVXBkYXRlSW5jb3JyZWN0SGFzaCwgVXBkYXRlSW5jb3JyZWN0U2lnLCBVcGRhdGVZb3VyQXBwLCBVc2VyUmVmdXNlZEFkZHJlc3MsIFVzZXJSZWZ1c2VkQWxsb3dNYW5hZ2VyLCBVc2VyUmVmdXNlZERldmljZU5hbWVDaGFuZ2UsIFVzZXJSZWZ1c2VkRmlybXdhcmVVcGRhdGUsIFVzZXJSZWZ1c2VkT25EZXZpY2UsIFdlYnNvY2tldENvbm5lY3Rpb25FcnJvciwgV2Vic29ja2V0Q29ubmVjdGlvbkZhaWxlZCwgV3JvbmdBcHBGb3JDdXJyZW5jeSwgV3JvbmdEZXZpY2VGb3JBY2NvdW50LCBhZGRDdXN0b21FcnJvckRlc2VyaWFsaXplciwgY3JlYXRlQ3VzdG9tRXJyb3JDbGFzcywgZGVzZXJpYWxpemVFcnJvciwgZ2V0QWx0U3RhdHVzTWVzc2FnZSwgc2VyaWFsaXplRXJyb3IgfTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///a8fc\n')}}]);